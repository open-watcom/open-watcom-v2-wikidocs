<HEAD>
<TITLE> Open Watcom 2.0 C/C++ Programmer's Guide </TITLE>
</HEAD>
<BODY>
<H1 ID="Index_of_Topics"> Index of Topics </H1>
<DL>
<DT>- 1 -
<DD><A HREF="#16Mbit_OSD2__Building_and_Running_the_Sample_OSD2_1_x_Application">16-bit OS/2:&nbsp; Building and Running the Sample OS/2 1.x Application</A>
<BR><A HREF="#16Mbit_OSD2__Creating_16Mbit_OSD2_1_x_Applications">16-bit OS/2:&nbsp; Creating 16-bit OS/2 1.x Applications</A>
<BR><A HREF="#16Mbit_OSD2__Debugging_the_Sample_OSD2_1_x_Application">16-bit OS/2:&nbsp; Debugging the Sample OS/2 1.x Application</A>
<BR><A HREF="#16Mbit_OSD2__The_Sample_Application">16-bit OS/2:&nbsp; The Sample Application</A>
<BR><A HREF="#16Mbit_Windows__Building_and_Running_the_GUI_Application">16-bit Windows:&nbsp; Building and Running the GUI Application</A>
<BR><A HREF="#16Mbit_Windows__Building_and_Running_the_NonMGUI_Application">16-bit Windows:&nbsp; Building and Running the Non-GUI Application</A>
<BR><A HREF="#16Mbit_Windows__Console_Device_in_a_Windowed_Environment">16-bit Windows:&nbsp; Console Device in a Windowed Environment</A>
<BR><A HREF="#16Mbit_Windows__Creating_16Mbit_Windows_3_x_Applications">16-bit Windows:&nbsp; Creating 16-bit Windows 3.x Applications</A>
<BR><A HREF="#16Mbit_Windows__Debugging_the_GUI_Application">16-bit Windows:&nbsp; Debugging the GUI Application</A>
<BR><A HREF="#16Mbit_Windows__Debugging_the_NonMGUI_Application">16-bit Windows:&nbsp; Debugging the Non-GUI Application</A>
<BR><A HREF="#16Mbit_Windows__Default_Windowing_Library_Functions">16-bit Windows:&nbsp; Default Windowing Library Functions</A>
<BR><A HREF="#16Mbit_Windows__Porting_NonMGUI_Applications_to_16Mbit_Windows_3_x">16-bit Windows:&nbsp; Porting Non-GUI Applications to 16-bit Windows 3.x</A>
<BR><A HREF="#16Mbit_Windows__The_Sample_GUI_Application">16-bit Windows:&nbsp; The Sample GUI Application</A>
<BR><A HREF="#16Mbit_Windows__The_Sample_NonMGUI_Application">16-bit Windows:&nbsp; The Sample Non-GUI Application</A>
<DT>- 3 -
<DD><A HREF="#32Mbit_Extended_DOS_Application_Development">32-bit Extended DOS Application Development</A>
<BR><A HREF="#32Mbit_OSD2__Building_and_Running_the_Sample_OSD2_Application">32-bit OS/2:&nbsp; Building and Running the Sample OS/2 Application</A>
<BR><A HREF="#32Mbit_OSD2__Creating_32Mbit_OSD2_Applications">32-bit OS/2:&nbsp; Creating 32-bit OS/2 Applications</A>
<BR><A HREF="#32Mbit_OSD2__Debugging_the_Sample_OSD2_Application">32-bit OS/2:&nbsp; Debugging the Sample OS/2 Application</A>
<BR><A HREF="#32Mbit_OSD2__The_Sample_Application">32-bit OS/2:&nbsp; The Sample Application</A>
<BR><A HREF="#32Mbit_Windows__Building_and_Running_the_GUI_Application">32-bit Windows:&nbsp; Building and Running the GUI Application</A>
<BR><A HREF="#32Mbit_Windows__Building_and_Running_the_NonMGUI_Application">32-bit Windows:&nbsp; Building and Running the Non-GUI Application</A>
<BR><A HREF="#32Mbit_Windows__Console_Device_in_a_Windowed_Environment">32-bit Windows:&nbsp; Console Device in a Windowed Environment</A>
<BR><A HREF="#32Mbit_Windows__Creating_32Mbit_Windows_3_x_Applications">32-bit Windows:&nbsp; Creating 32-bit Windows 3.x Applications</A>
<BR><A HREF="#32Mbit_Windows__Debugging_the_GUI_Application">32-bit Windows:&nbsp; Debugging the GUI Application</A>
<BR><A HREF="#32Mbit_Windows__Debugging_the_NonMGUI_Application">32-bit Windows:&nbsp; Debugging the Non-GUI Application</A>
<BR><A HREF="#32Mbit_Windows__Default_Windowing_Library_Functions">32-bit Windows:&nbsp; Default Windowing Library Functions</A>
<BR><A HREF="#32Mbit_Windows__Porting_NonMGUI_Applications_to_32Mbit_Windows_3_x">32-bit Windows:&nbsp; Porting Non-GUI Applications to 32-bit Windows 3.x</A>
<BR><A HREF="#32Mbit_Windows__The_Sample_GUI_Application">32-bit Windows:&nbsp; The Sample GUI Application</A>
<BR><A HREF="#32Mbit_Windows__The_Sample_NonMGUI_Application">32-bit Windows:&nbsp; The Sample Non-GUI Application</A>
<DT>- A -
<DD><A HREF="#Accessing_the_First_Megabyte_under_Tenberry_Software_DOSD4GW">Accessing the First Megabyte under Tenberry Software DOS/4GW</A>
<BR><A HREF="#Accessing_the_First_Megabyte_under_the_Phar_Lap_386_DOSMExtender">Accessing the First Megabyte under the Phar Lap 386|DOS-Extender</A>
<BR><A HREF="#Argument_Passing_Convention">Argument Passing Convention</A>
<DT>- C -
<DD><A HREF="#Commonly_Asked_Questions_and_Answers">Commonly Asked Questions and Answers</A>
<BR><A HREF="#The_compiler_cannot_find__stdio_h_">The compiler cannot find &quot;stdio.h&quot;</A>
<BR><A HREF="#Conversion_from_IBMMcompatible_PC_compilers">Conversion from IBM-compatible PC compilers</A>
<BR><A HREF="#Conversion_from_UNIX_compilers">Conversion from UNIX compilers</A>
<BR><A HREF="#Converting_to_Open_Watcom_CDCPP">Converting to Open Watcom C/C++</A>
<BR><A HREF="#Creating_NetWare_386_NLM_Applications">Creating NetWare 386 NLM Applications</A>
<DT>- D -
<DD><A HREF="#Definitions_of_Windows_Terms">Definitions of Windows Terms</A>
<BR><A HREF="#Determining_my_current_patch_level">Determining my current patch level</A>
<BR><A HREF="#The_difference_between_the__d1__and__d2__compiler_options">The difference between the &quot;d1&quot; and &quot;d2&quot; compiler options</A>
<BR><A HREF="#DOSD4GW__32MBit_Gates">DOS/4GW:&nbsp; 32-Bit Gates</A>
<BR><A HREF="#DOSD4GW__Access_to_Technical_Support">DOS/4GW:&nbsp; Access to Technical Support</A>
<BR><A HREF="#DOSD4GW__Addressing">DOS/4GW:&nbsp; Addressing</A>
<BR><A HREF="#DOSD4GW__Building_and_Running_the_Sample_DOSD4GW_Application">DOS/4GW:&nbsp; Building and Running the Sample DOS/4GW Application</A>
<BR><A HREF="#DOSD4GW__Chaining_16Mbit_and_32Mbit_Handlers">DOS/4GW:&nbsp; Chaining 16-bit and 32-bit Handlers</A>
<BR><A HREF="#DOSD4GW__Changing_the_Defaults">DOS/4GW:&nbsp; Changing the Defaults</A>
<BR><A HREF="#DOSD4GW__Changing_the_Switch_Mode_Setting">DOS/4GW:&nbsp; Changing the Switch Mode Setting</A>
<BR><A HREF="#DOSD4GW__Compatibility">DOS/4GW:&nbsp; Compatibility</A>
<BR><A HREF="#DOSD4GW__Configuring_DOSD4GW">DOS/4GW:&nbsp; Configuring DOS/4GW</A>
<BR><A HREF="#DOSD4GW__Controlling_Address_Line_20">DOS/4GW:&nbsp; Controlling Address Line 20</A>
<BR><A HREF="#DOSD4GW__Coprocessor_Status">DOS/4GW:&nbsp; Coprocessor Status</A>
<BR><A HREF="#DOSD4GW__Creating_32Mbit_DOSD4GW_Applications">DOS/4GW:&nbsp; Creating 32-bit DOS/4GW Applications</A>
<BR><A HREF="#DOSD4GW__Debugging">DOS/4GW:&nbsp; Debugging</A>
<BR><A HREF="#DOSD4GW__Debugging_the_Sample_DOSD4GW_Application">DOS/4GW:&nbsp; Debugging the Sample DOS/4GW Application</A>
<BR><A HREF="#DOSD4GW__Demand_Paging_Performance_Tuning_Services">DOS/4GW:&nbsp; Demand Paging Performance Tuning Services</A>
<BR><A HREF="#DOSD4GW__Differences_Within_the_DOSD4G_Product_Line">DOS/4GW:&nbsp; Differences Within the DOS/4G Product Line</A>
<BR><A HREF="#DOSD4GW__DOS_Memory_Management_Services">DOS/4GW:&nbsp; DOS Memory Management Services</A>
<BR><A HREF="#DOSD4GW__DOS__BIOS__and_Mouse_Services">DOS/4GW:&nbsp; DOS, BIOS, and Mouse Services</A>
<BR><A HREF="#DOSD4GW__DOSD4G_Errors">DOS/4GW:&nbsp; DOS/4G Errors</A>
<BR><A HREF="#DOSD4GW__DOSD4GW_Commonly_Asked_Questions">DOS/4GW:&nbsp; DOS/4GW Commonly Asked Questions</A>
<BR><A HREF="#DOSD4GW__DOS4GW">DOS/4GW:&nbsp; DOS4GW</A>
<BR><A HREF="#DOSD4GW__DPMI_Version">DOS/4GW:&nbsp; DPMI Version</A>
<BR><A HREF="#DOSD4GW__Error_Messages">DOS/4GW:&nbsp; Error Messages</A>
<BR><A HREF="#DOSD4GW__Fine_Control_of_Memory_Usage">DOS/4GW:&nbsp; Fine Control of Memory Usage</A>
<BR><A HREF="#DOSD4GW__Functions_25H_and_35H__Interrupt_Handling_in_Protected_Mode">DOS/4GW:&nbsp; Functions 25H and 35H:&nbsp; Interrupt Handling in Protected Mode</A>
<BR><A HREF="#DOSD4GW__Getting_the_Address_of_the_Interrupt_Handler">DOS/4GW:&nbsp; Getting the Address of the Interrupt Handler</A>
<BR><A HREF="#DOSD4GW__Int31H_Function_Calls">DOS/4GW:&nbsp; Int31H Function Calls</A>
<BR><A HREF="#DOSD4GW__Interrupt_21H_Functions">DOS/4GW:&nbsp; Interrupt 21H Functions</A>
<BR><A HREF="#DOSD4GW__Interrupt_31H_DPMI_Functions">DOS/4GW:&nbsp; Interrupt 31H DPMI Functions</A>
<BR><A HREF="#DOSD4GW__Interrupt_and_Exception_Handling">DOS/4GW:&nbsp; Interrupt and Exception Handling</A>
<BR><A HREF="#DOSD4GW__Interrupt_Services">DOS/4GW:&nbsp; Interrupt Services</A>
<BR><A HREF="#DOSD4GW__Kernel_Error_Messages">DOS/4GW:&nbsp; Kernel Error Messages</A>
<BR><A HREF="#DOSD4GW__Linear_Executables">DOS/4GW:&nbsp; Linear Executables</A>
<BR><A HREF="#DOSD4GW__Local_Descriptor_Table_LLDTR_Management_Services">DOS/4GW:&nbsp; Local Descriptor Table (LDT) Management Services</A>
<BR><A HREF="#DOSD4GW__Memory_Management">DOS/4GW:&nbsp; Memory Management</A>
<BR><A HREF="#DOSD4GW__Memory_Management_Services">DOS/4GW:&nbsp; Memory Management Services</A>
<BR><A HREF="#DOSD4GW__Memory_Use">DOS/4GW:&nbsp; Memory Use</A>
<BR><A HREF="#DOSD4GW__Page_Locking_Services">DOS/4GW:&nbsp; Page Locking Services</A>
<BR><A HREF="#DOSD4GW__Physical_Address_Mapping">DOS/4GW:&nbsp; Physical Address Mapping</A>
<BR><A HREF="#DOSD4GW__PMINFO">DOS/4GW:&nbsp; PMINFO</A>
<BR><A HREF="#DOSD4GW__PRIVATXM">DOS/4GW:&nbsp; PRIVATXM</A>
<BR><A HREF="#DOSD4GW__RMINFO">DOS/4GW:&nbsp; RMINFO</A>
<BR><A HREF="#DOSD4GW__Setting_Runtime_Options">DOS/4GW:&nbsp; Setting Runtime Options</A>
<BR><A HREF="#DOSD4GW__Specifying_a_Range_of_Extended_Memory">DOS/4GW:&nbsp; Specifying a Range of Extended Memory</A>
<BR><A HREF="#DOSD4GW__The__VMC_File">DOS/4GW:&nbsp; The .VMC File</A>
<BR><A HREF="#DOSD4GW__The_DOS4G_Environment_Variable">DOS/4GW:&nbsp; The DOS4G Environment Variable</A>
<BR><A HREF="#DOSD4GW__The_Linear_Executable_Format">DOS/4GW:&nbsp; The Linear Executable Format</A>
<BR><A HREF="#DOSD4GW__The_Sample_Application">DOS/4GW:&nbsp; The Sample Application</A>
<BR><A HREF="#DOSD4GW__The_Stub_Program">DOS/4GW:&nbsp; The Stub Program</A>
<BR><A HREF="#DOSD4GW__The_Tenberry_Software_DOSD4GW_DOS_Extender">DOS/4GW:&nbsp; The Tenberry Software DOS/4GW DOS Extender</A>
<BR><A HREF="#DOSD4GW__Translation_Services">DOS/4GW:&nbsp; Translation Services</A>
<BR><A HREF="#DOSD4GW__Using_Extra_Memory">DOS/4GW:&nbsp; Using Extra Memory</A>
<BR><A HREF="#DOSD4GW__Using_Interrupt_31H_Function_Calls">DOS/4GW:&nbsp; Using Interrupt 31H Function Calls</A>
<BR><A HREF="#DOSD4GW__Utilities">DOS/4GW:&nbsp; Utilities</A>
<BR><A HREF="#DOSD4GW__Vendor_Specific_Extensions">DOS/4GW:&nbsp; Vendor Specific Extensions</A>
<BR><A HREF="#DOSD4GW__Virtual_Interrupt_State_Functions">DOS/4GW:&nbsp; Virtual Interrupt State Functions</A>
<BR><A HREF="#DOSD4GW__Virtual_Memory">DOS/4GW:&nbsp; Virtual Memory</A>
<BR><A HREF="#DOSD4GW__VMM">DOS/4GW:&nbsp; VMM</A>
<BR><A HREF="#DOSD4GW__VMM_Default_Parameters">DOS/4GW:&nbsp; VMM Default Parameters</A>
<BR><A HREF="#DOS__Building_and_Running_the_Sample_DOS_Application">DOS:&nbsp; Building and Running the Sample DOS Application</A>
<BR><A HREF="#DOS__Creating_16Mbit_DOS_Applications">DOS:&nbsp; Creating 16-bit DOS Applications</A>
<BR><A HREF="#DOS__Debugging_the_Sample_DOS_Application">DOS:&nbsp; Debugging the Sample DOS Application</A>
<BR><A HREF="#DOS__The_Sample_Application">DOS:&nbsp; The Sample Application</A>
<DT>- G -
<DD><A HREF="#Getting_Free_Memory_Information_in_the_32Mbit_Environment_under_Windows_3_x">Getting Free Memory Information in the 32-bit Environment under Windows 3.x</A>
<BR><A HREF="#Getting_Free_Memory_Information_under_DOSD4GW">Getting Free Memory Information under DOS/4GW</A>
<BR><A HREF="#Getting_Free_Memory_Information_under_the_Phar_Lap_386_DOSMExtender">Getting Free Memory Information under the Phar Lap 386|DOS-Extender</A>
<DT>- H -
<DD><A HREF="#How_Can_I_Use_the_Mouse_Interrupt_L0x33R_with_DOSD4GW_">How Can I Use the Mouse Interrupt (0x33) with DOS/4GW?</A>
<BR><A HREF="#How_can_I_write_directly_to_video_memory_using_a_DOS_extender_">How can I write directly to video memory using a DOS extender?</A>
<BR><A HREF="#How_do_I_access_a_FORTRAN_common_block_from_within_C_">How do I access a FORTRAN common block from within C?</A>
<BR><A HREF="#How_do_I_access_the_first_megabyte_in_the_extended_DOS_environment_">How do I access the first megabyte in the extended DOS environment?</A>
<BR><A HREF="#How_do_I_call_a_C_function_that_accepts_a_variable_number_of_arguments_">How do I call a C function that accepts a variable number of arguments?</A>
<BR><A HREF="#How_do_I_get_information_about_free_memory_in_the_32Mbit_environment_">How do I get information about free memory in the 32-bit environment?</A>
<BR><A HREF="#How_do_I_pass_a_string_from_a_C_function_to_FORTRAN_">How do I pass a string from a C function to FORTRAN?</A>
<BR><A HREF="#How_do_I_pass_a_string_from_FORTRAN_to_a_C_function_">How do I pass a string from FORTRAN to a C function?</A>
<BR><A HREF="#How_do_I_pass_integers_from_C_to_a_FORTRAN_function_">How do I pass integers from C to a FORTRAN function?</A>
<BR><A HREF="#How_do_I_pass_integers_from_FORTRAN_to_a_C_function_">How do I pass integers from FORTRAN to a C function?</A>
<BR><A HREF="#How_Do_I_Simulate_a_RealMMode_Interrupt_with_DOSD4GW_">How Do I Simulate a Real-Mode Interrupt with DOS/4GW?</A>
<BR><A HREF="#How_do_I_spawn_a_protectedMmode_application_">How do I spawn a protected-mode application?</A>
<BR><A HREF="#How_do_you_install_a_biMmodal_interrupt_handler_using_DOSD4GW_">How do you install a bi-modal interrupt handler using DOS/4GW?</A>
<BR><A HREF="#How_more_than_20_files_at_a_time_can_be_opened">How more than 20 files at a time can be opened</A>
<BR><A HREF="#How_source_files_can_be_seen_in_the_debugger">How source files can be seen in the debugger</A>
<DT>- I -
<DD><A HREF="#Integer_Type_Compatibility">Integer Type Compatibility</A>
<BR><A HREF="#InterMLanguage_calls__C_and_FORTRAN">Inter-Language calls:&nbsp; C and FORTRAN</A>
<DT>- L -
<DD><A HREF="#Linking_Considerations">Linking Considerations</A>
<DT>- M -
<DD><A HREF="#Memory_Model_Compatibility">Memory Model Compatibility</A>
<DT>- N -
<DD><A HREF="#NT__A_MultiMthreaded_Example">NT:&nbsp; A Multi-threaded Example</A>
<BR><A HREF="#NT__Building_and_Running_the_CharacterMmode_Application">NT:&nbsp; Building and Running the Character-mode Application</A>
<BR><A HREF="#NT__Building_and_Running_the_GUI_Application">NT:&nbsp; Building and Running the GUI Application</A>
<BR><A HREF="#NT__Creating_a_New_Thread">NT:&nbsp; Creating a New Thread</A>
<BR><A HREF="#NT__Creating_a_Sample_Dynamic_Link_Library">NT:&nbsp; Creating a Sample Dynamic Link Library</A>
<BR><A HREF="#NT__Creating_Dynamic_Link_Libraries">NT:&nbsp; Creating Dynamic Link Libraries</A>
<BR><A HREF="#NT__Creating_Threads">NT:&nbsp; Creating Threads</A>
<BR><A HREF="#NT__Creating_Windows_NT_CharacterMmode_Applications">NT:&nbsp; Creating Windows NT Character-mode Applications</A>
<BR><A HREF="#NT__Creating_Windows_NT_GUI_Applications">NT:&nbsp; Creating Windows NT GUI Applications</A>
<BR><A HREF="#NT__Creating_Windows_NT_POSIX_Applications">NT:&nbsp; Creating Windows NT POSIX Applications</A>
<BR><A HREF="#NT__Debugging_the_CharacterMmode_Application">NT:&nbsp; Debugging the Character-mode Application</A>
<BR><A HREF="#NT__Debugging_the_GUI_Application">NT:&nbsp; Debugging the GUI Application</A>
<BR><A HREF="#NT__Getting_the_Current_Thread_Identifier">NT:&nbsp; Getting the Current Thread Identifier</A>
<BR><A HREF="#NT__Programming_Considerations">NT:&nbsp; Programming Considerations</A>
<BR><A HREF="#NT__Terminating_the_Current_Thread">NT:&nbsp; Terminating the Current Thread</A>
<BR><A HREF="#NT__The_Dynamic_Link_Library_Data_Area">NT:&nbsp; The Dynamic Link Library Data Area</A>
<BR><A HREF="#NT__The_Sample_CharacterMmode_Application">NT:&nbsp; The Sample Character-mode Application</A>
<BR><A HREF="#NT__The_Sample_GUI_Application">NT:&nbsp; The Sample GUI Application</A>
<BR><A HREF="#NT__Using_Dynamic_Link_Libraries">NT:&nbsp; Using Dynamic Link Libraries</A>
<BR><A HREF="#NT__Windows_NT_CharacterMmode_Versus_GUI">NT:&nbsp; Windows NT Character-mode Versus GUI</A>
<BR><A HREF="#NT__Windows_NT_Dynamic_Link_Libraries">NT:&nbsp; Windows NT Dynamic Link Libraries</A>
<BR><A HREF="#NT__Windows_NT_MultiMthreaded_Applications">NT:&nbsp; Windows NT Multi-threaded Applications</A>
<BR><A HREF="#NT__Windows_NT_Programming_Note">NT:&nbsp; Windows NT Programming Note</A>
<BR><A HREF="#NT__Windows_NT_Programming_Overview">NT:&nbsp; Windows NT Programming Overview</A>
<DT>- O -
<DD><A HREF="#Open_Watcom_CDCPP_Application_Development">Open Watcom C/C++ Application Development</A>
<BR><A HREF="#OSD2__A_MultiMthreaded_Example">OS/2:&nbsp; A Multi-threaded Example</A>
<BR><A HREF="#OSD2__An_Example">OS/2:&nbsp; An Example</A>
<BR><A HREF="#OSD2__Calling_Presentation_Manager_API_Functions">OS/2:&nbsp; Calling Presentation Manager API Functions</A>
<BR><A HREF="#OSD2__Creating_a_New_Thread">OS/2:&nbsp; Creating a New Thread</A>
<BR><A HREF="#OSD2__Creating_a_Sample_Dynamic_Link_Library">OS/2:&nbsp; Creating a Sample Dynamic Link Library</A>
<BR><A HREF="#OSD2__Creating_Dynamic_Link_Libraries">OS/2:&nbsp; Creating Dynamic Link Libraries</A>
<BR><A HREF="#OSD2__Creating_Threads">OS/2:&nbsp; Creating Threads</A>
<BR><A HREF="#OSD2__Developing_an_OSD2_Physical_Device_Driver">OS/2:&nbsp; Developing an OS/2 Physical Device Driver</A>
<BR><A HREF="#OSD2__Dynamic_Link_Library_InitializationDTermination">OS/2:&nbsp; Dynamic Link Library Initialization/Termination</A>
<BR><A HREF="#OSD2__Getting_the_Current_Thread_Identifier">OS/2:&nbsp; Getting the Current Thread Identifier</A>
<BR><A HREF="#OSD2__OSD2_2_x_Dynamic_Link_Libraries">OS/2:&nbsp; OS/2 2.x Dynamic Link Libraries</A>
<BR><A HREF="#OSD2__OSD2_2_x_MultiMthreaded_Applications">OS/2:&nbsp; OS/2 2.x Multi-threaded Applications</A>
<BR><A HREF="#OSD2__Porting_Existing_CDCPP_Applications">OS/2:&nbsp; Porting Existing C/C++ Applications</A>
<BR><A HREF="#OSD2__Programming_Considerations">OS/2:&nbsp; Programming Considerations</A>
<BR><A HREF="#OSD2__Programming_for_OSD2_Presentation_Manager">OS/2:&nbsp; Programming for OS/2 Presentation Manager</A>
<BR><A HREF="#OSD2__Terminating_the_Current_Thread">OS/2:&nbsp; Terminating the Current Thread</A>
<BR><A HREF="#OSD2__The_Dynamic_Link_Library_Data_Area">OS/2:&nbsp; The Dynamic Link Library Data Area</A>
<BR><A HREF="#OSD2__Thread_Limits">OS/2:&nbsp; Thread Limits</A>
<BR><A HREF="#OSD2__Using_Dynamic_Link_Libraries">OS/2:&nbsp; Using Dynamic Link Libraries</A>
<DT>- P -
<DD><A HREF="#Phar_Lap__Building_and_Running_the_Sample_386_DOSMExtender_Application">Phar Lap:&nbsp; Building and Running the Sample 386|DOS-Extender Application</A>
<BR><A HREF="#Phar_Lap__Creating_32Mbit_Phar_Lap_386_DOSMExtender_Applications">Phar Lap:&nbsp; Creating 32-bit Phar Lap 386|DOS-Extender Applications</A>
<BR><A HREF="#Phar_Lap__Debugging_the_Sample_386_DOSMExtender_Application">Phar Lap:&nbsp; Debugging the Sample 386|DOS-Extender Application</A>
<BR><A HREF="#Phar_Lap__The_Sample_Application">Phar Lap:&nbsp; The Sample Application</A>
<DT>- R -
<DD><A HREF="#Resolving_an__Undefined_Reference__linker_error">Resolving an &quot;Undefined Reference&quot; linker error</A>
<DT>- S -
<DD><A HREF="#Spawning_ProtectedMMode_Applications_Under_Phar_Lap_386_DOSMExtender">Spawning Protected-Mode Applications Under Phar Lap 386|DOS-Extender</A>
<BR><A HREF="#Spawning_ProtectedMMode_Applications_Under_Tenberry_Software_DOSD4GW">Spawning Protected-Mode Applications Under Tenberry Software DOS/4GW</A>
<BR><A HREF="#Special_Variables_for_Windows_Programming">Special Variables for Windows Programming</A>
<BR><A HREF="#Special_Windows_API_Functions">Special Windows API Functions</A>
<BR><A HREF="#Symbol_Naming_Convention">Symbol Naming Convention</A>
<DT>- W -
<DD><A HREF="#What__Stack_Overflow___means">What &quot;Stack Overflow!&quot; means</A>
<BR><A HREF="#What_does__NULL_assignment_detected__mean_in_16Mbit_applications_">What does &quot;NULL assignment detected&quot; mean in 16-bit applications?</A>
<BR><A HREF="#What_does__size_of_DGROUP_exceeds_64K__mean_for_16Mbit_applications_">What does &quot;size of DGROUP exceeds 64K&quot; mean for 16-bit applications?</A>
<BR><A HREF="#What_you_should_know_about_optimization">What you should know about optimization</A>
<BR><A HREF="#Why_my_variables_are_not_set_to_zero">Why my variables are not set to zero</A>
<BR><A HREF="#Why_redefinition_errors_are_issued_from_WLINK">Why redefinition errors are issued from WLINK</A>
<BR><A HREF="#Windows__32Mbit_Extended_Windows_Application_Development">Windows:&nbsp; 32-bit Extended Windows Application Development</A>
<BR><A HREF="#Windows___16_Functions">Windows:&nbsp; _16 Functions</A>
<BR><A HREF="#_Call16">Windows:&nbsp; _Call16</A>
<BR><A HREF="#Windows__A_Sample_32Mbit_DLL">Windows:&nbsp; A Sample 32-bit DLL</A>
<BR><A HREF="#Windows__A_Working_Example">Windows:&nbsp; A Working Example</A>
<BR><A HREF="#AllocAlias16">Windows:&nbsp; AllocAlias16</A>
<BR><A HREF="#AllocHugeAlias16">Windows:&nbsp; AllocHugeAlias16</A>
<BR><A HREF="#Windows__Building_the_Applications">Windows:&nbsp; Building the Applications</A>
<BR><A HREF="#Windows__Callback_Function_Pointers">Windows:&nbsp; Callback Function Pointers</A>
<BR><A HREF="#Windows__Calling_16Mbit_DLLs">Windows:&nbsp; Calling 16-bit DLLs</A>
<BR><A HREF="#Windows__Calling_Functions_in_a_32Mbit_DLL_from_a_16Mbit_Application">Windows:&nbsp; Calling Functions in a 32-bit DLL from a 16-bit Application</A>
<BR><A HREF="#Windows__Can_I_WinExec_another_Windows_application_">Windows:&nbsp; Can I WinExec another Windows application?</A>
<BR><A HREF="#Windows__Can_you_call_16Mbit_code_from_a_32Mbit_code_">Windows:&nbsp; Can you call 16-bit code from a 32-bit code?</A>
<BR><A HREF="#Windows__Compiling_and_Linking_the_Examples">Windows:&nbsp; Compiling and Linking the Examples</A>
<BR><A HREF="#Windows__Creating_and_Debugging_Dynamic_Link_Libraries">Windows:&nbsp; Creating and Debugging Dynamic Link Libraries</A>
<BR><A HREF="#Windows__Debugging_a_32Mbit_DLL">Windows:&nbsp; Debugging a 32-bit DLL</A>
<BR><A HREF="#DefineDLLEntry">Windows:&nbsp; DefineDLLEntry</A>
<BR><A HREF="#DefineUserProc16">Windows:&nbsp; DefineUserProc16</A>
<BR><A HREF="#Windows__Environment_Notes">Windows:&nbsp; Environment Notes</A>
<BR><A HREF="#Windows__Far_Pointer_Manipulation">Windows:&nbsp; Far Pointer Manipulation</A>
<BR><A HREF="#Windows__FloatingMpoint_Emulation">Windows:&nbsp; Floating-point Emulation</A>
<BR><A HREF="#FreeAlias16">Windows:&nbsp; FreeAlias16</A>
<BR><A HREF="#FreeHugeAlias16">Windows:&nbsp; FreeHugeAlias16</A>
<BR><A HREF="#FreeIndirectFunctionHandle">Windows:&nbsp; FreeIndirectFunctionHandle</A>
<BR><A HREF="#GetIndirectFunctionHandle">Windows:&nbsp; GetIndirectFunctionHandle</A>
<BR><A HREF="#GetProc16">Windows:&nbsp; GetProc16</A>
<BR><A HREF="#Windows__GlobalAlloc_and_LocalAlloc">Windows:&nbsp; GlobalAlloc and LocalAlloc</A>
<BR><A HREF="#Windows__How_do_I_add_my_Windows_resources_">Windows:&nbsp; How do I add my Windows resources?</A>
<BR><A HREF="#Windows__Implementation_Overview">Windows:&nbsp; Implementation Overview</A>
<BR><A HREF="#Windows__Installing_the_Examples_under_Windows">Windows:&nbsp; Installing the Examples under Windows</A>
<BR><A HREF="#Windows__Interfacing_Visual_Basic_and_Open_Watcom_CDCPP_DLLs">Windows:&nbsp; Interfacing Visual Basic and Open Watcom C/C++ DLLs</A>
<BR><A HREF="#InvokeIndirectFunction">Windows:&nbsp; InvokeIndirectFunction</A>
<BR><A HREF="#Windows__Making_DLL_Calls_Transparent">Windows:&nbsp; Making DLL Calls Transparent</A>
<BR><A HREF="#MapAliasToFlat">Windows:&nbsp; MapAliasToFlat</A>
<BR><A HREF="#MK_FP16">Windows:&nbsp; MK_FP16</A>
<BR><A HREF="#MK_FP32">Windows:&nbsp; MK_FP32</A>
<BR><A HREF="#MK_LOCAL32">Windows:&nbsp; MK_LOCAL32</A>
<BR><A HREF="#Windows__Multiple_Instances">Windows:&nbsp; Multiple Instances</A>
<BR><A HREF="#PASS_WORD_AS_POINTER">Windows:&nbsp; PASS_WORD_AS_POINTER</A>
<BR><A HREF="#Windows__Pointer_Handling">Windows:&nbsp; Pointer Handling</A>
<BR><A HREF="#Windows__Pointers">Windows:&nbsp; Pointers</A>
<BR><A HREF="#ReleaseProc16">Windows:&nbsp; ReleaseProc16</A>
<BR><A HREF="#Windows__Running_the_Examples">Windows:&nbsp; Running the Examples</A>
<BR><A HREF="#Windows__Sample_Visual_Basic_DLL_Programs">Windows:&nbsp; Sample Visual Basic DLL Programs</A>
<BR><A HREF="#Windows__SendMessage_and_SendDlgItemMessage">Windows:&nbsp; SendMessage and SendDlgItemMessage</A>
<BR><A HREF="#Windows__Source_code_for_COVER16_DLL">Windows:&nbsp; Source code for COVER16.DLL</A>
<BR><A HREF="#Windows__Source_Code_for_VBDLL32_DLL">Windows:&nbsp; Source Code for VBDLL32.DLL</A>
<BR><A HREF="#Windows__Steps_to_Obtaining_a_32Mbit_Application">Windows:&nbsp; Steps to Obtaining a 32-bit Application</A>
<BR><A HREF="#Windows__Summary">Windows:&nbsp; Summary</A>
<BR><A HREF="#Windows__System_Overview">Windows:&nbsp; System Overview</A>
<BR><A HREF="#Windows__System_Structure">Windows:&nbsp; System Structure</A>
<BR><A HREF="#Windows__Tell_Me_More_About_Thunking_and_Aliases">Windows:&nbsp; Tell Me More About Thunking and Aliases</A>
<BR><A HREF="#Windows__The_Open_Watcom_32Mbit_Windows_3_x_Extender">Windows:&nbsp; The Open Watcom 32-bit Windows 3.x Extender</A>
<BR><A HREF="#Windows__What_about_pointers_in_structures_">Windows:&nbsp; What about pointers in structures?</A>
<BR><A HREF="#Windows__What_is_the_difference_between_AllocAlias16_and_MK_FP16_">Windows:&nbsp; What is the difference between AllocAlias16 and MK_FP16?</A>
<BR><A HREF="#Windows__What_size_of_function_pointers_passed_to_Windows_">Windows:&nbsp; What size of function pointers passed to Windows?</A>
<BR><A HREF="#Windows__When_do_I_use_MK_FP32_">Windows:&nbsp; When do I use MK_FP32?</A>
<BR><A HREF="#Windows__When_To_Convert_Incoming_Pointers">Windows:&nbsp; When To Convert Incoming Pointers</A>
<BR><A HREF="#Windows__When_To_Convert_Outgoing_Pointers">Windows:&nbsp; When To Convert Outgoing Pointers</A>
<BR><A HREF="#Windows__Why_are_32Mbit_callback_routines_FAR_">Windows:&nbsp; Why are 32-bit callback routines FAR?</A>
<BR><A HREF="#Windows__Why_use_the__16_API_functions_">Windows:&nbsp; Why use the _16 API functions?</A>
<BR><A HREF="#Windows__WIN386_Library_Functions_and_Macros">Windows:&nbsp; WIN386 Library Functions and Macros</A>
<BR><A HREF="#Windows__Window_SubMclassing">Windows:&nbsp; Window Sub-classing</A>
<BR><A HREF="#Windows__Windows_3_x_32Mbit_Programming_Overview">Windows:&nbsp; Windows 3.x 32-bit Programming Overview</A>
<BR><A HREF="#Windows__Windows_32MBit_Dynamic_Link_Libraries">Windows:&nbsp; Windows 32-Bit Dynamic Link Libraries</A>
<BR><A HREF="#Windows__WINDOWS_H">Windows:&nbsp; WINDOWS.H</A>
<BR><A HREF="#Windows__Writing_a_16Mbit_Cover_for_the_32Mbit_DLL">Windows:&nbsp; Writing a 16-bit Cover for the 32-bit DLL</A>
<BR><A HREF="#Writing_to_Video_Memory_under_Tenberry_Software_DOSD4GW">Writing to Video Memory under Tenberry Software DOS/4GW</A>
<BR><A HREF="#Writing_to_Video_Memory_under_the_Phar_Lap_386_DOSMExtender">Writing to Video Memory under the Phar Lap 386|DOS-Extender</A>
</DL>
<H1 ID="Open_Watcom_CDCPP_Application_Development"> Open Watcom C/C++ Application Development </H1>
<BR><IMG SRC="pguide.bmp">
<BR>This document contains guides to application development for several environments including 16-bit DOS, 32-bit extended
DOS, Windows 3.x, 32-bit extended Windows 3.x, Windows NT/2000/XP, Win9x, OS/2, and Novell NLMs.&nbsp; It also describes mixed
language (C, FORTRAN) application development.&nbsp; It concludes with a chapter on some general questions and the answers
to them.
<BR><BR>This document covers the following topics:
<UL>
<LI>DOS Programming Guide
<DL>
<DT>Creating 16-bit DOS Applications
<DD>
<DT>Creating 32-bit Phar Lap 386|DOS-Extender Applications
<DD>
<DT>Creating 32-bit DOS/4GW Applications
<DD>
<DT>32-bit Extended DOS Application Development
<DD>
</DL>
<LI>The DOS/4GW DOS Extender
<DL>
<DT>The Tenberry Software DOS/4GW DOS Extender
<DD>
<DT>Linear Executables
<DD>
<DT>Configuring DOS/4GW
<DD>
<DT>VMM
<DD>
<DT>Interrupt 21H Functions
<DD>
<DT>Interrupt 31H DPMI Functions
<DD>
<DT>Utilities
<DD>
<DT>Error Messages
<DD>
<DT>DOS/4GW Commonly Asked Questions
<DD>
</DL>
<LI>Windows 3.x Programming Guide
<DL>
<DT>Creating 16-bit Windows 3.x Applications
<DD>
<DT>Porting Non-GUI Applications to 16-bit Windows 3.x
<DD>
<DT>Creating 32-bit Windows 3.x Applications
<DD>
<DT>Porting Non-GUI Applications to 32-bit Windows 3.x
<DD>
<DT>The Open Watcom 32-bit Windows Extender
<DD>
<DT>Windows 3.x 32-bit Programming Overview
<DD>
<DT>Windows 32-Bit Dynamic Link Libraries
<DD>
<DT>Interfacing Visual Basic and Open Watcom C/C++ DLLs
<DD>
<DT>WIN386 Library Functions and Macros
<DD>
<DT>32-bit Extended Windows Application Development
<DD>
<DT>Special Variables for Windows Programming
<DD>
<DT>Definitions of Windows Terms
<DD>
<DT>Special Windows API Functions
<DD>
</DL>
<LI>Windows NT Programming Guide
<DL>
<DT>Windows NT Programming Overview
<DD>
<DT>Creating Windows NT GUI Applications
<DD>
<DT>Porting Non-GUI Applications to Windows NT GUI
<DD>
<DT>Windows NT Multi-threaded Applications
<DD>
<DT>Windows NT Dynamic Link Libraries
<DD>
</DL>
<LI>OS/2 Programming Guide
<DL>
<DT>Creating 16-bit OS/2 1.x Applications
<DD>
<DT>Creating 32-bit OS/2 Applications
<DD>
<DT>OS/2 Multi-threaded Applications
<DD>
<DT>OS/2 Dynamic Link Libraries
<DD>
<DT>Programming for OS/2 Presentation Manager
<DD>
</DL>
<LI>Novell NLM Programming Guide
<DL>
<DT>Creating NetWare 386 NLM Applications
<DD>
</DL>
<LI>Mixed Language Programming
<DL>
<DT>Inter-Language calls:&nbsp; C and FORTRAN
<DD>
</DL>
<LI>Common Problems
<DL>
<DT>Commonly Asked Questions and Answers
<DD>
</DL>
</UL>
<H1 ID="DOS__Creating_16Mbit_DOS_Applications"> DOS:&nbsp; Creating 16-bit DOS Applications </H1>
<BR>This chapter describes how to compile and link 16-bit DOS applications simply and quickly.
<BR><BR>We will illustrate the steps to creating 16-bit DOS applications by taking a small sample application and showing
you how to compile, link, run and debug it.
<H2 ID="DOS__The_Sample_Application"> DOS:&nbsp; The Sample Application </H2>
<BR>To demonstrate the creation of 16-bit DOS applications using command-line oriented tools, we introduce a simple sample
program.&nbsp; For our example, we are going to use the famous &quot;hello&quot; program.
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; #include &lt;stdio.h&gt;</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; void main()</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;Hello world\n&quot; );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; }</TT>
<BR><BR>The C++ version of this program follows:
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; #include &lt;iostream.h&gt;</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; void main()</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cout &lt;&lt; &quot;Hello world&quot; &lt;&lt; endl;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; }</TT>
<BR><BR>The goal of this program is to display the message &quot;Hello world&quot; on the screen.&nbsp; The C version uses
the C library<TT> printf</TT> routine to accomplish this task.&nbsp; The C++ version uses the &quot;iostream&quot; library
to accomplish this task.&nbsp; We will take you through the steps necessary to produce this result.
<H2 ID="DOS__Building_and_Running_the_Sample_DOS_Application"> DOS:&nbsp; Building and Running the Sample DOS Application </H2>
<BR>To compile and link our example program which is stored in the file<TT> hello.c</TT>, enter the following command:
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; C&gt;wcl -l=dos hello.c</TT>
<BR><BR>The typical messages that appear on the screen are shown in the following illustration.
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; C&gt;wcl -l=dos&nbsp; hello.c</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Open Watcom C/C++16 Compile and Link Utility</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Copyright (c) 2002-2019 the Open Watcom Contributors. All Rights Reserved.</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Portions Copyright (c) 1988-2002 Sybase, Inc. All Rights Reserved.</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Source code is available under the Sybase Open Watcom Public License.</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; See http://www.openwatcom.org/ for details.</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; wcc hello.c&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Open Watcom C16 Optimizing Compiler</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Copyright (c) 2002-2019 the Open Watcom Contributors. All Rights Reserved.</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Portions Copyright (c) 1984-2002 Sybase, Inc. All Rights Reserved.</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Source code is available under the Sybase Open Watcom Public License.</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; See http://www.openwatcom.org/ for details.</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; hello.c: 6 lines, included 155, 0 warnings, 0 errors</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Code size: 17</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Open Watcom Linker</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Copyright (c) 2002-2019 the Open Watcom Contributors. All Rights Reserved.</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Portions Copyright (c) 1985-2002 Sybase, Inc. All Rights Reserved.</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Source code is available under the Sybase Open Watcom Public License.</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; See http://www.openwatcom.org/ for details.</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; loading object files</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; searching libraries</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; creating a DOS executable</TT>
<BR><BR>Provided that no errors were encountered during the compile or link phases, the &quot;hello&quot; program may now
be run.
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; C&gt;hello</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Hello world</TT>
<BR><BR>If you examine the current directory, you will find that two files have been created.&nbsp; These are<TT> hello.obj</TT>
(the result of compiling<TT> hello.c</TT>) and<TT> hello.exe</TT> (the result of linking<TT> hello.obj</TT> with the appropriate
Open Watcom C/C++ libraries).&nbsp; It is<TT> hello.exe</TT> that is run by DOS when you enter the &quot;hello&quot; command.
<H2 ID="DOS__Debugging_the_Sample_DOS_Application"> DOS:&nbsp; Debugging the Sample DOS Application </H2>
<BR>Let us assume that you wish to debug your application in order to locate an error in programming.&nbsp; In the previous
section, the &quot;hello&quot; program was compiled with default compile and link options.&nbsp; When debugging an application,
it is useful to refer to the symbolic names of routines and variables.&nbsp; It is also convenient to debug at the source
line level rather than the machine language level.&nbsp; To do this, we must direct both the compiler and linker to include
additional debugging information in the object and executable files.&nbsp; Using the<B><I> WCL</I></B> command, this is fairly
straightforward.<B><I>&nbsp; WCL</I></B> recognizes the Open Watcom C/C++ compiler &quot;debug&quot; options and will create
the appropriate debug directives for the Open Watcom Linker.
<BR><BR>For example, to compile and link the &quot;hello&quot; program with debugging information, the following command may
be issued.
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; C&gt;wcl -l=dos -d2 hello.c</TT>
<BR><BR>The typical messages that appear on the screen are shown in the following illustration.
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; C&gt;wcl -l=dos&nbsp; -d2 hello.c</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Open Watcom C/C++16 Compile and Link Utility</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Copyright (c) 2002-2019 the Open Watcom Contributors. All Rights Reserved.</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Portions Copyright (c) 1988-2002 Sybase, Inc. All Rights Reserved.</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Source code is available under the Sybase Open Watcom Public License.</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; See http://www.openwatcom.org/ for details.</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; wcc hello.c&nbsp; -d2</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Open Watcom C16 Optimizing Compiler</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Copyright (c) 2002-2019 the Open Watcom Contributors. All Rights Reserved.</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Portions Copyright (c) 1984-2002 Sybase, Inc. All Rights Reserved.</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Source code is available under the Sybase Open Watcom Public License.</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; See http://www.openwatcom.org/ for details.</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; hello.c: 6 lines, included 155, 0 warnings, 0 errors</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Code size: 23</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Open Watcom Linker</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Copyright (c) 2002-2019 the Open Watcom Contributors. All Rights Reserved.</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Portions Copyright (c) 1985-2002 Sybase, Inc. All Rights Reserved.</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Source code is available under the Sybase Open Watcom Public License.</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; See http://www.openwatcom.org/ for details.</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; loading object files</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; searching libraries</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; creating a DOS executable</TT>
<BR><BR>The &quot;d2&quot; option requests the maximum amount of debugging information that can be provided by the Open Watcom
C/C++ compiler.<B><I>&nbsp; WCL</I></B> will make sure that this debugging information is included in the executable file
that is produced by the linker.
<BR><BR>The &quot;Code size&quot; value is larger than in the previous example since selection of the &quot;d2&quot; option
results in fewer code optimizations by default.&nbsp; You can request more optimization by specifying the appropriate options.
&nbsp;However, you do so at the risk of making it more difficult for yourself to determine the relationship between the object
code and the original source language code.
<BR><BR>To request the Open Watcom Debugger to assist in debugging the application, the following command may be issued.
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; C&gt;wd hello</TT>
<BR><BR>It would be too ambitious to describe the debugger in this introductory chapter so we refer you to the book entitled<B><I>
Open Watcom Debugger User's Guide.</I></B>
<H1 ID="Phar_Lap__Creating_32Mbit_Phar_Lap_386_DOSMExtender_Applications"> Phar Lap:&nbsp; Creating 32-bit Phar Lap 386|DOS-Extender Applications </H1>
<BR>This chapter describes how to compile and link 32-bit Phar Lap 386|DOS-Extender applications simply and quickly.
<BR><BR>We will illustrate the steps to creating 32-bit Phar Lap 386|DOS-Extender applications by taking a small sample application
and showing you how to compile, link, run and debug it.
<H2 ID="Phar_Lap__The_Sample_Application"> Phar Lap:&nbsp; The Sample Application </H2>
<BR>To demonstrate the creation of 32-bit Phar Lap 386|DOS-Extender applications using command-line oriented tools, we introduce
a simple sample program.&nbsp; For our example, we are going to use the famous &quot;hello&quot; program.
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; #include &lt;stdio.h&gt;</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; void main()</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;Hello world\n&quot; );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; }</TT>
<BR><BR>The C++ version of this program follows:
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; #include &lt;iostream.h&gt;</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; void main()</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cout &lt;&lt; &quot;Hello world&quot; &lt;&lt; endl;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; }</TT>
<BR><BR>The goal of this program is to display the message &quot;Hello world&quot; on the screen.&nbsp; The C version uses
the C library<TT> printf</TT> routine to accomplish this task.&nbsp; The C++ version uses the &quot;iostream&quot; library
to accomplish this task.&nbsp; We will take you through the steps necessary to produce this result.
<H2 ID="Phar_Lap__Building_and_Running_the_Sample_386_DOSMExtender_Application"> Phar Lap:&nbsp; Building and Running the Sample 386|DOS-Extender Application </H2>
<BR>To compile and link our example program which is stored in the file<TT> hello.c</TT>, enter the following command:
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; C&gt;wcl386 -l=pharlap hello.c</TT>
<BR><BR>The typical messages that appear on the screen are shown in the following illustration.
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; C&gt;wcl386 -l=pharlap&nbsp; hello.c</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Open Watcom C/C++32 Compile and Link Utility</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Copyright (c) 2002-2019 the Open Watcom Contributors. All Rights Reserved.</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Portions Copyright (c) 1988-2002 Sybase, Inc. All Rights Reserved.</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Source code is available under the Sybase Open Watcom Public License.</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; See http://www.openwatcom.org/ for details.</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; wcc386 hello.c&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Open Watcom C32 Optimizing Compiler</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Copyright (c) 2002-2019 the Open Watcom Contributors. All Rights Reserved.</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Portions Copyright (c) 1984-2002 Sybase, Inc. All Rights Reserved.</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Source code is available under the Sybase Open Watcom Public License.</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; See http://www.openwatcom.org/ for details.</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; hello.c: 6 lines, included 174, 0 warnings, 0 errors</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Code size: 24</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Open Watcom Linker</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Copyright (c) 2002-2019 the Open Watcom Contributors. All Rights Reserved.</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Portions Copyright (c) 1985-2002 Sybase, Inc. All Rights Reserved.</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Source code is available under the Sybase Open Watcom Public License.</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; See http://www.openwatcom.org/ for details.</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; loading object files</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; searching libraries</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; creating a Phar Lap simple executable</TT>
<BR><BR>Provided that no errors were encountered during the compile or link phases, the &quot;hello&quot; program may now
be run.
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; C&gt;run386 hello</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Hello world</TT>
<BR><BR>If you examine the current directory, you will find that two files have been created.&nbsp; These are<TT> hello.obj</TT>
(the result of compiling<TT> hello.c</TT>) and<TT> hello.exp</TT> (the result of linking<TT> hello.obj</TT> with the appropriate
Open Watcom C/C++ libraries).&nbsp; It is<TT> hello.exp</TT> that is run by DOS when you enter the &quot;run386 hello&quot;
command.
<H2 ID="Phar_Lap__Debugging_the_Sample_386_DOSMExtender_Application"> Phar Lap:&nbsp; Debugging the Sample 386|DOS-Extender Application </H2>
<BR>Let us assume that you wish to debug your application in order to locate an error in programming.&nbsp; In the previous
section, the &quot;hello&quot; program was compiled with default compile and link options.&nbsp; When debugging an application,
it is useful to refer to the symbolic names of routines and variables.&nbsp; It is also convenient to debug at the source
line level rather than the machine language level.&nbsp; To do this, we must direct both the compiler and linker to include
additional debugging information in the object and executable files.&nbsp; Using the<B><I> WCL386</I></B> command, this is
fairly straightforward.<B><I>&nbsp; WCL386</I></B> recognizes the Open Watcom C/C++ compiler &quot;debug&quot; options and
will create the appropriate debug directives for the Open Watcom Linker.
<BR><BR>For example, to compile and link the &quot;hello&quot; program with debugging information, the following command may
be issued.
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; C&gt;wcl386 -l=pharlap -d2 hello.c</TT>
<BR><BR>The typical messages that appear on the screen are shown in the following illustration.
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; C&gt;wcl386 -l=pharlap&nbsp; -d2 hello.c</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Open Watcom C/C++32 Compile and Link Utility</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Copyright (c) 2002-2019 the Open Watcom Contributors. All Rights Reserved.</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Portions Copyright (c) 1988-2002 Sybase, Inc. All Rights Reserved.</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Source code is available under the Sybase Open Watcom Public License.</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; See http://www.openwatcom.org/ for details.</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; wcc386 hello.c&nbsp; -d2</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Open Watcom C32 Optimizing Compiler</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Copyright (c) 2002-2019 the Open Watcom Contributors. All Rights Reserved.</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Portions Copyright (c) 1984-2002 Sybase, Inc. All Rights Reserved.</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Source code is available under the Sybase Open Watcom Public License.</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; See http://www.openwatcom.org/ for details.</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; hello.c: 6 lines, included 174, 0 warnings, 0 errors</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Code size: 45</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Open Watcom Linker</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Copyright (c) 2002-2019 the Open Watcom Contributors. All Rights Reserved.</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Portions Copyright (c) 1985-2002 Sybase, Inc. All Rights Reserved.</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Source code is available under the Sybase Open Watcom Public License.</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; See http://www.openwatcom.org/ for details.</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; loading object files</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; searching libraries</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; creating a Phar Lap simple executable</TT>
<BR><BR>The &quot;d2&quot; option requests the maximum amount of debugging information that can be provided by the Open Watcom
C/C++ compiler.<B><I>&nbsp; WCL386</I></B> will make sure that this debugging information is included in the executable file
that is produced by the linker.
<BR><BR>The &quot;Code size&quot; value is larger than in the previous example since selection of the &quot;d2&quot; option
results in fewer code optimizations by default.&nbsp; You can request more optimization by specifying the appropriate options.
&nbsp;However, you do so at the risk of making it more difficult for yourself to determine the relationship between the object
code and the original source language code.
<BR><BR>To request the Open Watcom Debugger to assist in debugging the application, the following command may be issued.
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; C&gt;wd /trap=pls hello</TT>
<BR><BR>It would be too ambitious to describe the debugger in this introductory chapter so we refer you to the book entitled<B><I>
Open Watcom Debugger User's Guide.</I></B>
<H1 ID="DOSD4GW__Creating_32Mbit_DOSD4GW_Applications"> DOS/4GW:&nbsp; Creating 32-bit DOS/4GW Applications </H1>
<BR>This chapter describes how to compile and link 32-bit DOS/4GW applications simply and quickly.
<BR><BR>We will illustrate the steps to creating 32-bit DOS/4GW applications by taking a small sample application and showing
you how to compile, link, run and debug it.
<H2 ID="DOSD4GW__The_Sample_Application"> DOS/4GW:&nbsp; The Sample Application </H2>
<BR>To demonstrate the creation of 32-bit DOS/4GW applications using command-line oriented tools, we introduce a simple sample
program.&nbsp; For our example, we are going to use the famous &quot;hello&quot; program.
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; #include &lt;stdio.h&gt;</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; void main()</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;Hello world\n&quot; );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; }</TT>
<BR><BR>The C++ version of this program follows:
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; #include &lt;iostream.h&gt;</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; void main()</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cout &lt;&lt; &quot;Hello world&quot; &lt;&lt; endl;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; }</TT>
<BR><BR>The goal of this program is to display the message &quot;Hello world&quot; on the screen.&nbsp; The C version uses
the C library<TT> printf</TT> routine to accomplish this task.&nbsp; The C++ version uses the &quot;iostream&quot; library
to accomplish this task.&nbsp; We will take you through the steps necessary to produce this result.
<H2 ID="DOSD4GW__Building_and_Running_the_Sample_DOSD4GW_Application"> DOS/4GW:&nbsp; Building and Running the Sample DOS/4GW Application </H2>
<BR>To compile and link our example program which is stored in the file<TT> hello.c</TT>, enter the following command:
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; C&gt;wcl386 -l=dos4g hello.c</TT>
<BR><BR>The typical messages that appear on the screen are shown in the following illustration.
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; C&gt;wcl386 -l=dos4g&nbsp; hello.c</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Open Watcom C/C++32 Compile and Link Utility</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Copyright (c) 2002-2019 the Open Watcom Contributors. All Rights Reserved.</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Portions Copyright (c) 1988-2002 Sybase, Inc. All Rights Reserved.</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Source code is available under the Sybase Open Watcom Public License.</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; See http://www.openwatcom.org/ for details.</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; wcc386 hello.c&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Open Watcom C32 Optimizing Compiler</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Copyright (c) 2002-2019 the Open Watcom Contributors. All Rights Reserved.</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Portions Copyright (c) 1984-2002 Sybase, Inc. All Rights Reserved.</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Source code is available under the Sybase Open Watcom Public License.</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; See http://www.openwatcom.org/ for details.</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; hello.c: 6 lines, included 174, 0 warnings, 0 errors</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Code size: 24</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Open Watcom Linker</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Copyright (c) 2002-2019 the Open Watcom Contributors. All Rights Reserved.</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Portions Copyright (c) 1985-2002 Sybase, Inc. All Rights Reserved.</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Source code is available under the Sybase Open Watcom Public License.</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; See http://www.openwatcom.org/ for details.</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; loading object files</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; searching libraries</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; creating a DOS/4G executable</TT>
<BR><BR>Provided that no errors were encountered during the compile or link phases, the &quot;hello&quot; program may now
be run.
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; C&gt;hello</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Hello world</TT>
<BR><BR>If you examine the current directory, you will find that two files have been created.&nbsp; These are<TT> hello.obj</TT>
(the result of compiling<TT> hello.c</TT>) and<TT> hello.exe</TT> (the result of linking<TT> hello.obj</TT> with the appropriate
Open Watcom C/C++ libraries).&nbsp; It is<TT> hello.exe</TT> that is run by DOS when you enter the &quot;hello&quot; command.
<H2 ID="DOSD4GW__Debugging_the_Sample_DOSD4GW_Application"> DOS/4GW:&nbsp; Debugging the Sample DOS/4GW Application </H2>
<BR>Let us assume that you wish to debug your application in order to locate an error in programming.&nbsp; In the previous
section, the &quot;hello&quot; program was compiled with default compile and link options.&nbsp; When debugging an application,
it is useful to refer to the symbolic names of routines and variables.&nbsp; It is also convenient to debug at the source
line level rather than the machine language level.&nbsp; To do this, we must direct both the compiler and linker to include
additional debugging information in the object and executable files.&nbsp; Using the<B><I> WCL386</I></B> command, this is
fairly straightforward.<B><I>&nbsp; WCL386</I></B> recognizes the Open Watcom C/C++ compiler &quot;debug&quot; options and
will create the appropriate debug directives for the Open Watcom Linker.
<BR><BR>For example, to compile and link the &quot;hello&quot; program with debugging information, the following command may
be issued.
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; C&gt;wcl386 -l=dos4g -d2 hello.c</TT>
<BR><BR>The typical messages that appear on the screen are shown in the following illustration.
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; C&gt;wcl386 -l=dos4g&nbsp; -d2 hello.c</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Open Watcom C/C++32 Compile and Link Utility</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Copyright (c) 2002-2019 the Open Watcom Contributors. All Rights Reserved.</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Portions Copyright (c) 1988-2002 Sybase, Inc. All Rights Reserved.</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Source code is available under the Sybase Open Watcom Public License.</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; See http://www.openwatcom.org/ for details.</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; wcc386 hello.c&nbsp; -d2</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Open Watcom C32 Optimizing Compiler</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Copyright (c) 2002-2019 the Open Watcom Contributors. All Rights Reserved.</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Portions Copyright (c) 1984-2002 Sybase, Inc. All Rights Reserved.</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Source code is available under the Sybase Open Watcom Public License.</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; See http://www.openwatcom.org/ for details.</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; hello.c: 6 lines, included 174, 0 warnings, 0 errors</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Code size: 45</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Open Watcom Linker</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Copyright (c) 2002-2019 the Open Watcom Contributors. All Rights Reserved.</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Portions Copyright (c) 1985-2002 Sybase, Inc. All Rights Reserved.</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Source code is available under the Sybase Open Watcom Public License.</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; See http://www.openwatcom.org/ for details.</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; loading object files</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; searching libraries</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; creating a DOS/4G executable</TT>
<BR><BR>The &quot;d2&quot; option requests the maximum amount of debugging information that can be provided by the Open Watcom
C/C++ compiler.<B><I>&nbsp; WCL386</I></B> will make sure that this debugging information is included in the executable file
that is produced by the linker.
<BR><BR>The &quot;Code size&quot; value is larger than in the previous example since selection of the &quot;d2&quot; option
results in fewer code optimizations by default.&nbsp; You can request more optimization by specifying the appropriate options.
&nbsp;However, you do so at the risk of making it more difficult for yourself to determine the relationship between the object
code and the original source language code.
<BR><BR>To request the Open Watcom Debugger to assist in debugging the application, the following command may be issued.
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; C&gt;wd /trap=rsi hello</TT>
<BR><BR>It would be too ambitious to describe the debugger in this introductory chapter so we refer you to the book entitled<B><I>
Open Watcom Debugger User's Guide.</I></B>
<H1 ID="32Mbit_Extended_DOS_Application_Development"> 32-bit Extended DOS Application Development </H1>
<BR>The purpose of this chapter is to anticipate common programming questions for 32-bit extended DOS application development.
&nbsp;Note that these programming solutions may be DOS-extender specific and therefore may not work for other DOS extenders.
<BR><BR>The following topics are discussed in this chapter:
<UL>
<LI>How can I write directly to video memory using a DOS extender?
<LI>How do I get information about free memory in the 32-bit environment?
<LI>How do I access the first megabyte in the extended DOS environment?
<LI>How do I spawn a protected-mode application?
<LI>How can I use the mouse interrupt (0x33) with DOS/4GW?
<LI>How do I simulate a real-mode interrupt with DOS/4GW?
<LI>How do you install a bi-modal interrupt handler with DOS/4GW?
</UL>
<BR>Please refer to the<B><I> DOS Protected-Mode Interface (DPMI) Specification</I></B> for information on DPMI services.
&nbsp;In the past, the DPMI specification could be obtained free of charge by contacting Intel Literature JP26 at 800-548-4725
or by writing to the address below.&nbsp; We have been advised that the DPMI specification is no longer available in printed
form.
<BR><BR>&nbsp;&nbsp;&nbsp;&nbsp; Intel Literature JP26
<BR>&nbsp;&nbsp;&nbsp;&nbsp; 3065 Bowers Avenue
<BR>&nbsp;&nbsp;&nbsp;&nbsp; P.O. Box 58065
<BR>&nbsp;&nbsp;&nbsp;&nbsp; Santa Clara, California
<BR>&nbsp;&nbsp;&nbsp;&nbsp; U.S.A. 95051-8065
<BR><BR>However, the DPMI 1.0 specification can be obtained from the Intel ftp site.&nbsp; Here is the URL.
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; ftp://ftp.intel.com/pub/IAL/software_specs/dpmiv1.zip</TT>
<BR><BR>This ZIP file contains a Postscript version of the DPMI 1.0 specification.
<H2 ID="How_can_I_write_directly_to_video_memory_using_a_DOS_extender_"> How can I write directly to video memory using a DOS extender? </H2>
<BR>Many programmers require access to video RAM in order to directly manipulate data on the screen.&nbsp; Under DOS, it was
standard practice to use a far pointer, with the segment part of the far pointer set to the screen segment.&nbsp; Under DOS
extenders, this practice is not so standard.&nbsp; Each DOS extender provides its own method for accessing video memory.
<H3 ID="Writing_to_Video_Memory_under_Tenberry_Software_DOSD4GW"> Writing to Video Memory under Tenberry Software DOS/4GW </H3>
<BR>Under DOS/4GW, the first megabyte of physical memory is mapped as a shared linear address space.&nbsp; This allows your
application to access video RAM using a near pointer set to the screen's linear address.&nbsp; The following program demonstrates
this method.
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; /*</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; SCREEN.C - This example shows how to write directly</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; to screen memory under the DOS/4GW dos-extender.</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Compile &amp; Link: wcl386 -l=dos4g SCREEN</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; #include &lt;stdio.h&gt;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; #include &lt;dos.h&gt;</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; /*</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Under DOS/4GW, the first megabyte of physical memory</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (real-mode memory) is mapped as a shared linear address</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; space. This allows your application to access video RAM</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; using its linear address.&nbsp; The DOS segment:offset of</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; B800:0000 corresponds to a linear address of B8000.</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; #define SCREEN_AREA 0xb800</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; #define SCREEN_LIN_ADDR ((SCREEN_AREA) &lt;&lt; 4)</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; #define SCREEN_SIZE 80*25</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; void main()</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; char&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; *ptr;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; i;</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* Set the pointer to the screen's linear address */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ptr = (char *)SCREEN_LIN_ADDR;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for( i = 0; i &lt; SCREEN_SIZE - 1; i++ ) {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; *ptr = '*';</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ptr += 2 * sizeof( char );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; }</TT>
<BR><BR>Please refer to the chapter entitled <A HREF="#DOSD4GW__Linear_Executables">DOS/4GW:&nbsp; Linear Executables</A>
for more information on how DOS/4GW maps the first megabyte.
<H3 ID="Writing_to_Video_Memory_under_the_Phar_Lap_386_DOSMExtender"> Writing to Video Memory under the Phar Lap 386|DOS-Extender </H3>
<BR>The Phar Lap DOS extender provides screen access through the special segment selector 0x1C.&nbsp; This allows far pointer
access to video RAM from a 32-bit program.&nbsp; The following example illustrates this technique.
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; /*</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; SCREENPL.C - This example shows how to write directly</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; to screen memory under the Phar Lap DOS extender.</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Compile &amp; Link: wcl386 -l=pharlap SCREENPL</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; #include &lt;stdio.h&gt;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; #include &lt;dos.h&gt;</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; /*</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Phar Lap allows access to screen memory through a</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; special selector.&nbsp; Refer to &quot;Hardware Access&quot; in</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Phar Lap's documentation for details.</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; #define PL_SCREEN_SELECTOR 0x1c</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; #define SCREEN_SIZE 80*25</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; void main()</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* Need a far pointer to use the screen selector */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; char far&nbsp;&nbsp; *ptr;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; i;</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* Make a far pointer to screen memory */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ptr = MK_FP( PL_SCREEN_SELECTOR, 0 );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for( i = 0; i &lt; SCREEN_SIZE - 1; i++ ) {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; *ptr = '*';</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ptr += 2 * sizeof( char );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; }</TT>
<BR><BR>It is also possible to map screen memory into your near memory using Phar Lap system calls.&nbsp; Please refer to
the chapter entitled &quot;386|DOS-Extender System Calls&quot; in Phar Lap's<B><I> 386|DOS-Extender Reference Manual</I></B>
for details.
<H2 ID="How_do_I_get_information_about_free_memory_in_the_32Mbit_environment_"> How do I get information about free memory in the 32-bit environment? </H2>
<BR>Under a virtual memory system, programmers are often interested in the amount of physical memory they can allocate.&nbsp;
Information about the amount of free memory that is available is always provided under a DPMI host, however, the manner in
which this information is provided may differ under various environments.&nbsp; Keep in mind that in a multi-tasking environment,
the information returned to your task from the DPMI host can easily become obsolete if other tasks allocate memory independently
of your task.
<H3 ID="Getting_Free_Memory_Information_under_DOSD4GW"> Getting Free Memory Information under DOS/4GW </H3>
<BR>DOS/4GW provides a DPMI interface through interrupt 0x31.&nbsp; This allows you to use DPMI service 0x0500 to get free
memory information.&nbsp; The following program illustrates this procedure.
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; /*</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; MEMORY.C - This example shows how to get information</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; about free memory using DPMI call 0500h under DOS/4GW.</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Note that only the first field of the structure is</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; guaranteed to contain a valid value; any field that</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; is not returned by DOS/4GW is set to -1 (0FFFFFFFFh).</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Compile &amp; Link: wcl386 -l=dos4g memory</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; #include &lt;i86.h&gt;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; #include &lt;dos.h&gt;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; #include &lt;stdio.h&gt;</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; #define DPMI_INT&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0x31</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; struct meminfo {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; unsigned LargestBlockAvail;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; unsigned MaxUnlockedPage;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; unsigned LargestLockablePage;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; unsigned LinAddrSpace;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; unsigned NumFreePagesAvail;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; unsigned NumPhysicalPagesFree;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; unsigned TotalPhysicalPages;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; unsigned FreeLinAddrSpace;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; unsigned SizeOfPageFile;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; unsigned Reserved[3];</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; } MemInfo;</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; void main()</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; union REGS regs;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; struct SREGS sregs;</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; regs.x.eax = 0x00000500;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; memset( &amp;sregs, 0, sizeof(sregs) );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; sregs.es = FP_SEG( &amp;MemInfo );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; regs.x.edi = FP_OFF( &amp;MemInfo );</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int386x( DPMI_INT, &amp;regs, &amp;regs, &amp;sregs );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;Largest available block (in bytes): %lu\n&quot;,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; MemInfo.LargestBlockAvail
);</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;Maximum unlocked page allocation: %lu\n&quot;,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; MemInfo.MaxUnlockedPage
);</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;Pages that can be allocated and locked: &quot;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &quot;%lu\n&quot;,
MemInfo.LargestLockablePage );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;Total linear address space including &quot;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &quot;allocated pages:
%lu\n&quot;,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; MemInfo.LinAddrSpace
);</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;Number of free pages available: %lu\n&quot;,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; MemInfo.NumFreePagesAvail
);</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;Number of physical pages not in use: %lu\n&quot;,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; MemInfo.NumPhysicalPagesFree
);</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;Total physical pages managed by host: %lu\n&quot;,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; MemInfo.TotalPhysicalPages
);</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;Free linear address space (pages): %lu\n&quot;,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; MemInfo.FreeLinAddrSpace
);</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;Size of paging/file partition (pages): %lu\n&quot;,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; MemInfo.SizeOfPageFile
);</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; }</TT>
<BR><BR>Please refer to the chapter entitled <A HREF="#DOSD4GW__Interrupt_31H_DPMI_Functions">DOS/4GW:&nbsp; Interrupt 31H DPMI Functions</A>
for more information on DPMI services.
<H3 ID="Getting_Free_Memory_Information_under_the_Phar_Lap_386_DOSMExtender"> Getting Free Memory Information under the Phar Lap 386|DOS-Extender </H3>
<BR>Phar Lap provides memory statistics through 386|DOS-Extender System Call 0x2520.&nbsp; The following example illustrates
how to use this system call from a 32-bit program.
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; /*</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; MEMPLS40.C - This is an example of how to get the</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; amount of physical memory present under Phar Lap</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 386|DOS-Extender v4.0.</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Compile &amp; Link: wcl386 -l=pharlap MEMPLS40</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; #include &lt;dos.h&gt;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; #include &lt;stdio.h&gt;</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; typedef struct {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; unsigned data[25];</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; } pharlap_mem_status;</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; /* Names suggested in Phar Lap documentation */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; #define APHYSPG&nbsp;&nbsp;&nbsp;&nbsp; 5</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; #define SYSPHYSPG&nbsp;&nbsp; 7</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; #define NFREEPG&nbsp;&nbsp;&nbsp;&nbsp; 21</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; unsigned long memavail( void )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pharlap_mem_status status;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; union REGS regs;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; unsigned long amount;</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; regs.h.ah = 0x25;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; regs.h.al = 0x20;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; regs.h.bl = 0;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; regs.x.edx = (unsigned int) &amp;status;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; intdos( &amp;regs, &amp;regs );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* equation is given in description for nfreepg */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; amount = status.data[ APHYSPG ];</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; amount += status.data[ SYSPHYSPG ];</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; amount += status.data[ NFREEPG ];</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return( amount * 4096 );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; }</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; void main()</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;%lu bytes of memory available\n&quot;,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; memavail() );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; }</TT>
<BR><BR>Please refer to the chapter entitled &quot;386|DOS-Extender System Calls&quot; in Phar Lap's<B><I> 386|DOS-Extender
Reference Manual</I></B> for more information on 386|DOS-Extender System Calls.
<H3 ID="Getting_Free_Memory_Information_in_the_32Mbit_Environment_under_Windows_3_x"> Getting Free Memory Information in the 32-bit Environment under Windows 3.x </H3>
<BR>Windows 3.x provides a DPMI host that you can access from a 32-bit program.&nbsp; The interface to this host is a 16-bit
interface, hence there are some considerations involved when calling Windows 3.x DPMI services from 32-bit code.&nbsp; If
a pointer to a data buffer is required to be passed in ES:DI, for example, an AllocAlias16() may be used to get a 16-bit far
pointer that can be passed to Windows 3.x through these registers.&nbsp; Also, an int86() call should be issued rather than
an int386() call.&nbsp; The following program demonstrates the techniques mentioned above.
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; /*</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; MEMWIN.C - This example shows how to get information</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; about free memory with DPMI call 0x0500 using Windows</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; as a DPMI host.&nbsp; Note that only the first field of the</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; structure is guaranteed to contain a valid value; any</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; field that is not returned by the DPMI implementation</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; is set to -1 (0FFFFFFFFh).</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Compile &amp; Link: wcl386 -l=win386 -zw memwin</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Bind: wbind -n memwin</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; #include &lt;windows.h&gt;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; #include &lt;i86.h&gt;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; #include &lt;dos.h&gt;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; #include &lt;stdio.h&gt;</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; struct meminfo {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; unsigned LargestBlockAvail;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; unsigned MaxUnlockedPage;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; unsigned LargestLockablePage;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; unsigned LinAddrSpace;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; unsigned NumFreePagesAvail;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; unsigned NumPhysicalPagesFree;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; unsigned TotalPhysicalPages;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; unsigned FreeLinAddrSpace;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; unsigned SizeOfPageFile;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; unsigned Reserved[3];</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; } MemInfo;</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; #define DPMI_INT&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0x31</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; void main()</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; union REGS regs;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; struct SREGS sregs;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DWORD mi_16;</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; regs.w.ax = 0x0500;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mi_16 = AllocAlias16( &amp;MemInfo );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; sregs.es = HIWORD( mi_16 );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; regs.x.di = LOWORD( mi_16 );</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int86x( DPMI_INT, &amp;regs, &amp;regs, &amp;sregs );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;Largest available block (in bytes): %lu\n&quot;,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; MemInfo.LargestBlockAvail
);</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;Maximum unlocked page allocation: %lu\n&quot;,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; MemInfo.MaxUnlockedPage
);</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;Pages that can be allocated and locked: &quot;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &quot;%lu\n&quot;,
MemInfo.LargestLockablePage );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;Total linear address space including &quot;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &quot;allocated pages:
%lu\n&quot;,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; MemInfo.LinAddrSpace
);</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;Number of free pages available: %lu\n&quot;,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; MemInfo.NumFreePagesAvail
);</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;Number of physical pages not in use: %lu\n&quot;,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; MemInfo.NumPhysicalPagesFree
);</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;Total physical pages managed by host: %lu\n&quot;,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; MemInfo.TotalPhysicalPages
);</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;Free linear address space (pages): %lu\n&quot;,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; MemInfo.FreeLinAddrSpace
);</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;Size of paging/file partition (pages): %lu\n&quot;,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; MemInfo.SizeOfPageFile
);</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; FreeAlias16( mi_16 );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; }</TT>
<BR><BR>Please refer to the<B><I> DOS Protected-Mode Interface (DPMI) Specification</I></B> for information on DPMI services.
&nbsp;In the past, the DPMI specification could be obtained free of charge by contacting Intel Literature JP26 at 800-548-4725
or by writing to the address below.&nbsp; We have been advised that the DPMI specification is no longer available in printed
form.
<BR><BR>&nbsp;&nbsp;&nbsp;&nbsp; Intel Literature JP26
<BR>&nbsp;&nbsp;&nbsp;&nbsp; 3065 Bowers Avenue
<BR>&nbsp;&nbsp;&nbsp;&nbsp; P.O. Box 58065
<BR>&nbsp;&nbsp;&nbsp;&nbsp; Santa Clara, California
<BR>&nbsp;&nbsp;&nbsp;&nbsp; U.S.A. 95051-8065
<BR><BR>However, the DPMI 1.0 specification can be obtained from the Intel ftp site.&nbsp; Here is the URL.
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; ftp://ftp.intel.com/pub/IAL/software_specs/dpmiv1.zip</TT>
<BR><BR>This ZIP file contains a Postscript version of the DPMI 1.0 specification.
<H2 ID="How_do_I_access_the_first_megabyte_in_the_extended_DOS_environment_"> How do I access the first megabyte in the extended DOS environment? </H2>
<BR>Many programmers require access to the first megabyte of memory in order to look at key low memory addresses.&nbsp; Under
DOS, it was standard practice to use a far pointer, with the far pointer set to the segmented address of the memory area that
was being inspected.&nbsp; Under DOS extenders, this practice is not so standard.&nbsp; Each DOS extender provides its own
method for accessing the first megabyte of memory.
<H3 ID="Accessing_the_First_Megabyte_under_Tenberry_Software_DOSD4GW"> Accessing the First Megabyte under Tenberry Software DOS/4GW </H3>
<BR>Under DOS/4GW, the first megabyte of physical memory - the real memory - is mapped as a shared linear address space.&nbsp;
This allows your application to access the first megabyte of memory using a near pointer set to the linear address.&nbsp;
The following program demonstrates this method.&nbsp; This example is similar to the screen memory access example.
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; /*</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; KEYSTAT.C - This example shows how to get the keyboard</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; status under DOS/4GW by looking at the ROM BIOS</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; keyboard status byte in low memory.</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Compile &amp; Link: wcl386 -l=dos4g keystat</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; #include &lt;stdio.h&gt;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; #include &lt;dos.h&gt;</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; /*</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Under DOS, the keyboard status byte has a segmented</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; address of 0x0040:0x0017.&nbsp; This corresponds to a</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; linear address of 0x417.</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; #define LOW_AREA 0x417</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; void main()</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* Only need a near pointer in the flat model */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; char *ptr;</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* Set pointer to linear address of the first</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; status byte */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ptr = (char *)LOW_AREA;</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* Caps lock state is in bit 6 */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if( *ptr &amp; 0x40 ) {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; puts( &quot;Caps Lock on&quot; );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* Num lock state is in bit 5 */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if( *ptr &amp; 0x20 ) {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; puts( &quot;Num Lock on&quot; );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* Scroll lock state is in bit 4 */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if( *ptr &amp; 0x10 ) {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; puts( &quot;Scroll Lock on&quot; );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; }</TT>
<BR><BR>Please refer to the chapter entitled <A HREF="#DOSD4GW__Linear_Executables">DOS/4GW:&nbsp; Linear Executables</A>
for more information on how DOS/4GW maps the first megabyte.
<H3 ID="Accessing_the_First_Megabyte_under_the_Phar_Lap_386_DOSMExtender"> Accessing the First Megabyte under the Phar Lap 386|DOS-Extender </H3>
<BR>The Phar Lap DOS extender provides access to real memory through the special segment selector 0x34.&nbsp; This allows
far pointer access to the first megabyte from a 32-bit program.&nbsp; The following example illustrates this technique.
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; /*</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; KEYSTAPL.C - This example shows how to get the keyboard</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; status under 386|DOS-Extender by looking at the ROM</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; BIOS keyboard status byte in low memory.</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Compile &amp; Link: wcl386 -l=pharlap keystapl</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; #include &lt;stdio.h&gt;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; #include &lt;dos.h&gt;</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; /*</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Under DOS, the keyboard status byte has a segmented</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; address of 0x0040:0x0017.&nbsp; This corresponds to a</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; linear address of 0x417.</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; */</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; void main()</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* We require a far pointer to use selector</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for 1st megabyte */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; char far *ptr;</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* Set pointer to segmented address of the first</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; status byte */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ptr = MK_FP( 0x34, 0x417 );</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* Caps lock state is in bit 6 */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if( *ptr &amp; 0x40 ) {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; puts( &quot;Caps Lock on&quot; );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* Num lock state is in bit 5 */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if( *ptr &amp; 0x20 ) {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; puts( &quot;Num Lock on&quot; );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* Scroll lock state is in bit 4 */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if( *ptr &amp; 0x10 ) {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; puts( &quot;Scroll Lock on&quot; );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; }</TT>
<BR><BR>Please refer to the chapter entitled &quot;Program Environment&quot; in Phar Lap's<B><I> 386|DOS-Extender Reference
Manual</I></B> for more information on segment selectors available to your program.
<H2 ID="How_do_I_spawn_a_protectedMmode_application_"> How do I spawn a protected-mode application? </H2>
<BR>Sometimes applications need to spawn other programs as part of their execution.&nbsp; In the extended DOS environment,
spawning tasks is much the same as under DOS, however it should be noted that the only mode supported is P_WAIT.&nbsp; The
P_OVERLAY mode is not supported since the DOS extender cannot be removed from memory by the application (this is also the
reason why the exec() functions are unsupported).&nbsp; The other modes are for concurrent operating systems only.
<BR><BR>Also, unless the application being spawned is bound or stubbed, the DOS extender must be spawned with the application
and its arguments passed in the parameter list.
<H3 ID="Spawning_ProtectedMMode_Applications_Under_Tenberry_Software_DOSD4GW"> Spawning Protected-Mode Applications Under Tenberry Software DOS/4GW </H3>
<BR>In the case of DOS/4GW, some real-mode memory must be set aside at run time for spawning the DOS extender, otherwise the
spawning application could potentially allocate all of system memory.&nbsp; The real memory can be reserved from within your
program by assigning the global variable<TT> __minreal</TT> the number of bytes to be set aside.&nbsp; This variable is referenced
in<TT> &lt;stdlib.h&gt;.</TT>&nbsp; The following two programs demonstrate how to spawn a DOS/4GW application.
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; /*</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; SPWNRD4G.C - The following program demonstrates how to</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; spawn another DOS/4GW application.</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Compile and link: wcl386 -l=dos4g spwnrd4g</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; #include &lt;process.h&gt;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; #include &lt;stdio.h&gt;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; #include &lt;stdlib.h&gt;</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; /* DOS/4GW var for WLINK MINREAL option */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; unsigned __near __minreal = 100*1024;</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; void main()</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int app2_exit_code;</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; puts( &quot;Spawning a protected-mode application...&quot;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &quot;using spawnlp() with P_WAIT&quot;
);</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; app2_exit_code = spawnlp( P_WAIT, &quot;dos4gw&quot;,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &quot;dos4gw&quot;, &quot;spwndd4g&quot;, NULL );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;Application #2 returned with exit code %d\n&quot;,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; app2_exit_code );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; }</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; /*</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; SPWNDD4G.C - Will be spawned by the SPWNRD4G program.</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Compile &amp; Link: wcl386 -l=dos4g spwndd4g</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; #include &lt;stdio.h&gt;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; #include &lt;stdlib.h&gt;</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; void main()</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; puts( &quot;\nApplication #2 spawned\n&quot; );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* Send back exit code 59 */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; exit( 59 );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; }</TT>
<H3 ID="Spawning_ProtectedMMode_Applications_Under_Phar_Lap_386_DOSMExtender"> Spawning Protected-Mode Applications Under Phar Lap 386|DOS-Extender </H3>
<BR>In the case of the Phar Lap 386|DOS-Extender, some real-mode memory must be set aside at link time for spawning the DOS
extender, otherwise the spawning application will be assigned all the system memory at startup.&nbsp; This is done at link
time by specifying the<B> runtime minreal</B> and<B> runtime maxreal</B> options, as demonstrated by the following programs.
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; /*</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; SPWNRPLS.C - The following program demonstrates how to</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; spawn a Phar Lap application.</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Compile &amp; Link:</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; wcl386 -l=pharlap -&quot;runt minr=300K,maxr=400K&quot; spwnrpls</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; #include &lt;process.h&gt;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; #include &lt;stdio.h&gt;</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; void main()</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int app2_exit_code;</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; puts( &quot;Spawning a protect-mode application...&quot;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &quot;using spawnlp() with P_WAIT&quot;
);</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; puts( &quot;Spawning application #2...&quot; );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; app2_exit_code = spawnlp( P_WAIT, &quot;run386&quot;,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &quot;run386&quot;, &quot;spwndpls&quot;, NULL );</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;Application #2 returned with exit code %d&quot;,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;app2_exit_code );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; }</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; /*</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; SPWNDPLS.C - Will be spawned by the SPWNRPLS program.</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Compile &amp; Link: wcl386 -l=pharlap spwndpls</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; #include &lt;stdio.h&gt;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; #include &lt;stdlib.h&gt;</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; void main()</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; puts( &quot;\nApplication #2 spawned\n&quot; );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* Exit with error code 59 */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; exit( 59 );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; }</TT>
<H2 ID="How_Can_I_Use_the_Mouse_Interrupt_L0x33R_with_DOSD4GW_"> How Can I Use the Mouse Interrupt (0x33) with DOS/4GW? </H2>
<BR>Several commonly used interrupts are automatically supported in protected mode with DOS/4GW.&nbsp; The DOS extender handles
the switch from protected mode to real mode and manages any intermediate real-mode data buffers that are required.&nbsp; To
use a supported interrupt, set up the register information as required for the interrupt and use one of the int386() or int386x()
library functions to execute the interrupt.&nbsp; For calls that are not supported by DOS/4GW, you can use the DPMI function,
Simulate a Real-Mode Interrupt (0x0300).&nbsp; This process is described in the next section.
<BR><BR>Since the mouse interrupt (0x33) is quite commonly used, DOS/4GW provides protected-mode support for the interrupt
and any mouse data buffer that is required.&nbsp; The following example demonstrates how a programmer could use the Microsoft
standard mouse interrupt (0x33) from within a DOS/4GW application.
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; /*</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mouse.c - The following program demonstrates
how</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; to use the mouse interrupt (0x33) with DOS/4GW.</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Compile and link: wcl386 -l=dos4g mouse</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; #include &lt;stdio.h&gt;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; #include &lt;dos.h&gt;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; #include &lt;i86.h&gt;</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; /* Data touched at mouse callback time -- they are</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; in a structure to simplify calculating the size</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; of the region to lock.</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; struct callback_data {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;right_button;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;mouse_event;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; unsigned short&nbsp; mouse_code;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; unsigned short&nbsp; mouse_bx;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; unsigned short&nbsp; mouse_cx;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; unsigned short&nbsp; mouse_dx;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; signed short&nbsp;&nbsp;&nbsp; mouse_si;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; signed short&nbsp;&nbsp;&nbsp; mouse_di;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; } cbd = { 0 };</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; /* Set up data buffer for mouse cursor bitmap */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; unsigned short cursor[] = {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* 16 words of screen mask */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0x3fff,&nbsp; /*0011111111111111*/</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0x1fff,&nbsp; /*0001111111111111*/</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0x0fff,&nbsp; /*0000111111111111*/</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0x07ff,&nbsp; /*0000011111111111*/</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0x03ff,&nbsp; /*0000001111111111*/</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0x01ff,&nbsp; /*0000000111111111*/</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0x00ff,&nbsp; /*0000000011111111*/</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0x007f,&nbsp; /*0000000001111111*/</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0x01ff,&nbsp; /*0000000111111111*/</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0x10ff,&nbsp; /*0001000011111111*/</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0xb0ff,&nbsp; /*1011000011111111*/</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0xf87f,&nbsp; /*1111100001111111*/</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0xf87f,&nbsp; /*1111100001111111*/</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0xfc3f,&nbsp; /*1111110000111111*/</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0xfc3f,&nbsp; /*1111110000111111*/</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0xfe1f,&nbsp; /*1111111000011111*/</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* 16 words of cursor mask */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0x0000,&nbsp; /*0000000000000000*/</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0x4000,&nbsp; /*0100000000000000*/</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0x6000,&nbsp; /*0110000000000000*/</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0x7000,&nbsp; /*0111000000000000*/</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0x7800,&nbsp; /*0111100000000000*/</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0x7c00,&nbsp; /*0111110000000000*/</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0x7e00,&nbsp; /*0111111000000000*/</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0x7f00,&nbsp; /*0111111100000000*/</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0x7c00,&nbsp; /*0111110000000000*/</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0x4600,&nbsp; /*0100011000000000*/</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0x0600,&nbsp; /*0000011000000000*/</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0x0300,&nbsp; /*0000001100000000*/</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0x0300,&nbsp; /*0000001100000000*/</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0x0180,&nbsp; /*0000000110000000*/</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0x0180,&nbsp; /*0000000110000000*/</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0x00c0,&nbsp; /*0000000011000000*/</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; };</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; int lock_region( void *address, unsigned length )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; union REGS&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; regs;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; unsigned&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; linear;</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* Thanks to DOS/4GW's zero-based flat memory</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; model, converting a pointer of any type to</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; a linear address is trivial.</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; linear = (unsigned)address;</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* DPMI Lock Linear Region */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; regs.w.ax = 0x600;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* Linear address in BX:CX */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; regs.w.bx = (unsigned short)(linear &gt;&gt; 16);</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; regs.w.cx = (unsigned short)(linear &amp; 0xFFFF);</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* Length in SI:DI */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; regs.w.si = (unsigned short)(length &gt;&gt; 16);</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; regs.w.di = (unsigned short)(length &amp; 0xFFFF);</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int386( 0x31, &amp;regs, &amp;regs );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* Return 0 if lock failed */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return( !regs.w.cflag );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; }</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; #pragma off( check_stack )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; void _loadds far click_handler( int max, int mbx,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int mcx, int mdx,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int msi, int mdi )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; #pragma aux click_handler __parm [EAX] [EBX] [ECX] \</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; [EDX] [ESI] [EDI]</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cbd.mouse_event = 1;</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cbd.mouse_code = (unsigned short)max;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cbd.mouse_bx&nbsp;&nbsp; = (unsigned short)mbx;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cbd.mouse_cx&nbsp;&nbsp; = (unsigned short)mcx;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cbd.mouse_dx&nbsp;&nbsp; = (unsigned short)mdx;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cbd.mouse_si&nbsp;&nbsp; = (signed short)msi;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cbd.mouse_di&nbsp;&nbsp; = (signed short)mdi;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if( cbd.mouse_code &amp; 8 )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cbd.right_button = 1;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; }</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; /* Dummy function so we can calculate size of</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; code to lock (cbc_end - click_handler).</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; void cbc_end( void )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; }</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; #pragma on( check_stack )</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; void main (void)</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; struct SREGS&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; sregs;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; union REGS&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
inregs, outregs;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp; installed = 0;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; unsigned char&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; orig_mode = 0;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; unsigned short far&nbsp; *ptr;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; void (far *function_ptr)();</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; segread( &amp;sregs );</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* get original video mode */</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; inregs.w.ax = 0x0f00;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int386( 0x10, &amp;inregs, &amp;outregs );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; orig_mode = outregs.h.al;</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* goto graphics mode */</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; inregs.h.ah = 0x00;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; inregs.h.al = 0x6;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int386( 0x10, &amp;inregs, &amp;outregs );</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;Previous Mode = %u\n&quot;, orig_mode );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;Current Mode = %u\n&quot;, inregs.h.al );</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* check for mouse driver */</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; inregs.w.ax = 0;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int386( 0x33, &amp;inregs, &amp;outregs );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if( installed = (outregs.w.ax == 0xffff) )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;Mouse installed...\n&quot;
);</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;Mouse NOT installed...\n&quot;
);</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if( installed ) {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* lock callback code and data (essential
under VMM!)</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; note that click_handler,
although it does a far</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return and is installed
using a full 48-bit pointer,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; is really linked into the
flat model code segment</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -- so we can use a regular
(near) pointer in the</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; lock_region() call.</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if( (! lock_region( &amp;cbd, sizeof( cbd
) )) ||</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (! lock_region( (void
near *)click_handler,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
(char *)cbc_end - (char near *)click_handler )) )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;locks
failed\n&quot; );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; } else {</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* show mouse
cursor */</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; inregs.w.ax =
0x1;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int386( 0x33, &amp;inregs,
&amp;outregs );</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* set mouse
cursor form */</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; inregs.w.ax&nbsp;
= 0x9;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; inregs.w.bx&nbsp;
= 0x0;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; inregs.w.cx&nbsp;
= 0x0;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ptr&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; = cursor;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; inregs.x.edx = FP_OFF(
ptr );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; sregs.es&nbsp;&nbsp;
&nbsp; = FP_SEG( ptr );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int386x( 0x33, &amp;inregs,
&amp;outregs, &amp;sregs );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* install click
watcher */</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; inregs.w.ax&nbsp;
= 0xC;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; inregs.w.cx&nbsp;
= 0x0002 + 0x0008;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; function_ptr = (
void (far *)( void ) )click_handler;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; inregs.x.edx = FP_OFF(
function_ptr );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; sregs.es&nbsp;&nbsp;
&nbsp; = FP_SEG( function_ptr );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int386x( 0x33, &amp;inregs,
&amp;outregs, &amp;sregs );</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; while( !cbd.right_button
) {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;if( cbd.mouse_event ) {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;Ev %04hxh&nbsp; BX %hu&nbsp; CX %hu&nbsp; DX %hu&nbsp; &quot;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &quot;SI %hd&nbsp; DI %hd\n&quot;,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cbd.mouse_code, cbd.mouse_bx,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cbd.mouse_cx, cbd.mouse_dx,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cbd.mouse_si, cbd.mouse_di );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp; cbd.mouse_event = 0;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;}</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* check installation again (to clear watcher) */</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; inregs.w.ax = 0;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int386( 0x33, &amp;inregs, &amp;outregs );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if( outregs.w.ax == 0xffff )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;DONE : Mouse still installed...\n&quot;
);</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;DONE : Mouse NOT installed...\n&quot;
);</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;Press Enter key to return to original mode\n&quot;
);</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; getc( stdin );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; inregs.h.ah = 0x00;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; inregs.h.al = orig_mode;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int386( 0x10, &amp;inregs, &amp;outregs );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; }</TT>
<H2 ID="How_Do_I_Simulate_a_RealMMode_Interrupt_with_DOSD4GW_"> How Do I Simulate a Real-Mode Interrupt with DOS/4GW? </H2>
<BR>Some interrupts are not supported in protected mode with DOS/4GW but they can still be called using the DPMI function,
Simulate Real-Mode Interrupt (0x0300).&nbsp; Information that needs to be passed down to the real-mode interrupt is transferred
using an information data structure that is allocated in the protected-mode application.&nbsp; The address to this protected-mode
structure is passed into DPMI function 0x0300.&nbsp; DOS/4GW will then use this information to set up the real-mode registers,
switch to real mode and then execute the interrupt in real mode.
<BR><BR>If your protected-mode application needs to pass data down into the real-mode interrupt, an intermediate real-mode
buffer must be used.&nbsp; This buffer can be created using DPMI function 0x0100 to allocate real-mode memory.&nbsp; You can
then transfer data from the protected-mode memory to the real-mode memory using a far pointer as illustrated in the &quot;SIMULATE.C&quot;
example.
<BR><BR>The following example illustrates how to allocate some real-mode memory, transfer a string of characters from protected
mode into the real-mode buffer, then set up and call the Interrupt 0x0021 function to create a directory.&nbsp; The string
of characters are used to provide the directory name.&nbsp; This example can be adapted to handle most real-mode interrupt
calls that aren't supported in protected mode.
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; /*</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; SIMULATE.C - Shows how to issue a real-mode interrupt</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; from protected mode using DPMI call 300h.&nbsp; Any buffers</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; to be passed to DOS must be allocated in DOS memory</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; This can be done with DPMI call 100h.&nbsp; This program</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; will call DOS int 21, function 39h, &quot;Create</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Directory&quot;.</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Compile &amp; Link: wcl386 -l=dos4g simulate</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; #include &lt;i86.h&gt;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; #include &lt;dos.h&gt;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; #include &lt;stdio.h&gt;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; #include &lt;string.h&gt;</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; static struct rminfo {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; long EDI;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; long ESI;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; long EBP;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; long reserved_by_system;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; long EBX;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; long EDX;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; long ECX;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; long EAX;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; short flags;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; short ES,DS,FS,GS,IP,CS,SP,SS;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; } RMI;</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; void main()</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; union REGS regs;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; struct SREGS sregs;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int interrupt_no=0x31;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; short selector;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; short segment;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; char far *str;</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* DPMI call 100h allocates DOS memory */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; memset(&amp;sregs,0,sizeof(sregs));</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; regs.w.ax=0x0100;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; regs.w.bx=0x0001;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int386x( interrupt_no, &amp;regs, &amp;regs, &amp;sregs);</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; segment=regs.w.ax;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; selector=regs.w.dx;</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* Move string to DOS real-mode memory */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; str=MK_FP(selector,0);</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; _fstrcpy( str, &quot;myjunk&quot; );</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* Set up real-mode call structure */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; memset(&amp;RMI,0,sizeof(RMI));</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; RMI.EAX=0x00003900; /* call service 39h ah=0x39&nbsp; */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; RMI.DS=segment;&nbsp;&nbsp;&nbsp;&nbsp; /* put DOS seg:off into DS:DX*/</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; RMI.EDX=0;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
/* DOS ignores EDX high word */</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* Use DPMI call 300h to issue the DOS interrupt */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; regs.w.ax = 0x0300;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; regs.h.bl = 0x21;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; regs.h.bh = 0;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; regs.w.cx = 0;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; sregs.es = FP_SEG(&amp;RMI);</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; regs.x.edi = FP_OFF(&amp;RMI);</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int386x( interrupt_no, &amp;regs, &amp;regs, &amp;sregs );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; }</TT>
<H2 ID="How_do_you_install_a_biMmodal_interrupt_handler_using_DOSD4GW_"> How do you install a bi-modal interrupt handler using DOS/4GW? </H2>
<BR>Due to the nature of the protected-mode/real-mode interface, it is often difficult to handle high speed communications
with hardware interrupt handlers.&nbsp; For example, if you install your communications interrupt handler in protected mode,
you may find that some data is lost when transmitting data from a remote machine at the rate of 9600 baud.&nbsp; This occurs
because the data arrived at the communication port while the machine was in the process of transferring the previous interrupt
up to protected mode.&nbsp; Data will also be lost if you install the interrupt handler in real mode since your program, running
in protected mode, will have to switch down into real mode to handle the interrupt.&nbsp; The reason for this is that the
data arrived at the communication port while the DOS extender was switching between real mode and protected mode, and the
machine was not available to process the interrupt.
<BR><BR>To avoid the delay caused by switching between real-mode and protected mode to handle hardware interrupts, install
interrupt handlers in both real-mode and protected-mode.&nbsp; During the execution of a protected-mode program, the system
often switches down into real-mode for DOS system calls.&nbsp; If a communications interrupt occurs while the machine is in
real-mode, then the real-mode interrupt handler will be used.&nbsp; If the interrupt occurs when the machine is executing
in protected-mode, then the protected-mode interrupt handler will be used.&nbsp; This enables the machine to process the hardware
interrupts faster and avoid the loss of data caused by context switching.
<BR><BR>Installing the interrupt handlers in both protected-mode and real-mode is called bi-modal interrupt handling.&nbsp;
The following program is an example of how to install both handlers for Interrupt 0x0C (also known as COM1 or IRQ4).&nbsp;
The program writes either a 'P' to absolute address 0xB8002 or an 'R' to absolute address 0xB8000.&nbsp; These locations are
the first two character positions in screen memory for a color display.&nbsp; As the program runs, you can determine which
interrupt is handling the COM1 port by the letter that is displayed.&nbsp; A mouse attached to COM1 makes a suitable demo.
&nbsp;Type on the keyboard as you move the mouse around.&nbsp; The ESC key can be used to terminate the program.&nbsp; Transmitted
data from a remote machine at 9600 baud can also be used to test the COM1 handling.
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; /*</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; BIMODAL.C - The following program demonstrates how</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; to set up a bi-modal interrupt handler for DOS/4GW</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Compile and link: wcl386 -l=dos4g bimodal bimo.obj</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; */</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; #include &lt;stdio.h&gt;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; #include &lt;conio.h&gt;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; #include &lt;dos.h&gt;</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; #define D32RealSeg(P)&nbsp;&nbsp; ((((DWORD) (P)) &gt;&gt; 4) &amp; 0xFFFF)</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; #define D32RealOff(P)&nbsp;&nbsp; (((DWORD) (P)) &amp; 0xF)</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; typedef unsigned int WORD;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; typedef unsigned long DWORD;</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; extern void com1_init (void);</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; extern void __interrupt pmhandler (void);</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; extern void __interrupt __far rmhandler (void);</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; void *D32DosMemAlloc (DWORD size)</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; union REGS r;</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; r.x.eax = 0x0100;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp; /* DPMI allocate DOS memory */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; r.x.ebx = (size + 15) &gt;&gt; 4; /* Number of paragraphs requested
*/</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int386 (0x31, &amp;r, &amp;r);</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if( r.x.cflag )&nbsp; /* Failed */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return ((DWORD) 0);</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return (void *) ((r.x.eax &amp; 0xFFFF) &lt;&lt; 4);</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; }</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; void main (void)</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; union REGS&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; r;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; struct SREGS&nbsp;&nbsp;&nbsp; sr;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; void&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
*lowp;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; void far&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; *fh;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; WORD&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;orig_pm_sel;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DWORD&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
orig_pm_off;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; WORD&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;orig_rm_seg;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; WORD&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;orig_rm_off;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;c;</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; /*&nbsp; Save the starting protected-mode handler address */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; r.x.eax = 0x350C;&nbsp;&nbsp; /* DOS get vector (INT 0Ch) */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; sr.ds = sr.es = 0;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int386x (0x21, &amp;r, &amp;r, &amp;sr);</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; orig_pm_sel = (WORD) sr.es;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; orig_pm_off = r.x.ebx;</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; /*</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Save the starting real-mode handler address using DPMI</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (INT 31h).</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; r.x.eax = 0x0200;&nbsp;&nbsp; /* DPMI get real mode vector */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; r.h.bl = 0x0C;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int386 (0x31, &amp;r, &amp;r);</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; orig_rm_seg = (WORD) r.x.ecx;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; orig_rm_off = (WORD) r.x.edx;</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; /*</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Allocate 128 bytes of DOS memory for the real-mode</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; handler, which must of course be less than 128 bytes</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; long.&nbsp; Then copy the real-mode handler into that</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; segment.</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if(! ( lowp = D32DosMemAlloc(128) ) ) {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf (&quot;Couldn't get low memory!\n&quot;);</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; exit (1);</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; memcpy (lowp, (void *) rmhandler, 128);</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; /*</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Install the new protected-mode vector.&nbsp; Because INT 0Ch</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; is in the auto-passup range, its normal &quot;passdown&quot;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; behavior will change as soon as we install a</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; protected-mode handler.&nbsp; After this next call, when a</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; real mode INT 0Ch is generated, it will be resignalled</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; in protected mode and handled by pmhandler.</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; r.x.eax = 0x250C;&nbsp;&nbsp; /* DOS set vector (INT 0Ch) */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; fh = (void far *) pmhandler;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; r.x.edx = FP_OFF (fh);</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* DS:EDX == &amp;handler */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; sr.ds = FP_SEG (fh);</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; sr.es = 0;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int386x (0x21, &amp;r, &amp;r, &amp;sr);</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; /*</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Install the new real-mode vector.&nbsp; We do this after</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; installing the protected-mode vector in order to</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; override the &quot;passup&quot; behavior.&nbsp; After the next call,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; interrupts will be directed to the appropriate handler,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; regardless of which mode we are in when they are</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; generated.</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; r.x.eax = 0x0201;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; r.h.bl = 0x0C;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* CX:DX == real mode &amp;handler */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; r.x.ecx = D32RealSeg(lowp);</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; r.x.edx = D32RealOff(lowp);</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int386 (0x31, &amp;r, &amp;r);</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; /*</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Initialize COM1.</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; com1_init ();</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; puts( &quot;Move mouse, transmit data; ESC to quit\n&quot; );</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; while( 1 ) {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if( kbhit() ) {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if( ( (c = getch
()) &amp; 0xff ) == 27 )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp; break;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; putch (c);</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; delay( 1 );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; /*</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Clean up.</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; r.x.eax = 0x250C;&nbsp;&nbsp; /* DOS set vector (INT 0Ch) */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; r.x.edx = orig_pm_off;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; sr.ds = orig_pm_sel;&nbsp;&nbsp;&nbsp; /* DS:EDX == &amp;handler
*/</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; sr.es = 0;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int386x (0x21, &amp;r, &amp;r, &amp;sr);</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; r.x.eax = 0x0201;&nbsp;&nbsp; /* DPMI set real mode vector */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; r.h.bl = 0x0C;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* CX:DX == real mode &amp;handler */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; r.x.ecx = (DWORD) orig_rm_seg;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; r.x.edx = (DWORD) orig_rm_off;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int386 (0x31, &amp;r, &amp;r);</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; }</TT>
<BR><BR>You will also need to create the following assembler code module.&nbsp; The first part provides the interrupt handling
routine for the real-mode interrupt handler.&nbsp; The second provides the protected-mode version of the interrupt handler.
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; ;**</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; ;** bimo.asm:</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; ;** Assembler code for real-mode and protected-mode</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; ;** INT 0xC interrupt handlers to support the INT 0xC</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; ;** interrupt in both modes</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; ;**</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; .386</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; ;**</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; ;** The real-mode interrupt handler is in a 16-bit code</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; ;** segment so that the assembler will generate the right</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; ;** code.&nbsp; We will copy this code down to a 16-bit segment</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; ;** in low memory rather than executing it in place.</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; ;**</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; _TEXT16 SEGMENT BYTE PUBLIC USE16 'CODE'</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ASSUME&nbsp; cs:_TEXT16</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; PUBLIC&nbsp; rmhandler_</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; rmhandler_:</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; push&nbsp;&nbsp;&nbsp; es</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; push&nbsp;&nbsp;&nbsp; bx</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mov&nbsp;&nbsp;&nbsp;&nbsp; bx,0B800h</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mov&nbsp;&nbsp;&nbsp;&nbsp; es,bx&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ; ES = 0xB800</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; sub&nbsp;&nbsp;&nbsp;&nbsp; bx,bx&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ; BX = 0</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mov&nbsp;&nbsp;&nbsp;&nbsp; WORD PTR es:[bx],0720h&nbsp; ; Clear
2 char cells</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mov&nbsp;&nbsp;&nbsp;&nbsp; WORD PTR es:[bx+2],0720h</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mov&nbsp;&nbsp;&nbsp;&nbsp; BYTE PTR es:[bx],'R'&nbsp;&nbsp;&nbsp;
; Write R to memory</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pop&nbsp;&nbsp;&nbsp;&nbsp; bx</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pop&nbsp;&nbsp;&nbsp;&nbsp; es</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; push&nbsp;&nbsp;&nbsp; ax</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; push&nbsp;&nbsp;&nbsp; dx</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mov&nbsp;&nbsp;&nbsp;&nbsp; dx,03FAh</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; in&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; al,dx&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ; Read ports so</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mov&nbsp;&nbsp;&nbsp;&nbsp; dx,03F8h&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ; interrupts can</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; in&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; al,dx&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ; continue to be</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mov&nbsp;&nbsp;&nbsp;&nbsp; dx,020h&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ; generated</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mov&nbsp;&nbsp;&nbsp;&nbsp; al,dl</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; out&nbsp;&nbsp;&nbsp;&nbsp; dx,al&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ; Send EOI</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pop&nbsp;&nbsp;&nbsp;&nbsp; dx</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pop&nbsp;&nbsp;&nbsp;&nbsp; ax</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; iret</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; _TEXT16 ENDS</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; ;**</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; ;** The protected-mode interrupt handler is in a 32-bit code</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; ;** segment.&nbsp; Even so, we have to be sure to force an IRETD</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; ;** at the end of the handler, because MASM doesn't generate</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; ;** one.&nbsp; This handler will be called on a 32-bit stack by</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; ;** DOS/4GW.</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; ;**</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; ;** _DATA is the flat model data segment, which we load into</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; ;** ES so we can write to absolute address 0xB8000.&nbsp; (In the</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; ;** flat model, DS is based at 0.)</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; ;**</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; _DATA&nbsp;&nbsp; SEGMENT BYTE PUBLIC USE32 'DATA'</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; _DATA&nbsp;&nbsp; ENDS</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; DGROUP GROUP _DATA</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; _TEXT&nbsp;&nbsp; SEGMENT BYTE PUBLIC USE32 'CODE'</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ASSUME&nbsp; cs:_TEXT</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; PUBLIC&nbsp; com1_init_</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; com1_init_:</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mov&nbsp;&nbsp;&nbsp;&nbsp; ax,0F3h&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ; 9600,n,8,1</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mov&nbsp;&nbsp;&nbsp;&nbsp; dx,0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ; com1</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int&nbsp;&nbsp;&nbsp;&nbsp; 14h&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ; Initialize COM1</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mov&nbsp;&nbsp;&nbsp;&nbsp; bx,03F8h&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ; COM1 port space</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; lea&nbsp;&nbsp;&nbsp;&nbsp; dx,[bx+5]&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ; line status reg</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; in&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; al,dx</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; lea&nbsp;&nbsp;&nbsp;&nbsp; dx,[bx+4]&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ; modem control reg</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; in&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; al,dx</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; or&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; al,8&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ; enable OUT2 int</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; out&nbsp;&nbsp;&nbsp;&nbsp; dx,al</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; lea&nbsp;&nbsp;&nbsp;&nbsp; dx,[bx+2]&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ; int id register</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; in&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; al,dx</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mov&nbsp;&nbsp;&nbsp;&nbsp; dx,bx&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ; data receive reg</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; in&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; al,dx</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; in&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; al,21h&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ; interrupt mask reg</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; and&nbsp;&nbsp;&nbsp;&nbsp; al,0EFh&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ; force IRQ4 unmask</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; out&nbsp;&nbsp;&nbsp;&nbsp; 21h,al</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; lea&nbsp;&nbsp;&nbsp;&nbsp; dx,[bx+1]&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ; int enable reg</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mov&nbsp;&nbsp;&nbsp;&nbsp; al,1</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; out&nbsp;&nbsp;&nbsp;&nbsp; dx,al&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ; enable received int</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ret</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; PUBLIC&nbsp; pmhandler_</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; pmhandler_:</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; push&nbsp;&nbsp;&nbsp; es</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; push&nbsp;&nbsp;&nbsp; bx</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mov&nbsp;&nbsp;&nbsp;&nbsp; bx,DGROUP</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mov&nbsp;&nbsp;&nbsp;&nbsp; es,bx</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mov&nbsp;&nbsp;&nbsp;&nbsp; ebx,0B8000h&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ; ES:EBX=flat:0B8000h</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mov&nbsp;&nbsp;&nbsp;&nbsp; DWORD PTR es:[ebx],07200720h&nbsp; ;
Clear cells</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mov&nbsp;&nbsp;&nbsp;&nbsp; BYTE PTR es:[ebx+2],'P' ; Write P to
memory</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pop&nbsp;&nbsp;&nbsp;&nbsp; bx</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pop&nbsp;&nbsp;&nbsp;&nbsp; es</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; push&nbsp;&nbsp;&nbsp; ax</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; push&nbsp;&nbsp;&nbsp; dx</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mov&nbsp;&nbsp;&nbsp;&nbsp; dx,03FAh</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; in&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; al,dx&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ; Read ports so</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mov&nbsp;&nbsp;&nbsp;&nbsp; dx,03F8h&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ; interrupts can</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; in&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; al,dx&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ; continue to be</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mov&nbsp;&nbsp;&nbsp;&nbsp; dx,020h&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ; generated</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mov&nbsp;&nbsp;&nbsp;&nbsp; al,dl</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; out&nbsp;&nbsp;&nbsp;&nbsp; dx,al&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ; Send EOI</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pop&nbsp;&nbsp;&nbsp;&nbsp; dx</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pop&nbsp;&nbsp;&nbsp;&nbsp; ax</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; iretd</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; _TEXT&nbsp;&nbsp; ENDS</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; END</TT>
<H1 ID="DOSD4GW__The_Tenberry_Software_DOSD4GW_DOS_Extender"> DOS/4GW:&nbsp; The Tenberry Software DOS/4GW DOS Extender </H1>
<BR><BR>The chapters in this section describe the 32-bit Tenberry Software<B> DOS/4GW</B> DOS Extender which is provided with
the Open Watcom C/C++ package.<B>&nbsp; DOS/4GW</B> is a subset of Tenberry Software's DOS/4G product.<B>&nbsp; DOS/4GW</B>
is customized for use with the Open Watcom C/C++ package.&nbsp; Key differences are:
<UL>
<LI><B> DOS/4GW</B> will only execute programs built with a Open Watcom 32-bit compiler such as Open Watcom C/C++ and linked
with its run-time libraries.
<LI>The<B> DOS/4GW</B> virtual memory manager (VMM), included in the package, is restricted to 32MB of memory.
<LI><B> DOS/4GW</B> does not provide extra functionality such as TSR capability and VMM performance tuning enhancements.
</UL>
<BR>If your application has requirements beyond those provided by<B> DOS/4GW</B>, you may wish to acquire DOS/4GW Professional
or DOS/4G from:
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Tenberry Software, Inc.</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; PO Box 20050</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Fountain Hills, Arizona</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; U.S.A&nbsp; 85269-0050</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; WWW:&nbsp;&nbsp;&nbsp; http://www.tenberry.com/dos4g/</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Email:&nbsp; info@tenberry.com</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Phone:&nbsp; 1.480.767.8868</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Fax:&nbsp;&nbsp;&nbsp; 1.480.767.8709</TT>
<BR><BR>Programs developed to use the restricted version of<B> DOS/4GW</B> which is included in the Open Watcom C/C++ package
can be distributed on a royalty-free basis, subject to the licensing terms of the product.
<H1 ID="DOSD4GW__Linear_Executables"> DOS/4GW:&nbsp; Linear Executables </H1>
<BR>To build a linear executable, compile and link it as described in the chapter entitled &quot;Creating 32-bit DOS/4GW Executables&quot;.
&nbsp;The resulting file will not run independently:&nbsp; you can run it under the Open Watcom Debugger, Tenberry Software
Instant-D debugger, or with the standalone &quot;DOS4GW.EXE&quot;.
<H2 ID="DOSD4GW__The_Linear_Executable_Format"> DOS/4GW:&nbsp; The Linear Executable Format </H2>
<BR><B> DOS/4GW</B> works with files that use the Linear Executable (LE) file format.&nbsp; The format represents a protected-mode
program in the context of a 32-bit 386 runtime environment with linear to physical address translation hardware enabled.&nbsp;
It uses a flat address space.
<BR><BR>This file format is similar to the Segmented Executable (NE) format used in OS/2 1.x and MS Windows.&nbsp; Both support
Dynamic Linking, Resources, and are geared toward protected-mode programs.&nbsp; Both formats use tables of &quot;counted
ASCII&quot; names, and they use similar relocation formats.
<BR><BR>Both formats begin with a DOS style stub program that sophisticated loaders skip.&nbsp; This stub program executes
when the<B> DOS/4GW</B> loader is not present, displaying the message,<B> This program cannot run in DOS mode.</B>
<BR><BR>When the Open Watcom Linker is used to link a<B> DOS/4GW</B> application, it automatically replaces the default stub
program with one that calls DOS4GW.
<H3 ID="DOSD4GW__The_Stub_Program"> DOS/4GW:&nbsp; The Stub Program </H3>
<BR>The stub at the beginning of a linear executable is a real-mode program that you can modify as you like.&nbsp; For example,
you can:
<UL>
<LI>make the stub program do a checksum on the &quot;DOS4GW.EXE&quot; file to make sure it's the correct version.
<LI>copy protect your program.
<LI>specify a search path for the &quot;DOS4GW.EXE&quot; file.
<LI>add command line arguments.
</UL>
<BR>The SRC directory contains source code for a sample stub program.&nbsp; &quot;WSTUB.C&quot; is a simple example, a good
base to start from when you construct your own stub.&nbsp; Please note that you will require a 16-bit C compiler to compile
a new stub program.&nbsp; Following is the code in &quot;WSTUB.C&quot;:&nbsp; 
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; #include &lt;stdio.h&gt;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; #include &lt;stdlib.h&gt;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; #include &lt;process.h&gt;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; #include &lt;errno.h&gt;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; #include &lt;string.h&gt;</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; /* Add environment strings to be searched here */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; char *paths_to_check[] = {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &quot;DOS4GPATH&quot;,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &quot;PATH&quot;};</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; char *dos4g_path()</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; static char fullpath[80];</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int i;</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for( i = 0;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; i &lt; sizeof( paths_to_check ) / sizeof(
paths_to_check[0] );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; i++ ) {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; _searchenv( &quot;dos4gw.exe&quot;, paths_to_check[i],
fullpath );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if( fullpath[0] ) return( &amp;fullpath );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for( i = 0;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; i &lt; sizeof( paths_to_check ) / sizeof(
paths_to_check[0] );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; i++ ) {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; _searchenv( &quot;dos4g.exe&quot;, paths_to_check[i],
fullpath );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if( fullpath[0] ) return( &amp;fullpath );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return( &quot;dos4gw.exe&quot; );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; }</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; main( int argc, char *argv[] )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; char&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; *av[4];</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; auto char&nbsp;&nbsp; cmdline[128];</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; av[0] = dos4g_path();&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* Locate the DOS/4G loader */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; av[1] = argv[0];&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* name of executable to run */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; av[2] = getcmd( cmdline );&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp; /* command line */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; av[3] = NULL;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* end of list */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; #ifdef QUIET</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; putenv( &quot;DOS4G=QUIET&quot; );&nbsp;&nbsp;&nbsp; /* disables
DOS/4G Copyright banner */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; #endif</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; execvp( av[0], av );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; puts( &quot;Stub exec failed:&quot; );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; puts( av[0] );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; puts( strerror( errno ) );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; exit( 1 );&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* indicate error */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; }</TT>
<H2 ID="DOSD4GW__Memory_Use"> DOS/4GW:&nbsp; Memory Use </H2>
<BR>This section explains how a<B> DOS/4GW</B> application uses the memory on a 386-based PC/AT.&nbsp; The basic memory layout
of an AT machine consists of 640KB of DOS memory, 384KB of upper memory, and an undetermined amount of extended memory.&nbsp;
DOS memory and upper memory together compose real memory, the memory that can be addressed when the processor is running in
real mode.
<BR><BR><TT><IMG SRC="mem1.bmp" ALIGN=MIDDLE></TT>
<BR><B><I>Figure 1.</I></B><B><I></I></B><B> Basic Memory Layout</B>
<BR><BR>Under<B> DOS/4GW</B>, the first megabyte of physical memory - the real memory - is mapped as a shared linear address
space.&nbsp; This allows your application to use absolute addresses in real memory, to access video RAM or BIOS ROM, for example.
&nbsp;Because the real memory is available to all processes, you are not guaranteed to be able to allocate a particular area
in real memory:&nbsp; another process may have allocated it already.
<BR><BR>Most code and data is placed in a paged linear address space starting at 4MB.&nbsp; The linear address space starts
at 4MB, the first address in the second page table, to avoid conflicts with VCPI system software.
<BR><BR>This split mapping - an executable that is linked to start at 4MB in the linear address space, with the first MB in
the address space mapped to the first MB of physical memory - is called a<B> split flat model.</B>
<BR><BR>The illustration below shows the layout of physical memory on the left, and the layout of the linear address space
on the right.
<BR><BR><TT><IMG SRC="mem2.bmp" ALIGN=MIDDLE></TT>
<BR><B><I>Figure 2.</I></B><B><I></I></B><B> Physical Memory/Linear Address Space</B>
<BR><BR>The 1KB label in the diagram indicates the top of the real-mode interrupt vectors.&nbsp; 4KB marks the end of the
first page.
<H1 ID="DOSD4GW__Configuring_DOSD4GW"> DOS/4GW:&nbsp; Configuring DOS/4GW </H1>
<BR>This chapter explains various options that can be specified with the<B> DOS4G</B> environment variable including how to
suppress the banner that is displayed by<B> DOS/4GW</B> at startup.&nbsp; It also explains how to use the<B> DOS16M</B> environment
variable to select the switch mode setting, if necessary, and to specify the range of extended memory in which<B> DOS/4GW</B>
will operate.<B>&nbsp; DOS/4GW</B> is based on Tenberry Software's DOS/16M 16-bit Protected-Mode support; hence the<B> DOS16M</B>
environment variable name remains unchanged.
<H2 ID="DOSD4GW__The_DOS4G_Environment_Variable"> DOS/4GW:&nbsp; The DOS4G Environment Variable </H2>
<BR>A number of options can be selected by setting the<B> DOS4G</B> environment variable.&nbsp; The syntax for setting options
is:
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; set DOS4G=option1,option2,...</TT>
<BR><BR>Do not insert a space between<B> DOS4G</B> and the equal sign.&nbsp; A space to the right of the equal sign is optional.
<DL>
<DT>Options:
<DD>
<DT>QUIET
<DD>Use this option to suppress the<B> DOS/4GW</B> banner.
<BR><BR>The banner that is displayed by<B> DOS/4GW</B> at startup can be suppressed by issuing the following command:
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; set DOS4G=quiet</TT>
<BR><BR><B><I>Note:</I></B>&nbsp; Use of the quiet switch is only permitted pursuant to the terms and conditions of the WATCOM
Software License Agreement and the additional redistribution rights described in the<B><I> Getting Started</I></B> manual.
&nbsp;Under these terms, suppression of the copyright by using the quiet switch is not permitted for applications which you
distribute to others.
<DT>VERBOSE
<DD>Use this option to maximize the information available for postmortem debugging.
<BR><BR>Before running your application, issue the following command:
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; set DOS4G=verbose</TT>
<BR><BR>Reproduce the crash and record the output.
<DT>NULLP
<DD>Use this option to trap references to the first sixteen bytes of physical memory.
<BR><BR>Before running your application, issue the following command:
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; set DOS4G=nullp</TT>
</DL>
<BR>To select a combination of options, list them with commas as separators.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; set DOS4G=nullp,verbose</TT>
<H2 ID="DOSD4GW__Changing_the_Switch_Mode_Setting"> DOS/4GW:&nbsp; Changing the Switch Mode Setting </H2>
<BR>In almost all cases,<B> DOS/4GW</B> programs can detect the type of machine that is running and automatically choose an
appropriate real- to protected-mode switch technique.&nbsp; For the few cases in which this default setting does not work
we provide the<B> DOS16M</B> DOS environment variable, which overrides the default setting.
<BR><BR>Change the switch mode settings by issuing the following command:
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; set DOS16M=value</TT>
<BR><BR>Do not insert a space between<B> DOS16M</B> and the equal sign.&nbsp; A space to the right of the equal sign is optional.
<BR><BR>The table below lists the machines and the settings you would use with them.&nbsp; Many settings have mnemonics, listed
in the column &quot;Alternate Name&quot;, that you can use instead of the number.&nbsp; Settings that you must set with the<B>
DOS16M</B> variable have the notation<B> req'd</B> in the first column.&nbsp; Settings you may use are marked<B> option,</B>
and settings that will automatically be set are marked<B> auto.</B>
<BR><BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Alternate
<BR> Status&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Machine&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;Setting&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Name
<BR> Comment&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
<BR><BR> auto&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 386/486 w/ DPMI 0&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; None
<BR> Set automatically if DPMI is active&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp; 
<BR> req'd&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; NEC 98-series&nbsp;&nbsp; 1&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 9801
<BR> Must be set for NEC 98-series&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
<BR> auto&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; PS/2&nbsp;&nbsp;&nbsp; 2&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp; None&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Set
automatically for PS/2
<BR> auto&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 386/486&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp; 3&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;386,
<BR>80386 Set automatically for 386 or 486&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp; 
<BR> auto&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 386&nbsp;&nbsp;&nbsp;&nbsp; INBOARD None
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 386 with Intel Inboard
<BR> req'd&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Fujitsu FMR-70&nbsp; 5&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; None
<BR> Must be set for Fujitsu FMR-70&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
<BR> auto&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 386/486 w/ VCPI 11&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; None
<BR> Set automatically if VCPI detected&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
<BR> req'd&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Hitachi B32&nbsp;&nbsp;&nbsp;&nbsp; 14&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; None
<BR> Must be set for Hitachi B32&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
<BR> req'd&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; OKI if800&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
15&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; None
<BR> Must be set for OKI if800&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
<BR> option&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; IBM PS/55&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 16&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; None
<BR> May be needed for some PS/55s&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
<BR><BR>The following procedure shows you how to test the switch mode setting.
<OL>
<LI>If you have one of the machines listed below, set the<B> DOS16M</B> environment variable to the value shown for that machine
and specify a range of extended memory.&nbsp; For example, if your machine is a NEC 98-series, set<TT> DOS16M=1 @2M-4M.</TT>
&nbsp;See the section entitled <A HREF="#DOSD4GW__Fine_Control_of_Memory_Usage">DOS/4GW:&nbsp; Fine Control of Memory Usage</A>
in this chapter for more information about setting the memory range.
<BR><BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Machine&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp; Setting&nbsp; 
<BR><BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; NEC 98-series&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 1&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp; 
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Fujitsu FMR-60,-70&nbsp;&nbsp; 5&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Hitachi B32&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 14
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; OKI if800&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;15&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
<BR><BR>Before running<B> DOS/4GW</B> applications, check the switch mode setting by following this procedure:
<LI>Run PMINFO and note the switch setting reported on the last line of the display.&nbsp; (PMINFO, which reports on the protected-mode
resources available to your programs, is described in more detail in the chapter entitled <A HREF="#DOSD4GW__Utilities">DOS/4GW:&nbsp; Utilities</A>)
<BR><BR>If PMINFO runs, the setting is usable on your machine.
<LI>If you changed the switch setting, add the new setting to your AUTOEXEC.BAT file.
</OL>
<BR><B>Note:</B>&nbsp; PMINFO will run successfully on 286 machines.&nbsp; If your<B> DOS/4GW</B> application does not run,
and PMINFO does, check the CPU type reported on the first line of the display.
<BR><BR>You are authorized (and encouraged) to distribute PMINFO to your customers.&nbsp; You may also include a copy of this
section in your documentation.
<H2 ID="DOSD4GW__Fine_Control_of_Memory_Usage"> DOS/4GW:&nbsp; Fine Control of Memory Usage </H2>
<BR>In addition to setting the switch mode as described above, the<B> DOS16M</B> environment variable enables you to specify
which portion of extended memory<B> DOS/4GW</B> will use.&nbsp; The variable also allows you to instruct<B> DOS/4GW</B> to
search for extra memory and use it if it is present.
<H3 ID="DOSD4GW__Specifying_a_Range_of_Extended_Memory"> DOS/4GW:&nbsp; Specifying a Range of Extended Memory </H3>
<BR>Normally, you don't need to specify a range of memory with the<B> DOS16M</B> variable.&nbsp; You must use the variable,
however, in the following cases:
<UL>
<LI>You are running on a Fujitsu FMR-series, NEC 98-series, OKI if800-series or Hitachi B-series machine.
<LI>You have older programs that use extended memory but don't follow one of the standard disciplines.
<LI>You want to shell out of<B> DOS/4GW</B> to use another program that requires extended memory.
</UL>
<BR>If none of these conditions applies to you, you can skip this section.
<BR><BR>The general syntax is:
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; set DOS16M= [switch_mode] [@start_address [- end_address]] [:size]</TT>
<BR><BR>In the syntax shown above,<TT> start_address, end_address</TT> and<TT> size</TT> represent numbers, expressed in decimal
or in hexadecimal (hex requires a<TT> 0x</TT> prefix).&nbsp; The number may end with a K to indicate an address or size in
kilobytes, or an M to indicate megabytes.&nbsp; If no suffix is given, the address or size is assumed to be in kilobytes.
&nbsp;If both a size and a range are specified, the more restrictive interpretation is used.
<BR><BR>The most flexible strategy is to specify only a size.&nbsp; However, if you are running with other software that does
not follow a convention for indicating its use of extended memory, and these other programs start before<B> DOS/4GW</B>, you
will need to calculate the range of memory used by the other programs and specify a range for<B> DOS/4GW</B> programs to use.
<BR><BR><B>DOS/4GW</B> ignores specifications (or parts of specifications) that conflict with other information about extended
memory use.&nbsp; Below are some examples of memory usage control:
<DL>
<DT>set DOS16M= 1 @2m-4m
<DD>Mode 1, for NEC 98-series machines, and use extended memory between 2.0 and 4.0MB.
<DT>set DOS16M= :1M
<DD>Use the last full megabyte of extended memory, or as much as available limited to 1MB.
<DT>set DOS16M= @2m
<DD>Use any extended memory available above 2MB.
<DT>set DOS16M= @ 0 - 5m
<DD>Use any available extended memory from 0.0 (really 1.0) to 5.0MB.
<DT>set DOS16M= :0
<DD>Use no extended memory.
</DL>
<BR>As a default condition<B> DOS/4GW</B> applications take all extended memory that is not otherwise in use.&nbsp; Multiple<B>
DOS/4GW</B> programs that execute simultaneously will share the reserved range of extended memory.&nbsp; Any non-<B>DOS/4GW</B>
programs started while<B> DOS/4GW</B> programs are executing will find that extended memory above the start of the<B> DOS/4GW</B>
range is unavailable, so they may not be able to run.&nbsp; This is very safe.&nbsp; There will be a conflict only if the
other program does not check the BIOS configuration call (Interrupt 15H function 88H, get extended memory size).
<BR><BR>To create a private pool of extended memory for your<B> DOS/4GW</B> application, use the PRIVATXM program, described
in the chapter entitled <A HREF="#DOSD4GW__Utilities">DOS/4GW:&nbsp; Utilities</A>.
<BR><BR>The default memory allocation strategy is to use extended memory if available, and overflow into DOS (low) memory.
<BR><BR>In a VCPI or DPMI environment, the<TT> start_address</TT> and<TT> end_address</TT> arguments are not meaningful.<B>
&nbsp;DOS/4GW</B> memory under these protocols is not allocated according to specific addresses because VCPI and DPMI automatically
prevent address conflicts between extended memory programs.&nbsp; You can specify a<TT> size</TT> for memory managed by VCPI
or DPMI, but<B> DOS/4GW</B> will not necessarily allocate this memory from the highest available extended memory address,
as it does for memory managed under other protocols.
<H3 ID="DOSD4GW__Using_Extra_Memory"> DOS/4GW:&nbsp; Using Extra Memory </H3>
<BR>Some machines contain extra non-extended, non-conventional memory just below 16MB.&nbsp; When<B> DOS/4GW</B> runs on a
Compaq 386, it automatically uses this memory because the memory is allocated according to a certain protocol, which<B> DOS/4GW</B>
follows.&nbsp; Other machines have no protocol for allocating this memory.&nbsp; To use the extra memory that may exist on
these machines, set<B> DOS16M</B> with the + option.
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; set DOS16M=+</TT>
<BR><BR>Setting the + option causes<B> DOS/4GW</B> to search for memory in the range from FA0000 to FFFFFF and determine whether
the memory is usable.<B>&nbsp; DOS/4GW</B> does this by writing into the extra memory and reading what it has written.&nbsp;
In some cases, this memory is mapped for DOS or BIOS usage, or for other system uses.&nbsp; If<B> DOS/4GW</B> finds extra
memory that is mapped this way, and is not marked read-only, it will write into that memory.&nbsp; This will cause a crash,
but won't have any other effect on your system.
<H2 ID="DOSD4GW__Setting_Runtime_Options"> DOS/4GW:&nbsp; Setting Runtime Options </H2>
<BR>The<B> DOS16M</B> environment variable sets certain runtime options for all<B> DOS/4GW</B> programs running on the same
system.
<BR><BR>To set the environment variable, the syntax is:
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; set DOS16M=[switch_mode_setting]^options.</TT>
<BR><BR><B>Note:</B>&nbsp; Some command line editing TSRs, such as CED, use the caret (^) as a delimiter.&nbsp; If you want
to set<B> DOS16M</B> using the syntax above while one of these TSRs is resident, modify the TSR to use a different delimiter.
<BR><BR>These are the options:
<DL>
<DT>0x01
<DD><B> check A20 line --</B> This option forces<B> DOS/4GW</B> to wait until the A20 line is enabled before switching to protected
mode.&nbsp; When<B> DOS/4GW</B> switches to real mode, this option suspends your program's execution until the A20 line is
disabled, unless an XMS manager (such as HIMEM.SYS) is active.&nbsp; If an XMS manager is running, your program's execution
is suspended until the A20 line is restored to the state it had when the CPU was last in real mode.&nbsp; Specify this option
if you have a machine that runs<B> DOS/4GW</B> but is not truly AT-compatible.&nbsp; For more information on the A20 line,
see the section entitled <A HREF="#DOSD4GW__Controlling_Address_Line_20">DOS/4GW:&nbsp; Controlling Address Line 20</A>.
<DT>0x02
<DD><B> prevent initialization of VCPI --</B> By default,<B> DOS/4GW</B> searches for a VCPI server and, if one is present, forces
it on.&nbsp; This option is useful if your application does not use EMS explicitly, is not a resident program, and may be
used with 386-based EMS simulator software.
<DT>0x04
<DD><B> directly pass down keyboard status calls --</B> When this option is set, status requests are passed down immediately and
unconditionally.&nbsp; When disabled, pass-downs are limited so the 8042 auxiliary processor does not become overloaded by
keyboard polling loops.
<DT>0x10
<DD><B> restore only changed interrupts --</B> Normally, when a<B> DOS/4GW</B> program terminates, all interrupts are restored
to the values they had at the time of program startup.&nbsp; When you use this option, only the interrupts changed by the<B>
DOS/4GW</B> program are restored.
<DT>0x20
<DD><B> set new memory to 00 --</B> When<B> DOS/4GW</B> allocates a new segment or increases the size of a segment, the memory
is zeroed.&nbsp; This can help you find bugs having to do with uninitialized memory.&nbsp; You can also use it to provide
a consistent working environment regardless of what programs were run earlier.&nbsp; This option only affects segment allocations
or expansions that are made through the<B> DOS/4GW</B> kernel (with DOS function 48H or 4AH).&nbsp; This option does not affect
memory allocated with a compiler's<TT> malloc</TT> function.
<DT>0x40
<DD><B> set new memory to FF --</B> When<B> DOS/4GW</B> allocates a new segment or increases the size of a segment, the memory
is set to 0xFF bytes.&nbsp; This is helpful in making reproducible cases of bugs caused by using uninitialized memory.&nbsp;
This option only affects segment allocations or expansions that are made through the<B> DOS/4GW</B> kernel (with DOS function
48H or 4AH).&nbsp; This option does not affect memory allocated with a compiler's<TT> malloc</TT> function.
<DT>0x80
<DD><B> new selector rotation --</B> When<B> DOS/4GW</B> allocates a new selector, it usually looks for the first available (unused)
selector in numerical order starting with the highest selector used when the program was loaded.&nbsp; When this option is
set, the new selector search begins after the last selector that was allocated.&nbsp; This causes new selectors to rotate
through the range.&nbsp; Use this option to find references to<B> stale</B> selectors, i.e., segments that have been cancelled
or freed.
</DL>
<H2 ID="DOSD4GW__Controlling_Address_Line_20"> DOS/4GW:&nbsp; Controlling Address Line 20 </H2>
<BR>This section explains how<B> DOS/4GW</B> uses address line 20 (A20) and describes the related<B> DOS16M</B> environment
variable settings.&nbsp; It is unlikely that you will need to use these settings.
<BR><BR>Because the 8086 and 8088 chips have 20-bit address spaces, their highest addressable memory location is one byte
below 1MB.&nbsp; If you specify an address at 1MB or over, which would require a twenty-first bit to set, the address wraps
back to zero.&nbsp; Some parts of DOS depend on this wrap, so on the 286 and 386, the twenty-first address bit is disabled.
&nbsp;To address extended memory,<B> DOS/4GW</B> enables the twenty-first address bit (the A20 line).&nbsp; The A20 line must
be enabled for the CPU to run in protected mode, but it may be either enabled or disabled in real mode.
<BR><BR>By default, when<B> DOS/4GW</B> returns to real mode, it disables the A20 line.&nbsp; Some software depends on the
line being enabled.<B>&nbsp; DOS/4GW</B> recognizes the most common software in this class, the XMS managers (such as HIMEM.SYS),
and enables the A20 line when it returns to real mode if an XMS manager is present.&nbsp; For other software that requires
the A20 line to be enabled, use the<TT> A20</TT> option.&nbsp; The<TT> A20</TT> option makes<B> DOS/4GW</B> restore the A20
line to the setting it had when<B> DOS/4GW</B> switched to protected mode.&nbsp; Set the environment variable as follows:
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; set DOS16M=A20</TT>
<BR><BR>To specify more than one option on the command line, separate the options with spaces.
<BR><BR>The<B> DOS16M</B> variable also lets you to specify the length of the delay between a<B> DOS/4GW</B> instruction to
change the status of the A20 line and the next<B> DOS/4GW</B> operation.&nbsp; By default, this delay is 1 loop instruction
when<B> DOS/4GW</B> is running on a 386 machine.&nbsp; In some cases, you may need to specify a longer delay for a machine
that will run<B> DOS/4GW</B> but is not truly AT-compatible.&nbsp; To change the delay, set<B> DOS16M</B> to the desired number
of loop instructions, preceded by a comma:&nbsp; 
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; set DOS16M=,loops</TT>
<H1 ID="DOSD4GW__VMM"> DOS/4GW:&nbsp; VMM </H1>
<BR>The Virtual Memory Manager (VMM) uses a swap file on disk to augment RAM.&nbsp; With VMM you can use more memory than
your machine actually has.&nbsp; When RAM is not sufficient, part of your program is swapped out to the disk file until it
is needed again.&nbsp; The combination of the swap file and available RAM is the<B> virtual memory.</B>
<BR><BR>Your program can use VMM if you set the DOS environment variable,<B> DOS4GVM</B> , as follows.&nbsp; To set the<B>
DOS4GVM</B> environment variable, use the format shown below.
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; set DOS4GVM= [option[#value]] [option[#value]]</TT>
<BR><BR>A &quot;#&quot; is used with options that take values since the DOS command shell will not accept &quot;=&quot;.
<BR><BR>If you set<B> DOS4GVM</B> equal to 1, the default parameters are used for all options.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; C&gt;set DOS4GVM=1</TT>
<H2 ID="DOSD4GW__VMM_Default_Parameters"> DOS/4GW:&nbsp; VMM Default Parameters </H2>
<BR>VMM parameters control the options listed below.
<DL>
<DT>MINMEM
<DD>The minimum amount of RAM managed by VMM.&nbsp; The default is 512KB.
<DT>MAXMEM
<DD>The maximum amount of RAM managed by VMM.&nbsp; The default is 4MB.
<DT>SWAPMIN
<DD>The minimum or initial size of the swap file.&nbsp; If this option is not used, the size of the swap file is based on<B><I>
VIRTUALSIZE</I></B> (see below).
<DT>SWAPINC
<DD>The size by which the swap file grows.
<DT>SWAPNAME
<DD>The swap file name.&nbsp; The default name is &quot;DOS4GVM.SWP&quot;.&nbsp; By default the file is in the root directory
of the current drive.&nbsp; Specify the complete path name if you want to keep the swap file somewhere else.
<DT>DELETESWAP
<DD>Whether the swap file is deleted when your program exits.&nbsp; By default the file is not deleted.&nbsp; Program startup
is quicker if the file is not deleted.
<DT>VIRTUALSIZE
<DD>The size of the virtual memory space.&nbsp; The default is 16MB.
</DL>
<H2 ID="DOSD4GW__Changing_the_Defaults"> DOS/4GW:&nbsp; Changing the Defaults </H2>
<BR>You can change the defaults in two ways.
<OL>
<LI>Specify different parameter values as arguments to the<B> DOS4GVM</B> environment variable, as shown in the example below.
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; set DOS4GVM=deleteswap maxmem#8192</TT>
<LI>Create a configuration file with the filetype extension &quot;.VMC&quot;, and use that as an argument to the<B> DOS4GVM</B>
environment variable, as shown below.
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; set DOS4GVM=@NEW4G.VMC</TT>
</OL>
<H3 ID="DOSD4GW__The__VMC_File"> DOS/4GW:&nbsp; The .VMC File </H3>
<BR>A &quot;.VMC&quot; file contains VMM parameters and settings as shown in the example below.&nbsp; Comments are permitted.
&nbsp;Comments on lines by themselves are preceded by an exclamation point (!).&nbsp; Comments that follow option settings
are preceded by white space.&nbsp; Do not insert blank lines:&nbsp; processing stops at the first blank line.
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; !Sample .VMC file</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; !This file shows the default parameter values.</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; minmem = 512&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; At least 512K
bytes of RAM is required.</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; maxmem = 4096&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Uses no more than
4MB of RAM</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; virtualsize = 16384&nbsp;&nbsp;&nbsp;&nbsp; Swap file plus allocated memory is 16MB</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; !To delete the swap file automatically when the program exits, add</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; !deleteswap</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; !To store the swap file in a directory called SWAPFILE, add</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; !swapname = c:\swapfile\dos4gvm.swp</TT>
<H1 ID="DOSD4GW__Interrupt_21H_Functions"> DOS/4GW:&nbsp; Interrupt 21H Functions </H1>
<BR>When you call an Interrupt 21H function under<B> DOS/4GW</B>, the 32-bit registers in which you pass values are translated
into the appropriate 16-bit registers, since DOS works only with 16 bits.&nbsp; However, you can use 32-bit values in your
DOS calls.&nbsp; You can allocate blocks of memory larger than 64KB or use an address with a 32-bit offset, and<B> DOS/4GW</B>
will translate the call appropriately, to use 16-bit registers.&nbsp; When the Interrupt 21H function returns, the value is
widened - placed in a 32-bit register, with the high order bits zeroed.
<BR><BR><B>DOS/4GW</B> uses the following rules to manage registers:
<UL>
<LI>When you pass a parameter to an Interrupt 21H function that expects a 16-bit quantity in a general register (for example,
AX), pass a 32-bit quantity in the corresponding extended register (for example, EAX).&nbsp; When a DOS function returns a
16-bit quantity in a general register, expect to receive it (with high-order zero bits) in the corresponding extended register.
<LI>When an Interrupt 21H function expects to receive a 16:16 pointer in a segment:general register pair (for example, ES:BX),
supply a 16:32 pointer using the same segment register and the corresponding extended general register (ES:EBX).<B>&nbsp;
DOS/4GW</B> will copy data and translate pointers so that DOS ultimately receives a 16:16 real-mode pointer in the correct
registers.
<LI>When DOS returns a 16:16 real-mode pointer,<B> DOS/4GW</B> translates the segment value into an appropriate protected-mode
selector and generates a 32-bit offset that results in a 16:32 pointer to the same location in the linear address space.
<LI>Many DOS functions return an error code in AX if the function fails.<B>&nbsp; DOS/4GW</B> checks the status of the carry
flag, and if it is set, indicating an error, zero-extends the code for EAX.&nbsp; It does not change any other registers.
<LI>If the value is passed or returned in an 8-bit register (AL or AH, for example),<B> DOS/4GW</B> puts the value in the
appropriate location and leaves the upper half of the 32-bit register untouched.
</UL>
<BR>The table below lists all the Interrupt 21h functions.&nbsp; For each, it shows the registers that are widened or narrowed.
&nbsp;Footnotes provide additional information about some of the interrupts that require special handling.&nbsp; Following
the table is a section that provides a detailed explanation of interrupt handling under<B> DOS/4GW.</B>
<BR><BR> Function&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Purpose&nbsp; Managed
Registers
<BR><BR> 00H&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Terminate Process&nbsp;&nbsp; None
<BR> 01H&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp; Character Input with Echo&nbsp;&nbsp; None
<BR> 02H&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Character Output&nbsp;&nbsp; None
<BR> 03H&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Auxiliary Input&nbsp;&nbsp; None
<BR> 04H&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Auxiliary Output&nbsp;&nbsp; None
<BR> 05H&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Print Character&nbsp;&nbsp; None
<BR> 06H&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Direct Console I/O&nbsp;&nbsp; None
<BR> 07H&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Unfiltered Character Input Without Echo&nbsp;&nbsp; None
<BR> 08H&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
Character Input Without Echo&nbsp;&nbsp; None
<BR> 09H&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Display String&nbsp;&nbsp; EDX
<BR> 0AH&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp; Buffered Keyboard Input&nbsp;&nbsp; EDX
<BR> 0BH&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Check Keyboard Status&nbsp;&nbsp; None
<BR> 0CH&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;Flush Buffer, Read Keyboard&nbsp;&nbsp; EDX
<BR> 0DH&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Disk Reset&nbsp;&nbsp;
None
<BR> 0EH&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Select Disk&nbsp;&nbsp; None
<BR> 0FH&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Open File with FCB&nbsp;&nbsp; EDX
<BR><BR> 10H&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Close File with FCB&nbsp;&nbsp; EDX
<BR> 11H&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Find First File&nbsp;&nbsp; EDX
<BR> 12H&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Find Next File&nbsp;&nbsp; EDX
<BR> 13H&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Delete File&nbsp;&nbsp; EDX
<BR> 14H&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Sequential Read&nbsp;&nbsp; EDX
<BR> 15H&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Sequential Write&nbsp;&nbsp; EDX
<BR> 16H&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Create File with FCB&nbsp;&nbsp; EDX
<BR> 17H&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Rename File&nbsp;&nbsp; EDX
<BR> 19H&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Get Current Disk&nbsp;&nbsp; None
<BR> 1AH&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Set DTA Address&nbsp;&nbsp; EDX
<BR> 1BH&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Get Default Drive Data&nbsp;&nbsp; Returns in EBX, ECX, and EDX
<BR> 1CH&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Get Drive Data&nbsp;&nbsp; Returns in EBX,
ECX, and EDX
<BR><BR> 21H&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Random Read&nbsp;&nbsp; EDX
<BR> 22H&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Random Write&nbsp;&nbsp; EDX
<BR> 23H&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Get File Size&nbsp;&nbsp; EDX
<BR> 24H&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Set Relative Record&nbsp;&nbsp; EDX
<BR> 25H&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Set Interrupt Vector&nbsp;&nbsp; EDX
<BR> 26H&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Create New Program Segment Prefix
&nbsp; None
<BR> 27H&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Random Block Read&nbsp;&nbsp; EDX, returns in ECX
<BR> 28H&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Random Block Write&nbsp;&nbsp; EDX, returns in ECX
<BR> 29H&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Parse Filename&nbsp;&nbsp; ESI, EDI, returns
in EAX, ESI and EDI (1.)
<BR> 2AH&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Get Date
&nbsp; Returns in ECX
<BR> 2BH&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Set Date
&nbsp; None
<BR> 2CH&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Get Time
&nbsp; None
<BR> 2DH&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Set Time
&nbsp; None
<BR> 2EH&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Set/Reset Verify Flag&nbsp;&nbsp; None
<BR> 2FH&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Get DTA Address&nbsp;&nbsp; Returns in EBX
<BR><BR> 30H&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp; Get MS-DOS Version Number&nbsp;&nbsp; Returns in ECX
<BR> 31H&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;Terminate and Stay Resident&nbsp;&nbsp; None
<BR> 33H&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
Get/Set Control-C Check Flag&nbsp;&nbsp; None
<BR> 34H&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
Return Address of InDOS Flag&nbsp;&nbsp; Returns in EBX
<BR> 35H&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Get Interrupt Vector&nbsp;&nbsp; Returns in EBX
<BR> 36H&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Get Disk Free Space&nbsp;&nbsp; Returns in EAX, EBX, ECX, and EDX
<BR> 38H&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp; Get/Set Current Country&nbsp;&nbsp; EDX, returns in EBX
<BR> 39H&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Create Directory&nbsp;&nbsp; EDX
<BR> 3AH&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Remove Directory&nbsp;&nbsp; EDX
<BR> 3BH&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; Change Current Directory&nbsp;&nbsp; EDX
<BR> 3CH&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp; Create File with Handle&nbsp;&nbsp; EDX, returns in EAX
<BR> 3DH&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Open File with Handle&nbsp;&nbsp; EDX, returns in EAX
<BR> 3EH&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Close File&nbsp;&nbsp;
None
<BR> 3FH&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Read File or Device&nbsp;&nbsp; EBX, ECX, EDX, returns in EAX (2.)
<BR><BR> 40H&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Write File or Device&nbsp;&nbsp; EBX, ECX, EDX, returns in EAX (2.)
<BR> 41H&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Delete File&nbsp;&nbsp; EDX
<BR> 42H&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Move File Pointer&nbsp;&nbsp; Returns in EDX, EAX
<BR> 43H&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Get/Set File Attribute&nbsp;&nbsp; EDX, returns in ECX
<BR> 44H&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;IOCTL&nbsp;&nbsp; (3.)
<BR>&nbsp;&nbsp;&nbsp; 00H Get Device Information&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Returns in EDX
<BR>&nbsp;&nbsp;&nbsp; 01H SetDevice Information&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; None
<BR>&nbsp;&nbsp;&nbsp; 02H Read Control Data from CDD
<BR> EDX, returns in EAX
<BR>&nbsp;&nbsp;&nbsp; 03H Write Control Data to CDD
<BR> EDX, returns in EAX
<BR>&nbsp;&nbsp;&nbsp; 04H Read Control Data from BDD
<BR> EDX, returns in EAX
<BR>&nbsp;&nbsp;&nbsp; 05H Write Control Data to BDD
<BR> EDX, returns in EAX
<BR>&nbsp;&nbsp;&nbsp; 06H Check Input Status&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; None
<BR>&nbsp;&nbsp;&nbsp; 07H Check Output Status&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; None
<BR>&nbsp;&nbsp;&nbsp; 08H Check if Block Device is Removeable
<BR> Returns in EAX
<BR>&nbsp;&nbsp;&nbsp; 09H Check if Block Device is Remote
<BR> Returns in EDX
<BR>&nbsp;&nbsp;&nbsp; 0AH Check if Handle is Remote&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Returns in EDX
<BR>&nbsp;&nbsp;&nbsp; 0BH Change Sharing Retry Count&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp; None
<BR>&nbsp;&nbsp;&nbsp; 0CH Generic I/O Control for Character Devices EDX
<BR>&nbsp;&nbsp;&nbsp; 0DH Generic I/O Control for Block Devices&nbsp;&nbsp;&nbsp;&nbsp; EDX
<BR>&nbsp;&nbsp;&nbsp; 0EH Get Logical Drive Map&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; None
<BR>&nbsp;&nbsp;&nbsp; 0FH Set Logical Drive Map&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; None
<BR> 45H&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Duplicate File Handle&nbsp;&nbsp; Returns in EAX
<BR> 46H&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;Force Duplicate File Handle&nbsp;&nbsp; None
<BR> 47H&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Get Current Directory&nbsp;&nbsp; ESI
<BR> 48H&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Allocate Memory Block&nbsp;&nbsp; Returns in EAX
<BR> 49H&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Free Memory Block&nbsp;&nbsp; None
<BR> 4AH&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Resize Memory Block&nbsp;&nbsp; None
<BR> 4BH&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Load and Execute
Program (EXEC)&nbsp;&nbsp; EBX, EDX (4.)
<BR> 4CH&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Terminate Process with Return Code
&nbsp; None
<BR> 4DH&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Get Return Code of Child
Process&nbsp;&nbsp; None
<BR> 4EH&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Find First File&nbsp;&nbsp; EDX
<BR> 4FH&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Find Next File&nbsp;&nbsp; None
<BR><BR> 52H&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Get List of Lists&nbsp;&nbsp; (not supported)
<BR> 54H&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Get Verify Flag&nbsp;&nbsp; None
<BR> 56H&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Rename File&nbsp;&nbsp; EDX,
EDI
<BR> 57H&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp; Get/Set Date/Time of File&nbsp;&nbsp; Returns in ECX, and EDX
<BR> 58H&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;Get/Set Allocation Strategy&nbsp;&nbsp; Returns in EAX
<BR> 59H&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Get Extended
Error Information&nbsp;&nbsp; Returns in EAX
<BR> 5AH&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Create Temporary File&nbsp;&nbsp; EDX, returns in EAX and EDX
<BR> 5BH&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Create New File&nbsp;&nbsp; EDX, returns in EAX
<BR> 5CH&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp; Lock/Unlock File Region&nbsp;&nbsp; None
<BR> 5EH&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Network Machine Name/Printer
Setup&nbsp; 
<BR>&nbsp;&nbsp;&nbsp; 00H Get Machine Name&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; EDX
<BR>&nbsp;&nbsp;&nbsp; 02H Set Printer Setup String&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp; ESI
<BR>&nbsp;&nbsp;&nbsp; 03H Get Printer Setup String&nbsp; EDI, returns in ECX
<BR> 5FH&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp; Get/Make Assign List Entry&nbsp; 
<BR>&nbsp;&nbsp;&nbsp; 02H Get Redirection List Entry
<BR> ESI, EDI, returns in ECX
<BR>&nbsp;&nbsp;&nbsp; 03H Redirect Device&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ESI, EDI
<BR>&nbsp;&nbsp;&nbsp; 04H Cancel Device Redirection&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; ESI
<BR><BR> 62H&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Get Program Segment Prefix Address
&nbsp; Returns in EBX
<BR> 63H&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Get Lead Byte Table (version 2.25 only)&nbsp;&nbsp; Returns in ESI
<BR> 65H&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Get Extended Country Information
&nbsp; EDI
<BR> 66H&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Get or Set Code Page&nbsp;&nbsp; None
<BR> 67H&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Set Handle Count&nbsp;&nbsp; None
<BR>This list of functions is excerpted from<B> The MS-DOS Encyclopedia</B>, Copyright (c) 1988 by Microsoft Press.&nbsp;
All Rights Reserved.
<OL>
<LI>For Function 29H, DS:ESI and ES:EDI contain pointer values that are not changed by the call.
<LI>You can read and write quantities larger than 64KB with Functions 3FH and 40H.<B>&nbsp; DOS/4GW</B> breaks your request
into chunks smaller than 64KB, and calls the DOS function once for each chunk.
<LI>You can't transfer more than 64KB using Function 44h, subfunctions 02H, 03H, 04H, or 05H.<B>&nbsp; DOS/4GW</B> does not
break larger requests into DOS-sized chunks, as it does for Functions 3FH and 40H.
<LI>When you call Function 4B under<B> DOS/4GW</B>, you pass it a data structure that contains 16:32 bit pointers.<B>&nbsp;
DOS/4GW</B> translates these into 16:16 bit pointers in the structure it passes to DOS.
</OL>
<H2 ID="DOSD4GW__Functions_25H_and_35H__Interrupt_Handling_in_Protected_Mode"> DOS/4GW:&nbsp; Functions 25H and 35H:&nbsp; Interrupt Handling in Protected Mode </H2>
<BR>By default, interrupts that occur in protected mode are passed down:&nbsp; the entry in the IDT points to code in<B> DOS/4GW</B>
that switches the CPU to real mode and resignals the interrupt.&nbsp; If you install an interrupt handler using Interrupt
21H, Function 25H, that handler will get control of any interrupts that occur while the processor is in protected mode.&nbsp;
If the interrupt for which you installed the handler is in the<B> autopassup range,</B> your handler will also get control
of interrupts signalled in real mode.
<BR><BR>The autopassup range runs from 08H to 2EH inclusive, but excluding 21H.&nbsp; If the interrupt is in the autopassup
range, the real-mode vector will be modified when you install the protected-mode handler to point to code in the<B> DOS/4GW</B>
kernel.&nbsp; This code switches the processor to protected mode and resignals the interrupt-where your protected-mode handler
will get control.
<H3 ID="DOSD4GW__32MBit_Gates"> DOS/4GW:&nbsp; 32-Bit Gates </H3>
<BR>The<B> DOS/4GW</B> kernel always assigns a 32-bit gate for the interrupt handlers it installs.&nbsp; It does not distinguish
between 16-bit and 32-bit handlers for consistency with DPMI.
<BR><BR>This 32-bit gate points into the<B> DOS/4GW</B> kernel.&nbsp; When<B> DOS/4GW</B> handles the interrupt, it switches
to its own 16-bit stack, and from there it calls the interrupt handler (yours or the default).&nbsp; This translation is transparent
to the handler, with one exception:&nbsp; since the current stack is not the one on which the interrupt occurred, the handler
cannot look up the stack for the address at which the interrupt occurred.
<H3 ID="DOSD4GW__Chaining_16Mbit_and_32Mbit_Handlers"> DOS/4GW:&nbsp; Chaining 16-bit and 32-bit Handlers </H3>
<BR>If your program hooks an interrupt, write a normal service routine that either handles the interrupt and IRETs or chains
to the previous handler.&nbsp; As part of handling the interrupt, your handler can PUSHF/CALL to the previous handler.&nbsp;
The handler<B> must</B> IRET (or IRETD) or chain.
<BR><BR>For each protected-mode interrupt,<B> DOS/4GW</B> maintains separate chains of 16-bit and 32-bit handlers.&nbsp; If
your 16-bit handler chains, the previous handler is a 16-bit program.&nbsp; If your 32-bit handler chains, the previous handler
is a 32-bit program.
<BR><BR>If a 16-bit program hooks a given interrupt before any 32-bit programs hook it, the 16-bit chain is executed first.
&nbsp;If all the 16-bit handlers unhook later and a new 16-bit program hooks the interrupt while 32-bit handlers are still
outstanding, the 32-bit handlers will be executed first.
<BR><BR>If the first program to hook an interrupt is 32-bit, the 32-bit chain is executed first.
<H3 ID="DOSD4GW__Getting_the_Address_of_the_Interrupt_Handler"> DOS/4GW:&nbsp; Getting the Address of the Interrupt Handler </H3>
<BR>When you signal Interrupt 21H, Function 35, it always returns a non-null address even if no other program of your bitness
(i.e., 16-bit or 32-bit) has hooked the interrupt.&nbsp; The address points to a dummy handler that looks to you as though
it does an IRET to end the chain.&nbsp; This means that you can't find an unused interrupt by looking for a NULL pointer.
&nbsp;Since this technique is most frequently used by programs that are looking for an unclaimed<B> real-mode</B> interrupt
on which to install a TSR, it shouldn't cause you problems.
<H1 ID="DOSD4GW__Interrupt_31H_DPMI_Functions"> DOS/4GW:&nbsp; Interrupt 31H DPMI Functions </H1>
<BR>When a<B> DOS/4GW</B> application runs under a DPMI host, such as Windows 3.1 in enhanced mode, an OS/2 virtual DOS machine,
386Max (with DEBUG=DPMIXCOPY), or QEMM/QDPMI (with EXTCHKOFF), the DPMI host provides the DPMI services, not<B> DOS/4GW</B>.
&nbsp;The DPMI host also provides virtual memory, if any.&nbsp; Performance (speed and memory use) under different DPMI hosts
varies greatly due to the quality of the DPMI implementation.
<BR><BR>DPMI services are accessed using Interrupt 31H.
<BR><BR>The following describes the services provided by<B> DOS/4GW</B> and DOS/4GW Professional in the absence of a DPMI
host.<B>&nbsp; DOS/4GW</B> supports many of the common DPMI system services.&nbsp; Not all of the services described below
are supported by other DPMI hosts.
<BR><BR>Some of the information in this chapter was obtained from the the DOS Protected-Mode Interface (DPMI) specification.
&nbsp;It is no longer in print; however the DPMI 1.0 specification can be obtained from the Intel ftp site.&nbsp; Here is
the URL.
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; ftp://ftp.intel.com/pub/IAL/software_specs/dpmiv1.zip</TT>
<BR><BR>This ZIP file contains a Postscript version of the DPMI 1.0 specification.
<H2 ID="DOSD4GW__Using_Interrupt_31H_Function_Calls"> DOS/4GW:&nbsp; Using Interrupt 31H Function Calls </H2>
<BR>Interrupt 31H DPMI function calls can be used only by protected-mode programs.
<BR><BR>The general ground rules for Interrupt 31H calls are as follows:
<UL>
<LI>All Interrupt 31H calls modify the AX register.&nbsp; Unsupported or unsuccessful calls return an error code in AX.&nbsp;
Other registers are saved unless they contain specified return values.
<LI>All Interrupt 31H calls modify flags:&nbsp; Unsupported or unsuccessful calls return with the carry flag set.&nbsp; Successful
calls clear the carry flag.&nbsp; Only memory management and interrupt flag management calls modify the interrupt flag.
<LI>Memory management calls can enable interrupts.
<LI>All calls are reentrant.
</UL>
<BR>The flag and register information for each call is listed in the following descriptions of supported Interrupt 31H function
calls.
<H2 ID="DOSD4GW__Int31H_Function_Calls"> DOS/4GW:&nbsp; Int31H Function Calls </H2>
<BR>The Interrupt 31H subfunction calls supported by<B> DOS/4GW</B> are listed below by category:
<UL>
<LI>Local Descriptor Table (LDT) management services
<LI>DOS memory management services
<LI>Interrupt services
<LI>Translation services
<LI>DPMI version
<LI>Memory management services
<LI>Page locking services
<LI>Demand paging performance tuning services
<LI>Physical address mapping
<LI>Virtual interrupt state functions
<LI>Vendor specific extensions
<LI>Coprocessor status
</UL>
<BR>Only the most commonly used Interrupt 31H function calls are supported in this version.
<H3 ID="DOSD4GW__Local_Descriptor_Table_LLDTR_Management_Services"> DOS/4GW:&nbsp; Local Descriptor Table (LDT) Management Services </H3>
<DL>
<DT>Function 0000H
<DD>This function allocates a specified number of descriptors from the LDT and returns the base selector.&nbsp; Pass the following
information:
<DL>
<DT>AX = 0000H
<DD>
<DT>CX = number of descriptors to be allocated
<DD>
</DL>
<BR>If the call succeeds, the carry flag is clear and the base selector is returned in AX.&nbsp; If the call fails, the carry
flag is set.
<BR><BR>An allocated descriptor is set to the present data type, with a base and limit of zero.&nbsp; The privilege level
of an allocated descriptor is set to match the code segment privilege level of the application.&nbsp; To find out the privilege
level of a descriptor, use the<TT> lar</TT> instruction.
<BR><BR>Allocated descriptors must be filled in by the application.&nbsp; If more than one descriptor is allocated, the returned
selector is the first of a contiguous array.&nbsp; Use Function 0003H to get the increment for the next selector in the array.
<DT>Function 0001H
<DD>This function frees the descriptor specified.&nbsp; Pass the following information:
<DL>
<DT>AX = 0001H
<DD>
<DT>BX = the selector to free
<DD>
</DL>
<BR>Use the selector returned with function 0000h when the descriptor was allocated.&nbsp; To free an array of descriptors,
call this function for each descriptor.&nbsp; Use Function 0003H to find out the increment for each descriptor in the array.
<BR><BR>If the call succeeds, the carry flag is clear; if it fails, the carry flag is set.
<BR><BR>You can use this function to free the descriptors allocated for the program's initial CS, DS, and SS segments, but
you should not free other segments that were not allocated with Function 0000H or Function 000DH.
<DT>Function 0002H
<DD>This function converts a real-mode segment to a descriptor that a protected-mode program can address.&nbsp; Pass the following
information:
<DL>
<DT>AX = 0002H
<DD>
<DT>BX = real-mode segment address
<DD>
</DL>
<BR>If the call succeeds, it clears the carry flag and returns the selector mapped to the real-mode segment in AX.&nbsp; If
the call fails, the carry flag is set.
<BR><BR>If you call this function more than once with the same real-mode segment address, you get the same selector value
each time.&nbsp; The descriptor limit is set to 64KB.
<BR><BR>The purpose of this function is to give protected-mode programs easy access to commonly used real-mode segments.&nbsp;
However, because you cannot modify or free descriptors created by this function, it should be used infrequently.&nbsp; Do
not use this function to get descriptors for private data areas.
<BR><BR>To examine real-mode addresses using the same selector, first allocate a descriptor, and then use Function 0007H to
change the linear base address.
<DT>Function 0003H
<DD>This function returns the increment value for the next selector.&nbsp; Use this function to get the value you add to the base
address of an allocated array of descriptors to get the next selector address.&nbsp; Pass the following information:
<DL>
<DT>AX = 0003H
<DD>
</DL>
<BR>This call always succeeds.&nbsp; The increment value is returned in AX.&nbsp; This value is always a power of two, but
no other assumptions can be made.
<DT>Function 0006H
<DD>This function gets the linear base address of a selector.&nbsp; Pass the following information:
<DL>
<DT>AX = 0006H
<DD>
<DT>BX = selector
<DD>
</DL>
<BR>If the call succeeds, the carry flag is clear and CX:DX contains the 32-bit linear base address of the segment.&nbsp;
If the call fails, it sets the carry flag.
<BR><BR>If the selector you specify in BX is invalid, the call fails.
<DT>Function 0007H
<DD>This function changes the base address of a specified selector.&nbsp; Only descriptors allocated through Function 0000H should
be modified.&nbsp; Pass the following information:
<DL>
<DT>AX = 0007H
<DD>
<DT>BX = selector
<DD>
<DT>CX:DX = the new 32-bit linear base address for the segment
<DD>
</DL>
<BR>If the call succeeds, the carry flag is clear; if unsuccessful, the carry flag is set.
<BR><BR>If the selector you specify in BX is invalid, the call fails.
<DT>Function 0008H
<DD>This function sets the upper limit of a specified segment.&nbsp; Use this function to modify descriptors allocated with Function
0000H only.&nbsp; Pass the following information:
<DL>
<DT>AX = 0008H
<DD>
<DT>BX = selector
<DD>
<DT>CX:DX = 32-bit segment limit
<DD>
</DL>
<BR>If the call succeeds, the carry flag is clear; if unsuccessful, the carry flag is set.
<BR><BR>The call fails if the specified selector is invalid, or if the specified limit cannot be set.
<BR><BR>Segment limits greater than 1MB must be page-aligned.&nbsp; This means that limits greater than 1MB must have the
low 12 bits set.
<BR><BR>To get the limit of a segment, use the 32-bit form of<TT> lsl</TT> for segment limits greater than 64KB.
<DT>Function 0009H
<DD>This function sets the descriptor access rights.&nbsp; Use this function to modify descriptors allocated with Function 0000H
only.&nbsp; To examine the access rights of a descriptor, use the<TT> lar</TT> instruction.&nbsp; Pass the following information:
<DL>
<DT>AX = 0009H
<DD>
<DT>BX = selector
<DD>
<DT>CL = Access rights/type byte
<DD>
<DT>CH = 386 extended access rights/type byte
<DD>
</DL>
<BR>If the call succeeds, the carry flag is clear; if unsuccessful, the carry flag is set.&nbsp; If the selector you specify
in BX is invalid, the call fails.&nbsp; The call also fails if the access rights/type byte does not match the format and meet
the requirements shown in the figures below.
<BR><BR>The access rights/type byte passed in CL has the format shown in the figure below.
<BR><BR><TT><IMG SRC="mem3.bmp" ALIGN=MIDDLE></TT>
<BR><B><I>Figure 3.</I></B><B><I></I></B><B> Access Rights/Type</B>
<BR><BR>The extended access rights/type byte passed in CH has the following format.
<BR><BR><TT><IMG SRC="mem4.bmp" ALIGN=MIDDLE></TT>
<BR><B><I>Figure 4.</I></B><B><I></I></B><B> Extended Access Rights/Type</B>
<DT>Function 000AH
<DD>This function creates an alias to a code segment.&nbsp; This function creates a data descriptor that has the same base and
limit as the specified code segment descriptor.&nbsp; Pass the following information:
<DL>
<DT>AX = 000AH
<DD>
<DT>BX = code segment selector
<DD>
</DL>
<BR>If the call succeeds, the carry flag is clear and the new data selector is returned in AX.&nbsp; If the call fails, the
carry flag is set.&nbsp; The call fails if the selector passed in BX is not a valid code segment.
<BR><BR>To deallocate an alias to a code segment, use Function 0001H.
<BR><BR>After the alias is created, it does not change if the code segment descriptor changes.&nbsp; For example, if the base
or limit of the code segment change later, the alias descriptor stays the same.
<DT>Function 000BH
<DD>This function copies the descriptor table entry for a specified descriptor.&nbsp; The copy is written into an 8-byte buffer.
&nbsp;Pass the following information:
<DL>
<DT>AX = 000BH
<DD>
<DT>BX = selector
<DD>
<DT>ES:EDI = a pointer to the 8-byte buffer for the descriptor copy
<DD>
</DL>
<BR>If the call succeeds, the carry flag is clear and ES:EDI contains a pointer to the buffer that contains a copy of the
descriptor.&nbsp; If the call fails, the carry flag is set.&nbsp; The call fails if the selector passed in BX is invalid or
unallocated.
<DT>Function 000CH
<DD>This function copies an 8-byte buffer into the LDT for a specified descriptor.&nbsp; The descriptor must first have been allocated
with Function 0000H.&nbsp; Pass the following information:
<DL>
<DT>AX = 000CH
<DD>
<DT>BX = selector
<DD>
<DT>ES:EDI = a pointer to the 8-byte buffer containing the descriptor
<DD>
</DL>
<BR>If the call succeeds, the carry flag is clear; if it fails, the carry flag is set.&nbsp; The call fails if the descriptor
passed in BX is invalid.
<BR>The type byte, byte 5, has the same format and requirements as the access rights/type byte passed to Function 0009H in
CL.&nbsp; The format is shown in the first figure presented with the description of Function 0009H.
<BR><BR>The extended type byte, byte 6, has the same format and requirements as the extended access rights/type byte passed
to Function 0009H in CH, except that the limit field can have any value, and the low order bits marked<B> reserved</B> are
used to set the upper 4 bits of the descriptor limit.&nbsp; The format is shown in the second figure presented with the description
of Function 0009H.
<DT>Function 000DH
<DD>This function allocates a specific LDT descriptor.&nbsp; Pass the following information:
<DL>
<DT>AX = 000DH
<DD>
<DT>BX = selector
<DD>
</DL>
<BR>If the call succeeds, the carry flag is clear and the specified descriptor is allocated.&nbsp; If the call fails, the
carry flag is set.
<BR><BR>The call fails if the specified selector is already in use, or if it is not a valid LDT descriptor.&nbsp; The first
10h (16 decimal) descriptors are reserved for this function, and should not be used by the host.&nbsp; Some of these descriptors
may be in use, however, if another client application is already loaded.
<BR><BR>To free the descriptor, use Function 0001H.
</DL>
<H3 ID="DOSD4GW__DOS_Memory_Management_Services"> DOS/4GW:&nbsp; DOS Memory Management Services </H3>
<DL>
<DT>Function 0100H
<DD>This function allocates memory from the DOS free memory pool.&nbsp; This function returns both the real-mode segment and one
or more descriptors that can be used by protected-mode applications.&nbsp; Pass the following information:
<DL>
<DT>AX = 0100H
<DD>
<DT>BX = the number of paragraphs (16-byte blocks) requested
<DD>
</DL>
<BR>If the call succeeds, the carry flag is clear.&nbsp; AX contains the initial real-mode segment of the allocated block
and DX contains the base selector for the allocated block.
<BR><BR>If the call fails, the carry flag is set.&nbsp; AX contains the DOS error code.&nbsp; If memory is damaged, code 07H
is returned.&nbsp; If there is not enough memory to satisfy the request, code 08H is returned.&nbsp; BX contains the number
of paragraphs in the largest available block of DOS memory.
<BR><BR>If you request a block larger than 64KB, contiguous descriptors are allocated.&nbsp; Use Function 0003H to find the
value of the increment to the next descriptor.&nbsp; The limit of the first descriptor is set to the entire block.&nbsp; Subsequent
descriptors have a limit of 64KB, except for the final descriptor, which has a limit of<TT> blocksize MOD 64KB.</TT>
<BR><BR>You cannot modify or deallocate descriptors allocated with this function.&nbsp; Function 101H deallocates the descriptors
automatically.
<DT>Function 0101H
<DD>This function frees a DOS memory block allocated with function 0100H.&nbsp; Pass the following information:
<DL>
<DT>AX = 0101H
<DD>
<DT>DX = selector of the block to be freed
<DD>
</DL>
<BR>If the call succeeds, the carry flag is clear.
<BR><BR>If the call fails, the carry flag is set and the DOS error code is returned in AX.&nbsp; If the incorrect segment
was specified, code 09H is returned.&nbsp; If memory control blocks are damaged, code 07H is returned.
<BR><BR>All descriptors allocated for the specified memory block are deallocated automatically and cannot be accessed correctly
after the block is freed.
<DT>Function 0102H
<DD>This function resizes a DOS memory block allocated with function 0100H.&nbsp; Pass the following information:
<DL>
<DT>AX = 0102H
<DD>
<DT>BX = the number of paragraphs (16-byte blocks) in the resized block
<DD>
<DT>DX = selector of block to resize
<DD>
</DL>
<BR>If the call succeeds, the carry flag is clear.
<BR><BR>If the call fails, the carry flag is set, the maximum number of paragraphs available is returned in BX, and the DOS
error code is returned in AX.&nbsp; If memory code blocks are damaged, code 07H is returned.&nbsp; If there isn't enough memory
to increase the size as requested, code 08H is returned.&nbsp; If the incorrect segment is specified, code 09h is returned.
<BR><BR>Because of the difficulty of finding additional contiguous memory or descriptors, this function is not often used
to increase the size of a memory block.&nbsp; Increasing the size of a memory block might well fail because other DOS allocations
have used contiguous space.&nbsp; If the next descriptor in the LDT is not free, allocation also fails when the size of a
block grows over the 64KB boundary.
<BR><BR>If you shrink the size of a memory block, you may also free some descriptors allocated to the block.&nbsp; The initial
selector remains unchanged, however; only the limits of subsequent selectors will change.
</DL>
<H3 ID="DOSD4GW__Interrupt_Services"> DOS/4GW:&nbsp; Interrupt Services </H3>
<DL>
<DT>Function 0200H
<DD>This function gets the value of the current task's real-mode interrupt vector for the specified interrupt.&nbsp; Pass the
following information:
<DL>
<DT>AX = 0200H
<DD>
<DT>BL = interrupt number
<DD>
</DL>
<BR>This call always succeeds.&nbsp; All 100H (256 decimal) interrupt vectors are supported by the host.&nbsp; When the call
returns, the carry flag is clear, and the<TT> segment:offset</TT> of the real-mode interrupt handler is returned in CX:DX.
<BR><BR>Because the address returned in CX is a segment, and not a selector, you cannot put it into a protected-mode segment
register.&nbsp; If you do, a general protection fault may occur.
<DT>Function 0201H
<DD>This function sets the value of the current task's real-mode interrupt vector for the specified interrupt.&nbsp; Pass the
following information:
<DL>
<DT>AX = 0201H
<DD>
<DT>BL = interrupt number
<DD>
<DT>CX:DX = segment:offset of the real-mode interrupt handler
<DD>
</DL>
<BR>If the call succeeds, the carry flag is clear; if it fails, the carry flag is set.
<BR><BR>The address passed in CX:DX should be a real-mode<TT> segment:offset,</TT> such as function 0200H returns.&nbsp; For
this reason, the interrupt handler must reside in DOS addressable memory.&nbsp; You can use Function 0100H to allocate DOS
memory.&nbsp; This version does not support the real-mode callback address function.
<BR><BR>If you are hooking a hardware interrupt, you have to lock all segments involved.&nbsp; These segments include the
segment in which the interrupt handler runs, and any segment it may touch at interrupt time.
<DT>Function 0202H
<DD>This function gets the processor exception handler vector.&nbsp; This function returns the CS:EIP of the current protected-mode
exception handler for the specified exception number.&nbsp; Pass the following information:
<DL>
<DT>AX = 0202H
<DD>
<DT>BL = exception/fault number (00h - 1Fh)
<DD>
</DL>
<BR>If the call succeeds, the carry flag is clear and the<TT> selector:offset</TT> of the protected-mode exception handler
is returned in CX:EDX.&nbsp; If it fails, the carry flag is set.
<BR><BR>The value returned in CX is a valid protected-mode selector, not a real-mode segment.
<DT>Function 0203H
<DD>This function sets the processor exception handler vector.&nbsp; This function allows protected-mode applications to intercept
processor exceptions that are not handled by the DPMI environment.&nbsp; Programs may wish to handle exceptions such as &quot;not
present segment faults&quot; which would otherwise generate a fatal error.&nbsp; Pass the following information:
<DL>
<DT>AX = 0203H
<DD>
<DT>BL = exception/fault number (00h - 1Fh)
<DD>
<DT>CX:EDX = selector:offset of the exception handler
<DD>
</DL>
<BR>If the call succeeds, the carry flag is clear.&nbsp; If it fails, the carry flag is set.
<BR><BR>The address passed in CX must be a valid protected-mode selector, such as Function 204H returns, and not a real-mode
segment.&nbsp; A 32-bit implementation must supply a 32-bit offset in the EDX register.&nbsp; If the handler chains to the
next handler, it must use a 32-bit interrupt stack frame to do so.
<BR><BR>The handler should return using a far return instruction.&nbsp; The original SS:ESP, CS:EIP and flags on the stack,
including the interrupt flag, will be restored.
<BR><BR>All fault stack frames have an error code.&nbsp; However the error code is only valid for exceptions 08h, 0Ah, 0Bh,
0Ch, 0Dh, and 0Eh.
<BR><BR>The handler must preserve and restore all registers.
<BR><BR>The exception handler will be called on a locked stack with interrupts disabled.&nbsp; The original SS, ESP, CS, and
EIP will be pushed on the exception handler stack frame.
<BR><BR>The handler must either return from the call by executing a far return or jump to the next handler in the chain (which
will execute a far return or chain to the next handler).
<BR><BR>The procedure can modify any of the values on the stack pertaining to the exception before returning.&nbsp; This can
be used, for example, to jump to a procedure by modifying the CS:EIP on the stack.&nbsp; Note that the procedure must not
modify the far return address on the stack - it must return to the original caller.&nbsp; The caller will then restore the
flags, CS:EIP and SS:ESP from the stack frame.
<BR><BR>If the DPMI client does not handle an exception, or jumps to the default exception handler, the host will reflect
the exception as an interrupt for exceptions 0, 1, 2, 3, 4, 5 and 7.&nbsp; Exceptions 6 and 8 - 1Fh will be treated as fatal
errors and the client will be terminated.
<BR><BR>Exception handlers will only be called for exceptions that occur in protected mode.
<DT>Function 0204H
<DD>This function gets the CS:EIP<TT> selector:offset</TT> of the current protected-mode interrupt handler for a specified interrupt
number.&nbsp; Pass the following information:
<DL>
<DT>AX = 0204H
<DD>
<DT>BL = interrupt number
<DD>
</DL>
<BR>This call always succeeds.&nbsp; All 100H (256 decimal) interrupt vectors are supported by the host.&nbsp; When the call
returns, the carry flag is clear and CX:EDX contains the protected-mode<TT> selector:offset</TT> of the exception handler.
<BR><BR>A 32-bit offset is returned in the EDX register.
<DT>Function 0205H
<DD>This function sets the address of the specified protected-mode interrupt vector.&nbsp; Pass the following information:
<DL>
<DT>AX = 0205H
<DD>
<DT>BL = interrupt number
<DD>
<DT>CX:EDX = selector:offset of the exception handler
<DD>
</DL>
<BR>If the call succeeds, the carry flag is clear; if it fails, the carry flag is set.
<BR><BR>The address passed in CX must be a valid protected-mode selector, such as Function 204H returns, and not a real-mode
segment.&nbsp; A 32-bit implementation must supply a 32-bit offset in the EDX register.&nbsp; If the handler chains to the
next handler, it must use a 32-bit interrupt stack frame to do so.
</DL>
<H3 ID="DOSD4GW__Translation_Services"> DOS/4GW:&nbsp; Translation Services </H3>
<BR>These services are provided so that protected-mode programs can call real-mode software that DPMI does not support directly.
&nbsp;The protected-mode program must set up a data structure with the appropriate register values.&nbsp; This &quot;real-mode
call structure&quot; is shown below.
<BR><BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Offset&nbsp; Register&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;

<BR><BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 00H&nbsp;&nbsp;&nbsp;&nbsp; EDI&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
<BR><BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 04H&nbsp;&nbsp;&nbsp;&nbsp; ESI&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
<BR><BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 08H&nbsp;&nbsp;&nbsp;&nbsp; EBP&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
<BR><BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0CH&nbsp;&nbsp;&nbsp;&nbsp; Reserved by system&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
<BR><BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 10H&nbsp;&nbsp;&nbsp;&nbsp; EBX&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
<BR><BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 14H&nbsp;&nbsp;&nbsp;&nbsp; EDX&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
<BR><BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 18H&nbsp;&nbsp;&nbsp;&nbsp; ECX&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
<BR><BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 1CH&nbsp;&nbsp;&nbsp;&nbsp; EAX&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
<BR><BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 20H&nbsp;&nbsp;&nbsp;&nbsp; Flags&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp; 
<BR><BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 22H&nbsp;&nbsp;&nbsp;&nbsp; ES&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
<BR><BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 24H&nbsp;&nbsp;&nbsp;&nbsp; DS&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
<BR><BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 26H&nbsp;&nbsp;&nbsp;&nbsp; FS&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
<BR><BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 28H&nbsp;&nbsp;&nbsp;&nbsp; GS&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
<BR><BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 2AH&nbsp;&nbsp;&nbsp;&nbsp; IP&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
<BR><BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 2CH&nbsp;&nbsp;&nbsp;&nbsp; CS&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
<BR><BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 2EH&nbsp;&nbsp;&nbsp;&nbsp; SP&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
<BR><BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 30H&nbsp;&nbsp;&nbsp;&nbsp; SS&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
<BR><BR>After the call or interrupt is complete, all real-mode registers and flags except SS, SP, CS, and IP will be copied
back to the real-mode call structure so that the caller can examine the real-mode return values.
<BR><BR>The values in the segment registers should be real-mode segments, not protected-mode selectors.
<BR><BR>The translation services will provide a real-mode stack if the SS:SP fields are zero.&nbsp; However, the stack provided
is relatively small.&nbsp; If the real-mode procedure/interrupt routine uses more than 30 words of stack space then you should
provide your own real-mode stack.
<DL>
<DT>Function 0300H
<DD>This function simulates a real-mode interrupt.&nbsp; This function simulates an interrupt in real mode.&nbsp; It will invoke
the CS:IP specified by the real-mode interrupt vector and the handler must return by executing an<TT> iret.</TT>&nbsp; Pass
the following information:
<DL>
<DT>AX = 0300H
<DD>
<DT>BL = interrupt number
<DD>
<DT>BH = flags
<DD>Bit 0 = 1 resets the interrupt controller and A20 line.&nbsp; Other flags are reserved and must be 0.
<DT>CX = number of words to copy from protected-mode stack to real-mode stack
<DD>
<DT>ES:EDI = the selector:offset of real-mode call structure
<DD>
</DL>
<BR>If the call fails, the carry flag is set.
<BR><BR>If the call succeeds, the carry flag is clear and ES:EDI contains the<TT> selector:offset</TT> of the modified real-mode
call structure.
<BR><BR>The CS:IP in the real-mode call structure is ignored by this service.&nbsp; The appropriate interrupt handler will
be called based on the value passed in BL.
<BR><BR>The flags specified in the real-mode call structure will be pushed on the real-mode stack<TT> iret</TT> frame.&nbsp;
The interrupt handler will be called with the interrupt and trace flags clear.
<BR><BR>It is up to the caller to remove any parameters that were pushed on the protected-mode stack.
<BR><BR>The flag to reset the interrupt controller and the A20 line is ignored by DPMI implementations that run in Virtual
8086 mode.&nbsp; It causes DPMI implementations that return to real mode to set the interrupt controller and A20 address line
hardware to its normal real-mode state.
<DT>Function 0301H
<DD>(DOS/4GW Professional only) This function calls a real-mode procedure with a FAR return frame.&nbsp; The called procedure
must execute a FAR return when it completes.&nbsp; Pass the following information:
<DL>
<DT>AX = 0301H
<DD>
<DT>BH = flags
<DD>Bit 0 = 1 resets the interrupt controller and A20 line.&nbsp; Other flags reserved and must be 0.
<DT>CX = Number of words to copy from protected-mode to real-mode stack
<DD>
<DT>ES:EDI = selector:offset of real-mode call structure
<DD>
</DL>
<BR>If the call succeeds, the carry flag is clear and ES:EDI contains the<TT> selector:offset</TT> of modified real-mode call
structure.
<BR><BR>If the call fails, the carry flag is set.
<BR><BR><B>Notes:</B>
<OL>
<LI>The CS:IP in the real-mode call structure specifies the address of the real-mode procedure to call.
<LI>The real-mode procedure must execute a FAR return when it has completed.
<LI>If the SS:SP fields are zero then a real-mode stack will be provided by the DPMI host.&nbsp; Otherwise, the real-mode
SS:SP will be set to the specified values before the procedure is called.
<LI>When the Int 31h returns, the real-mode call structure will contain the values that were returned by the real-mode procedure.
<LI>It is up to the caller to remove any parameters that were pushed on the protected-mode stack.
<LI>The flag to reset the interrupt controller and A20 line is ignored by DPMI implementations that run in Virtual 8086 mode.
&nbsp;It causes DPMI implementations that return to real mode to set the interrupt controller and A20 address line hardware
to its normal real-mode state.
</OL>
<DT>Function 0302H
<DD>(DOS/4GW Professional only) This function calls a real-mode procedure with an<TT> iret</TT> frame.&nbsp; The called procedure
must execute an<TT> iret</TT> when it completes.&nbsp; Pass the following information:
<DL>
<DT>AX = 0302H
<DD>
<DT>BH = flags
<DD>Bit 0 = 1 resets the interrupt controller and A20 line.&nbsp; Other flags reserved and must be 0.
<DT>CX = Number of words to copy from protected-mode to real-mode stack
<DD>
<DT>ES:EDI = selector:offset of real-mode call structure
<DD>
</DL>
<BR>If the call succeeds, the carry flag is clear and ES:EDI contains the<TT> selector:offset</TT> of modified real-mode call
structure.
<BR><BR>If the call fails, the carry flag is set.
<BR><BR><B>Notes:</B>
<OL>
<LI>The CS:IP in the real-mode call structure specifies the address of the real-mode procedure to call.
<LI>The real-mode procedure must execute an<TT> iret</TT> when it has completed.
<LI>If the SS:SP fields are zero then a real-mode stack will be provided by the DPMI host.&nbsp; Otherwise, the real-mode
SS:SP will be set to the specified values before the procedure is called.
<LI>When the Int 31h returns, the real-mode call structure will contain the values that were returned by the real-mode procedure.
<LI>The flags specified in the real-mode call structure will be pushed the real-mode stack<TT> iret</TT> frame.&nbsp; The
procedure will be called with the interrupt and trace flags clear.
<LI>It is up to the caller to remove any parameters that were pushed on the protected-mode stack.
<LI>The flag to reset the interrupt controller and A20 line is ignored by DPMI implementations that run in Virtual 8086 mode.
&nbsp;It causes DPMI implementations that return to real mode to set the interrupt controller and A20 address line hardware
to its normal real-mode state.
</OL>
<DT>Function 0303H
<DD>(DOS/4GW Professional only) This function allocates a real-mode callback address.&nbsp; This service is used to obtain a unique
real-mode SEG:OFFSET that will transfer control from real mode to a protected-mode procedure.
<BR><BR>At times it is necessary to hook a real-mode interrupt or device callback in a protected-mode driver.&nbsp; For example,
many mouse drivers call an address whenever the mouse is moved.&nbsp; Software running in protected mode can use a real-mode
callback to intercept the mouse driver calls.&nbsp; Pass the following information:
<DL>
<DT>AX = 0303H
<DD>
<DT>DS:ESI = selector:offset of procedure to call
<DD>
<DT>ES:EDI = selector:offset of real-mode call structure
<DD>
</DL>
<BR>If the call succeeds, the carry flag is clear and CX:DX contains the<TT> segment:offset</TT> of real-mode callback address.
<BR><BR>If the call fails, the carry flag is set.
<DL>
<DT>Callback Procedure Parameters
<DD>
<BR><BR>&nbsp;&nbsp;&nbsp;&nbsp; Interrupts disabled
<BR>&nbsp;&nbsp;&nbsp;&nbsp; DS:ESI = selector:offset of real-mode SS:SP
<BR>&nbsp;&nbsp;&nbsp;&nbsp; ES:EDI = selector:offset of real-mode call structure
<BR>&nbsp;&nbsp;&nbsp;&nbsp; SS:ESP = Locked protected-mode API stack
<BR>&nbsp;&nbsp;&nbsp;&nbsp; All other registers undefined
<DT>Return from Callback Procedure
<DD>
<BR><BR>&nbsp;&nbsp;&nbsp;&nbsp; Execute an IRET to return
<BR>&nbsp;&nbsp;&nbsp;&nbsp; ES:EDI =&nbsp; selector:offset of real-mode call structure
<BR>&nbsp;&nbsp;&nbsp;&nbsp; to restore (see note)
</DL>
<BR><B>Notes:</B>
<OL>
<LI>Since the real-mode call structure is static, you must be careful when writing code that may be reentered.&nbsp; The simplest
method of avoiding reentrancy is to leave interrupts disabled throughout the entire call.&nbsp; However, if the amount of
code executed by the callback is large then you will need to copy the real-mode call structure into another buffer.&nbsp;
You can then return with ES:EDI pointing to the buffer you copied the data to - it does not have to point to the original
real mode call structure.
<LI>The called procedure is responsible for modifying the real-mode CS:IP before returning.&nbsp; If the real-mode CS:IP is
left unchanged then the real-mode callback will be executed immediately and your procedure will be called again.&nbsp; Normally
you will want to pop a return address off of the real-mode stack and place it in the real-mode CS:IP.&nbsp; The example code
in the next section demonstrates chaining to another interrupt handler and simulating a real-mode<TT> iret.</TT>
<LI>To return values to the real-mode caller, you must modify the real-mode call structure.
<LI>Remember that all segment values in the real-mode call structure will contain real-mode segments, not selectors.&nbsp;
If you need to examine data pointed to by a real-mode seg:offset pointer, you should not use the segment to selector service
to create a new selector.&nbsp; Instead, allocate a descriptor during initialization and change the descriptor's base to 16
times the real-mode segment's value.&nbsp; This is important since selectors allocated though the segment to selector service
can never be freed.
<LI>DPMI hosts should provide a minimum of 16 callback addresses per task.
</OL>
<BR>The following code is a sample of a real-mode interrupt hook.&nbsp; It hooks the DOS Int 21h and returns an error for
the delete file function (AH=41h).&nbsp; Other calls are passed through to DOS.&nbsp; This example is somewhat silly but it
demonstrates the techniques used to hook a real mode interrupt.&nbsp; Note that since DOS calls are reflected from protected
mode to real mode, the following code will intercept all DOS calls from both real mode and protected mode.
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; ;******************************************************</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; ; This procedure gets the current Int 21h real-mode</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; ; Seg:Offset, allocates a real-mode callback address,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; ; and sets the real-mode Int 21h vector to the call-</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; ; back address.</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; ;******************************************************</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Initialization_Code:</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; ;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; ; Create a code segment alias to save data in</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; ;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mov&nbsp;&nbsp;&nbsp;&nbsp; ax, 000Ah</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mov&nbsp;&nbsp;&nbsp;&nbsp; bx, cs</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int&nbsp;&nbsp;&nbsp;&nbsp; 31h</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; jc&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ERROR</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mov&nbsp;&nbsp;&nbsp;&nbsp; ds, ax</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ASSUMES DS,_TEXT</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; ;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; ; Get current Int 21h real-mode SEG:OFFSET</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; ;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mov&nbsp;&nbsp;&nbsp;&nbsp; ax, 0200h</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mov&nbsp;&nbsp;&nbsp;&nbsp; bl, 21h</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int&nbsp;&nbsp;&nbsp;&nbsp; 31h</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; jc&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ERROR</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mov&nbsp;&nbsp;&nbsp;&nbsp; [Orig_Real_Seg],
cx</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mov&nbsp;&nbsp;&nbsp;&nbsp; [Orig_Real_Offset],
dx</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; ;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; ; Allocate a real-mode callback</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; ;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mov&nbsp;&nbsp;&nbsp;&nbsp; ax, 0303h</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; push&nbsp;&nbsp;&nbsp; ds</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mov&nbsp;&nbsp;&nbsp;&nbsp; bx, cs</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mov&nbsp;&nbsp;&nbsp;&nbsp; ds, bx</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mov&nbsp;&nbsp;&nbsp;&nbsp; si, OFFSET My_Int_21_Hook</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pop&nbsp;&nbsp;&nbsp;&nbsp; es</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mov&nbsp;&nbsp;&nbsp;&nbsp; di, OFFSET My_Real_Mode_Call_Struc</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int&nbsp;&nbsp;&nbsp;&nbsp; 31h</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; jc&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ERROR</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; ;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; ; Hook real-mode int 21h with the callback address</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; ;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mov&nbsp;&nbsp;&nbsp;&nbsp; ax, 0201h</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mov&nbsp;&nbsp;&nbsp;&nbsp; bl, 21h</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int&nbsp;&nbsp;&nbsp;&nbsp; 31h</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; jc&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ERROR</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; ;******************************************************</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; ;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; ; This is the actual Int 21h hook code.&nbsp; It will return</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; ; an &quot;access denied&quot; error for all calls made in real</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; ; mode to delete a file.&nbsp; Other calls will be passed</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; ; through to DOS.</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; ;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; ; ENTRY:</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; ;&nbsp;&nbsp;&nbsp; DS:SI -&gt; Real-mode SS:SP</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; ;&nbsp;&nbsp;&nbsp; ES:DI -&gt; Real-mode call structure</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; ;&nbsp;&nbsp;&nbsp; Interrupts disabled</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; ;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; ; EXIT:</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; ;&nbsp;&nbsp;&nbsp; ES:DI -&gt; Real-mode call structure</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; ;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; ;******************************************************</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; My_Int_21_Hook:</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cmp&nbsp;&nbsp;&nbsp;&nbsp; es:[di.RealMode_AH],
41h</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; jne&nbsp;&nbsp;&nbsp;&nbsp; Chain_To_DOS</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; ;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; ; This is a delete file call (AH=41h).&nbsp; Simulate an</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; ; iret on the real-mode stack, set the real-mode</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; ; carry flag, and set the real-mode AX to 5 to indicate</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; ; an access denied error.</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; ;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cld</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; lodsw&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ; Get real-mode ret IP</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mov&nbsp;&nbsp;&nbsp;&nbsp; es:[di.RealMode_IP],
ax</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; lodsw&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ; Get real-mode ret CS</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mov&nbsp;&nbsp;&nbsp;&nbsp; es:[di.RealMode_CS],
ax</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; lodsw&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ; Get real-mode flags</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; or&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ax, 1&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ; Set carry flag</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mov&nbsp;&nbsp;&nbsp;&nbsp; es:[di.RealMode_Flags],
ax</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; add&nbsp;&nbsp;&nbsp;&nbsp; es:[di.RealMode_SP],
6</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mov&nbsp;&nbsp;&nbsp;&nbsp; es:[di.RealMode_AX],
5</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; jmp&nbsp;&nbsp;&nbsp;&nbsp; My_Hook_Exit</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; ;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; ; Chain to original Int 21h vector by replacing the</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; ; real-mode CS:IP with the original Seg:Offset.</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; ;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Chain_To_DOS:</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mov&nbsp;&nbsp;&nbsp;&nbsp; ax, cs:[Orig_Real_Seg]</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mov&nbsp;&nbsp;&nbsp;&nbsp; es:[di.RealMode_CS],
ax</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mov&nbsp;&nbsp;&nbsp;&nbsp; ax, cs:[Orig_Real_Offset]</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mov&nbsp;&nbsp;&nbsp;&nbsp; es:[di.RealMode_IP],
ax</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; My_Hook_Exit:</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; iret</TT>
<DT>Function 0304H
<DD>(DOS/4GW Professional only) This function frees a real-mode callback address that was allocated through the allocate real-mode
callback address service.&nbsp; Pass the following information:
<DL>
<DT>AX = 0304H
<DD>
<DT>CX:DX = Real-mode callback address to free
<DD>
</DL>
<BR>If the call succeeds, the carry flag is clear; if it fails, the carry flag is set.
<BR><BR><B>Notes:</B>
<OL>
<LI>Real-mode callbacks are a limited resource.&nbsp; Your code should free any break point that it is no longer using.
</OL>
</DL>
<H3 ID="DOSD4GW__DPMI_Version"> DOS/4GW:&nbsp; DPMI Version </H3>
<DL>
<DT>Function 0400H
<DD>This function returns the version of DPMI services supported.&nbsp; Note that this is not necessarily the version of any operating
system that supports DPMI.&nbsp; It should be used by programs to determine what calls are legal in the current environment.
&nbsp;Pass the following information:
<DL>
<DT>AX = 0400H
<DD>
</DL>
<BR>The information returned is:
<DL>
<DT>AH = Major version
<DD>
<DT>AL = Minor version
<DD>
<DT>BX = Flags
<DD>Bit 0 = 1 if running under an 80386 DPMI implementation.&nbsp; Bit 1 = 1 if processor is returned to real mode for reflected
interrupts (as opposed to Virtual 8086 mode).&nbsp; Bit 2 = 1 if virtual memory is supported.&nbsp; Bit 3 is reserved and
undefined.&nbsp; All other bits are zero and reserved for later use.
<DT>CL = Processor type
<DD>
<BR><BR>&nbsp;&nbsp;&nbsp;&nbsp; 02 = 80286
<BR>&nbsp;&nbsp;&nbsp;&nbsp; 03 = 80386
<BR>&nbsp;&nbsp;&nbsp;&nbsp; 04 = 80486
<BR>&nbsp;&nbsp;&nbsp;&nbsp; 05 = Pentium
<DT>DH = Current value of virtual master PIC base interrupt
<DD>
<DT>DL = Current value of virtual slave PIC base interrupt
<DD>
<DT>Carry flag clear (call cannot fail)
<DD>
</DL>
</DL>
<H3 ID="DOSD4GW__Memory_Management_Services"> DOS/4GW:&nbsp; Memory Management Services </H3>
<DL>
<DT>Function 0500H
<DD>This function gets information about free memory.&nbsp; Pass the following information:
<DL>
<DT>AX = 0500H
<DD>
<DT>ES:EDI = the selector:offset of a 30H byte buffer.
<DD>
</DL>
<BR>If the call fails, the carry flag is set.
<BR><BR>If the call succeeds, the carry flag is clear and ES:EDI contains the<TT> selector:offset</TT> of a buffer with the
structure shown in the figure below.
<BR><BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Offset&nbsp; Description&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;

<BR><BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 00H&nbsp;&nbsp;&nbsp;&nbsp; Largest available block,
in bytes&nbsp;&nbsp;&nbsp;&nbsp; 
<BR><BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 04H&nbsp;&nbsp;&nbsp;&nbsp; Maximum unlocked page
allocation&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
<BR><BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 08H&nbsp;&nbsp;&nbsp;&nbsp; Largest block of memory
(in pages) that
<BR>could&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; be
allocated and then locked&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
<BR><BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0CH&nbsp;&nbsp;&nbsp;&nbsp; Total linear address
space size, in pages,
<BR>including&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; already
allocated pages&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
<BR><BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 10H&nbsp;&nbsp;&nbsp;&nbsp; Total number of free
pages and pages&nbsp; 
<BR>currently&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; unlocked
and available for paging out 
<BR><BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 14H&nbsp;&nbsp;&nbsp;&nbsp; Number of physical
pages not in use&nbsp;&nbsp; 
<BR><BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 18H&nbsp;&nbsp;&nbsp;&nbsp; Total number of physical
pages managed by host
<BR><BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 1CH&nbsp;&nbsp;&nbsp;&nbsp; Free linear address
space, in pages&nbsp;&nbsp; 
<BR><BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 20H&nbsp;&nbsp;&nbsp;&nbsp; Size of paging/file
partition, in pages
<BR><BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 24H -&nbsp;&nbsp; Reserved&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp; 
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 2FH&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
<BR><BR>Only the first field of the structure is guaranteed to contain a valid value.&nbsp; Any field that is not returned
by<B> DOS/4GW</B> is set to -1 (0FFFFFFFFH).
<DT>Function 0501H
<DD>This function allocates and commits linear memory.&nbsp; Pass the following information:
<DL>
<DT>AX = 0501H
<DD>
<DT>BX:CX = size of memory to allocate, in bytes.
<DD>
</DL>
<BR>If the call succeeds, the carry flag is clear, BX:CX contains the linear address of the allocated memory, and SI:DI contains
the memory block handle used to free or resize the block.&nbsp; If the call fails, the carry flag is set.
<BR><BR>No selectors are allocated for the memory block.&nbsp; The caller must allocate and initialize selectors needed to
access the memory.
<BR><BR>If VMM is present, the memory is allocated as unlocked, page granular blocks.&nbsp; Because of the page granularity,
memory should be allocated in multiples of 4KB.
<DT>Function 0502H
<DD>This function frees a block of memory allocated through function 0501H.&nbsp; Pass the following information:
<DL>
<DT>AX = 0502H
<DD>
<DT>SI:DI = handle returned with function 0501H when memory was allocated
<DD>
</DL>
<BR>If the call succeeds, the carry flag is clear; if it fails, the carry flag is set.&nbsp; You must also free any selectors
allocated to point to the freed memory block.
<DT>Function 0503H
<DD>This function resizes a block of memory allocated through the 0501H function.&nbsp; If you resize a block of linear memory,
it may have a new linear address and a new handle.&nbsp; Pass the following information:
<DL>
<DT>AX = 0503H
<DD>
<DT>BX:CX = new size of memory block, in bytes
<DD>
<DT>SI:DI = handle returned with function 0501H when memory was allocated
<DD>
</DL>
<BR>If the call succeeds, the carry flag is clear, BX:CX contains the new linear address of the memory block, and SI:DI contains
the new handle of the memory block.&nbsp; If the call fails, the carry flag is set.
<BR><BR>If either the linear address or the handle has changed, update the selectors that point to the memory block.&nbsp;
Use the new handle instead of the old one.
<BR><BR>You cannot resize a memory block to zero bytes.
</DL>
<H3 ID="DOSD4GW__Page_Locking_Services"> DOS/4GW:&nbsp; Page Locking Services </H3>
<BR>These services are only useful under DPMI implementations that support virtual memory.&nbsp; Although memory ranges are
specified in bytes, the actual unit of memory that will be locked will be one or more pages.&nbsp; Page locks are maintained
as a count.&nbsp; When the count is decremented to zero, the page is unlocked and can be swapped to disk.&nbsp; This means
that if a region of memory is locked three times then it must be unlocked three times before the pages will be unlocked.
<DL>
<DT>Function 0600H
<DD>This function locks a specified linear address range.&nbsp; Pass the following information:
<DL>
<DT>AX = 0600H
<DD>
<DT>BX:CX = starting linear address of memory to lock
<DD>
<DT>SI:DI = size of region to lock (in bytes)
<DD>
</DL>
<BR>If the call fails, the carry flag is set and none of the memory will be locked.
<BR><BR>If the call succeeds, the carry flag is clear.&nbsp; If the specified region overlaps part of a page at the beginning
or end of a region, the page(s) will be locked.
<DT>Function 0601H
<DD>This function unlocks a specified linear address range that was previously locked using the &quot;lock linear region&quot;
function (0600h).&nbsp; Pass the following information:
<DL>
<DT>AX = 0601H
<DD>
<DT>BX:CX = starting linear address of memory to unlock
<DD>
<DT>SI:DI = size of region to unlock (in bytes)
<DD>
</DL>
<BR>If the call fails, the carry flag is set and none of the memory will be unlocked.&nbsp; An error will be returned if the
memory was not previously locked or if the specified region is invalid.
<BR><BR>If the call succeeds, the carry flag is clear.&nbsp; If the specified region overlaps part of a page at the beginning
or end of a region, the page(s) will be unlocked.&nbsp; Even if the call succeeds, the memory will remain locked if the lock
count is not decremented to zero.
<DT>Function 0604H
<DD>This function gets the page size for Virtual Memory (VM) only.&nbsp; This function returns the size of a single memory page
in bytes.&nbsp; Pass the following information:
<DL>
<DT>AX = 0604H
<DD>
</DL>
<BR>If the call succeeds, the carry flag is clear and BX:CX = Page size in bytes.
<BR><BR>If the call fails, the carry flag is set.
</DL>
<H3 ID="DOSD4GW__Demand_Paging_Performance_Tuning_Services"> DOS/4GW:&nbsp; Demand Paging Performance Tuning Services </H3>
<BR>Some applications will discard memory objects or will not access objects for long periods of time.&nbsp; These services
can be used to improve the performance of demand paging.
<BR><BR>Although these functions are only relevant for DPMI implementations that support virtual memory, other implementations
will ignore these functions (it will always return carry clear).&nbsp; Therefore your code can always call these functions
regardless of the environment it is running under.
<BR><BR>Since both of these functions are simply advisory functions, the operating system may choose to ignore them.&nbsp;
In any case, your code should function properly even if the functions fail.
<DL>
<DT>Function 0702H
<DD>(DOS/4GW Professional only) This function marks a page as a demand paging candidate.&nbsp; This function is used to inform
the operating system that a range of pages should be placed at the head of the page out candidate list.&nbsp; This will force
these pages to be swapped to disk ahead of other pages even if the memory has been accessed recently.&nbsp; However, all memory
contents will be preserved.
<BR><BR>This is useful, for example, if a program knows that a given piece of data will not be accessed for a long period
of time.&nbsp; That data is ideal for swapping to disk since the physical memory it now occupies can be used for other purposes.
&nbsp;Pass the following information:
<DL>
<DT>AX = 0702H
<DD>
<DT>BX:CX = Starting linear address of pages to mark
<DD>
<DT>SI:DI = Number of bytes to mark as paging candidates
<DD>
</DL>
<BR>If the call succeeds, the carry flag is clear; if it fails, the carry flag is set.
<BR><BR><B>Notes:</B>
<OL>
<LI>This function does not force the pages to be swapped to disk immediately.
<LI>Partial pages will not be discarded.
</OL>
<DT>Function 0703H
<DD>(DOS/4GW Professional only) This function discards page contents.&nbsp; This function discards the entire contents of a given
linear memory range.&nbsp; It is used after a memory object that occupied a given piece of memory has been discarded.
<BR><BR>The contents of the region will be undefined the next time the memory is accessed.&nbsp; All values previously stored
in this memory will be lost.&nbsp; Pass the following information:
<DL>
<DT>AX = 0703H
<DD>
<DT>BX:CX = Starting linear address of pages to discard
<DD>
<DT>SI:DI = Number of bytes to discard
<DD>
</DL>
<BR>If the call succeeds, the carry flag is clear; if it fails, the carry flag is set.
<BR><BR><B>Notes:</B>
<OL>
<LI>Partial pages will not be discarded.
</OL>
</DL>
<H3 ID="DOSD4GW__Physical_Address_Mapping"> DOS/4GW:&nbsp; Physical Address Mapping </H3>
<BR>Memory mapped devices such as network adapters and displays sometimes have memory mapped at physical addresses that lie
outside of the normal 1Mb of memory that is addressable in real mode.&nbsp; Under many implementations of DPMI, all addresses
are linear addresses since they use the paging mechanism of the 80386.&nbsp; This service can be used by device drivers to
convert a physical address into a linear address.&nbsp; The linear address can then be used to access the device memory.
<DL>
<DT>Function 0800H
<DD>This function is used for Physical Address Mapping.
<BR><BR>Some implementations of DPMI may not support this call because it could be used to circumvent system protection.&nbsp;
This call should only be used by programs that absolutely require direct access to a memory mapped device.
<BR><BR>Pass the following information:
<DL>
<DT>AX = 0800H
<DD>
<DT>BX:CX = Physical address of memory
<DD>
<DT>SI:DI = Size of region to map in bytes
<DD>
</DL>
<BR>If the call succeeds, the carry flag is clear and BX:CX = Linear Address that can be used to access the physical memory.
<BR><BR>If the call fails, the carry flag is set.
<BR><BR><B>Notes:</B>
<OL>
<LI>Under DPMI implementations that do not use the 80386 paging mechanism, the call will always succeed and the address returned
will be equal to the physical address parameter passed into this function.
<LI>It is up to the caller to build an appropriate selector to access the memory.
<LI>Do not use this service to access memory that is mapped in the first megabyte of address space (the real-mode addressable
region).
</OL>
<DT>Function 0801H
<DD>This function is used to free Physical Address Mapping.&nbsp; Pass the following information:
<DL>
<DT>AX = 0801H
<DD>
<DT>BX:CX = Linear address returned by Function 0800H.
<DD>
</DL>
<BR>If the call succeeds, the carry flag is clear; if it fails, the carry flag is set.
<BR><BR><B>Notes:</B>
<OL>
<LI>The client should call this function when it is finished using a device previously mapped to linear addresses with the
Physical Address Mapping function (Function 0800H).
</OL>
</DL>
<H3 ID="DOSD4GW__Virtual_Interrupt_State_Functions"> DOS/4GW:&nbsp; Virtual Interrupt State Functions </H3>
<BR>Under many implementations of DPMI, the interrupt flag in protected mode will always be set (interrupts enabled).&nbsp;
This is because the program is running under a protected operating system that cannot allow programs to disable physical hardware
interrupts.&nbsp; However, the operating system will maintain a &quot;virtual&quot; interrupt state for protected-mode programs.
&nbsp;When the program executes a CLI instruction, the program's virtual interrupt state will be disabled, and the program
will not receive any hardware interrupts until it executes an STI to reenable interrupts (or calls service 0901h).
<BR><BR>When a protected-mode program executes a PUSHF instruction, the real processor flags will be pushed onto the stack.
&nbsp;Thus, examining the flags pushed on the stack is not sufficient to determine the state of the program's virtual interrupt
flag.&nbsp; These services enable programs to get and modify the state of their virtual interrupt flag.
<BR><BR>The following sample code enters an interrupt critical section and then restores the virtual interrupt state to it's
previous state.
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; ;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; ; Disable interrupts and get previous interrupt state</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; ;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mov&nbsp;&nbsp;&nbsp;&nbsp; ax, 0900h</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int&nbsp;&nbsp;&nbsp;&nbsp; 31h</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; ;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; ; At this point AX = 0900h or 0901h</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; ;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; ;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; ; Restore previous state (assumes AX unchanged)</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; ;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int&nbsp;&nbsp;&nbsp;&nbsp; 31h</TT>
<DL>
<DT>Function 0900H
<DD>This function gets and disables Virtual Interrupt State.&nbsp; This function will disable the virtual interrupt flag and return
the previous state of the virtual interrupt flag.&nbsp; Pass the following information:
<DL>
<DT>AX = 0900H
<DD>
</DL>
<BR>After the call, the carry flag is clear (this function always succeeds) and virtual interrupts are disabled.
<BR><BR>&nbsp;&nbsp;&nbsp;&nbsp; AL = 0 if virtual interrupts were previously disabled.
<BR>&nbsp;&nbsp;&nbsp;&nbsp; AL = 1 if virtual interrupts were previously enabled.
<BR><BR><B>Notes:</B>
<OL>
<LI>AH will not be changed by this procedure.&nbsp; Therefore, to restore the previous state, simply execute an Int 31h.
</OL>
<DT>Function 0901H
<DD>This function gets and enables the Virtual Interrupt State.&nbsp; This function will enable the virtual interrupt flag and
return the previous state of the virtual interrupt flag.&nbsp; Pass the following information:
<DL>
<DT>AX = 0901H
<DD>
</DL>
<BR>After the call, the carry flag is clear (this function always succeeds) and virtual interrupts are enabled.
<BR><BR>&nbsp;&nbsp;&nbsp;&nbsp; AL = 0 if virtual interrupts were previously disabled.
<BR>&nbsp;&nbsp;&nbsp;&nbsp; AL = 1 if virtual interrupts were previously enabled.
<BR><BR><B>Notes:</B>
<OL>
<LI>AH will not be changed by this procedure.&nbsp; Therefore, to restore the previous state, simply execute an Int 31h.
</OL>
<DT>Function 0902H
<DD>This function gets the Virtual Interrupt State.&nbsp; This function will return the current state of the virtual interrupt
flag.&nbsp; Pass the following information:
<DL>
<DT>AX = 0902H
<DD>
</DL>
<BR>After the call, the carry flag is clear (this function always succeeds).
<BR><BR>&nbsp;&nbsp;&nbsp;&nbsp; AL = 0 if virtual interrupts are disabled.
<BR>&nbsp;&nbsp;&nbsp;&nbsp; AL = 1 if virtual interrupts are enabled.
</DL>
<H3 ID="DOSD4GW__Vendor_Specific_Extensions"> DOS/4GW:&nbsp; Vendor Specific Extensions </H3>
<BR>Some DOS extenders provide extensions to the standard set of DPMI calls.&nbsp; This call is used to obtain an address
which must be called to use the extensions.&nbsp; The caller points DS:ESI to a null terminated string that specifies the
vendor name or some other unique identifier to obtain the specific extension entry point.
<DL>
<DT>Function 0A00H
<DD>This function gets Tenberry Software's API Entry Point.&nbsp; Pass the following information:
<DL>
<DT>AX = 0A00H
<DD>
<DT>DS:ESI = Pointer to null terminated string &quot;RATIONAL DOS/4G&quot;
<DD>
</DL>
<BR>If the call succeeds, the carry flag is clear and ES:EDI = Extended API entry point.&nbsp; DS, FS, GS, EAX, EBX, ECX,
EDX, ESI, and EBP may be modified.
<BR><BR>If the call fails, the carry flag is set.
<BR><BR><B>Notes:</B>
<OL>
<LI>Execute a far call to call the API entry point.
<LI>All extended API parameters are specified by the vendor.
<LI>The string comparison used to return the API entry point is case sensitive.
</OL>
</DL>
<H3 ID="DOSD4GW__Coprocessor_Status"> DOS/4GW:&nbsp; Coprocessor Status </H3>
<DL>
<DT>Function 0E00H
<DD>This function gets the coprocessor status.&nbsp; Pass the following information:
<DL>
<DT>AX = 0E00H
<DD>
</DL>
<BR>If the call succeeds, the carry flag is clear and AX contains the coprocessor status.
<DL>
<DT><B><I>Bit</I></B>
<DD><B><I>Significance</I></B>
<DT>0
<DD>MPv (MP bit in the virtual MSW/CR0).
<BR><BR>0 = Numeric coprocessor is disabled for this client.
<BR>1 = Numeric coprocessor is disabled for this client.
<DT>1
<DD>EMv (EM bit in the virtual MSW/CR0).
<BR><BR>0 = Client is not emulating coprocessor instructions.
<BR>1 = Client is emulating coprocessor instructions.
<DT>2
<DD>MPr (MP bit from the actual MSW/CR0).
<BR><BR>0 = Numeric coprocessor is not present.
<BR>1 = Numeric coprocessor is present.
<DT>1
<DD>EMr (EM bit from the actual MSW/CR0).
<BR><BR>0 = Host is not emulating coprocessor instructions.
<BR>1 = Host is emulating coprocessor instructions.
<DT>4-7
<DD>Coprocessor type.
<BR><BR>&nbsp;&nbsp;&nbsp;&nbsp; 00H = no coprocessor.
<BR>&nbsp;&nbsp;&nbsp;&nbsp; 02H = 80287
<BR>&nbsp;&nbsp;&nbsp;&nbsp; 03H = 80387
<BR>&nbsp;&nbsp;&nbsp;&nbsp; 04H = 80486 with numeric coprocessor
<BR>&nbsp;&nbsp;&nbsp;&nbsp; 05H = Pentium
<DT>8-15
<DD>Not applicable.
</DL>
<BR>If the call fails, the carry flag is set.
<BR><BR><B>Notes:</B>
<OL>
<LI>If the real EM (EMr) bit is set, the host is supplying or is capable of supplying floating-point emulation.
<LI>If the MPv bit is not set, the host may not need to save the coprocessor state for this virtual machine to improve system
performance.
<LI>The MPr bit setting should be consistent with the setting of the coprocessor type information.&nbsp; Ignore MPr bit information
if it is in conflict with the coprocessor type information.
<LI>If the virtual EM (EMv) bit is set, the host delivers all coprocessor exceptions to the client, and the client is performing
its own floating-point emulation (wether or not a coprocessor is present or the host also has a floating-point emulator).
&nbsp;In other words, if the EMv bit is set, the host sets the EM bit in the real CR0 while the virtual machine is active,
and reflects coprocessor not present faults (int 7) to the virtual machine.
<LI>A client can determine the CPU type with int 31H Function 0400H, but a client should not draw any conclusions about the
presence or absence of a coprocessor based on the CPU type alone.
</OL>
<DT>Function 0E01H
<DD>This function sets coprocessor emulation.&nbsp; Pass the following information:
<DL>
<DT>AX = 0E01H
<DD>
<DT>BX = coprocessor bits
<DD>
<DL>
<DT><B><I>Bit</I></B>
<DD><B><I>Significance</I></B>
<DT>0
<DD>New value of MPv bit for client's virtual CR0.
<BR><BR>0 = Disable numeric coprocessor for this client.
<BR>1 = Enable numeric coprocessor for this client.
<DT>1
<DD>New value of EMv bit for client's virtual CR0.
<BR><BR>0 = client will not supply coprocessor emulation.
<BR>1 = client will supply coprocessor emulation.
<DT>2-15
<DD>Not applicable.
</DL>
</DL>
<BR>If the call succeeds, the carry flag is clear; if it fails, the carry flag is set.
</DL>
<H1 ID="DOSD4GW__Utilities"> DOS/4GW:&nbsp; Utilities </H1>
<BR>This chapter describes the Tenberry Software<B> DOS/4GW</B> utility programs provided with the Open Watcom C/C++ package.
&nbsp;Each program is described using the following format:
<DL>
<DT>Purpose:
<DD>This is a brief statement of what the utility program does.&nbsp; More specific information is provided under &quot;Notes&quot;.
<DT>Syntax:
<DD>This shows the syntax of the program.&nbsp; The fixed portion of each command is in a<TT> typewriter font,</TT> while variable
parts of the command are in<B> italics.</B>&nbsp; Optional parts are enclosed in [brackets].
<DT>Notes:
<DD>These are explanatory remarks noting major features and possible pitfalls.&nbsp; We explain anything special that you might
need to know about the program.
<DT>See Also:
<DD>This is a cross-reference to any information that is related to the program.
<DT>Example:
<DD>You'll find one or more sample uses of the utility program with an explanation of what the program is doing.
</DL>
<BR>Some of the utilities are<B> DOS/4GW</B>-based, protected-mode programs.&nbsp; To determine which programs run in protected
mode and which in real, run the program.&nbsp; If you see the<B> DOS/4GW</B> banner, the program runs in protected mode.
<H2 ID="DOSD4GW__DOS4GW"> DOS/4GW:&nbsp; DOS4GW </H2>
<DL>
<DT>Purpose:
<DD>Loads and executes linear executables.
<DT>Syntax:
<DD><B> linear_executable</B>
<DT>Notes:
<DD>The stub program at the beginning of the linear executable invokes this program, which loads the linear executable and starts
up the DOS extender.&nbsp; The stub program must be able to find DOS4GW:&nbsp; make sure it is in the path.
</DL>
<H2 ID="DOSD4GW__PMINFO"> DOS/4GW:&nbsp; PMINFO </H2>
<DL>
<DT>Purpose:
<DD>Measures the performance of protected/real-mode switching and extended memory.
<DT>Syntax:
<DD><TT> PMINFO.EXE</TT>
<DT>Notes:
<DD>We encourage you to distribute this program to your users.
<BR><BR>The time-based measurements made by PMINFO may vary slightly from run to run.
<DT>Example:
<DD>The following example shows the output of the PMINFO program on a 386 AT-compatible machine.
<HR>
<BR><TT>&nbsp;&nbsp; C&gt;pminfo</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Protected Mode and Extended Memory Performance Measurement -- 5.00</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Copyright (c) Tenberry
Software, Inc. 1987 - 1993</TT>
<BR><BR><TT>&nbsp;&nbsp; DOS memory&nbsp;&nbsp; Extended memory&nbsp;&nbsp; CPU performance equivalent to 67.0 MHz 80486</TT>
<BR><TT>&nbsp;&nbsp; ----------&nbsp;&nbsp; ---------------</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 736&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp; 8012&nbsp;&nbsp; K bytes configured (according to BIOS).</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 640&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp; 15360&nbsp;&nbsp; K bytes physically present (SETUP).</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 651&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp; 7887&nbsp;&nbsp; K bytes available for DOS/16M programs.</TT>
<BR><TT>&nbsp;&nbsp; 22.0 (3.0)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 18.9 (4.0)&nbsp;&nbsp; MB/sec word transfer rate
(wait states).</TT>
<BR><TT>&nbsp;&nbsp; 42.9 (3.0)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 37.0 (4.0)&nbsp;&nbsp; MB/sec 32-bit transfer rate
(wait states).</TT>
<BR><BR><TT>&nbsp;&nbsp; Overall cpu and memory performance (non-floating point) for typical</TT>
<BR><TT>&nbsp;&nbsp; DOS programs is 10.36  1.04 times an 8MHz IBM PC/AT.</TT>
<BR><BR><TT>&nbsp;&nbsp; Protected/Real switch rate = 36156/sec (27 usec/switch, 15 up + 11 down),</TT>
<BR><TT>&nbsp;&nbsp; DOS/16M switch mode 11 (VCPI).</TT>
<HR>
<BR>The top information line shows that the CPU performance is equivalent to a 67.0 MHz 80486.&nbsp; Below are the configuration
and timings for both the DOS memory and extended memory.&nbsp; If the computer is not equipped with extended memory, or none
is available for<B> DOS/4GW</B>, the extended memory measurements may be omitted (&quot;--&quot;).
<BR><BR>The line &quot;according to BIOS&quot; shows the information provided by the BIOS (interrupts 12h and 15h function
88h).&nbsp; The line &quot;SETUP&quot;, if displayed, is the configuration obtained directly from the CMOS RAM as set by the
computer's setup program.&nbsp; It is displayed only if the numbers are different from those in the BIOS line.&nbsp; They
will be different for computers where the BIOS has reserved memory for itself or if another program has allocated some memory
and is intercepting the BIOS configuration requests to report less memory available than is physically configured.&nbsp; The
&quot;DOS/16M memory range&quot;, if displayed, shows the low and high addresses available to<B> DOS/4GW</B> in extended memory.
<BR><BR>Below the configuration information is information on the memory speed<B> (transfer rate).</B>&nbsp; PMINFO tries
to determine the memory architecture.&nbsp; Some architectures will perform well under some circumstances and poorly under
others; PMINFO will show both the best and worst cases.&nbsp; The architectures detected are cache, interleaved, page-mode
(or static column), and direct.&nbsp; Measurements are made using 32-bit accesses and reported as the number of megabytes
per second that can be transferred.&nbsp; The number of wait states is reported in parentheses.&nbsp; The wait states can
be a fractional number, like 0.5, if there is a wait state on writes but not on reads.&nbsp; Memory bandwidth (i.e., how fast
the CPU can access memory) accounts for 60% to 70% of the performance for typical programs (that are not heavily dependent
on floating-point math).
<BR><BR>A performance metric developed by Tenberry Software is displayed, showing the expected throughput for the computer
relative to a standard 8MHz IBM PC/AT (disk accesses and floating point are excluded).&nbsp; Finally, the speed with which
the computer can switch between real and protected mode is displayed, both as the maximum number of round-trip switches that
can occur per second, and the time for a single round-trip switch, broken out into the real-to-protected (up) and protected-to-real
(down) components.
</DL>
<H2 ID="DOSD4GW__PRIVATXM"> DOS/4GW:&nbsp; PRIVATXM </H2>
<DL>
<DT>Purpose:
<DD>Creates a private pool of memory for<B> DOS/4GW</B> programs.
<DT>Syntax:
<DD><TT> PRIVATXM [-r]</TT>
<DT>Notes:
<DD>This program may be distributed to your users.
<BR><BR>Without PRIVATXM, a<B> DOS/4GW</B> program that starts up while another<B> DOS/4GW</B> program is active uses the
pool of memory built by the first program.&nbsp; The new program cannot change the parameters of this memory pool, so setting<B>
DOS16M</B> to increase the size of the pool has no effect.&nbsp; To specify that the two programs use different pools of memory,
use PRIVATXM.
<BR><BR>PRIVATXM marks the active<B> DOS/4GW</B> programs as private, preventing subsequent<B> DOS/4GW</B> programs from using
the same memory pool.&nbsp; The first<B> DOS/4GW</B> program to start after PRIVATXM sets up a new pool of memory for itself
and any subsequent<B> DOS/4GW</B> programs.&nbsp; To release the memory used by the private programs, use the PRIVATXM<TT>
-r</TT> option.
<BR><BR>PRIVATXM is a TSR that requires less than 500 bytes of memory.&nbsp; It is not supported under DPMI.
<DT>Example:
<DD>The following example creates a 512KB memory pool that is shared by two<B> DOS/4GW</B> TSRs.&nbsp; Subsequent<B> DOS/4GW</B>
programs use a different memory pool.
<DL>
<DT>C&gt;set DOS16M= :512
<DD>Specifies the size of the memory pool.
<DT>C&gt;TSR1
<DD>Sets up the memory pool at startup.
<DT>C&gt;TSR2
<DD>This TSR shares the pool built by TSR1.
<DT>C&gt;PRIVATXM
<DD>Makes subsequent<B> DOS/4GW</B> programs use a new memory pool.
<DT>C&gt;set DOS16M=
<DD>Specifies an unlimited size for the new pool.
<DT>C&gt;PROGRAM3
<DD>This program uses the new memory pool.
<DT>C&gt;PRIVATXM -R
<DD>Releases the 512KB memory pool used by the TSRs.&nbsp; (If the TSRs shut down, their memory is not released unless PRIVATXM
is released.)
</DL>
</DL>
<H2 ID="DOSD4GW__RMINFO"> DOS/4GW:&nbsp; RMINFO </H2>
<DL>
<DT>Purpose:
<DD>Supplies configuration information and the basis for real/protected-mode switching in your machine.
<DT>Syntax:
<DD><TT> RMINFO.EXE</TT>
<DT>Notes:
<DD>This program may be distributed to your users.
<BR><BR>RMINFO starts up<B> DOS/4GW</B>, but stops your machine just short of switching from real mode to protected mode and
displays configuration information about your computer.&nbsp; The information shown by RMINFO can help determine why<B> DOS/4GW</B>
applications won't run on a particular machine.&nbsp; Run RMINFO if PMINFO does not run to completion.
<DT>Example:
<DD>The following example shows the output of the RMINFO program on an 386 AT-compatible machine.
<HR>
<BR><TT>&nbsp;&nbsp; C&gt;rminfo</TT>
<BR><BR><TT>&nbsp;&nbsp; DOS/16M Real Mode Information Program 5.00</TT>
<BR><TT>&nbsp;&nbsp; Copyright (C) Tenberry Software, Inc. 1987 - 1993</TT>
<BR><BR><TT>&nbsp;&nbsp; Machine and Environment:</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Processor:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; i386, coprocessor present</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Machine type:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp; 10 (AT-compatible)</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; A20 now:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; enabled</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; A20 switch rigor:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
disabled</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DPMI host found</TT>
<BR><TT>&nbsp;&nbsp; Switching Functions:</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; To PM switch:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp; DPMI</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; To RM switch:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp; DPMI</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Nominal switch mode:&nbsp;&nbsp;&nbsp; 0</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Switch control flags:&nbsp;&nbsp; 0000</TT>
<BR><TT>&nbsp;&nbsp; Memory Interfaces:</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DPMI may provide:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
16384K returnable</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Contiguous DOS memory:&nbsp; 463K</TT>
<HR>
<BR>The information provided by RMINFO includes:
<DL>
<DT>Machine and Environment:
<DD>
<DT>Processor:
<DD>processor type, coprocessor present/not present
<DT>Machine type:
<DD>
<BR><BR>&nbsp;&nbsp;&nbsp;&nbsp; (NEC 9801)
<BR>&nbsp;&nbsp;&nbsp;&nbsp; (PS/2-compatible)
<BR>&nbsp;&nbsp;&nbsp;&nbsp; (AT-compatible)
<BR>&nbsp;&nbsp;&nbsp;&nbsp; (FM R)
<BR>&nbsp;&nbsp;&nbsp;&nbsp; (AT&amp;T 6300+)
<BR>&nbsp;&nbsp;&nbsp;&nbsp; (AT-compatible)
<BR>&nbsp;&nbsp;&nbsp;&nbsp; (C&amp;T 230 chipset)
<BR>&nbsp;&nbsp;&nbsp;&nbsp; (AT-compatible)
<BR>&nbsp;&nbsp;&nbsp;&nbsp; (AT-compatible)
<BR>&nbsp;&nbsp;&nbsp;&nbsp; (Acer)
<BR>&nbsp;&nbsp;&nbsp;&nbsp; (Zenith)
<BR>&nbsp;&nbsp;&nbsp;&nbsp; (Hitachi)
<BR>&nbsp;&nbsp;&nbsp;&nbsp; (Okidata)
<BR>&nbsp;&nbsp;&nbsp;&nbsp; (PS/55)
<DT>A20 now:
<DD>Current state of Address line 20.
<DT>A20 switch rigor:
<DD>Whether DOS4GW rigorously controls enabling and disabling of Address line 20 when switching modes.
<DT>PS feature flag
<DD>
<DT>XMS host found
<DD>Whether your system has any software using extended memory under the XMS discipline.
<DT>VCPI host found
<DD>Whether your system has any software using extended memory under the VCPI discipline.
<DT>page table 0 at:&nbsp; x000h
<DD>
<DT>DPMI host found
<DD>
<DT>DOS/16M resident with private/public memory
<DD>
</DL>
<DL>
<DT>Switching Functions:
<DD>
<DT>A20 switching:
<DD>
<DT>To PM switch:
<DD>reset catch:
<BR><BR>pre-PM prep:
<BR>post-PM-switch:
<DT>To RM switch:
<DD>
<BR><BR>pre-RM prep:
<BR>reset method:
<BR>post-reset:
<BR>reset uncatch:
<DT>Nominal switch mode:&nbsp; x
<DD>
<DT>Switch control flags:&nbsp; xxxxh
<DD>
</DL>
<DL>
<DT>Memory Interfaces:
<DD>
<DT>(VCPI remapping in effect)
<DD>
<DT>DPMI may provide:&nbsp; xxxxxK returnable
<DD>
<DT>VCPI may provide:&nbsp; xxxxxK returnable
<DD>
<DT>Top-down
<DD>
<DT>Other16M
<DD>
<DT>Forced
<DD>
<DT>Contiguous DOS memory:
<DD>
</DL>
</DL>
<H1 ID="DOSD4GW__Error_Messages"> DOS/4GW:&nbsp; Error Messages </H1>
<BR>The following lists DOS/4G error messages, with descriptions of the circumstances in which the error is most likely to
occur, and suggestions for remedying the problem.&nbsp; Some error messages pertaining to features - like DLLs - that are
not supported in<B> DOS/4GW</B> will not arise with that product.&nbsp; In the following descriptions, references to DOS/4G,
DOS4G, or DOS4G.EXE may be replaced by DOS/4GW, DOS4GW, or DOS4GW.EXE should the error message arise when using<B> DOS/4GW</B>.
<H2 ID="DOSD4GW__Kernel_Error_Messages"> DOS/4GW:&nbsp; Kernel Error Messages </H2>
<BR>This section describes error messages from the DOS/16M kernel embedded in DOS/4G.&nbsp; Kernel error messages may occur
because of severe resource shortages, corruption of DOS4GW.EXE, corruption of memory, operating system incompatibilities,
or internal errors in DOS/4GW.&nbsp; All of these messages are quite rare.
<DL>
<DT>0.&nbsp; involuntary switch to real mode
<DD>
<BR><BR>The computer was in protected mode but switched to real mode without going through DOS/16M.&nbsp; This error most
often occurs because of an unrecoverable stack segment exception (stack overflow), but can also occur if the Global Descriptor
Table or Interrupt Descriptor Table is corrupted.&nbsp; Increase the stack size, recompile your program with stack overflow
checking, or look into ways that the descriptor tables may have been overwritten.
<DT>1.&nbsp; not enough extended memory
<DD>
<DT>2.&nbsp; not a DOS/16M executable &lt;filename&gt;
<DD>
<BR><BR>DOS4G.EXE, or a bound DOS/4G application, has probably been corrupted in some way.&nbsp; Rebuild or recopy the file.
<DT>3.&nbsp; no DOS memory for transparent segment
<DD>
<DT>4.&nbsp; cannot make transparent segment
<DD>
<DT>5.&nbsp; too many transparent segments
<DD>
<DT>6.&nbsp; not enough memory to load program
<DD>
<BR><BR>There is not enough memory to load DOS/4G.&nbsp; Make more memory available and try again.
<DT>7.&nbsp; no relocation segment
<DD>
<DT>8.&nbsp; cannot open file &lt;filename&gt;
<DD>
<BR><BR>The DOS/16M loader cannot load DOS/4G, probably because DOS has run out of file units.&nbsp; Set a larger FILES= entry
in CONFIG.SYS, reboot, and try again.
<DT>9.&nbsp; cannot allocate tstack
<DD>
<BR><BR>There is not enough memory to load DOS/4G.&nbsp; Make more memory available and try again.
<DT>10.&nbsp; cannot allocate memory for GDT
<DD>
<BR><BR>There is not enough memory to load DOS/4G.&nbsp; Make more memory available and try again.
<DT>11.&nbsp; no passup stack selectors -- GDT too small
<DD>
<BR><BR>This error indicates an internal error in DOS/4G or an incompatibility with other software.
<DT>12.&nbsp; no control program selectors -- GDT too small
<DD>
<BR><BR>This error indicates an internal error in DOS/4G or an incompatibility with other software.
<DT>13.&nbsp; cannot allocate transfer buffer
<DD>
<BR><BR>There is not enough memory to load DOS/4G.&nbsp; Make more memory available and try again.
<DT>14.&nbsp; premature EOF
<DD>
<BR><BR>DOS4G.EXE, or a bound DOS/4G application, has probably been corrupted in some way.&nbsp; Rebuild or recopy the file.
<DT>15.&nbsp; protected mode available only with 386 or 486
<DD>
<BR><BR>DOS/4G requires an 80386 (or later) CPU.&nbsp; It cannot run on an 80286 or earlier CPU.
<DT>16.&nbsp; cannot run under OS/2
<DD>
<DT>17.&nbsp; system software does not follow VCPI or DPMI specifications
<DD>
<BR><BR>Some memory resident program has put your 386 or 486 CPU into Virtual 8086 mode.&nbsp; This is done to provide special
memory services to DOS programs, such as EMS simulation (EMS interface without EMS hardware) or high memory.&nbsp; In this
mode, it is not possible to switch into protected mode unless the resident software follows a standard that DOS/16M supports
(DPMI, VCPI, and XMS are the most common).&nbsp; Contact the vendor of your memory management software.
<DT>18.&nbsp; you must specify an extended memory range (SET DOS16M= )
<DD>
<BR><BR>On some Japanese machines that are not IBM AT-compatible, and have no protocol for managing extended memory, you must
set the DOS16M environment variable to specify the range of available extended memory.
<DT>19.&nbsp; computer must be AT- or PS/2- compatible
<DD>
<DT>20.&nbsp; unsupported DOS16M switchmode choice
<DD>
<DT>21.&nbsp; requires DOS 3.0 or later
<DD>
<DT>22.&nbsp; cannot free memory
<DD>
<BR><BR>This error probably indicates that memory was corrupted during execution of your program.
<DT>23.&nbsp; no memory for VCPI page table
<DD>
<BR><BR>There is not enough memory to load DOS/4G.&nbsp; Make more memory available and try again.
<DT>24.&nbsp; VCPI page table address incorrect
<DD>
<BR><BR>This is an internal error.
<DT>25.&nbsp; cannot initialize VCPI
<DD>
<BR><BR>This error indicates an incompatibility with other software.&nbsp; DOS/16M has detected that VCPI is present, but
VCPI returns an error when DOS/16M tries to initialize the interface.
<DT>26.&nbsp; 8042 timeout
<DD>
<DT>27.&nbsp; extended memory is configured but it cannot be allocated
<DD>
<DT>28.&nbsp; memory error, avail loop
<DD>
<BR><BR>This error probably indicates that memory was corrupted during execution of your program.&nbsp; Using an invalid or
stale alias selector may cause this error.&nbsp; Incorrect manipulation of segment descriptors may also cause it.
<DT>29.&nbsp; memory error, out of range
<DD>
<BR><BR>This error probably indicates that memory was corrupted during execution of your program.&nbsp; Writing through an
invalid or stale alias selector may cause this error.
<DT>30.&nbsp; program must be built -AUTO for DPMI
<DD>
<DT>31.&nbsp; protected mode already in use in this DPMI virtual machine
<DD>
<DT>32.&nbsp; DPMI host error (possibly insufficient memory)
<DD>
<DT>33.&nbsp; DPMI host error (need 64K XMS)
<DD>
<DT>34.&nbsp; DPMI host error (cannot lock stack)
<DD>
<BR><BR>Any of these errors (32, 33, 34) probably indicate insufficient memory under DPMI.&nbsp; Under Windows, you might
try making more physical memory available by eliminating or reducing any RAM drives or disk caches.&nbsp; You might also try
editing DEFAULT.PIF so that at least 64KB of XMS memory is available to non-Windows programs.&nbsp; Under OS/2, you want to
increase the DPMI_MEMORY_LIMIT in the DOS box settings.
<DT>35.&nbsp; General Protection Fault
<DD>
<BR><BR>This message probably indicates an internal error in DOS/4G.&nbsp; Faults generated by your program should cause error
2001 instead.
<DT>36.&nbsp; The DOS16M.386 virtual device driver was never loaded
<DD>
<DT>37.&nbsp; Unable to reserve selectors for DOS16M.386 Windows driver
<DD>
<DT>38.&nbsp; Cannot use extended memory:&nbsp; HIMEM.SYS not version 2
<DD>
<BR><BR>This error indicates an incompatibility with an old version of HIMEM.SYS.
<DT>39.&nbsp; An obsolete version of DOS16M.386 was loaded
<DD>
<DT>40.&nbsp; not enough available extended memory (XMIN)
<DD>
<BR><BR>This message probably indicates an incompatibility with your memory manager or its configuration.&nbsp; Try configuring
the memory manager to provide more extended memory, or change memory managers.
</DL>
<H2 ID="DOSD4GW__DOSD4G_Errors"> DOS/4GW:&nbsp; DOS/4G Errors </H2>
<DL>
<DT>1000 &quot;can't hook interrupts&quot;
<DD>
<BR><BR>A DPMI host has prevented DOS/4G from loading.&nbsp; Please contact Tenberry Technical Support.
<DT>1001 &quot;error in interrupt chain&quot;
<DD>
<BR><BR>DOS/4G internal error.&nbsp; Please contact Tenberry Technical Support.
<DT>1003 &quot;can't lock extender kernel in memory&quot;
<DD>
<BR><BR>DOS/4G couldn't lock the kernel in physical memory, probably because of a memory shortage.
<DT>1004 &quot;syntax is DOS4G &lt;executable.xxx&gt;&quot;
<DD>
<BR><BR>You must specify a program name.
<DT>1005 &quot;not enough memory for dispatcher data&quot;
<DD>
<BR><BR>There is not enough memory for DOS/4G to manage user-installed interrupt handlers properly.&nbsp; Free some memory
for the DOS/4G application.
<DT>1007 &quot;can't find file &lt;program&gt; to load&quot;
<DD>
<BR><BR>DOS/4G could not open the specified program.&nbsp; Probably the file didn't exist.&nbsp; It is possible that DOS ran
out of file handles, or that a network or similar utility has prohibited read access to the program.&nbsp; Make sure that
the file name was spelled correctly.
<DT>1008 &quot;can't load executable format for file &lt;filename&gt; [&lt;error code&gt;]&quot;
<DD>
<BR><BR>DOS/4G did not recognize the specified file as a valid executable file.&nbsp; DOS/4G can load linear executables (LE
and LX) and EXPs (BW).&nbsp; The error code is for Tenberry Software's use.
<DT>1009 &quot;program &lt;filename&gt; is not bound&quot;
<DD>
<BR><BR>This message does not occur in DOS/4G, only DOS/4GW Professional; the latter requires that the DOS extender be bound
to the program file.&nbsp; The error signals an attempt to load
<DT>1010 &quot;can't initialize loader &lt;loader&gt; [&lt;error code&gt;]&quot;
<DD>
<BR><BR>DOS/4G could not initialize the named loader, probably because of a resource shortage.&nbsp; Try making more memory
available.&nbsp; If that doesn't work, please contact Tenberry Technical Support.&nbsp; The error code is for Tenberry Software'
use.
<DT>1011 &quot;VMM initialization error [&lt;error code&gt;]&quot;
<DD>
<BR><BR>DOS/4G could not initialize the Virtual Memory Manager, probably because of a resource shortage.&nbsp; Try making
more memory available.&nbsp; If that doesn't work, please contact Tenberry Technical Support.&nbsp; The error code is for
Tenberry Software' use.
<DT>1012 &quot;&lt;filename&gt; is not a WATCOM program&quot;
<DD>
<BR><BR>This message does not occur in DOS/4G, only DOS/4GW and DOS/4GW Professional.&nbsp; Those extenders only support WATCOM
32-bit compilers.
<DT>1013 &quot;int 31h initialization error&quot;
<DD>
<BR><BR>DOS/4G was unable to initialize the code that handles Interrupt 31h, probably because of an internal error.&nbsp;
Please call Tenberry Technical Support.
<DT>1100 &quot;assertion \&quot;&lt;statement&gt;\&quot; failed (&lt;file&gt;:&lt;line&gt;)&quot;
<DD>
<BR><BR>DOS/4G internal error.&nbsp; Please contact Tenberry Technical Support.
<DT>1200 &quot;invalid EXP executable format&quot;
<DD>
<BR><BR>DOS/4G tried to load an EXP, but couldn't.&nbsp; The executable file is probably corrupted.
<DT>1201 &quot;program must be built -AUTO for DPMI&quot;
<DD>
<BR><BR>Under DPMI, DOS/4G can only load EXPs that have been linked with the GLU -AUTO or -DPMI switch.
<DT>1202 &quot;can't allocate memory for GDT&quot;
<DD>
<BR><BR>There is not enough memory available for DOS/4G to build a Global Descriptor Table.&nbsp; Make more memory available.
<DT>1203 &quot;premature EOF&quot;
<DD>
<BR><BR>DOS/4G tried to load an EXP but couldn't.&nbsp; The file is probably corrupted.
<DT>1204 &quot;not enough memory to load program&quot;
<DD>
<BR><BR>There is not enough memory available for DOS/4G to load your program.&nbsp; Make more memory available.
<DT>1301 &quot;invalid linear executable format&quot;
<DD>
<BR><BR>DOS/4G cannot recognize the program file as a LINEXE format.&nbsp; Make sure that you specified the correct file name.
<DT>1304 &quot;file I/O seek error&quot;
<DD>
<BR><BR>DOS/4G was unable to seek to a file location that should exist.&nbsp; This usually indicates truncated program files
or problems with the storage device from which your program loads.&nbsp; Run CHKDSK or a similar utility to begin determining
possible causes.
<DT>1305 &quot;file I/O read error&quot;
<DD>
<BR><BR>DOS/4G was unable to read a file location that should contain program data.&nbsp; This usually indicates truncated
program files or problems with the storage device from which your program loads.&nbsp; Run CHKDSK or a similar utility to
begin determining possible causes.
<DT>1307 &quot;not enough memory&quot;
<DD>
<BR><BR>As it attempted to load your program, DOS/4G ran out of memory.&nbsp; Make more memory available, or enable VMM.
<DT>1308 &quot;can't load requested program&quot;
<DD>
<DT>1309 &quot;can't load requested program&quot;
<DD>
<DT>1311 &quot;can't load requested program&quot;
<DD>
<DT>1312 &quot;can't load requested program&quot;
<DD>
<BR><BR>DOS/4G cannot load your program for some reason.&nbsp; Contact Tenberry Technical Support.
<DT>1313 &quot;can't resolve external references&quot;
<DD>
<BR><BR>DOS/4G was unable to resolve all references to DLLs for the requested program, or the program contained unsupported
fixup types.&nbsp; Use EXEHDR or a similar LINEXE dump utility to see what references your program makes and what special
fixup records might be present.
<DT>1314 &quot;not enough lockable memory&quot;
<DD>
<BR><BR>As it attempted to load your program, DOS/4G encountered a refusal to lock a virtual memory region.&nbsp; Some memory
must be locked in order to handle demand-load page faults.&nbsp; Make more physical memory available.
<DT>1315 &quot;can't load requested program&quot;
<DD>
<DT>1316 &quot;can't load requested program&quot;
<DD>
<BR><BR>DOS/4G cannot load your program for some reason.&nbsp; Contact Tenberry Technical Support.
<DT>1317 &quot;program has no stack&quot;
<DD>
<BR><BR>DOS/4G reports this error when you try to run a program with no stack.&nbsp; Rebuild your program, building in a stack.
<DT>2000 &quot;deinitializing twice&quot;
<DD>
<BR><BR>DOS/4G internal error.&nbsp; Please contact Tenberry Technical Support.
<DT>2001 &quot;exception &lt;exception_number&gt; (&lt;exception_description&gt;) at
<DD>&lt;selector:offset&gt;&quot;
<BR><BR>Your program has generated an exception.&nbsp; For information about interpreting this message, see the file COMMON.DOC.
<DT>2002 &quot;transfer stack overflow at &lt;selector:offset&gt;&quot;
<DD>
<BR><BR>Your program has overflowed the DOS/4G transfer stack.&nbsp; For information about interpreting this message, see
the file COMMON.DOC.
<DT>2300 &quot; can't find &lt;DLL&gt;.&lt;ordinal&gt; - referenced from &lt;module&gt;&quot;
<DD>
<BR><BR>DOS/4G could not find the ordinal listed in the specified DLL, or it could not find the DLL at all.&nbsp; Correct
or remove the reference, and make sure that DOS/4G can find the DLL.
<BR><BR>DOS/4G looks for DLLs in the following directories:
<UL>
<LI>The directory specified by the Libpath32 configuration option (which defaults to the directory of the main application
file).
<LI>The directory or directories specified by the LIBPATH32 environment variable.
<LI>Directories specified in the PATH.
</UL>
<DT>2301 &quot;can't find &lt;DLL&gt;.&lt;name&gt; - referenced from &lt;module&gt;&quot;
<DD>
<BR><BR>DOS/4G could not find the entry point named in the specified module.&nbsp; Correct or remove the reference, and make
sure that DOS/4G can find the DLL.
<DT>2302 &quot;DLL modules not supported&quot;
<DD>
<BR><BR>This DOS/4GW Professional error message arises when an application references or tries to explicitly load a DLL.&nbsp;
DOS/4GW Professional does not support DLLs.
<DT>2303 &quot;internal LINEXE object limit reached&quot;
<DD>
<BR><BR>DOS/4G currently handles a maximum of 128 LINEXE objects, including all .DLL and .EXE files.&nbsp; Most .EXE or .DLL
files use only three or four objects.&nbsp; If possible, reduce the number of objects, or contact Tenberry Technical Support.
<DT>2500 &quot;can't connect to extender kernel&quot;
<DD>
<BR><BR>DOS/4G internal error.&nbsp; Please contact Tenberry Technical Support.
<DT>2503 &quot;not enough disk space for swapping - &lt;count&gt; byes required&quot;
<DD>
<BR><BR>VMM was unable to create a swap file of the required size.&nbsp; Increase the amount of disk space available.
<DT>2504 &quot;can't create swap file \&lt;filename&gt;\&quot;&quot;
<DD>
<BR><BR>VMM was unable to create the swap file.&nbsp; This could be because the swap file is specified for a nonexistent drive
or on a drive that is read-only.&nbsp; Set the SWAPNAME parameter to change the location of the swap file.
<DT>2505 &quot;not enough memory for &lt;table&gt;&quot;
<DD>
<BR><BR>VMM was unable to get sufficient extended memory for internal tables.&nbsp; Make more memory available.&nbsp; If &lt;table&gt;
is page buffer, make more DOS memory available.
<DT>2506 &quot;not enough physical memory (minmem)&quot;
<DD>
<BR><BR>There is less physical memory available than the amount specified by the MINMEM parameter.&nbsp; Make more memory
available.
<DT>2511 &quot;swap out error [&lt;error code&gt;]&quot;
<DD>
<BR><BR>Unknown disk error.&nbsp; The error code is for Tenberry Software' use.
<DT>2512 &quot;swap in error [&lt;error code&gt;]&quot;
<DD>
<BR><BR>Unknown disk error.&nbsp; The error code is for Tenberry Software' use.
<DT>2514 &quot;can't open trace file&quot;
<DD>
<BR><BR>VMM could not open the VMM.TRC file in the current directory for writing.&nbsp; If the directory already has a VMM.TRC
file, delete it.&nbsp; If not, there may not be enough memory on the drive for the trace file, or DOS may not have any more
file handles.
<DT>2520 &quot;can't hook int 31h&quot;
<DD>
<BR><BR>DOS/4G internal error.&nbsp; Please contact Tenberry Technical Support.
<DT>2523 &quot;page fault on non-present mapped page&quot;
<DD>
<BR><BR>Your program references memory that has been mapped to a nonexistent physical device, using DPMI function 508h.&nbsp;
Make sure the device is present, or remove the reference.
<DT>2524 &quot;page fault on uncommitted page&quot;
<DD>
<BR><BR>Your program references memory reserved with a call to DPMI function
<DT>504h, but never committed (using a DPMI 507h or 508h call).&nbsp; Commit
<DD>the memory before you reference it.
<DT>3301 &quot;unhandled EMPTYFWD, GATE16, or unknown relocation&quot;
<DD>
<DT>3302 &quot;unhandled ALIAS16 reference to unaliased object&quot;
<DD>
<DT>3304 &quot;unhandled or unknown relocation&quot;
<DD>
<BR><BR>If your program was built for another platform that supports the LINEXE format, it may contain a construct that DOS/4G
does not currently support, such as a call gate.&nbsp; This message may also occur if your program has a problem mixing 16-
and 32-bit code.&nbsp; A linker error is another likely cause.
</DL>
<H1 ID="DOSD4GW__DOSD4GW_Commonly_Asked_Questions"> DOS/4GW:&nbsp; DOS/4GW Commonly Asked Questions </H1>
<BR>The following information has been provided by Tenberry Software, Inc.&nbsp; for their DOS/4GW and DOS/4GW Professional
product.&nbsp; The content of this chapter has been edited by Open Watcom.&nbsp; In most cases, the information is applicable
to both products.
<BR><BR>This chapter covers the following topics:
<UL>
<LI>Access to technical support
<LI>Differences within the DOS/4G product line
<LI>Addressing
<LI>Interrupt and exception handling
<LI>Memory management
<LI>DOS, BIOS, and mouse services
<LI>Virtual memory
<LI>Debugging
<LI>Compatibility
</UL>
<H2 ID="DOSD4GW__Access_to_Technical_Support"> DOS/4GW:&nbsp; Access to Technical Support </H2>
<DL>
<DT>1a.&nbsp; How to reach technical support.
<DD>
<BR><BR>Here are the various ways you may contact Tenberry Software for technical support.
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; WWW:&nbsp;&nbsp;&nbsp; http://www.tenberry.com/dos4g/</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Email:&nbsp; 4gwhelp@tenberry.com</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Phone:&nbsp; 1.480.767.8868</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Fax:&nbsp;&nbsp;&nbsp; 1.480.767.8709</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Mail:&nbsp;&nbsp; Tenberry Software, Inc.</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; PO Box 20050</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Fountain Hills, Arizona</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; U.S.A&nbsp; 85269-0050</TT>
<BR><BR><B><I>PLEASE GIVE YOUR SERIAL NUMBER WHEN YOU CONTACT TENBERRY.</I></B>
<DT>1b.&nbsp; When to contact Open Watcom, when to contact Tenberry.
<DD>
<BR><BR>Since DOS/4GW Professional is intended to be completely compatible with DOS/4GW, you may wish to ascertain whether
your program works properly under DOS/4GW before contacting Tenberry Software for technical support.&nbsp; (This is likely
to be the second question we ask you, after your serial number.)
<BR><BR>If your program fails under both DOS/4GW and DOS/4GW Professional, and you suspect your own code or a problem compiling
or linking, you may wish to contact Open Watcom first.&nbsp; Tenberry Software support personnel are not able to help you
with most programming questions, or questions about using the Open Watcom tools.
<BR><BR>If your program only fails with DOS/4GW Professional, you have probably found a bug in DOS/4GW Professional, so please
contact us right away.
<DT>1c.&nbsp; Telephone support.
<DD>
<BR><BR>Tenberry Software's hours for telephone support are 9am-6pm EST.&nbsp; Please note that telephone support is free
for the first 30 days only.&nbsp; A one-year contract for continuing telephone support on DOS/4GW Professional is US$500 per
developer, including an update subscription for one year, to customers in the United States and Canada; for overseas customers,
the price is $600.&nbsp; Site licenses may be negotiated.
<BR><BR>There is no time limit on free support by fax, mail, or electronic means.
<DT>1d.&nbsp; References.
<DD>
<BR><BR>The DOS/4GW documentation from Open Watcom is the primary reference for DOS/4GW Professional as well.&nbsp; Another
useful reference is the DPMI specification.&nbsp; In the past, the DPMI specification could be obtained free of charge by
contacting Intel Literature.&nbsp; We have been advised that the DPMI specification is no longer available in printed form.
<BR><BR>However, the DPMI 1.0 specification can be obtained at:
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; http://www.delorie.com/djgpp/doc/dpmi/</TT>
<BR><BR>Online HTML as well as a downloadable archive are provided.
</DL>
<H2 ID="DOSD4GW__Differences_Within_the_DOSD4G_Product_Line"> DOS/4GW:&nbsp; Differences Within the DOS/4G Product Line </H2>
<DL>
<DT>2a.&nbsp; DOS/4GW Professional versus DOS/4GW
<DD>
<BR><BR>DOS/4GW Professional was designed to be a higher-performance version of DOS/4GW suitable for commercial applications.
&nbsp;Here is a summary of the advantages of DOS/4GW Professional with respect to DOS/4GW:
<UL>
<LI>Extender binds to the application program file
<LI>Extender startup time has been reduced
<LI>Support for Open Watcom floating-point emulator has been optimized
<LI>Virtual memory manager performance has been greatly improved
<LI>Under VMM, programs are demand loaded
<LI>Virtual address space is 4 GB instead of 32 MB
<LI>Extender memory requirements have been reduced by more than 50K
<LI>Extender disk space requirements have been reduced by 40K
<LI>Can omit virtual memory manager to save 50K more disk space
<LI>Support for INT 31h functions 301h-304h and 702h-703h
</UL>
<BR>DOS/4GW Professional is intended to be fully compatible with programs written for DOS/4GW 1.9 and up.&nbsp; The only functional
difference is that the extender is bound to your program instead of residing in a separate file.&nbsp; Not only does this
help reduce startup time, but it eliminates version-control problems when someone has both DOS/4GW and DOS/4GW Professional
applications present on one machine.
<DT>2b.&nbsp; DOS/4GW Professional versus DOS/4G.
<DD>
<BR><BR>DOS/4GW Professional is not intended to provide any other new DOS extender functionality.&nbsp; Tenberry Software's
top-of-the-line 32-bit extender, DOS/4G, is not sold on a retail basis but is of special interest to developers who require
more flexibility (such as OEMs).&nbsp; DOS/4G offers these additional features beyond DOS/4GW and DOS/4GW Professional:
<UL>
<LI>Complete documentation
<LI>DLL support
<LI>TSR support
<LI>Support for INT 31h functions 301h-306h, 504h-50Ah, 702h-703h
<LI>A C language API that offers more control over interrupt handling and program loading, as well as making it easier to
use the extender
<LI>An optional (more protected) nonzero-based flat memory model
<LI>Remappable error messages
<LI>More configuration options
<LI>The D32 debugger, GLU linker, and other tools
<LI>Support for other compilers besides Open Watcom
<LI>A higher level of technical support
<LI>Custom work is available (e.g., support for additional executable formats, operating system API emulations, mixed 16-bit
and 32-bit code)
</UL>
<BR>Please contact Tenberry Software if you have questions about other products (present or future) in the DOS/4G line.
<DT>2c.&nbsp; DPMI functions supported by DOS/4GW.
<DD>
<BR><BR>Note that when a DOS/4GW application runs under a DPMI host, such as Windows 3.1 in enhanced mode, an OS/2 virtual
DOS machine, 386Max (with DEBUG=DPMIXCOPY), or QDPMI (with EXTCHKOFF), the DPMI host provides the DPMI services, not DOS/4GW.
&nbsp;The DPMI host also provides virtual memory, if any.&nbsp; Performance (speed and memory use) under different DPMI hosts
varies greatly due to the quality of the DPMI implementation.
<BR><BR>These are the services provided by DOS/4GW and DOS/4GW Professional in the absence of a DPMI host.
<DL>
<DT>0000
<DD>Allocate LDT Descriptors
<DT>0001
<DD>Free LDT Descriptor
<DT>0002
<DD>Map Real-Mode Segment to Descriptor
<DT>0003
<DD>Get Selector Increment Value
<DT>0006
<DD>Get Segment Base Address
<DT>0007
<DD>Set Segment Base Address
<DT>0008
<DD>Set Segment Limit
<DT>0009
<DD>Set Descriptor Access Rights
<DT>000A
<DD>Create Alias Descriptor
<DT>000B
<DD>Get Descriptor
<DT>000C
<DD>Set Descriptor
<DT>000D
<DD>Allocate Specific LDT Descriptor
<DT>0100
<DD>Allocate DOS Memory Block
<DT>0101
<DD>Free DOS Memory Block
<DT>0102
<DD>Resize DOS Memory Block
<DT>0200
<DD>Get Real-Mode Interrupt Vector
<DT>0201
<DD>Set Real-Mode Interrupt Vector
<DT>0202
<DD>Get Processor Exception Handler
<DT>0203
<DD>Set Processor Exception Handler
<DT>0204
<DD>Get Protected-Mode Interrupt Vector
<DT>0205
<DD>Set Protected-Mode Interrupt Vector
<DT>0300
<DD>Simulate Real-Mode Interrupt
<DT>0301
<DD>Call Real-Mode Procedure with Far Return Frame (DOS/4GW Professional only)
<DT>0302
<DD>Call Real-Mode Procedure with IRET Frame (DOS/4GW Professional only)
<DT>0303
<DD>Allocate Real-Mode Callback Address (DOS/4GW Professional only)
<DT>0304
<DD>Free Real-Mode Callback Address (DOS/4GW Professional only)
<DT>0400
<DD>Get DPMI Version
<DT>0500
<DD>Get Free Memory Information
<DT>0501
<DD>Allocate Memory Block
<DT>0502
<DD>Free Memory Block
<DT>0503
<DD>Resize Memory Block
<DT>0600
<DD>Lock Linear Region
<DT>0601
<DD>Unlock Linear Region
<DT>0604
<DD>Get Page Size (VM only)
<DT>0702
<DD>Mark Page as Demand Paging Candidate (DOS/4GW Professional only)
<DT>0703
<DD>Discard Page Contents (DOS/4GW Professional only)
<DT>0800
<DD>Physical Address Mapping
<DT>0801
<DD>Free Physical Address Mapping
<DT>0900
<DD>Get and Disable Virtual Interrupt State
<DT>0901
<DD>Get and Enable Virtual Interrupt State
<DT>0902
<DD>Get Virtual Interrupt State
<DT>0A00
<DD>Get Tenberry Software API Entry Point
<DT>0E00
<DD>Get Coprocessor Status
<DT>0E01
<DD>Set Coprocessor Emulation
</DL>
</DL>
<H2 ID="DOSD4GW__Addressing"> DOS/4GW:&nbsp; Addressing </H2>
<DL>
<DT>3a.&nbsp; Converting between pointers and linear addresses.
<DD>
<BR><BR>Because DOS/4GW uses a zero-based flat memory model, converting between pointers and linear addresses is trivial.
&nbsp;A pointer value is always relative to the current segment (the value in CS for a code pointer, or in DS or SS for a
data pointer).&nbsp; The segment bases for the default DS, SS, and CS are all zero.&nbsp; Hence a near pointer is exactly
the same thing as a linear address:&nbsp; a null pointer points to linear address 0, and a pointer with value 0x10000 points
to linear address 0x10000.
<DT>3b.&nbsp; Converting between code and data pointers.
<DD>
<BR><BR>Because DS and CS have the same base address, they are natural aliases for each other.&nbsp; To create a data alias
for a code pointer, merely create a data pointer and set it equal to the code pointer.&nbsp; It's not necessary for you to
create your own alias descriptor.&nbsp; Similarly, to create a code alias for a data pointer, merely create a code pointer
and set it equal to the data pointer.
<DT>3c.&nbsp; Converting between pointers and low memory addresses.
<DD>
<BR><BR>Linear addresses under 1 MB map directly to physical memory.&nbsp; Hence the real-mode interrupt vector table is at
address 0, the BIOS data segment is at address 0x400, the monochrome video memory is at address 0xB0000, and the color video
memory is at address 0xB8000.&nbsp; To read and write any of these, you can just use a pointer set to the proper address.
&nbsp;You don't need to create a far pointer, using some magic segment value.
<DT>3d.&nbsp; Converting between linear and physical addresses.
<DD>
<BR><BR>Linear addresses at or above 1 MB do not map directly to physical memory, so you can not in general read or write
extended memory directly, nor can you tell how a particular block of extended memory has been used.
<BR><BR>DOS/4GW supports the DPMI call INT 31h/800h, which maps physical addresses to linear addresses.&nbsp; In other words,
if you have a peripheral device in your machine that has memory at a physical address of 256 MB, you can issue this call to
create a linear address that points to that physical memory.&nbsp; The linear address is the same thing as a near pointer
to the memory and can be manipulated as such.
<BR><BR>There is no way in a DPMI environment to determine the physical address corresponding to a given linear address.&nbsp;
This is part of the design of DPMI.&nbsp; You must design your application accordingly.
<DT>3e.&nbsp; Null pointer checking.
<DD>
<BR><BR>DOS/4GW will trap references to the first sixteen bytes of physical memory if you set the environment variable DOS4G=NULLP.
&nbsp;This is currently the only null-pointer check facility provided by DOS/4GW.
<BR><BR>As of release 1.95, DOS/4GW traps both reads and writes.&nbsp; Prior to this, it only trapped writes.
<BR><BR>You may experience problems if you set DOS4G=NULLP and use some versions of the Open Watcom Debugger with a 1.95 or
later extender.&nbsp; These problems have been corrected in later versions of the Open Watcom Debugger.
</DL>
<H2 ID="DOSD4GW__Interrupt_and_Exception_Handling"> DOS/4GW:&nbsp; Interrupt and Exception Handling </H2>
<DL>
<DT>4a.&nbsp; Handling asynchronous interrupts.
<DD>
<BR><BR>Under DOS/4GW, there is a convenient way to handle asynchronous interrupts and an efficient way to handle them.
<BR><BR>Because your CPU may be in either protected mode (when 32-bit code is executing) or real mode (a DOS or BIOS call)
when a hardware interrupt comes in, you have to be prepared to handle interrupts in either mode.&nbsp; Otherwise, you may
miss interrupts.
<BR><BR>You can handle both real-mode and protected-mode interrupts with a single handler, if 1) the interrupt is in the auto-passup
range, 8 to 2Eh; and 2) you install a handler with INT 21h/25h or _dos_setvect(); 3) you do not install a handler for the
same interrupt using any other mechanism.&nbsp; DOS/4GW will route both protected-mode interrupts and real-mode interrupts
to your protected-mode handler.&nbsp; This is the convenient way.
<BR><BR>The efficient way is to install separate real-mode and protected-mode handlers for your interrupt, so your CPU won't
need to do unnecessary mode switches.&nbsp; Writing a real-mode handler is tricky; all you can reasonably expect to do is
save data in a buffer and IRET.&nbsp; Your protected-mode code can periodically check the buffer and process any queued data.
&nbsp;(Remember, protected-mode code can access data and execute code in low memory, but real-mode code can't access data
or execute code in extended memory.)
<BR><BR>For performance, it doesn't matter how you install the real-mode handler, but we recommend the DPMI function INT 31h/201h
for portability.
<BR><BR>It does matter how you install the protected-mode handler.&nbsp; You can't install it directly into the IDT, because
a DPMI provider must distinguish between interrupts and exceptions and maintain separate handler chains.&nbsp; Installing
with INT 31h/205h is the recommended way to install your protected-mode handler for both performance and portability.
<BR><BR>If you install a protected-mode handler with INT 21h/25h, both interrupts and exceptions will be funneled to your
handler, to mimic DOS.&nbsp; Since DPMI exception handlers and interrupt handlers are called with different stack frames,
DOS/4GW executes a layer of code to cover these differences up; the same layer is used to support the DOS/4G API (not part
of DOS/4GW).&nbsp; This layer is the reason that hooking with INT 21h/25h is less efficient than hooking with INT 31h/205h.
<DT>4b.&nbsp; Handling asynchronous interrupts in the second IRQ range.
<DD>
<BR><BR>Because the second IRQ range (normally INTs 70h-77h) is outside the DOS/4GW auto-passup range (8-2Eh, excluding 21h)
you may not handle these interrupts with a single handler, as described above (the &quot;convenient&quot; method).&nbsp; You
must install separate real-mode and protected-mode handlers (the &quot;efficient&quot; method).
<BR><BR>DOS/4G does allow you to specify additional passup interrupts, however.
<DT>4c.&nbsp; Asynchronous interrupt handlers and DPMI.
<DD>
<BR><BR>The DPMI specification requires that all code and data referenced by a hardware interrupt handler MUST be locked at
interrupt time.&nbsp; A DPMI virtual memory manager can use the DOS file system to swap pages of memory to and from the disk;
because DOS is not reentrant, a DPMI host is not required to be able to handle page faults during asynchronous interrupts.
&nbsp;Use INT 31h/600h (Lock Linear Region) to lock an address range in memory.
<BR><BR>If you fail to lock all of your code and data, your program may run under DOS/4GW, but fail under the DOS/4GW Virtual
Memory Manager or under another DPMI host such as Windows or OS/2.
<BR><BR>You should also lock the code and data of a mouse callback function.
<DT>4d.&nbsp; Open Watcom signal() function and Ctrl-Break.
<DD>
<BR><BR>In earlier versions of the Open Watcom C/C++ library, there was a bug that caused signal(SIGBREAK) not to work.&nbsp;
Calling signal(SIGBREAK) did not actually install an interrupt handler for Ctrl-Break (INT 1Bh), so Ctrl-Break would terminate
the application rather than invoking the signal handler.
<BR><BR>With these earlier versions of the library, you could work around this problem by hooking INT 1Bh directly.&nbsp;
With release 10.0, this problem has been fixed.
<DT>4e.&nbsp; More tips on writing hardware interrupt handlers.
<DD>
<UL>
<LI>It's more like handling interrupts in real mode than not.
<BR><BR>The same problems arise when writing hardware interrupt handlers for protected mode as arise for real mode.&nbsp;
We assume you know how to write real-mode handlers; if our suggestions don't seem clear, you might want to brush up on real-mode
interrupt programming.
<LI>Minimize the amount of time spent in your interrupt handlers.
<BR><BR>When your interrupt handlers are called, interrupts are disabled.&nbsp; This means that no other system tasks can
be performed until you enable interrupts (an STI instruction) or until your handler returns.&nbsp; In general, it's a good
idea to handle interrupts as quickly as possible.
<LI>Minimize the amount of time spent in the DOS extender by installing separate real-mode and protected-mode handlers.
<BR><BR>If you use a passup interrupt handler, so that interrupts received in real mode are resignalled in protected mode
by the extender, your application has to switch from real mode to protected mode to real mode once per interrupt.&nbsp; Mode
switching is a time-consuming process, and interrupts are disabled during a mode switch.&nbsp; Therefore, if you're concerned
about performance, you should install separate handlers for real-mode and protected-mode interrupts, eliminating the mode
switch.
<LI>If you can't just set a flag and return, enable interrupts (STI).
<BR><BR>Handlers that do more than just set a flag or store data in a buffer should re-enable interrupts as soon as it's safe
to do so.&nbsp; In other words, save your registers on the stack, establish your addressing conventions, switch stacks if
you're going to - and then enable interrupts (STI), to give priority to other hardware interrupts.
<LI>If you enable interrupts (STI), you should disable interrupts (CLI).
<BR><BR>Because some DPMI hosts virtualize the interrupt flag, if you do an STI in your handler, you should be sure to do
a CLI before you return.&nbsp; (CLI, then switch back to the original stack if you switched away, then restore registers,
then IRET.) If you don't do this, the IRET will not necessarily restore the previous interrupt flag state, and your program
may crash.&nbsp; This is a difference from real-mode programming, and it tends to show up as a problem when you try running
your program in a Windows or OS/2 DOS box for the first time (but not before).
<LI>Add a reentrancy check.
<BR><BR>If your handler doesn't complete its work by the time the next interrupt is signalled, then interrupts can quickly
nest to the point of overflowing the transfer stack.&nbsp; This is a design flaw in your program, not in the DOS extender;
a real-mode DOS program can have exactly the same behavior.&nbsp; If you can conceive of a situation where your interrupt
handler can be called again before the first instance returns, you need to code in a reentrancy check of some sort (before
you switch stacks and enable interrupts (STI), obviously).
<BR><BR>Remember that interrupts can take different amounts of time to execute on different machines; the CPU manufacturer,
CPU speed, speed of memory accesses, and CMOS settings (e.g.&nbsp; &quot;system BIOS shadowing&quot;) can all affect performance
in subtle ways.&nbsp; We recommend you program defensively and always check for unexpected reentry, to avoid transfer stack
overflows.
<LI>Switch to your own stack.
<BR><BR>Interrupt handlers are called on a stack that typically has only a small amount of stack available (512 bytes or less).
&nbsp;If you need to use more stack than this, you have to switch to your own stack on entry into the handler, and switch
back before returning.
<BR><BR>If you want to use C run-time library functions, which are compiled for flat memory model (SS == DS, and the base
of CS == the base of DS), you need to switch back to a stack in the flat data segment first.
<BR><BR>Note that switching stacks by itself won't prevent transfer stack overflows of the kind described above.
</UL>
</DL>
<H2 ID="DOSD4GW__Memory_Management"> DOS/4GW:&nbsp; Memory Management </H2>
<DL>
<DT>5a.&nbsp; Using the realloc() function.
<DD>
<BR><BR>In versions of Open Watcom C/C++ prior to 9.5b, there was a bug in the library implementation of realloc() under DOS/4GW
and DOS/4GW Professional.&nbsp; This bug was corrected by Open Watcom in the 9.5b release.
<DT>5b.&nbsp; Using all of physical memory.
<DD>
<BR><BR>DOS/4GW Professional is currently limited to 64 MB of physical memory.&nbsp; We do not expect to be able to fix this
problem for at least six months.&nbsp; If you need more than 64 MB of memory, you must use virtual memory.
</DL>
<H2 ID="DOSD4GW__DOS__BIOS__and_Mouse_Services"> DOS/4GW:&nbsp; DOS, BIOS, and Mouse Services </H2>
<DL>
<DT>6a.&nbsp; Speeding up file I/O.
<DD>
<BR><BR>The best way to speed up DOS file I/O in DOS/4GW is to write large blocks (up to 65535 bytes, or the largest number
that will fit in a 16-bit int) at a time from a buffer in low memory.&nbsp; In this case, DOS/4GW has to copy the least amount
of data and make the fewest number of DOS calls in order to process the I/O request.
<BR><BR>Low memory is allocated through INT 31h/0100h, Allocate DOS Memory Block.&nbsp; You can convert the real-mode segment
address returned by INT 31h/0100h to a pointer (suitable for passing to setvbuf()) by shifting it left four bits.
<DT>6b.&nbsp; Spawning.
<DD>
<BR><BR>It is possible to spawn one DOS/4GW application from another.&nbsp; However, two copies of the DOS extender will be
loaded into memory.&nbsp; DOS/4G supports loading of multiple programs atop a single extender, as well as DLLs.
<DT>6c.&nbsp; Mouse callbacks.
<DD>
<BR><BR>DOS/4GW Professional now supports the INT 31h interface for managing real-mode callbacks.&nbsp; However, you don't
need to bother with them for their single most important application:&nbsp; mouse callback functions.&nbsp; Just register
your protected-mode mouse callback function as you would in real mode, by issuing INT 33h/0Ch with the event mask in CX and
the function address in ES:EDX, and your function will work as expected.
<BR><BR>Because a mouse callback function is called asynchronously, the same locking requirement exists for a mouse callback
function as for a hardware interrupt handler.&nbsp; See (4c) above.
<DT>6d.&nbsp; VESA support.
<DD>
<BR><BR>While DOS/4GW automatically handles most INT 10h functions so that you can you can issue them from protected mode,
it does not translate the INT 10h VESA extensions.&nbsp; The workaround is to use INT 31h/300h (Simulate Real-Mode Interrupt).
</DL>
<H2 ID="DOSD4GW__Virtual_Memory"> DOS/4GW:&nbsp; Virtual Memory </H2>
<DL>
<DT>7a.&nbsp; Testing for the presence of VMM.
<DD>
<BR><BR>INT 31h/400h returns a value (BX, bit 2) that tells if virtual memory is available.&nbsp; Under a DPMI host such as
Windows 3.1, this will be the host's virtual memory manager, not DOS/4GW's.
<BR><BR>You can test for the presence of a DOS/4G-family DOS extender with INT 31h/0A00h, with a pointer to the null-terminated
string &quot;RATIONAL DOS/4G&quot; in DS:ESI.&nbsp; If the function returns with carry clear, a DOS/4G-family extender is
running.
<DT>7b.&nbsp; Reserving memory for a spawned application.
<DD>
<BR><BR>If you spawn one DOS/4GW application from another, you should set the DELETESWAP configuration option (i.e., SET DOS4GVM=deleteswap)
so that the two applications don't try to use the same swap file.&nbsp; You should also set the MAXMEM option low enough so
that the parent application doesn't take all available physical memory; memory that's been reserved by the parent application
is not available to the child application.
<DT>7c.&nbsp; Instability under VMM.
<DD>
<BR><BR>A program that hooks hardware interrupts, and works fine without VMM but crashes sporadically with it, probably needs
to lock the code and data for its hardware interrupt handlers down in memory.&nbsp; DOS/4GW does not support page faults during
hardware interrupts, because DOS services may not be available at that time.&nbsp; See (4c) and (6c) above.
<BR><BR>Memory can be locked down with INT 31h/600h (Lock Linear Region).
<DT>7d.&nbsp; Running out of memory with a huge virtual address space.
<DD>
<BR><BR>Because DOS/4GW has to create page tables to describe your virtual address space, we recommend that you set your VIRTUALSIZE
parameter just large enough to accommodate your program.&nbsp; If you set your VIRTUALSIZE to 4 GB, the physical memory occupied
by the page tables will be 4 MB, and that memory will not be available to DOS/4GW.
<DT>7e.&nbsp; Reducing the size of the swap file.
<DD>
<BR><BR>DOS/4GW will normally create a swap file equal to your VIRTUALSIZE setting, for efficiency.&nbsp; However, if you
set the SWAPMIN parameter to a size (in KB), DOS/4GW will start with a swap file of that size, and will grow the swap file
when it has to.&nbsp; The SWAPINC value (default 64 KB) controls the incremental size by which the swap file will grow.
<DT>7f.&nbsp; Deleting the swap file.
<DD>
<BR><BR>The DELETESWAP option has two effects:&nbsp; telling DOS/4GW to delete the swap file when it exits, and causing DOS/4GW
to provide a unique swap file name if an explicit SWAPNAME setting was not given.
<BR><BR>DELETESWAP is required if one DOS/4GW application is to spawn another; see (7b) above.
<DT>7g.&nbsp; Improving demand-load performance of large static arrays.
<DD>
<BR><BR>DOS/4GW demand-loading feature normally cuts the load time of a large program drastically.&nbsp; However, if your
program has large amounts of global, zero-initialized data (storage class BSS), the Open Watcom startup code will explicitly
zero it (version 9.5a or earlier).&nbsp; Because the zeroing operation touches every page of the data, the benefits of demand-loading
are lost.
<BR><BR>Demand loading can be made fast again by taking advantage of the fact that DOS/4GW automatically zeroes pages of BSS
data as they are loaded.&nbsp; You can make this change yourself by inserting a few lines into the startup routine, assembling
it (MASM 6.0 will work), and listing the modified object module first when you link your program.
<BR><BR>Here are the changes for<TT> \watcom\src\startup\386\cstart3r.asm</TT> (startup module from the C/C++ 9.5 compiler,
library using register calling conventions).&nbsp; You can modify the workaround easily for other Open Watcom compilers:
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ...&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ; cstart3r.asm, circa line 332</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ; end of _BSS segment (start
of STACK)</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mov&nbsp;&nbsp;&nbsp;&nbsp; ecx,offset DGROUP:_end</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ; start of _BSS segment</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mov&nbsp;&nbsp;&nbsp;&nbsp; edi,offset DGROUP:_edata</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; ;-------------------------------; RSI OPTIMIZATION</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mov&nbsp;&nbsp;&nbsp;&nbsp; eax, edi&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ; minimize _BSS initialization loop</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; or&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; eax, 0FFFh
&nbsp;&nbsp;&nbsp;&nbsp; ; compute address of first page after</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; inc&nbsp;&nbsp;&nbsp;&nbsp; eax&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ;&nbsp;&nbsp; start of _BSS</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cmp&nbsp;&nbsp;&nbsp;&nbsp; eax, ecx&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ; if _BSS extends onto that page,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; jae&nbsp;&nbsp;&nbsp;&nbsp; allzero&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ;&nbsp;&nbsp; then we can rely on the loader</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mov&nbsp;&nbsp;&nbsp;&nbsp; ecx, eax&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ;&nbsp;&nbsp; zeroing the remaining pages</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; allzero:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; ;-------------------------------; END RSI OPTIMIZATION</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; sub&nbsp;&nbsp;&nbsp;&nbsp; ecx,edi&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ; calc # of bytes in _BSS segment</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mov&nbsp;&nbsp;&nbsp;&nbsp; dl,cl&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ; save bottom 2 bits of count in edx</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; shr&nbsp;&nbsp;&nbsp;&nbsp; ecx,2&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ; calc # of dwords</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; sub&nbsp;&nbsp;&nbsp;&nbsp; eax,eax&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ; zero the _BSS segment</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rep&nbsp;&nbsp;&nbsp;&nbsp; stosd&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ; ...</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mov&nbsp;&nbsp;&nbsp;&nbsp; cl,dl&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ; get bottom 2 bits of count</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; and&nbsp;&nbsp;&nbsp;&nbsp; cl,3&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ; ...</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rep&nbsp;&nbsp;&nbsp;&nbsp; stosb&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ; ...</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ...</TT>
<BR><BR>Note that the 9.5b and later versions of the Open Watcom C library already contain this enhancement.
<DT>7h.&nbsp; How should I configure VM for best performance?
<DD>
<BR><BR>Here are some recommendations for setting up the DOS/4GW virtual memory manager.
<DL>
<DT>VIRTUALSIZE
<DD>Set to no more than twice the total amount of memory (virtual and otherwise) your program requires.&nbsp; If your program
has 16 MB of code and data, set to 32 MB.&nbsp; (There is only a small penalty for setting this value larger than you will
need, but your program won't run if you set it too low.) See (7d) above.
<DT>MINMEM
<DD>Set to the minimum hardware requirement for running your application.&nbsp; (If you require a 2 MB machine, set to 2048).
<DT>MAXMEM
<DD>Set to the maximum amount of memory you want your application to use.&nbsp; If you don't spawn any other applications, set
this large (e.g., 32000) to make sure you can use all available physical memory.&nbsp; If you do spawn, see (7b) above.
<DT>SWAPMIN
<DD>Don't use this if you want the best possible VM performance.&nbsp; The trade-off is that DOS/4GW will create a swap file as
big as your VIRTUALSIZE.
<DT>SWAPINC
<DD>Don't use this if you want the best possible VM performance.
<DT>DELETESWAP
<DD>DOS/4GW's VM will start up slightly slower if it has to create the swap file afresh each time.&nbsp; However, unless your
swap file is very large, DELETESWAP is a reasonable choice; it may be required if you spawn another DOS/4GW program at the
same time.&nbsp; See (7b) above.
</DL>
</DL>
<H2 ID="DOSD4GW__Debugging"> DOS/4GW:&nbsp; Debugging </H2>
<DL>
<DT>8a.&nbsp; Attempting to debug a bound application.
<DD>
<BR><BR>You can't debug a bound application.&nbsp; The 4GWBIND utility (included with DOS/4GW Professional) will allow you
to take apart a bound application so that you can debug it:
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; 4GWBIND -U &lt;boundapp.exe&gt; &lt;yourapp.exe&gt;</TT>
<DT>8b.&nbsp; Debugging with an old version of the Open Watcom debugger.
<DD>
<BR><BR>DOS/4GW supports versions 8.5 and up of the Open Watcom C, C++ and FORTRAN compilers.&nbsp; However, in order to debug
your unbound application with a Open Watcom debugger, you must have version 9.5a or later of the debugger.
<BR><BR>If you have an older version of the debugger, we strongly recommend that you contact Open Watcom to upgrade your compiler
and tools.&nbsp; The only way to debug a DOS/4GW Professional application with an old version of the debugger is to rename
4GWPRO.EXE to DOS4GW.EXE and make sure that it's either in the current directory or the first DOS4GW.EXE on the DOS PATH.
<BR><BR>Tenberry will not provide technical support for this configuration; it's up to you to keep track of which DOS extender
is which.
<DT>8c.&nbsp; Meaning of &quot;unexpected interrupt&quot; message/error 2001.
<DD>
<BR><BR>In version 1.95 of DOS/4GW, we revised the &quot;unexpected interrupt&quot; message to make it easier to understand.
<BR><BR>For example, the message:
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Unexpected interrupt 0E (code 0) at 168:10421034</TT>
<BR><BR>is now printed:
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; error (2001): exception 0Eh (page fault) at 168:10421034</TT>
<BR><BR>followed by a register dump, as before.
<BR><BR>This message indicates that the processor detected some form of programming error and signaled an exception, which
DOS/4GW trapped and reported.&nbsp; Exceptions which can be trapped include:
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; 00h&nbsp;&nbsp;&nbsp;&nbsp; divide by zero</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; 01h&nbsp;&nbsp;&nbsp;&nbsp; debug exception OR null pointer used</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; 03h&nbsp;&nbsp;&nbsp;&nbsp; breakpoint</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; 04h&nbsp;&nbsp;&nbsp;&nbsp; overflow</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; 05h&nbsp;&nbsp;&nbsp;&nbsp; bounds</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; 06h&nbsp;&nbsp;&nbsp;&nbsp; invalid opcode</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; 07h&nbsp;&nbsp;&nbsp;&nbsp; device not available</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; 08h&nbsp;&nbsp;&nbsp;&nbsp; double fault</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; 09h&nbsp;&nbsp;&nbsp;&nbsp; overrun</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; 0Ah&nbsp;&nbsp;&nbsp;&nbsp; invalid TSS</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; 0Bh&nbsp;&nbsp;&nbsp;&nbsp; segment not present</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; 0Ch&nbsp;&nbsp;&nbsp;&nbsp; stack fault</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; 0Dh&nbsp;&nbsp;&nbsp;&nbsp; general protection fault</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; 0Eh&nbsp;&nbsp;&nbsp;&nbsp; page fault</TT>
<BR><BR>When you receive this message, this is the recommended course of action:
<OL>
<LI>Record all of the information from the register dump.
<LI>Determine the circumstances under which your program fails.
<LI>Consult your debugger manual, or an Intel 386, 486 or Pentium Programmer's Reference Manual, to determine the circumstances
under which the processor will generate the reported exception.
<LI>Get the program to fail under your debugger, which should stop the program as soon as the exception occurs.
<LI>Determine from the exception context why the processor generated an exception in this particular instance.
</OL>
<DT>8d.&nbsp; Meaning of &quot;transfer stack overflow&quot; message/error 2002.
<DD>
<BR><BR>In version 1.95 of DOS/4GW, we added more information to the &quot;transfer stack overflow&quot; message.&nbsp; The
message (which is now followed by a register dump) is printed:
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; error (2002): transfer stack overflow</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; on interrupt &lt;number&gt; at &lt;address&gt;</TT>
<BR><BR>This message means DOS/4GW detected an overflow on its interrupt handling stack.&nbsp; It usually indicates either
a recursive fault, or a hardware interrupt handler that can't keep up with the rate at which interrupts are occurring.&nbsp;
The best way to understand the problem is to use the VERBOSE option in DOS/4GW to dump the interrupt history on the transfer
stack; see (8e) below.
<DT>8e.&nbsp; Making the most of a DOS/4GW register dump.
<DD>
<BR><BR>If you can't understand your problem by running it under a debugger, the DOS/4GW register dump is your best debugging
tool.&nbsp; To maximize the information available for postmortem debugging, set the environment variable DOS4G to VERBOSE,
then reproduce the crash and record the output.
<BR><BR>Here's a typical register dump with VERBOSE turned on, with annotations.
<BR><BR><TT>&nbsp;&nbsp; </TT>
<BR><TT>&nbsp; 1 DOS/4GW error (2001): exception 0Eh (page fault)</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; at 170:0042C1B2</TT>
<BR><TT>&nbsp; 2 TSF32: prev_tsf32 67D8</TT>
<BR><TT>&nbsp; 3 SS&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 178 DS&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 178 ES&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp; 178 FS&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0 GS&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 20</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; EAX 1F000000 EBX&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0 ECX&nbsp;&nbsp; 43201C EDX&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp; E</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; ESI&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; E EDI&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0
EBP&nbsp;&nbsp; 431410 ESP&nbsp;&nbsp; 4313FC</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; CS:IP&nbsp; 170:0042C1B2 ID 0E COD&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0 FLG&nbsp;&nbsp;
&nbsp;10246</TT>
<BR><TT>&nbsp; 4 CS=&nbsp; 170, USE32, page granular, limit FFFFFFFF, base&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0, acc
CF9B</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; SS=&nbsp; 178, USE32, page granular, limit FFFFFFFF, base&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
0, acc CF93</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; DS=&nbsp; 178, USE32, page granular, limit FFFFFFFF, base&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
0, acc CF93</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; ES=&nbsp; 178, USE32, page granular, limit FFFFFFFF, base&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
0, acc CF93</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; FS=&nbsp;&nbsp;&nbsp; 0, USE16, byte granular, limit&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
0, base&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 15, acc&nbsp; 0</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; GS=&nbsp;&nbsp; 20, USE16, byte granular, limit&nbsp;&nbsp;&nbsp;&nbsp; FFFF, base&nbsp;&nbsp;
&nbsp; 6AA0, acc 93</TT>
<BR><TT>&nbsp; 5 CR0: PG:1 ET:1 TS:0 EM:0 MP:0 PE:1&nbsp;&nbsp; CR2: 1F000000 CR3: 9067</TT>
<BR><TT>&nbsp; 6 Crash address (unrelocated) = 1:000001B2</TT>
<BR><TT>&nbsp; 7 Opcode stream: 8A 18 31 D2 88 DA EB 0E 50 68 39 00 43 00 E8 1D</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; Stack:</TT>
<BR><TT>&nbsp; 8 0178:004313FC 000E 0000 0000 0000 C2D5 0042 C057 0042 0170 0000 0000 0000</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; 0178:00431414 0450 0043 0452 0043 0000 0000 1430 0043 CBEF 0042 011C 0000</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; 0178:0043142C C568 0042 0000 0000 0000 0000 0000 0000 F248 0042 F5F8 0042</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; 0178:00431444 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; 0178:0043145C 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; 0178:00431474 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000</TT>
<BR><TT>&nbsp; 9 Last 4 ints: 21 @ 170:42CF48/21 @ 170:42CF48/21 @ 170:42CF48/E @ 170:42C1B2/</TT>
<OL>
<LI>The error message includes a synopsis of the problem.&nbsp; In this case, the processor signaled a page fault exception
while executing at address 170:0042C1B2.
<LI>The prev_tsf32 field is not usually of interest.
<LI>These are the register values at the time of the exception.&nbsp; The interrupt number and error code (pushed on the stack
by the processor for certain exceptions) are also printed.
<LI>The descriptors referenced by each segment register are described for your convenience.&nbsp; USE32 segments in general
belong to your program; USE16 segments generally belong to the DOS extender.&nbsp; Here, CS points to your program's code
segment, and SS, DS, and ES point to your data segment.&nbsp; FS is NULL and GS points to a DOS extender segment.
<LI>The control register information is not of any general interest, except on a page fault, when CR2 contains the address
value that caused the fault.&nbsp; Since EAX in this case contains the same value, an attempt to dereference EAX could have
caused this particular fault.
<LI>If the crash address (unrelocated) appears, it tells you where the crash occurred relative to your program's link map.
&nbsp;You can therefore tell where a crash occurred even if you can't reproduce the crash in a debugger.
<LI>The opcode stream, if it appears, shows the next 16 bytes from the code segment at the point of the exception.&nbsp; If
you disassemble these instructions, you can tell what instructions caused the crash, even without using a debugger.&nbsp;
In this case, 8A 18 is the instruction<TT> mov bl,[eax].</TT>
<LI>72 words from the top of the stack, at the point of the exception, may be listed next.&nbsp; You may be able to recognize
function calls or data from your program on the stack.
<LI>The four interrupts least to most recently handled by DOS/4GW in protected mode are listed next.&nbsp; In this example,
the last interrupt issued before the page fault occurred was an INT 21h (DOS call) at address 170:42CF48.&nbsp; Sometimes,
this information provides helpful context.
</OL>
<BR>Here's an abridged register dump from a stack overflow.
<BR><BR><TT>&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp; DOS/4GW error (2002): transfer stack overflow</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; on interrupt 70h at 170:0042C002</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; TSF32: prev_tsf32 48C8</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; SS&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; C8 DS&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 170 ES&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 28 FS&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0 GS&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;20</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; EAX AAAAAAAA EBX BBBBBBBB ECX CCCCCCCC EDX DDDDDDDD</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; ESI 51515151 EDI D1D1D1D1 EBP B1B1B1B1 ESP&nbsp;&nbsp;&nbsp;&nbsp; 4884</TT>
<BR><TT>&nbsp; 1 CS:IP&nbsp; 170:0042C002 ID 70 COD&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0 FLG&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp; 2</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; ...</TT>
<BR><TT>&nbsp; 2 Previous TSF:</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; TSF32: prev_tsf32 498C</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; SS&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; C8 DS&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 170 ES&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 28 FS&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0 GS&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;20</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; EAX AAAAAAAA EBX BBBBBBBB ECX CCCCCCCC EDX DDDDDDDD</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; ESI 51515151 EDI D1D1D1D1 EBP B1B1B1B1 ESP&nbsp;&nbsp;&nbsp;&nbsp; 4960</TT>
<BR><TT>&nbsp; 3 CS:IP&nbsp; 170:0042C002 ID 70 COD&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0 FLG&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp; 2</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; ...</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; Previous TSF:</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; TSF32: prev_tsf32 67E4</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; SS&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 178 DS&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 170 ES&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 28 FS&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0 GS&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;20</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; EAX AAAAAAAA EBX BBBBBBBB ECX CCCCCCCC EDX DDDDDDDD</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; ESI 51515151 EDI D1D1D1D1 EBP B1B1B1B1 ESP&nbsp;&nbsp; 42FFE0</TT>
<BR><TT>&nbsp; 4 CS:IP&nbsp; 170:0042C039 ID 70 COD&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0 FLG&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;202</TT>
<BR><TT>&nbsp; 5 Opcode stream: CF 66 B8 62 25 66 8C CB 66 8E DB BA 00 C0 42 00</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; Last 4 ints: 70 @ 170:42C002/70 @ 170:42C002/70 @ 170:42C002/70 @ 170:42C002/</TT>
<OL>
<LI>We overflowed the transfer stack while trying to process an interrupt 70h at 170:0042C002.
<LI>The entire interrupt history from the transfer stack is printed next.&nbsp; The prev_tsf32 numbers increase as we progress
from most recent to least recent interrupt.&nbsp; All of these interrupts are still pending, which is why we ran out of stack
space.
<LI>Before we overflowed the stack, we got the same interrupt at the same address.&nbsp; For a recursive interrupt situation,
this is typical.
<LI>The oldest frame on the transfer stack shows the recursion was touched off at a slightly different address.&nbsp; Looking
at this address may help you understand the recursion.
<LI>The opcode stream and last four interrupt information comes from the newest transfer stack frame, not the oldest.
</OL>
</DL>
<H2 ID="DOSD4GW__Compatibility"> DOS/4GW:&nbsp; Compatibility </H2>
<DL>
<DT>9a.&nbsp; Running DOS/4GW applications from inside Lotus 1-2-3.
<DD>
<BR><BR>In order to run DOS/4GW applications while &quot;shelled out&quot; from Lotus 1-2-3, you must use the PRIVATXM program
included with your Open Watcom compiler.&nbsp; Otherwise, 1-2-3 will take all of the memory on your machine and prevent DOS/4GW
from using it.
<BR><BR>Before starting 1-2-3, you must set the DOS16M environment variable to limit Lotus' memory use (see your Open Watcom
manual).&nbsp; After shelling out, you must run PRIVATXM, then clear the DOS16M environment variable before running your application.
<DT>9b.&nbsp; EMM386.EXE provided with DOS 6.0.
<DD>
<BR><BR>We know of at least three serious bugs in the EMM386.EXE distributed with MS-DOS 6.0, one involving mis-counting the
amount of available memory, one involving mapping too little of the High Memory Area (HMA) into its page tables, and one involving
allocation of EMS memory.&nbsp; Version 1.95 of DOS/4GW contains workarounds for some of these problems.
<BR><BR>If you are having problems with DOS/4GW and you are using an EMM386.EXE dated 3-10-93 at 6:00:00, or later, you may
wish to try the following workarounds, in sequence, until the problem goes away.
<UL>
<LI>Configure EMM386 with both the NOEMS and NOVCPI options.
<LI>Convert the DEVICEHIGH statements in your CONFIG.SYS to DEVICE statements, and remove the LH (Load High) commands from
your AUTOEXEC.BAT.
<LI>Run in a Windows DOS box.
<LI>Replace EMM386 with another memory manager, such as QEMM-386, 386Max, or an older version of EMM386.
<LI>Run with HIMEM.SYS alone.
</UL>
<BR>You may also wish to contact Microsoft Corporation to inquire about the availability of a fix.
<DT>9c.&nbsp; Spawning under OS/2 2.1.
<DD>
<BR><BR>We know of a bug in OS/2 2.1 that prevents one DOS/4GW application from spawning another over and over again.&nbsp;
The actual number of repeated spawns that are possible under OS/2 varies from machine to machine, but is generally about 30.
<BR><BR>This bug also affects programs running under other DOS extenders, and we have not yet found a workaround, other than
linking your two programs together as a single program.
<DT>9d.&nbsp; &quot;DPMI host error:&nbsp; cannot lock stack&quot;.
<DD>
<BR><BR>This error message almost always indicates insufficient memory, rather than a real incompatibility.&nbsp; If you see
it under an OS/2 DOS box, you probably need to edit your DOS Session settings and make DPMI_MEMORY_LIMIT larger.
<DT>9e.&nbsp; Bug in Novell TCPIP driver.
<DD>
<BR><BR>Some versions of a program from Novell called TCPIP.EXE, a real-mode program, will cause the high words of EAX and
EDX to be altered during a hardware interrupt.&nbsp; This bug breaks protected-mode software (and other real-mode software
that uses the 80386 registers).&nbsp; Novell has released a newer version of TCPIP that fixes the problem; contact Novell
to obtain the fix.
<DT>9f.&nbsp; Bugs in Windows NT.
<DD>
<BR><BR>The initial release of Windows NT includes a DPMI host, DOSX.EXE, with several serious bugs, some of which apparently
cannot be worked around.&nbsp; We cannot warranty operation of DOS/4GW under Windows NT at this time, but we are continuing
to exercise our best efforts to work around these problems.
<BR><BR>You may wish to contact Microsoft Corporation to inquire about the availability of a new version of DOSX.EXE.
</DL>
<H1 ID="16Mbit_Windows__Creating_16Mbit_Windows_3_x_Applications"> 16-bit Windows:&nbsp; Creating 16-bit Windows 3.x Applications </H1>
<BR>This chapter describes how to compile and link 16-bit Windows 3.x applications simply and quickly.&nbsp; In this chapter,
we look at applications written to exploit the Windows 3.x Application Programming Interface (API).
<BR><BR>We will illustrate the steps to creating 16-bit Windows 3.x applications by taking a small sample application and
showing you how to compile, link, run and debug it.
<BR><BR>Note - It is supposed you are working on the host with Windows 3.x installed.&nbsp; If you are on the host with any
other operating system you should setup INCLUDE environment variable correctly to compile for 16-bit Windows 3.x target.
<BR><BR>You can do that by command (DOS, OS/2, NT)
<BR><BR>set INCLUDE=%WATCOM%\h;%WATCOM%\h\win
<BR><BR>or by command (LINUX)
<BR><BR>export INCLUDE=$WATCOM/h:$WATCOM/h/win
<H2 ID="16Mbit_Windows__The_Sample_GUI_Application"> 16-bit Windows:&nbsp; The Sample GUI Application </H2>
<BR>To demonstrate the creation of 16-bit Windows 3.x applications, we introduce a simple sample program.&nbsp; The following
example is the &quot;hello&quot; program adapted for Windows.
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; #include &lt;windows.h&gt;</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; int PASCAL WinMain( HANDLE hInstance, HANDLE hPrevInst,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp; LPSTR lpCmdLine, int nCmdShow )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; MessageBox( NULL, &quot;Hello world&quot;,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&quot;Open Watcom C/C++ for Windows&quot;,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;MB_OK | MB_TASKMODAL );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return( 0 );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; }</TT>
<BR><BR>The goal of this program is to display the message &quot;Hello world&quot; on the screen.&nbsp; The<TT> MessageBox</TT>
Windows API function is used to accomplish this task.&nbsp; We will take you through the steps necessary to produce this result.
<H2 ID="16Mbit_Windows__Building_and_Running_the_GUI_Application"> 16-bit Windows:&nbsp; Building and Running the GUI Application </H2>
<BR>To compile and link our example program which is stored in the file<TT> hello.c</TT>, enter the following command:
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; C&gt;wcl -l=windows -bt=windows hello.c</TT>
<BR><BR>The typical messages that appear on the screen are shown in the following illustration.
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; C&gt;wcl -l=windows -bt=windows hello.c</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Open Watcom C/C++16 Compile and Link Utility</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Copyright (c) 2002-2019 the Open Watcom Contributors. All Rights Reserved.</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Portions Copyright (c) 1988-2002 Sybase, Inc. All Rights Reserved.</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Source code is available under the Sybase Open Watcom Public License.</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; See http://www.openwatcom.org/ for details.</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; wcc hello.c&nbsp; -bt=windows</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Open Watcom C16 Optimizing Compiler</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Copyright (c) 2002-2019 the Open Watcom Contributors. All Rights Reserved.</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Portions Copyright (c) 1984-2002 Sybase, Inc. All Rights Reserved.</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Source code is available under the Sybase Open Watcom Public License.</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; See http://www.openwatcom.org/ for details.</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; hello.c: 10 lines, included 6500, 0 warnings, 0 errors</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Code size: 37</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Open Watcom Linker</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Copyright (c) 2002-2019 the Open Watcom Contributors. All Rights Reserved.</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Portions Copyright (c) 1985-2002 Sybase, Inc. All Rights Reserved.</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Source code is available under the Sybase Open Watcom Public License.</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; See http://www.openwatcom.org/ for details.</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; loading object files</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; searching libraries</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; creating a Windows 16-bit executable</TT>
<BR><BR>If you examine the current directory, you will find that two files have been created.&nbsp; These are<TT> hello.obj</TT>
(the result of compiling<TT> hello.c</TT>) and<TT> hello.exe</TT> (the result of linking<TT> hello.obj</TT> with the appropriate
Open Watcom C/C++ libraries).
<BR><BR>The resultant 16-bit Windows 3.x application<TT> HELLO.EXE</TT> can now be run under Windows 3.x.
<H2 ID="16Mbit_Windows__Debugging_the_GUI_Application"> 16-bit Windows:&nbsp; Debugging the GUI Application </H2>
<BR>Let us assume that you wish to debug your application in order to locate an error in programming.&nbsp; In the previous
section, the &quot;hello&quot; program was compiled with default compile and link options.&nbsp; When debugging an application,
it is useful to refer to the symbolic names of routines and variables.&nbsp; It is also convenient to debug at the source
line level rather than the machine language level.&nbsp; To do this, we must direct both the compiler and linker to include
additional debugging information in the object and executable files.&nbsp; Using the<B><I> WCL</I></B> command, this is fairly
straightforward.<B><I>&nbsp; WCL</I></B> recognizes the Open Watcom C/C++ compiler &quot;debug&quot; options and will create
the appropriate debug directives for the Open Watcom Linker.
<BR><BR>For example, to compile and link the &quot;hello&quot; program with debugging information, the following command may
be issued.
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; C&gt;wcl -l=windows -bt=windows -d2 hello.c</TT>
<BR><BR>The typical messages that appear on the screen are shown in the following illustration.
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; C&gt;wcl -l=windows -bt=windows -d2 hello.c</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Open Watcom C/C++16 Compile and Link Utility</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Copyright (c) 2002-2019 the Open Watcom Contributors. All Rights Reserved.</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Portions Copyright (c) 1988-2002 Sybase, Inc. All Rights Reserved.</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Source code is available under the Sybase Open Watcom Public License.</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; See http://www.openwatcom.org/ for details.</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; wcc hello.c -bt=windows -d2</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Open Watcom C16 Optimizing Compiler</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Copyright (c) 2002-2019 the Open Watcom Contributors. All Rights Reserved.</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Portions Copyright (c) 1984-2002 Sybase, Inc. All Rights Reserved.</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Source code is available under the Sybase Open Watcom Public License.</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; See http://www.openwatcom.org/ for details.</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; hello.c: 10 lines, included 6500, 0 warnings, 0 errors</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Code size: 58</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Open Watcom Linker</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Copyright (c) 2002-2019 the Open Watcom Contributors. All Rights Reserved.</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Portions Copyright (c) 1985-2002 Sybase, Inc. All Rights Reserved.</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Source code is available under the Sybase Open Watcom Public License.</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; See http://www.openwatcom.org/ for details.</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; loading object files</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; searching libraries</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; creating a Windows 16-bit executable</TT>
<BR><BR>The &quot;d2&quot; option requests the maximum amount of debugging information that can be provided by the Open Watcom
C/C++ compiler.<B><I>&nbsp; WCL</I></B> will make sure that this debugging information is included in the executable file
that is produced by the linker.
<BR><BR>The &quot;Code size&quot; value is larger than in the previous example since selection of the &quot;d2&quot; option
results in fewer code optimizations by default.&nbsp; You can request more optimization by specifying the appropriate options.
&nbsp;However, you do so at the risk of making it more difficult for yourself to determine the relationship between the object
code and the original source language code.
<BR><BR>To request the Open Watcom Debugger to assist in debugging the application, select the Open Watcom Debugger icon.
&nbsp;It would be too ambitious to describe the debugger in this introductory chapter so we refer you to the book entitled<B><I>
Open Watcom Debugger User's Guide.</I></B>
<H1 ID="16Mbit_Windows__Porting_NonMGUI_Applications_to_16Mbit_Windows_3_x"> 16-bit Windows:&nbsp; Porting Non-GUI Applications to 16-bit Windows 3.x </H1>
<BR>Generally, an application that is to run in a windowed environment must be written in such a way as to exploit the Windows
Application Programming Interface (API).&nbsp; To take an existing character-based (i.e., non-graphical) application that
ran under a system such as DOS and adapt it to run under Windows can require some considerable effort.&nbsp; There is a steep
learning curve associated with the API function libraries.
<BR><BR>This chapter describes how to create a Windows application quickly and simply from an application that does not use
the Windows API.&nbsp; The application will make use of Open Watcom's default windowing support.
<BR><BR>Suppose you have a set of C/C++ applications that previously ran under a system like DOS and you now wish to run them
under Windows 3.x.&nbsp; To achieve this, you can simply recompile your application with the appropriate options and link
with the appropriate libraries.&nbsp; We provide a default windowing system that turns your character-mode application into
a simple Windows 3.x Graphical User Interface (GUI) application.
<BR><BR>Normally, a Windows 3.x GUI application makes use of user-interface tools such as menus, icons, scroll bars, etc.
&nbsp;However, an application that was not designed as a windowed application (such as a DOS application) can run as a GUI
application.&nbsp; This is achieved by our default windowing system.&nbsp; The following sections describe the default windowing
system.
<H2 ID="16Mbit_Windows__Console_Device_in_a_Windowed_Environment"> 16-bit Windows:&nbsp; Console Device in a Windowed Environment </H2>
<BR>In a C/C++ application that runs under DOS,<B> stdin (C++ cin)</B> and<B> stdout (C++ cout)</B> are connected to the standard
input and standard output devices respectively.&nbsp; It is not a recommended practice to read directly from the standard
input device or write to the standard output device when running in a windowed environment.&nbsp; For this reason, a default
windowing environment is created for C/C++ applications that read from<B> stdin (C++ cin)</B> or write to<B> stdout (C++ cout).</B>
&nbsp;When your application is started, a window is created in which output to<B> stdout (C++ cout)</B> is displayed and input
from<B> stdin (C++ cin)</B> is requested.
<BR><BR>In addition to the standard I/O device, it is also possible to perform I/O to the console by explicitly opening a
file whose name is &quot;CON&quot;.&nbsp; When this occurs, another window is created and displayed.&nbsp; This window is
different from the one created for standard input and standard output.&nbsp; In fact, every time you open the console device
a different window is created.&nbsp; This provides a simple multi-windowing system for multiple streams of data to and from
the console device.
<H2 ID="16Mbit_Windows__The_Sample_NonMGUI_Application"> 16-bit Windows:&nbsp; The Sample Non-GUI Application </H2>
<BR>To demonstrate the creation of 16-bit Windows 3.x applications, we introduce a simple sample program.&nbsp; For our example,
we are going to use the famous &quot;hello&quot; program.
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; #include &lt;stdio.h&gt;</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; void main()</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;Hello world\n&quot; );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; }</TT>
<BR><BR>The C++ version of this program follows:
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; #include &lt;iostream.h&gt;</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; void main()</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cout &lt;&lt; &quot;Hello world&quot; &lt;&lt; endl;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; }</TT>
<BR><BR>The goal of this program is to display the message &quot;Hello world&quot; on the screen.&nbsp; The C version uses
the C library<TT> printf</TT> routine to accomplish this task.&nbsp; The C++ version uses the &quot;iostream&quot; library
to accomplish this task.&nbsp; We will take you through the steps necessary to produce this result.
<H2 ID="16Mbit_Windows__Building_and_Running_the_NonMGUI_Application"> 16-bit Windows:&nbsp; Building and Running the Non-GUI Application </H2>
<BR>Very little effort is required to port an existing C/C++ application to Windows 3.x.
<BR><BR>You must compile and link the file<TT> hello.c</TT> specifying the &quot;bw&quot; option.
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; C&gt;wcl -l=windows -bw -bt=windows hello.c</TT>
<BR><BR>The typical messages that appear on the screen are shown in the following illustration.
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; C&gt;wcl -l=windows -bw -bt=windows hello.c</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Open Watcom C/C++16 Compile and Link Utility</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Copyright (c) 2002-2019 the Open Watcom Contributors. All Rights Reserved.</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Portions Copyright (c) 1988-2002 Sybase, Inc. All Rights Reserved.</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Source code is available under the Sybase Open Watcom Public License.</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; See http://www.openwatcom.org/ for details.</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; wcc hello.c&nbsp; -bw -bt=windows</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Open Watcom C16 Optimizing Compiler</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Copyright (c) 2002-2019 the Open Watcom Contributors. All Rights Reserved.</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Portions Copyright (c) 1984-2002 Sybase, Inc. All Rights Reserved.</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Source code is available under the Sybase Open Watcom Public License.</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; See http://www.openwatcom.org/ for details.</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; hello.c: 6 lines, included 155, 0 warnings, 0 errors</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Code size: 17</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Open Watcom Linker</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Copyright (c) 2002-2019 the Open Watcom Contributors. All Rights Reserved.</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Portions Copyright (c) 1985-2002 Sybase, Inc. All Rights Reserved.</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Source code is available under the Sybase Open Watcom Public License.</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; See http://www.openwatcom.org/ for details.</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; loading object files</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; searching libraries</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; creating a Windows 16-bit executable</TT>
<BR><BR>If you examine the current directory, you will find that two files have been created.&nbsp; These are<TT> hello.obj</TT>
(the result of compiling<TT> hello.c</TT>) and<TT> hello.exe</TT> (the result of linking<TT> hello.obj</TT> with the appropriate
Open Watcom C/C++ libraries).
<BR><BR>The resultant 16-bit Windows 3.x application<TT> HELLO.EXE</TT> can now be run under Windows 3.x as a Windows GUI
application.
<H2 ID="16Mbit_Windows__Debugging_the_NonMGUI_Application"> 16-bit Windows:&nbsp; Debugging the Non-GUI Application </H2>
<BR>Let us assume that you wish to debug your application in order to locate an error in programming.&nbsp; In the previous
section, the &quot;hello&quot; program was compiled with default compile and link options.&nbsp; When debugging an application,
it is useful to refer to the symbolic names of routines and variables.&nbsp; It is also convenient to debug at the source
line level rather than the machine language level.&nbsp; To do this, we must direct both the compiler and linker to include
additional debugging information in the object and executable files.&nbsp; Using the<B><I> WCL</I></B> command, this is fairly
straightforward.<B><I>&nbsp; WCL</I></B> recognizes the Open Watcom C/C++ compiler &quot;debug&quot; options and will create
the appropriate debug directives for the Open Watcom Linker.
<BR><BR>For example, to compile and link the &quot;hello&quot; program with debugging information, the following command may
be issued.
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; C&gt;wcl -l=windows -bw -bt=windows -d2 hello.c</TT>
<BR><BR>The typical messages that appear on the screen are shown in the following illustration.
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; C&gt;wcl -l=windows -bw -bt=windows -d2 hello.c</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Open Watcom C/C++16 Compile and Link Utility</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Copyright (c) 2002-2019 the Open Watcom Contributors. All Rights Reserved.</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Portions Copyright (c) 1988-2002 Sybase, Inc. All Rights Reserved.</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Source code is available under the Sybase Open Watcom Public License.</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; See http://www.openwatcom.org/ for details.</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; wcc hello.c -bw -bt=windows -d2</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Open Watcom C16 Optimizing Compiler</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Copyright (c) 2002-2019 the Open Watcom Contributors. All Rights Reserved.</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Portions Copyright (c) 1984-2002 Sybase, Inc. All Rights Reserved.</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Source code is available under the Sybase Open Watcom Public License.</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; See http://www.openwatcom.org/ for details.</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; hello.c: 6 lines, included 155, 0 warnings, 0 errors</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Code size: 23</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Open Watcom Linker</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Copyright (c) 2002-2019 the Open Watcom Contributors. All Rights Reserved.</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Portions Copyright (c) 1985-2002 Sybase, Inc. All Rights Reserved.</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Source code is available under the Sybase Open Watcom Public License.</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; See http://www.openwatcom.org/ for details.</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; loading object files</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; searching libraries</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; creating a Windows 16-bit executable</TT>
<BR><BR>The &quot;d2&quot; option requests the maximum amount of debugging information that can be provided by the Open Watcom
C/C++ compiler.<B><I>&nbsp; WCL</I></B> will make sure that this debugging information is included in the executable file
that is produced by the linker.
<BR><BR>The &quot;Code size&quot; value is larger than in the previous example since selection of the &quot;d2&quot; option
results in fewer code optimizations by default.&nbsp; You can request more optimization by specifying the appropriate options.
&nbsp;However, you do so at the risk of making it more difficult for yourself to determine the relationship between the object
code and the original source language code.
<BR><BR>To request the Open Watcom Debugger to assist in debugging the application, select the Open Watcom Debugger icon.
&nbsp;It would be too ambitious to describe the debugger in this introductory chapter so we refer you to the book entitled<B><I>
Open Watcom Debugger User's Guide.</I></B>
<H2 ID="16Mbit_Windows__Default_Windowing_Library_Functions"> 16-bit Windows:&nbsp; Default Windowing Library Functions </H2>
<BR>A few library functions have been written to enable some simple customization of the default windowing system's behaviour.
&nbsp;The following functions are supplied:
<DL>
<DT>_dwDeleteOnClose
<DD>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; int _dwDeleteOnClose( int handle );</TT>
<BR><BR>This function tells the console window that it should close itself when the file is closed.&nbsp; You must pass to
it the handle associated with the opened console.
<DT>_dwSetAboutDlg
<DD>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; int _dwSetAboutDlg( const char *title, const char *text );</TT>
<BR><BR>This function sets the about dialog box of the default windowing system.&nbsp; The &quot;title&quot; points to the
string that will replace the current title.&nbsp; If title is NULL then the title will not be replaced.&nbsp; The &quot;text&quot;
points to a string which will be placed in the about box.&nbsp; To get multiple lines, embed a new line after each logical
line in the string.&nbsp; If &quot;text&quot; is NULL, then the current text in the about box will not be replaced.
<DT>_dwSetAppTitle
<DD>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; int _dwSetAppTitle( const char *title );</TT>
<BR><BR>This function sets the main window's title.
<DT>_dwSetConTitle
<DD>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; int _dwSetConTitle( int handle, const char *title );</TT>
<BR><BR>This function sets the console window's title which corresponds to the handle passed to it.
<DT>_dwShutDown
<DD>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; int _dwShutDown( void );</TT>
<BR><BR>This function shuts down the default windowing I/O system.&nbsp; The application will continue to execute but no windows
will be available for output.
<DT>_dwYield
<DD>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; int _dwYield( void );</TT>
<BR><BR>This function yields control back to the operating system, thereby giving other processes a chance to run.
</DL>
<BR>These functions are described more fully in the<B><I> WATCOM C Library Reference.</I></B>
<H1 ID="32Mbit_Windows__Creating_32Mbit_Windows_3_x_Applications"> 32-bit Windows:&nbsp; Creating 32-bit Windows 3.x Applications </H1>
<BR>This chapter describes how to compile and link 32-bit Windows 3.x applications simply and quickly.&nbsp; In this chapter,
we look at applications written to exploit the Windows 3.x Application Programming Interface (API).
<BR><BR>We will illustrate the steps to creating 32-bit Windows 3.x applications by taking a small sample application and
showing you how to compile, link, run and debug it.
<BR><BR>Note - It is supposed you are working on the host with Windows 3.x installed.&nbsp; If you are on the host with any
other operating system you should setup INCLUDE environment variable correctly to compile for 32-bit Windows 3.x target.
<BR><BR>You can do that by command (DOS, OS/2, NT)
<BR><BR>set INCLUDE=%WATCOM%\h;%WATCOM%\h\win
<BR><BR>or by command (LINUX)
<BR><BR>export INCLUDE=$WATCOM/h:$WATCOM/h/win
<H2 ID="32Mbit_Windows__The_Sample_GUI_Application"> 32-bit Windows:&nbsp; The Sample GUI Application </H2>
<BR>To demonstrate the creation of 32-bit Windows 3.x applications, we introduce a simple sample program.&nbsp; The following
example is the &quot;hello&quot; program adapted for Windows.
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; #include &lt;windows.h&gt;</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; int PASCAL WinMain( HANDLE hInstance, HANDLE hPrevInst,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp; LPSTR lpCmdLine, int nCmdShow )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; MessageBox( NULL, &quot;Hello world&quot;,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&quot;Open Watcom C/C++ for Windows&quot;,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;MB_OK | MB_TASKMODAL );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return( 0 );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; }</TT>
<BR><BR>The goal of this program is to display the message &quot;Hello world&quot; on the screen.&nbsp; The<TT> MessageBox</TT>
Windows API function is used to accomplish this task.&nbsp; We will take you through the steps necessary to produce this result.
<H2 ID="32Mbit_Windows__Building_and_Running_the_GUI_Application"> 32-bit Windows:&nbsp; Building and Running the GUI Application </H2>
<BR>To compile and link our example program which is stored in the file<TT> hello.c</TT>, enter the following command:
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; C&gt;wcl386 -l=win386 -bt=windows hello.c</TT>
<BR><BR>The typical messages that appear on the screen are shown in the following illustration.
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; C&gt;wcl386 -l=win386 -bt=windows hello.c</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Open Watcom C/C++32 Compile and Link Utility</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Copyright (c) 2002-2019 the Open Watcom Contributors. All Rights Reserved.</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Portions Copyright (c) 1988-2002 Sybase, Inc. All Rights Reserved.</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Source code is available under the Sybase Open Watcom Public License.</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; See http://www.openwatcom.org/ for details.</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; wcc386 hello.c&nbsp; -bt=windows</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Open Watcom C32 Optimizing Compiler</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Copyright (c) 2002-2019 the Open Watcom Contributors. All Rights Reserved.</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Portions Copyright (c) 1984-2002 Sybase, Inc. All Rights Reserved.</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Source code is available under the Sybase Open Watcom Public License.</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; See http://www.openwatcom.org/ for details.</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; hello.c: 10 lines, included 6500, 0 warnings, 0 errors</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Code size: 41</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Open Watcom Linker</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Copyright (c) 2002-2019 the Open Watcom Contributors. All Rights Reserved.</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Portions Copyright (c) 1985-2002 Sybase, Inc. All Rights Reserved.</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Source code is available under the Sybase Open Watcom Public License.</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; See http://www.openwatcom.org/ for details.</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; loading object files</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; searching libraries</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; creating a Windows 32-bit executable</TT>
<BR><BR>If you examine the current directory, you will find that two files have been created.&nbsp; These are<TT> hello.obj</TT>
(the result of compiling<TT> hello.c</TT>) and<TT> hello.rex</TT> (the result of linking<TT> hello.obj</TT> with the appropriate
Open Watcom C/C++ libraries).&nbsp; The &quot;.rex&quot; file must now be combined with Open Watcom's 32-bit Windows supervisor<TT>
WIN386.EXT</TT> using the Open Watcom Bind utility.<TT>&nbsp; WBIND.EXE</TT> combines your 32-bit application code and data
(&quot;.rex&quot; file) with the 32-bit Windows supervisor.&nbsp; The process involves the following steps:
<OL>
<LI><TT> WBIND</TT> copies<TT> WIN386.EXT</TT> into the current directory.
<LI><TT> WBIND.EXE</TT> optionally runs the resource compiler on the 32-bit Windows supervisor so that the 32-bit executable
can have access to the applications resources.
<LI><TT> WBIND.EXE</TT> concatenates<TT> WIN386.EXT</TT> and the &quot;.rex&quot; file, and creates a &quot;.exe&quot; file
with the same name as the &quot;.rex&quot; file.
</OL>
<BR>The following describes the syntax of the<TT> WBIND</TT> command.
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; WBIND file_spec [-d] [-n] [-q] [-s supervisor] [-R rc_options]</TT>
<BR><BR>The square brackets [ ] denote items which are optional.
<DL>
<DT>WBIND
<DD>is the name of the Open Watcom Bind utility.
<DT>file_spec
<DD>is the name of the 32-bit Windows EXE to bind.
<DT>-d
<DD>requests that a 32-bit DLL be built.
<DT>-n
<DD>indicates that the resource compiler is NOT to be invoked.
<DT>-q
<DD>requests that WBIND run in quiet mode (no informational messages are displayed).
<DT>-s supervisor
<DD>specifies the path and name of the Windows supervisor to be bound with the application.&nbsp; If not specified, a search of
the paths listed in the<B> PATH</B> environment variable is performed.&nbsp; If this search is not successful and the<B> WATCOM</B>
environment variable is defined, the<TT> %WATCOM%\BINW</TT> directory is searched.
<DT>-R rc_options
<DD>all options after -R are passed to the resource compiler.
</DL>
<BR>To bind our example program, the following command may be issued:
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; C&gt;wbind hello -n</TT>
<BR><BR>If the &quot;s&quot; option is specified, it must identify the location of the<TT> WIN386.EXT</TT> file or the<TT>
W386DLL.EXT</TT> file (if you are building a DLL).
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; C&gt;wbind hello -n -s c:\watcom\binw\win386.ext</TT>
<BR><BR>If the &quot;s&quot; option is not specified, then the<B> WATCOM</B> environment variable must be defined or the &quot;BINW&quot;
directory must be listed in your<B> PATH</B> environment variable.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; C&gt;set watcom=c:\watcom</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; or</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; C&gt;path c:\watcom\binw;c:\dos;c:\windows</TT>
<BR><BR>The resultant 32-bit Windows 3.x application<TT> HELLO.EXE</TT> can now be run under Windows 3.x.
<H2 ID="32Mbit_Windows__Debugging_the_GUI_Application"> 32-bit Windows:&nbsp; Debugging the GUI Application </H2>
<BR>Let us assume that you wish to debug your application in order to locate an error in programming.&nbsp; In the previous
section, the &quot;hello&quot; program was compiled with default compile and link options.&nbsp; When debugging an application,
it is useful to refer to the symbolic names of routines and variables.&nbsp; It is also convenient to debug at the source
line level rather than the machine language level.&nbsp; To do this, we must direct both the compiler and linker to include
additional debugging information in the object and executable files.&nbsp; Using the<B><I> WCL386</I></B> command, this is
fairly straightforward.<B><I>&nbsp; WCL386</I></B> recognizes the Open Watcom C/C++ compiler &quot;debug&quot; options and
will create the appropriate debug directives for the Open Watcom Linker.
<BR><BR>For example, to compile and link the &quot;hello&quot; program with debugging information, the following command may
be issued.
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; C&gt;wcl386 -l=win386 -bt=windows -d2 hello.c</TT>
<BR><BR>The typical messages that appear on the screen are shown in the following illustration.
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; C&gt;wcl386 -l=win386 -bt=windows -d2 hello.c</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Open Watcom C/C++32 Compile and Link Utility</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Copyright (c) 2002-2019 the Open Watcom Contributors. All Rights Reserved.</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Portions Copyright (c) 1988-2002 Sybase, Inc. All Rights Reserved.</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Source code is available under the Sybase Open Watcom Public License.</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; See http://www.openwatcom.org/ for details.</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; wcc386 hello.c -bt=windows -d2</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Open Watcom C32 Optimizing Compiler</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Copyright (c) 2002-2019 the Open Watcom Contributors. All Rights Reserved.</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Portions Copyright (c) 1984-2002 Sybase, Inc. All Rights Reserved.</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Source code is available under the Sybase Open Watcom Public License.</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; See http://www.openwatcom.org/ for details.</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; hello.c: 10 lines, included 6500, 0 warnings, 0 errors</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Code size: 66</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Open Watcom Linker</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Copyright (c) 2002-2019 the Open Watcom Contributors. All Rights Reserved.</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Portions Copyright (c) 1985-2002 Sybase, Inc. All Rights Reserved.</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Source code is available under the Sybase Open Watcom Public License.</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; See http://www.openwatcom.org/ for details.</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; loading object files</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; searching libraries</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; creating a Windows 32-bit executable</TT>
<BR><BR>The &quot;d2&quot; option requests the maximum amount of debugging information that can be provided by the Open Watcom
C/C++ compiler.<B><I>&nbsp; WCL386</I></B> will make sure that this debugging information is included in the executable file
that is produced by the linker.
<BR><BR>The &quot;Code size&quot; value is larger than in the previous example since selection of the &quot;d2&quot; option
results in fewer code optimizations by default.&nbsp; You can request more optimization by specifying the appropriate options.
&nbsp;However, you do so at the risk of making it more difficult for yourself to determine the relationship between the object
code and the original source language code.
<BR><BR>Once again, the &quot;.rex&quot; file must be combined with Open Watcom's 32-bit Windows supervisor<TT> WIN386.EXT</TT>
using the Open Watcom Bind utility.&nbsp; This step is described in the previous section.
<BR><BR>To request the Open Watcom Debugger to assist in debugging the application, select the Open Watcom Debugger icon.
&nbsp;It would be too ambitious to describe the debugger in this introductory chapter so we refer you to the book entitled<B><I>
Open Watcom Debugger User's Guide.</I></B>
<H1 ID="32Mbit_Windows__Porting_NonMGUI_Applications_to_32Mbit_Windows_3_x"> 32-bit Windows:&nbsp; Porting Non-GUI Applications to 32-bit Windows 3.x </H1>
<BR>Generally, an application that is to run in a windowed environment must be written in such a way as to exploit the Windows
Application Programming Interface (API).&nbsp; To take an existing character-based (i.e., non-graphical) application that
ran under a system such as DOS and adapt it to run under Windows can require some considerable effort.&nbsp; There is a steep
learning curve associated with the API function libraries.
<BR><BR>This chapter describes how to create a Windows application quickly and simply from an application that does not use
the Windows API.&nbsp; The application will make use of Open Watcom's default windowing support.
<BR><BR>Suppose you have a set of C/C++ applications that previously ran under a system like DOS and you now wish to run them
under Windows 3.x.&nbsp; To achieve this, you can simply recompile your application with the appropriate options and link
with the appropriate libraries.&nbsp; We provide a default windowing system that turns your character-mode application into
a simple Windows 3.x Graphical User Interface (GUI) application.
<BR><BR>Normally, a Windows 3.x GUI application makes use of user-interface tools such as menus, icons, scroll bars, etc.
&nbsp;However, an application that was not designed as a windowed application (such as a DOS application) can run as a GUI
application.&nbsp; This is achieved by our default windowing system.&nbsp; The following sections describe the default windowing
system.
<H2 ID="32Mbit_Windows__Console_Device_in_a_Windowed_Environment"> 32-bit Windows:&nbsp; Console Device in a Windowed Environment </H2>
<BR>In a C/C++ application that runs under DOS,<B> stdin (C++ cin)</B> and<B> stdout (C++ cout)</B> are connected to the standard
input and standard output devices respectively.&nbsp; It is not a recommended practice to read directly from the standard
input device or write to the standard output device when running in a windowed environment.&nbsp; For this reason, a default
windowing environment is created for C/C++ applications that read from<B> stdin (C++ cin)</B> or write to<B> stdout (C++ cout).</B>
&nbsp;When your application is started, a window is created in which output to<B> stdout (C++ cout)</B> is displayed and input
from<B> stdin (C++ cin)</B> is requested.
<BR><BR>In addition to the standard I/O device, it is also possible to perform I/O to the console by explicitly opening a
file whose name is &quot;CON&quot;.&nbsp; When this occurs, another window is created and displayed.&nbsp; This window is
different from the one created for standard input and standard output.&nbsp; In fact, every time you open the console device
a different window is created.&nbsp; This provides a simple multi-windowing system for multiple streams of data to and from
the console device.
<H2 ID="32Mbit_Windows__The_Sample_NonMGUI_Application"> 32-bit Windows:&nbsp; The Sample Non-GUI Application </H2>
<BR>To demonstrate the creation of 32-bit Windows 3.x applications, we introduce a simple sample program.&nbsp; For our example,
we are going to use the famous &quot;hello&quot; program.
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; #include &lt;stdio.h&gt;</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; void main()</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;Hello world\n&quot; );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; }</TT>
<BR><BR>The C++ version of this program follows:
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; #include &lt;iostream.h&gt;</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; void main()</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cout &lt;&lt; &quot;Hello world&quot; &lt;&lt; endl;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; }</TT>
<BR><BR>The goal of this program is to display the message &quot;Hello world&quot; on the screen.&nbsp; The C version uses
the C library<TT> printf</TT> routine to accomplish this task.&nbsp; The C++ version uses the &quot;iostream&quot; library
to accomplish this task.&nbsp; We will take you through the steps necessary to produce this result.
<H2 ID="32Mbit_Windows__Building_and_Running_the_NonMGUI_Application"> 32-bit Windows:&nbsp; Building and Running the Non-GUI Application </H2>
<BR>Very little effort is required to port an existing C/C++ application to Windows 3.x.
<BR><BR>You must compile and link the file<TT> hello.c</TT> specifying the &quot;bw&quot; option.
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; C&gt;wcl386 -l=win386 -bw -bt=windows hello.c</TT>
<BR><BR>The typical messages that appear on the screen are shown in the following illustration.
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; C&gt;wcl386 -l=win386 -bw -bt=windows hello.c</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Open Watcom C/C++32 Compile and Link Utility</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Copyright (c) 2002-2019 the Open Watcom Contributors. All Rights Reserved.</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Portions Copyright (c) 1988-2002 Sybase, Inc. All Rights Reserved.</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Source code is available under the Sybase Open Watcom Public License.</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; See http://www.openwatcom.org/ for details.</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; wcc386 hello.c&nbsp; -bw -bt=windows</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Open Watcom C32 Optimizing Compiler</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Copyright (c) 2002-2019 the Open Watcom Contributors. All Rights Reserved.</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Portions Copyright (c) 1984-2002 Sybase, Inc. All Rights Reserved.</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Source code is available under the Sybase Open Watcom Public License.</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; See http://www.openwatcom.org/ for details.</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; hello.c: 6 lines, included 174, 0 warnings, 0 errors</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Code size: 24</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Open Watcom Linker</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Copyright (c) 2002-2019 the Open Watcom Contributors. All Rights Reserved.</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Portions Copyright (c) 1985-2002 Sybase, Inc. All Rights Reserved.</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Source code is available under the Sybase Open Watcom Public License.</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; See http://www.openwatcom.org/ for details.</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; loading object files</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; searching libraries</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; creating a Windows 32-bit executable</TT>
<BR><BR>If you examine the current directory, you will find that two files have been created.&nbsp; These are<TT> hello.obj</TT>
(the result of compiling<TT> hello.c</TT>) and<TT> hello.rex</TT> (the result of linking<TT> hello.obj</TT> with the appropriate
Open Watcom C/C++ libraries).&nbsp; The &quot;.rex&quot; file must now be combined with Open Watcom's 32-bit Windows supervisor<TT>
WIN386.EXT</TT> using the Open Watcom Bind utility.<TT>&nbsp; WBIND.EXE</TT> combines your 32-bit application code and data
(&quot;.rex&quot; file) with the 32-bit Windows supervisor.&nbsp; The process involves the following steps:
<OL>
<LI><TT> WBIND</TT> copies<TT> WIN386.EXT</TT> into the current directory.
<LI><TT> WBIND.EXE</TT> optionally runs the resource compiler on the 32-bit Windows supervisor so that the 32-bit executable
can have access to the applications resources.
<LI><TT> WBIND.EXE</TT> concatenates<TT> WIN386.EXT</TT> and the &quot;.rex&quot; file, and creates a &quot;.exe&quot; file
with the same name as the &quot;.rex&quot; file.
</OL>
<BR>The following describes the syntax of the<TT> WBIND</TT> command.
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; WBIND file_spec [-d] [-n] [-q] [-s supervisor] [-R rc_options]</TT>
<BR><BR>The square brackets [ ] denote items which are optional.
<DL>
<DT>WBIND
<DD>is the name of the Open Watcom Bind utility.
<DT>file_spec
<DD>is the name of the 32-bit Windows EXE to bind.
<DT>-d
<DD>requests that a 32-bit DLL be built.
<DT>-n
<DD>indicates that the resource compiler is NOT to be invoked.
<DT>-q
<DD>requests that WBIND run in quiet mode (no informational messages are displayed).
<DT>-s supervisor
<DD>specifies the path and name of the Windows supervisor to be bound with the application.&nbsp; If not specified, a search of
the paths listed in the<B> PATH</B> environment variable is performed.&nbsp; If this search is not successful and the<B> WATCOM</B>
environment variable is defined, the<TT> %WATCOM%\BINW</TT> directory is searched.
<DT>-R rc_options
<DD>all options after -R are passed to the resource compiler.
</DL>
<BR>To bind our example program, the following command may be issued:
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; C&gt;wbind hello -n</TT>
<BR><BR>If the &quot;s&quot; option is specified, it must identify the location of the<TT> WIN386.EXT</TT> file or the<TT>
W386DLL.EXT</TT> file (if you are building a DLL).
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; C&gt;wbind hello -n -s c:\watcom\binw\win386.ext</TT>
<BR><BR>If the &quot;s&quot; option is not specified, then the<B> WATCOM</B> environment variable must be defined or the &quot;BINW&quot;
directory must be listed in your<B> PATH</B> environment variable.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; C&gt;set watcom=c:\watcom</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; or</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; C&gt;path c:\watcom\binw;c:\dos;c:\windows</TT>
<BR><BR>The resultant 32-bit Windows 3.x application<TT> HELLO.EXE</TT> can now be run under Windows 3.x as a Windows GUI
application.
<H2 ID="32Mbit_Windows__Debugging_the_NonMGUI_Application"> 32-bit Windows:&nbsp; Debugging the Non-GUI Application </H2>
<BR>Let us assume that you wish to debug your application in order to locate an error in programming.&nbsp; In the previous
section, the &quot;hello&quot; program was compiled with default compile and link options.&nbsp; When debugging an application,
it is useful to refer to the symbolic names of routines and variables.&nbsp; It is also convenient to debug at the source
line level rather than the machine language level.&nbsp; To do this, we must direct both the compiler and linker to include
additional debugging information in the object and executable files.&nbsp; Using the<B><I> WCL386</I></B> command, this is
fairly straightforward.<B><I>&nbsp; WCL386</I></B> recognizes the Open Watcom C/C++ compiler &quot;debug&quot; options and
will create the appropriate debug directives for the Open Watcom Linker.
<BR><BR>For example, to compile and link the &quot;hello&quot; program with debugging information, the following command may
be issued.
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; C&gt;wcl386 -l=win386 -bw -bt=windows -d2 hello.c</TT>
<BR><BR>The typical messages that appear on the screen are shown in the following illustration.
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; C&gt;wcl386 -l=win386 -bw -bt=windows -d2 hello.c</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Open Watcom C/C++32 Compile and Link Utility</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Copyright (c) 2002-2019 the Open Watcom Contributors. All Rights Reserved.</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Portions Copyright (c) 1988-2002 Sybase, Inc. All Rights Reserved.</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Source code is available under the Sybase Open Watcom Public License.</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; See http://www.openwatcom.org/ for details.</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; wcc386 hello.c -bw -bt=windows -d2</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Open Watcom C32 Optimizing Compiler</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Copyright (c) 2002-2019 the Open Watcom Contributors. All Rights Reserved.</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Portions Copyright (c) 1984-2002 Sybase, Inc. All Rights Reserved.</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Source code is available under the Sybase Open Watcom Public License.</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; See http://www.openwatcom.org/ for details.</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; hello.c: 6 lines, included 174, 0 warnings, 0 errors</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Code size: 45</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Open Watcom Linker</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Copyright (c) 2002-2019 the Open Watcom Contributors. All Rights Reserved.</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Portions Copyright (c) 1985-2002 Sybase, Inc. All Rights Reserved.</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Source code is available under the Sybase Open Watcom Public License.</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; See http://www.openwatcom.org/ for details.</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; loading object files</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; searching libraries</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; creating a Windows 32-bit executable</TT>
<BR><BR>The &quot;d2&quot; option requests the maximum amount of debugging information that can be provided by the Open Watcom
C/C++ compiler.<B><I>&nbsp; WCL386</I></B> will make sure that this debugging information is included in the executable file
that is produced by the linker.
<BR><BR>The &quot;Code size&quot; value is larger than in the previous example since selection of the &quot;d2&quot; option
results in fewer code optimizations by default.&nbsp; You can request more optimization by specifying the appropriate options.
&nbsp;However, you do so at the risk of making it more difficult for yourself to determine the relationship between the object
code and the original source language code.
<BR><BR>Once again, the &quot;.rex&quot; file must be combined with Open Watcom's 32-bit Windows supervisor<TT> WIN386.EXT</TT>
using the Open Watcom Bind utility.&nbsp; This step is described in the previous section.
<BR><BR>To request the Open Watcom Debugger to assist in debugging the application, select the Open Watcom Debugger icon.
&nbsp;It would be too ambitious to describe the debugger in this introductory chapter so we refer you to the book entitled<B><I>
Open Watcom Debugger User's Guide.</I></B>
<H2 ID="32Mbit_Windows__Default_Windowing_Library_Functions"> 32-bit Windows:&nbsp; Default Windowing Library Functions </H2>
<BR>A few library functions have been written to enable some simple customization of the default windowing system's behaviour.
&nbsp;The following functions are supplied:
<DL>
<DT>_dwDeleteOnClose
<DD>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; int _dwDeleteOnClose( int handle );</TT>
<BR><BR>This function tells the console window that it should close itself when the file is closed.&nbsp; You must pass to
it the handle associated with the opened console.
<DT>_dwSetAboutDlg
<DD>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; int _dwSetAboutDlg( const char *title, const char *text );</TT>
<BR><BR>This function sets the about dialog box of the default windowing system.&nbsp; The &quot;title&quot; points to the
string that will replace the current title.&nbsp; If title is NULL then the title will not be replaced.&nbsp; The &quot;text&quot;
points to a string which will be placed in the about box.&nbsp; To get multiple lines, embed a new line after each logical
line in the string.&nbsp; If &quot;text&quot; is NULL, then the current text in the about box will not be replaced.
<DT>_dwSetAppTitle
<DD>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; int _dwSetAppTitle( const char *title );</TT>
<BR><BR>This function sets the main window's title.
<DT>_dwSetConTitle
<DD>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; int _dwSetConTitle( int handle, const char *title );</TT>
<BR><BR>This function sets the console window's title which corresponds to the handle passed to it.
<DT>_dwShutDown
<DD>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; int _dwShutDown( void );</TT>
<BR><BR>This function shuts down the default windowing I/O system.&nbsp; The application will continue to execute but no windows
will be available for output.
<DT>_dwYield
<DD>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; int _dwYield( void );</TT>
<BR><BR>This function yields control back to the operating system, thereby giving other processes a chance to run.
</DL>
<BR>These functions are described more fully in the<B><I> WATCOM C Library Reference.</I></B>
<H1 ID="Windows__The_Open_Watcom_32Mbit_Windows_3_x_Extender"> Windows:&nbsp; The Open Watcom 32-bit Windows 3.x Extender </H1>
<BR>Open Watcom C/C++ contains the necessary tools and libraries to create 32-bit applications for Windows 3.x.&nbsp; Using
Open Watcom C/C++ gives the programmer the benefits of a 32-bit flat memory model and access to the full Windows API (along
with the usual C/C++ library functions).
<BR><BR>The general model of the environment is as follows:&nbsp; The 32-bit flat memory model program is linked against a
special 32-bit Windows library.&nbsp; This library contains the necessary information to invoke special 16-bit functions,
which lie in the supervisor<TT> (WIN386.EXT).</TT>&nbsp; The 32-bit program is then bound (using<TT> WBIND.EXE)</TT> with
the supervisor to create a Windows executable.&nbsp; At the same time as the 32-bit program is being bound, the resource compiler
is run on the supervisor, and all the resources for the application are placed there.&nbsp; When the application is started,
the supervisor obtains the 32-bit memory, relocates the 32-bit application into the memory, and invokes the 32-bit application.
<BR><BR>All Windows functions are invoked from the supervisor, and all callback routines lie within the supervisor.&nbsp;
The local heap resides within the supervisor as well.
<BR><BR>If you are starting from a 16-bit Windows application, most of the code will not change when you port it to the 32-bit
Windows environment.&nbsp; However, because of the nature of the Windows API and its implicit dependencies on a 16-bit environment,
some source changes are necessary.&nbsp; These source changes are minimal, and are backwards compatible with the 16-bit environment.
<H2 ID="Windows__Pointers"> Windows:&nbsp; Pointers </H2>
<BR>Throughout this document, there will be references to both<B><I> near</I></B> and<B><I> far</I></B> , and<B><I> 16-bit</I></B>
and<B><I> 32-bit</I></B> pointers.&nbsp; Since this can rapidly become confusing, some initial explanations will be given
here.
<BR><BR>A<B><I> far pointer</I></B> is a pointer that is composed of both a selector and an offset.&nbsp; A selector determines
a specific region of memory, and the offset is relative to the start of this region.&nbsp; A<B><I> near pointer</I></B> is
a pointer that has an offset only, the selector is automatically assumed by the CPU.
<BR><BR>The problem with far pointers is the selector overhead.&nbsp; Using a far pointer is much more expensive than using
a near pointer.&nbsp; This is the advantage of the 32-bit flat memory model - all pointers within the program are near, and
yet you can address up to 4 gigabytes of memory.
<BR><BR>A<B><I> 16-bit near pointer</I></B> occupies 2 bytes of memory (i.e., the offset is 16 bits long).&nbsp; This pointer
can reference up to 64K of data.
<BR><BR>A<B><I> 16-bit far pointer</I></B> occupies 4 bytes of memory.&nbsp; There is a 16-bit selector and a 16-bit offset.
&nbsp;This pointer can reference up to 64K of data.
<BR><BR>A<B><I> 32-bit near pointer</I></B> occupies 4 bytes of memory (i.e., the offset is 32 bits long).&nbsp; This pointer
can reference up to 4 gigabytes of data.
<BR><BR>A<B><I> 32-bit far pointer</I></B> occupies 6 bytes of memory.&nbsp; There is a 16-bit selector and a 32-bit offset.
&nbsp;This pointer can reference up to 4 gigabytes of data.
<BR><BR>Windows, in general, uses 16-bit far pointers to pass information around.&nbsp; These 16-bit far pointers can also
be used by a 32-bit Windows application.&nbsp; Using a special macro,<B><I> MK_FP32</I></B> , the offset of the 16-bit far
pointer is extended from 16 bits to 32 bits, and the pointer becomes a 32-bit far pointer.&nbsp; The 32-bit far pointer is
then used by the application to access the data (note that offsets still must be less than 64K, since the selector is still
for a 64K data area).
<H2 ID="Windows__Implementation_Overview"> Windows:&nbsp; Implementation Overview </H2>
<BR>This section provides an overview of the issues that require consideration when creating a 32-bit Windows application
for a 16-bit Windows environment.
<BR><BR>First, all modules have to be recompiled for the 32-bit flat memory model with a compiler capable of generating 32-bit
instructions.&nbsp; Many Windows API functions take<B><I> int</I></B> as a parameter.&nbsp; This<B><I> int</I></B> is from
the 16-bit world, and is 2 bytes long.&nbsp; In the 32-bit world, this<B><I> int</I></B> becomes 4 bytes long.&nbsp; Since
Windows is only expecting two bytes of data, all occurrences of<B><I> int</I></B> have to be changed to<B><I> short</I></B>
in<TT> WINDOWS.H.</TT>
<BR><BR>Pointers to data passed to Windows are all far pointers.&nbsp; We will be passing pointers to data in our 32-bit flat
address space, and these pointers are near pointers.&nbsp; By simply getting rid of all<B><I> far</I></B> keywords in<TT>
WINDOWS.H,</TT> all pointers will now be passed as 32-bit near pointers.&nbsp; As well, notice that these 32-bit near pointers
are the same size as as their 16-bit far pointer counterparts (4 bytes).&nbsp; This is good, since all data structures containing
pointers will remain the same size.
<BR><BR>Windows cannot be called from 32-bit code on a 32-bit stack.&nbsp; This means that in order to call the API functions,
it is necessary to write a set of cover functions that will accept the parameters, switch into a 16-bit environment, and then
call Windows.&nbsp; There is another issue, though.&nbsp; Windows only understands 16-bit pointers, so before calling Windows,
all pointers being passed to Windows must be converted to 16-bit far pointers.
<BR><BR>It turns out that Windows can also call back to your application.&nbsp; Windows can only call 16-bit code, though,
so there is a need for a bridge from the 16-bit side to the 32-bit side.&nbsp; It is necessary to allocate 16-bit call back
routines that can be passed to Windows.&nbsp; These call back routines will then switch into the 32-bit environment and call
whatever 32-bit function is required.&nbsp; The 32-bit call back has to be declared as a far function, since it is necessary
to issue a far call to enter it from the 16-bit side.&nbsp; If it is a far function, then the compiler will generate the appropriate
code for it to return from the far call.
<BR><BR>Once Windows calls you back, it can hand you 16-bit far pointers in a long (4 byte) parameter.&nbsp; This pointer
can only be used in the 32-bit environment if it is a 32-bit far pointer, not a 16-bit far pointer.&nbsp; The conversion is
simple:&nbsp; the 16-bit offset is extended to a 32-bit offset (the high word is zeroed out).&nbsp; Any far pointer that Windows
hands to you must be converted in this way.
<BR><BR>Sometimes, a Windows application wants to call a procedure in a DLL.&nbsp; The procedure address is a 16-bit far pointer.
&nbsp;It is not possible to issue an indirect call to this address from the 32-bit environment, so some sort of interface
is needed.&nbsp; This interface would switch into the 16-bit environment, and then call the 16-bit function.
<BR><BR>These issues, along with other minor items, are handled by Open Watcom C/C++, and are discussed in more technical
detail in later sections.
<H2 ID="Windows__System_Structure"> Windows:&nbsp; System Structure </H2>
<BR><TT><IMG SRC="struct.bmp" ALIGN=MIDDLE></TT>
<BR><B><I>Figure 5.</I></B><B><I></I></B><B> WIN386 Structure</B>
<BR><BR><TT><IMG SRC="struct2.bmp" ALIGN=MIDDLE></TT>
<BR><B><I>Figure 6.</I></B><B><I></I></B><B> 32-bit Application Structure</B>
<H2 ID="Windows__System_Overview"> Windows:&nbsp; System Overview </H2>
<UL>
<LI><TT> WIN386.EXT</TT> is the key component of a 32-bit Windows application.&nbsp; It is a 16-bit Windows application which
contains:
<UL>
<LI>All application resources.
<LI>A 16-bit local heap.
<LI>A 16-bit stack.
</UL>
<LI><TT> W386DLL.EXT</TT> is similar to<TT> WIN386.EXT,</TT> only it provides a DLL interface.
<BR><BR><TT>WIN386.EXT</TT> is bound to your 32-bit application to create a 32-bit application that will run under Windows
3.x.<TT>&nbsp; WIN386.EXT</TT> provides the following functionality:
<UL>
<LI>supervisor to bring the 32-bit application into memory and start it running.
<LI>&quot;glue&quot; functions to connect to Windows for both API and DOS functionality.&nbsp; This interface is designed
to transparently set up the calling functions' pointers and parameters to their 16-bit counterparts.
<LI>&quot;glue-back&quot; functions to allow Windows to call back 32-bit routines.
<LI>special code to allow debugging of 32-bit applications.
</UL>
<LI><TT> WINDOWS.H</TT> has been specially modified for use in the 32-bit Windows environment.&nbsp; As well, it contains
all special definitions for 32-bit applications.
<LI><TT> WIN386.LIB</TT> contains all the necessary library functions to connect to the 32-bit supervisor<TT> WIN386.EXT.</TT>
&nbsp;All Windows API calls and Open Watcom C/C++ library DOS calls are found here.
<LI>The standard C/C++ library functions, specially modified to run in the 32-bit environment, are located in the<TT> \WATCOM\LIB386\WIN</TT>
directory.
<LI><TT> WBIND.EXE</TT> merges your 32-bit executable and the appropriate Supervisor into a single executable.
</UL>
<H2 ID="Windows__Steps_to_Obtaining_a_32Mbit_Application"> Windows:&nbsp; Steps to Obtaining a 32-bit Application </H2>
<BR>The following is an overview of the procedure for creating a 32-bit Windows Application:
<OL>
<LI>If you are starting with a 16-bit Windows application, you must adapt your source code to the 32-bit environment.
<LI>You must compile the application using a 32-bit compiler.
<LI>You must link the application with the 32-bit libraries.
<LI>You must bind the 32-bit application with the 32-bit supervisor.
<LI>You can then run and/or debug the application.
</OL>
<H1 ID="Windows__Windows_3_x_32Mbit_Programming_Overview"> Windows:&nbsp; Windows 3.x 32-bit Programming Overview </H1>
<BR>This chapter includes the following topics:
<UL>
<LI>WINDOWS.H
<LI>Environment Notes
<LI>Floating-point Emulation
<LI>Multiple Instances
<LI>Pointer Handling
<LI>When To Convert Incoming Pointers
<LI>When To Convert Outgoing Pointers
<LI>SendMessage and SendDlgItemMessage
<LI>GlobalAlloc and LocalAlloc
<LI>Callback Function Pointers
<LI>Window Sub-classing
<LI>Calling 16-bit DLLs
<LI>Making DLL Calls Transparent
<LI>Far Pointer Manipulation
<LI>_16 Functions
</UL>
<H2 ID="Windows__WINDOWS_H"> Windows:&nbsp; WINDOWS.H </H2>
<BR>When developing programs, make sure<TT> WINDOWS.H</TT> is included as the first include file in all source files.&nbsp;
This header file contains only the following lines:
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; #ifdef _WINDOWS_16_</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; #include &lt;win16.h&gt;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; #else</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; #include &lt;_win386.h&gt;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; #endif</TT>
<BR><BR>The file<TT> WIN16.H</TT> is the regular 16-bit Windows header file, and is only conditionally included for 16-bit
Windows applications.&nbsp; The file<TT> _WIN386.H</TT> contains all the prototypes and macros for the 32-bit environment,
as well as including and modifying<TT> WIN16.H.</TT>&nbsp; These modifications are changing int to short, and changing the<B><I>
far</I></B> keyword to nothing.&nbsp; These changes (that ONLY apply to things defined in<TT> WIN16.H</TT>) cause all integers
to be 16-bit integers, and all LP...&nbsp; pointer types to be near pointers.
<BR><BR>Other include files for Windows must be specifically requested by defining macros before including<TT> WINDOWS.H.</TT>
&nbsp;This is required so that the same changes made to the primary Windows header file will apply to routines declared in
the other header files.
<DL>
<DT><B><I>Macro name</I></B>
<DD><B><I>File included</I></B>
<DT>#define INCLUDE_COMMDLG_H
<DD><TT> COMMDLG.H</TT>
<DT>#define INCLUDE_CUSTCNTL_H
<DD><TT> CUSTCNTL.H</TT>
<DT>#define INCLUDE_DDE_H
<DD><TT> DDE.H</TT>
<DT>#define INCLUDE_DDEML_H
<DD><TT> DDEML.H</TT>
<DT>#define INCLUDE_DRIVINIT_H
<DD><TT> DRIVINIT.H</TT>
<DT>#define INCLUDE_LZEXPAND_H
<DD><TT> LZEXPAND.H</TT>
<DT>#define INCLUDE_MMSYSTEM_H
<DD><TT> MMSYSTEM.H</TT>
<DT>#define INCLUDE_OLE_H
<DD><TT> OLE.H</TT>
<DT>#define INCLUDE_PENWIN_H
<DD><TT> PENWIN.H</TT>
<DT>#define INCLUDE_PENWOEM_H
<DD><TT> PENWOEM.H</TT>
<DT>#define INCLUDE_PRINT_H
<DD><TT> PRINT.H</TT>
<DT>#define INCLUDE_SHELLAPI_H
<DD><TT> SHELLAPI.H</TT>
<DT>#define INCLUDE_STRESS_H
<DD><TT> STRESS.H</TT>
<DT>#define INCLUDE_TOOLHELP_H
<DD><TT> TOOLHELP.H</TT>
<DT>#define INCLUDE_VER_H
<DD><TT> VER.H</TT>
</DL>
<H2 ID="Windows__Environment_Notes"> Windows:&nbsp; Environment Notes </H2>
<UL>
<LI>The Windows functions<B><I> Catch</I></B> and<B><I> Throw</I></B> save only the 16-bit state.&nbsp; Instead of these functions,
use the<B><I> setjmp</I></B> and<B><I> longjmp</I></B> functions.
<LI>The 32-bit Windows Supervisor uses the first 256 bytes of the 32-bit application's stack to save state information.&nbsp;
If this is corrupted, your application will abnormally terminate.
<LI>The 32-bit Windows Supervisor provides resources for up to 512 callback routines.&nbsp; Note that this restriction is
only on the maximum number of active callbacks.
</UL>
<H2 ID="Windows__FloatingMpoint_Emulation"> Windows:&nbsp; Floating-point Emulation </H2>
<BR>The file<TT> WEMU387.386</TT> is included to support floating-point emulation for 32-bit applications running under Windows.
&nbsp;This file is installed in the<TT> [386Enh]</TT> section of your<TT> SYSTEM.INI</TT> file.&nbsp; By using the floating-point
emulator, your application can be compiled with the &quot;fpi87&quot; option to use inline floating-point instructions, and
it will run on a machine without a numeric coprocessor.
<BR><BR>Only one of<TT> WEMU387.386</TT> and<TT> WDEBUG.386</TT> may be installed in your<TT> [386Enh]</TT> section.&nbsp;
<TT> WEMU387.386</TT> may be distributed with your application.
<H2 ID="Windows__Multiple_Instances"> Windows:&nbsp; Multiple Instances </H2>
<BR>Since the 32-bit application resides in a flat memory space, it is NOT possible to share code with other instances.&nbsp;
This means that you must register new window classes with callbacks into the new instance's code space.&nbsp; A simple way
of accomplishing this is as follows:
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; int PASCAL WinMain( HANDLE hInstance,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp; HANDLE hPrevInstance;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp; LPSTR lpCmdLine,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp; int nCmdShow );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; WNDCLASS&nbsp; wc;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; HWND&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; hWnd</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; char&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; class[32];</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; wc.style = NULL;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; wc.lpfnWndProc = (LPVOID) MainWndProc;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; wc.cbClsExtra = 0;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; wc.cbWndExtra = 0;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; wc.hInstance = hInstance;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; wc.hIcon = LoadIcon( NULL, IDI_APPLICATION );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; wc.hCursor = LoadCursor( NULL, IDC_ARROW );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; wc.hbrBackground = GetStockObject( WHITE_BRUSH );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; wc.lpszMenuName = &quot;Menu&quot;;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; sprintf( class,&quot;Class%d&quot;,hInstance );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; wc.lpszClassName = class;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; RegisterClass( &amp;wc );</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; hWnd = CreateWindow(</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; class,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &quot;Application&quot;,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; WS_OVERLAPPEDWINDOW,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CW_USEDEFAULT,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CW_USEDEFAULT,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CW_USEDEFAULT,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CW_USEDEFAULT,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; NULL,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; NULL,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; hInstance,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; NULL</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; );</TT>
<BR><BR>The variable<B><I> class</I></B> contains a unique name based on the instance of the application.
<H2 ID="Windows__Pointer_Handling"> Windows:&nbsp; Pointer Handling </H2>
<BR>Windows 3.x is a 16-bit operating system.&nbsp; Function pointers that Windows deals with are 16-bit far pointers, and
any data you communicate to Windows with are 16-bit far pointers.&nbsp; 16-bit far pointers occupy 4 bytes of data, and are
capable of addressing up to 64K.&nbsp; For data objects larger than 64K, huge pointers are used (a sequence of far pointers
that map out consecutive 64K segments for the data object).&nbsp; 16-bit far pointers are expensive to use due to the overhead
of selector loads (each time you use the pointer, a segment register must have a value put in it).&nbsp; 16-bit huge pointers
are even more expensive:&nbsp; not only is there the overhead of selector loads, but a run-time call is necessary to perform
any pointer arithmetic.
<BR><BR>In a 32-bit flat memory model, such as that of the Open Watcom C/C++ for Windows environment, all pointers are 32-bit
near pointers (occupying 4 bytes of data as well).&nbsp; However, these pointers may access objects of up to 4 gigabytes in
size, and there is no selector load overhead.
<BR><BR>All Windows defined pointer types (e.g., LPSTR) are by default near pointers, not far pointers.&nbsp; To obtain a
far pointer, the far keyword must be explicitly coded, i.e.,<TT> char far *foo</TT>, rather than<TT> LPSTR foo.</TT>&nbsp;
A 32-bit near pointer is the same size as a 16-bit far pointer, so that all Windows pointers are the same size in the 32-bit
flat memory model as they are in the original 16-bit segmented model.
<BR><BR>For a 32-bit environment to communicate with Windows 3.x, there are some considerations.&nbsp; All pointers sent to
Windows must be converted from 32-bit near pointers to 16-bit far pointers.&nbsp; These conversions are handled by the Supervisor.
<BR><BR>It is important to remember that all API functions which accept pointers (with the exception of functions that accept
function pointers) accept 32-bit near pointers in this 32-bit model.&nbsp; If you attempt to pass a 32-bit far pointer, the
conversion will not take place correctly.
<BR><BR>16-bit far pointers to data may be passed into the API functions, and the Supervisor will not do any conversion.
<BR><BR>Incoming pointers must be converted from 16-bit far pointers to 32-bit far pointers.&nbsp; This conversion is a trivial
one:&nbsp; the offset portion of the 16-bit far pointer is extended to 32-bits.&nbsp; Pointers from Windows are by their nature
far (that is, the data is pointed to by its own selector), and must be used as far in the 32-bit environment.&nbsp; Of course,
conversions are only required if you actually need to reference the pointer.
<BR><BR>Function pointers (i.e., pointers to callback routines) used by Windows are not converted from 32-bit to 16-bit.&nbsp;
Rather, a 16-bit thunking layer that transfers control from the 16-bit environment to the 32-bit environment must be used.
&nbsp;This thunking layer is provided by the Supervisor.
<H3 ID="Windows__When_To_Convert_Incoming_Pointers"> Windows:&nbsp; When To Convert Incoming Pointers </H3>
<BR>Whenever you wish to use a pointer passed to you by Windows, you must convert it to a 32-bit far pointer.&nbsp; If you
are passed a 16-bit far pointer, the macro<B><I> MK_FP32</I></B> can be used to convert it to a 32-bit far pointer.&nbsp;
If you are passed a 16-bit near pointer (e.g., from<B><I> LocalLock</I></B> ), then the macro<B><I> MK_LOCAL32</I></B> can
be used to convert it to a 32-bit far pointer.
<BR><BR>Some places where pointer conversion may be required are:
<UL>
<LI>LocalLock
<LI>GlobalLock
<LI>the lParam in a window callback routine (if it is a pointer)
</UL>
<H3 ID="Windows__When_To_Convert_Outgoing_Pointers"> Windows:&nbsp; When To Convert Outgoing Pointers </H3>
<BR>Typically, there is no need to do any kind of conversions on your pointers when passing them to Windows.&nbsp; The Supervisor
handles all 32-bit to 16-bit translations for you, in the case of the regular Windows API functions.&nbsp; However, if you
are passing a 32-bit pointer to some other 16-bit application in the Windows environment, then pointer conversions must by
done.&nbsp; There are two types of &quot;outgoing&quot; pointers:&nbsp; data pointers and function pointers.
<BR><BR>Function pointers (to callback routines) must have a thunking layer provided, using the<B><I> GetProc16</I></B> function
(this is explained in detail in a later section).
<BR><BR>Data pointers can be translated from 32-bit to 16-bit using the<B><I> AllocAlias16</I></B> and<B><I> AllocHugeAlias16</I></B>
functions.&nbsp; These functions create 16-bit far pointers that have the same linear address as the 32-bit near pointer that
was converted.
<BR><BR>It is important to remember that when passing a pointer to a data structure in this fashion, any pointers in the data
structure must also be converted.
<BR><BR>The Supervisor will convert any pointers that it knows about; but there are some complications created by the fact
that Windows allows you to pass pointers in functions that are prototyped to take a long integer.
<BR><BR>The Windows API functions<B><I> SendMessage</I></B> and<B><I> SendDlgItemMessage</I></B> rely on other fields determining
the nature of the long data item that they accept; this is discussed in detail in the next section.
<H4 ID="Windows__SendMessage_and_SendDlgItemMessage"> Windows:&nbsp; SendMessage and SendDlgItemMessage </H4>
<BR><B><I>SendMessage</I></B> and<B><I> SendDlgItemMessage</I></B> have special cover functions that determine when the long
integer is really a pointer and needs to be converted.&nbsp; These cover functions are used automatically, unless the macro<B><I>
NOCOVERSENDS</I></B> is defined before including <TT> WINDOWS.H</TT> as in the following example.
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; #define NOCOVERSENDS</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; #include &lt;windows.h&gt;</TT>
<BR><BR><B><I>SendMessage</I></B> and<B><I> SendDlgItemMessage</I></B> will do pointer conversions automatically using<B><I>
AllocAlias16</I></B> and<B><I> FreeAlias16</I></B> (unless<B><I> NOCOVERSENDS</I></B> is defined) for the following message
types:
<UL>
<LI>combo boxes (CB_ messages)
<LI>edit controls (EM_ messages)
<LI>list boxes (LB_ messages)
<LI>certain windows messages (WM_ messages);
</UL>
<BR>The messages that are intercepted by the cover functions for<B><I> SendMessage</I></B> and<B><I> SendDlgItemMessage</I></B>
are:
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; CB_ADDSTRING&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CB_DIR&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CB_FINDSTRING</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; CB_FINDSTRINGEXACT CB_GETLBTEXT&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CB_INSERTSTRING</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; CB_SELECTSTRING</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; EM_GETLINE&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; EM_GETRECT&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp; EM_REPLACESEL</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; EM_SETRECT&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; EM_SETRECTNP&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp; EM_SETTABSTOPS</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; LB_ADDSTRING&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; LB_DIR&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; LB_FINDSTRING</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; LB_FINDSTRINGEXACT LB_GETITEMRECT&nbsp;&nbsp;&nbsp;&nbsp; LB_GETSELITEMS</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; LB_GETTEXT&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; LB_INSERTSTRING&nbsp;&nbsp;&nbsp;
LB_SELECTSTRING</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; LB_SETTABSTOPS</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; WM_MDICREATE&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; WM_NCCALCSIZE</TT>
<BR><BR>Note that for<B><I> SendMessage</I></B> and<B><I> SendDlgItemMessage</I></B> , some of the messages may NOT require
pointer conversion:
<UL>
<LI>CB_ADDSTRING, CB_FINDSTRING, CB_FINDSTRINGEXACT, CB_INSERTSTRING will not need a conversion if the combo box was created
as owner-draw style without CBS_HASSTRINGS style.
<LI>LB_ADDSTRING, LB_FINDSTRING, LB_FINDSTRINGEXACT, LB_INSERTSTRING will not need a conversion if the list box was created
as owner-draw style without LBS_HASSTRINGS style.
</UL>
<BR>The macro<B><I> NOCOVERSENDS</I></B> should be defined in modules where messages like these are being sent.&nbsp; With
these messages, the lParam data item does not contain a pointer, and the automatic pointer conversion would be incorrect.
&nbsp;By doing
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; #define NOCOVERSENDS</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; #include &quot;windows.h&quot;</TT>
<BR><BR>modules that send messages like the above will not have the pointer conversion performed.
<H3 ID="Windows__GlobalAlloc_and_LocalAlloc"> Windows:&nbsp; GlobalAlloc and LocalAlloc </H3>
<BR>The functions<B><I> GlobalAlloc</I></B> and<B><I> LocalAlloc</I></B> are the typical way of allocating memory in the 16-bit
Windows environment.&nbsp; In the 32-bit environment, there is no need to use these functions.&nbsp; The only time<B><I> GlobalAlloc</I></B>
is needed is when allocating shared memory, i.e.,<B><I> GMEM_DDESHARE</I></B> .
<BR><BR>The C runtime functions<B><I> malloc</I></B> and<B><I> free</I></B> manipulate your 32-bit near heap for you.&nbsp;
By using these functions to allocate memory, you may create data objects as large as the enhanced mode Windows memory manager
will permit.
<H3 ID="Windows__Callback_Function_Pointers"> Windows:&nbsp; Callback Function Pointers </H3>
<BR>To access a callback function, an instance of it must be created using<B><I> MakeProcInstance</I></B> .&nbsp; This creates
a &quot;thunk&quot; (a special piece of code) that automatically puts the application's data segment into the AX register,
and then calls the specified callback function.
<BR><BR>In Windows 3.x, it is not possible to do a<B><I> MakeProcInstance</I></B> directly on a 32-bit callback routine, since
Windows 3.x does not understand 32-bit applications.&nbsp; Therefore, it is necessary to use a 16-bit callback routine that
passes control to the 32-bit callback routine.&nbsp; This 16-bit callback routine is automatically created by the Supervisor
when using any of the standard Windows API functions that accept a callback routine.
<BR><BR>The 16-bit callback routine for a 32-bit application is a special layer that transfers the parameters from a 16-bit
stack to the 32-bit stack, and then passes control to 32-bit code.&nbsp; These 16-bit callback routines are found in the Supervisor.
&nbsp;The function<B><I> GetProc16</I></B> provides pointers to these 16-bit callback routines.
<BR><BR>However, it is not often necessary to use the<B><I> GetProc16</I></B> function to obtain a 16-bit/32-bit callback
interface function.
<BR><BR>In the general case, one would have to write code as follows:
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; #define NOAUTOPROCS</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; #include &lt;windows.h&gt;</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; CALLBACKPTR&nbsp;&nbsp;&nbsp;&nbsp; pCb;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; FARPROC&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; fpProc;</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; pCb = GetProc16( A_Function, GETPROC_callbacktype );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; fpProc = MakeProcInstance( pCb, hInstance );</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; /* do stuff */</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Do_it( ..., fpProc, ... );</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; /* do more stuff */</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; FreeProcInstance( fpProc );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; ReleaseProc16( pCb );</TT>
<BR><BR>It is not necessary to use this general code in the case of the regular Windows API functions.&nbsp; The following
functions will automatically allocate the correct 16-bit/32-bit callback interface functions:
<UL>
<LI>ChooseColor
<LI>ChooseFont
<LI>CorrectWriting
<LI>CreateDialog
<LI>CreateDialogIndirect
<LI>CreateDialogIndirectParam
<LI>CreateDialogParam
<LI>DdeInitialize
<LI>DialogBox
<LI>DialogBoxIndirect
<LI>DialogBoxIndirectParam
<LI>DialogBoxParam
<LI>DictionarySearch
<LI>EnumChildWindows
<LI>EnumFontFamilies
<LI>EnumFonts
<LI>EnumMetaFile
<LI>EnumObjects
<LI>EnumProps
<LI>EnumSymbols
<LI>EnumTaskWindows
<LI>EnumWindows
<LI>Escape (SETABORTPROC option)
<LI>FindText
<LI>GetOpenFileName
<LI>GetSaveFileName
<LI>GlobalNotify
<LI>GrayString
<LI>LineDDA
<LI>mciSetYieldProc
<LI>mmioInstallIOProc
<LI>NotifyRegister
<LI>PrintDlg
<LI>ProcessWriting
<LI>Recognize
<LI>RecognizeData
<LI>RegisterClass
<LI>ReplaceText
<LI>SetClassLong (GCL_WNDPROC option)
<LI>SetPenHook
<LI>SetResourceHandler
<LI>SetTimer
<LI>SetWindowLong (GWL_WNDPROC option)
<LI>SetWindowsHook
<LI>SetWindowsHookEx
<LI>TrainInk
</UL>
<BR>As well, the following functions are covered to provide support for automatic creation of 16-bit callback routines:
<UL>
<LI>FreeProcInstance
<LI>MakeProcInstance
<LI>UnhookWindowsHook
</UL>
<BR>If you need to get a callback that is not used by one of the above functions, then you must code the general case.&nbsp;
Typically, this is required when a DLL needs a callback routine.&nbsp; In modules where this is necessary, you define the
macro<B><I> NOAUTOPROCS</I></B> before you include<TT> WINDOWS.H</TT> as in the following example.
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; #define NOAUTOPROCS</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; #include &lt;windows.h&gt;</TT>
<BR><BR>Be careful of the following when using<B><I> NOAUTOPROCS</I></B> .
<OL>
<LI>The call to<B><I> MakeProcInstance</I></B> and<B><I> FreeProcInstance</I></B> for the callback function occurs in a module
with<B><I> NOAUTOPROCS</I></B> defined.
<LI>No Windows API functions (listed above) are used in the module with<B><I> NOAUTOPROCS</I></B> defined.&nbsp; If they are,
you must code the general case to use them.
</OL>
<BR>Note that<B><I> NOAUTOPROCS</I></B> is in effect on a module-to-module basis only.
<BR><BR>You can avoid using<B><I> NOAUTOPROCS</I></B> on a call-by-call basis, if you do the following:
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; #undef &lt;function&gt;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; &lt;function&gt;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Note: re-defining is only needed if you want to</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; use a covered version of the function later on.</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; #define &lt;function&gt; _Cover_&lt;function&gt;</TT>
<BR><BR>For example:
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; #undef SetWindowsHook</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; #undef MakeProcInstance</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; FARPROC fp,oldfp;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CALLBACKPTR cbp;</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cbp = GetProc16( CallbackHook, GETPROC_CALLBACK );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; fp = MakeProcInstance( cbp, hInstance );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; oldfp = SetWindowsHook( WH_CALLWNDPROC, fp );</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; }</TT>
<BR><BR>This allows you to add general case code in the same module, without having to break the module into two parts.
<BR><BR>RegisterClass automatically does a GetProc16 for the callback function, unless the macro NOCOVERRC is specified before
including<TT> WINDOWS.H</TT> as in the following example.
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; #define NOCOVERRC</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; #include &lt;windows.h&gt;</TT>
<H4 ID="Windows__Window_SubMclassing"> Windows:&nbsp; Window Sub-classing </H4>
<BR>Sub-classing a Windows control in the 32-bit environment is straightforward.&nbsp; In fact, the code is identical to the
code used in the 16-bit environment.&nbsp; A simple example is:
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; FARPROC fpOldProc;</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; long FAR PASCAL SubClassProc( HWND hWnd,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; unsigned message,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; WORD wParam,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; LONG lParam )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /*</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; * code for sub-classing here</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return( CallWindowProc( fpOldProc, hWnd, message,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; wParam, lParam ) );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; }</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; void SubClassDemo( void )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; HWND&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp; hControl;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; FARPROC&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp; fp;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; extern HANDLE&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ProgramInstance;</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* assume hControl gets created in here */</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; fpOldProc = (FARPROC) GetWindowLong( hControl, GWL_WNDPROC );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; fp = MakeProcInstance( SubClassProc, ProgramInstance );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; SetWindowLong( hControl, GWL_WNDPROC, (LONG) fp );</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* set it back */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; SetWindowLong( hControl, GWL_WNDPROC, (LONG) fpOldProc );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; FreeProcInstance( fp );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; }</TT>
<BR><BR>Note that<B><I> SetWindowLong</I></B> is covered to recognize<B><I> GWL_WNDPROC</I></B> and automatically creates
a 16-bit callback for the 32-bit callback.&nbsp; When replacing the callback routine with the original 16-bit routine, the
covered version of<B><I> SetWindowLong</I></B> recognizes that the function is not a 32-bit callback, and so passes the pointer
right through to Windows unchanged.
<H2 ID="Windows__Calling_16Mbit_DLLs"> Windows:&nbsp; Calling 16-bit DLLs </H2>
<BR>A 16-bit function in a DLL can be called using the<B><I> _Call16</I></B> function.&nbsp; The first argument to<B><I> _Call16</I></B>
is the address of the 16-bit function.&nbsp; This address is usually obtained by calling<B><I> GetProcAddress</I></B> with
the name of the desired function.&nbsp; The second argument to<B><I> _Call16</I></B> is a string identifying the types of
the parameters to be passed to the 16-bit function.
<DL>
<DT><B><I>Character</I></B>
<DD><B><I>Parameter Type</I></B>
<DT>c
<DD>call a 'cdecl' function as opposed to a 'pascal' function (if specified, it must be listed first)
<DT>b
<DD>unsigned BYTE
<DT>w
<DD>16-bit WORD
<DT>d
<DD>32-bit DWORD
<DT>f
<DD>double precision floating-point
<DT>p
<DD>32-bit flat pointer (converted to 16:16 far pointer)
</DL>
<BR>The 16-bit function must use either the<B><I> PASCAL</I></B> or<B><I> CDECL</I></B> calling convention.<B><I>&nbsp; PASCAL</I></B>
calling convention is the default.&nbsp; If the function uses the<B><I> CDECL</I></B> calling convention, then you must specify
the letter &quot;c&quot; as the first character of the argument type string.
<BR><BR>Pointer types will automatically be converted from 32-bit near pointers to 16-bit far pointers before the function
is invoked.&nbsp; Note that this pointer is only valid over the period of the call; after control returns to the 32-bit application,
the 16-bit pointer created by the Supervisor is no longer valid.
<BR><BR>The return value from<B><I> _Call16</I></B> is a<B><I> DWORD</I></B> .
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; #include &lt;windows.h&gt;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; HANDLE hDrv;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; FARPROC lpfn;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; int cb;</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if( (hDrv = LoadLibrary (&quot;foo.dll&quot;)) &lt; 32 )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return FALSE;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if( !(lpfn = GetProcAddress (hDrv, &quot;ExtDeviceMode&quot;)) )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return FALSE;</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /*</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; * now, invoke the function</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cb = (WORD) _Call16(</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; lpfn,&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // address of function</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &quot;wwdppddw&quot;,&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // parameter type info</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; hwnd,&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // parameters ...</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; hDrv,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; NULL,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &quot;POSTSCRIPT PRINTER&quot;,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &quot;LPT1&quot;,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; NULL,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; NULL,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; );</TT>
<H3 ID="Windows__Making_DLL_Calls_Transparent"> Windows:&nbsp; Making DLL Calls Transparent </H3>
<BR>This section gives an example of how to make your source code look as if you are calling the 16-bit DLL directly.
<BR><BR>Assume there are 3 functions that you want to call in the 16-bit DLL, with prototypes as follows:
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; HWND FAR PASCAL Initialize( WORD start_code );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; BOOL FAR PASCAL DoStuff( HWND win_hld, HDC win_dc );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; void FAR PASCAL Finish( void );</TT>
<BR><BR>A fragment from the header file that you would include in your 32-bit application would be as follows:
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; extern FARPROC InitializeAddr;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; extern FARPROC DoStuffAddr;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; extern FARPROC FinishAddr;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; #define Initialize( start_code ) \</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; _Call16( InitializeAddr, &quot;w&quot;, (WORD)start_code )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; #define DoStuff( win_hld, data ) \</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; _Call16( DoStuffAddr, &quot;wp&quot;, (HWND)win_hld, (LPVOID)data )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; #define Finish( void )&nbsp; _Call16( FinishAddr, &quot;&quot; )</TT>
<BR><BR>The header file fragment gives external references for the function addresses for each function, and sets up macros
do a<B><I> _Call16</I></B> for each of the functions.
<BR><BR>At start up, you would call the following function:
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; /*</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; * LoadDLL - get DLL ready for 32-bit use</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; BOOL LoadDLL( void )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; HANDLE&nbsp; dll;</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; dll = LoadLibrary( &quot;chart.dll&quot; );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if( dll &lt; 32 ) return( FALSE);</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; InitializeAddr = GetProcAddress( dll, &quot;Initialize&quot;
);</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DoStuffAddr = GetProcAddress( dll, &quot;DoStuff&quot; );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; FinishAddr = GetProcAddress( dll, &quot;Finish&quot; );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return( TRUE );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; }</TT>
<BR><BR>This function loads the 16-bit DLL and gets the addresses for all of the entry points in the DLL.&nbsp; By including
the header file with all the macros in it, you can code calls to the DLL functions as if you were calling the functions directly.
&nbsp;For example:
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; #include &lt;windows.h&gt;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; #include &quot;fragment.h&quot;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; char *data = &quot;the data&quot;;</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; void TestDLL( void )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; HWND res;</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if( !LoadDLL() ) {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; MessageBox( NULL, &quot;Could not load DLL&quot;,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp; &quot;Error&quot;, MB_OK );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; res = Initialize( 1 );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DoStuff( res, data );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Finish();</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; }</TT>
<H2 ID="Windows__Far_Pointer_Manipulation"> Windows:&nbsp; Far Pointer Manipulation </H2>
<BR>The following C library functions are available for manipulating far data.&nbsp; These are useful when using pointers
obtained by<B><I> MK_FP32</I></B> and<B><I> MK_LOCAL32</I></B> .
<BR><BR>Memory manipulation:
<UL>
<LI>_fmemccpy
<LI>_fmemchr
<LI>_fmemcmp
<LI>_fmemcpy
<LI>_fmemicmp
<LI>_fmemmove
<LI>_fmemset
</UL>
<BR>String manipulation:
<UL>
<LI>_fstrcat
<LI>_fstrchr
<LI>_fstrcmp
<LI>_fstrcpy
<LI>_fstrcspn
<LI>_fstricmp
<LI>_fstrlen
<LI>_fstrlwr
<LI>_fstrncat
<LI>_fstrncmp
<LI>_fstrncpy
<LI>_fstrnicmp
<LI>_fstrnset
<LI>_fstrpbrk
<LI>_fstrrchr
<LI>_fstrrev
<LI>_fstrset
<LI>_fstrspn
<LI>_fstrtok
<LI>_fstrupr
</UL>
<H2 ID="Windows___16_Functions"> Windows:&nbsp; _16 Functions </H2>
<BR>Every Windows API function that accepts a pointer has a corresponding _16 function.&nbsp; The _16 version of the function
will not convert any of the pointers that it accepts; it will assume that all pointers are 16-bit far pointers already.&nbsp;
This applies to both data and function pointers.
<BR><BR>Some sample code demonstrating the use for this is:
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; void ReadEditBuffer( char *fname, HWND hwndEdit )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; file;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; HANDLE&nbsp;&nbsp;&nbsp; hText;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; char far *flpData;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; LPSTR&nbsp;&nbsp;&nbsp;&nbsp; lpData;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; WORD&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; filelen;</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /*</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; * no error checking is performed; we just</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; * assume everything works for this example.</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; file = _lopen( fname, 0);</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; filelen = _llseek( file, 0L, 2 );</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; hText = (HANDLE) SendMessage( hwndEdit, EM_GETHANDLE,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0, 0L );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; LocalReAlloc( hText, filelen+1, LHND );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; flpData = MK_LOCAL32( LocalLock( hText ) );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; lpData = (LPSTR) MK_FP16( flpB );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; _16_lread( file, lpData, filelen );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; _lclose( file );</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; }</TT>
<BR><BR>This example reads the contents of a file into the buffer of an edit window.&nbsp; Because the edit window's memory
is located in the local heap, which is the Supervisor's heap, the<B><I> MK_LOCAL32</I></B> function is needed to access the
data.&nbsp; The<B><I> MK_FP16</I></B> macro compresses the 32-bit far pointer into a 16-bit far pointer, which can then be
used by the _16_lread function.
<H1 ID="Windows__Windows_32MBit_Dynamic_Link_Libraries"> Windows:&nbsp; Windows 32-Bit Dynamic Link Libraries </H1>
<BR>Open Watcom C/C++ allows the creation of 32-bit Dynamic Link Libraries (DLL).&nbsp; In fact, 32-bit DLLs are simpler to
write than 16-bit DLLs.&nbsp; A 16-bit DLL runs on the caller's stack, and thus DS != SS.&nbsp; This creates difficulties
in the small and medium memory models because near pointers to local variables are different from near pointers to global
variables.&nbsp; The 32-bit DLL runs on its own stack, in the usual flat memory space, which eliminates these concerns.
<BR><BR>There is a special version of the supervisor,<TT> W386DLL.EXT</TT> that performs a similar job to<TT> WIN386.EXT.</TT>
&nbsp;However, the 32-bit DLL supervisor is a 16-bit Windows DLL, rather than a 16-bit Windows application.&nbsp; On the first
use of the 32-bit DLL, the DLL supervisor loads the 32-bit DLL and invokes the 32-bit initialization routine (the DLL's<TT>
WinMain</TT> routine).&nbsp; The initialization routine declares all entry points (via<TT> DefineDLLEntry</TT>) and performs
any other necessary initialization.&nbsp; An index number in the range 1 to 128 is used to identify all external 32-bit DLL
routines.<TT>&nbsp; DefineDLLEntry</TT> is used to assign an index number to each routine, as well as to identify the arguments.
<BR><BR>The DLL supervisor contains a general entry point for Windows applications to call into called<TT> Win386LibEntry.</TT>
&nbsp;It also contains 128 specific entry points called<TT> DLL1</TT> to<TT> DLL128</TT> which correspond to the entry points
established via<TT> DefineDLLEntry</TT> (the first argument to<TT> DefineDLLEntry</TT> is an index number in the range 1 to
128).&nbsp; These entry points are<TT> FAR PASCAL</TT> functions.&nbsp; All applications call into the 32-bit DLL via these
entry points.&nbsp; They build the necessary stack frame and switch to the 32-bit DLL's data space.
<BR><BR>If you call via<TT> Win386LibEntry</TT> then you pass the DLL entry point number or index (1 to 128) as the last argument.<TT>
&nbsp;Win386LibEntry</TT> uses this index number to call the appropriate 32-bit DLL routine.&nbsp; From a pseudo-code point
of view, the 16-bit supervisor might look like the following:
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; DLL1::&nbsp; set index=1</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; invoke 32bitDLLindirect</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; DLL2::&nbsp; set index=2</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; invoke 32bitDLLindirect</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; DLL128:: set index=128</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; invoke 32bitDLLindirect</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Win386LibEntry::</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; set index from index_argument</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; invoke 32bitDLLindirect</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; 32bitDLLindirect:</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; set up stack frame</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; switch to 32-bit data space</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call indirect registration_list[ index ]</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .</TT>
<BR><BR>When you are creating a 32-bit DLL, keep in mind that the entry points you define may be invoked by a 16-bit application
as well as a 32-bit application.&nbsp; It is for this reason that all far pointers passed to a 32-bit DLL are 16-bit far pointers.
&nbsp;Hence, whenever a pointer is passed as an argument to a 32-bit DLL entry point and you wish to access the data it points
to, you must convert the pointer appropriately.
<H2 ID="Windows__A_Sample_32Mbit_DLL"> Windows:&nbsp; A Sample 32-bit DLL </H2>
<BR>Let us begin our discussion of DLLs by showing the code for a simple DLL.&nbsp; The source code for these examples is
provided in the<TT> \WATCOM\SAMPLES\DLL</TT> directory.&nbsp; We describe how to compile and link the examples in the section
entitled <A HREF="#Windows__Creating_and_Debugging_Dynamic_Link_Libraries">Windows:&nbsp; Creating and Debugging Dynamic Link Libraries</A>.
&nbsp;The code for this DLL can be compiled with the 16-bit compiler to produce a 16-bit DLL and it can can be compiled with
the 32-bit compiler to produce a 32-bit DLL.&nbsp; The example illustrates the fundamental differences between the two types
of DLLs.&nbsp; The 32-bit DLL has a<TT> WinMain</TT> routine and the 16-bit DLL has a<TT> LibMain</TT> routine.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; /*</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; *&nbsp; DLL.C</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; #include &lt;stdio.h&gt;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; #include &lt;windows.h&gt;</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; #if defined(__386__)/* if we are doing a 32-bit DLL */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; #define DLL_ID &quot;DLL32&quot;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; #else&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
/* else we are doing a 16-bit DLL */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; #define DLL_ID &quot;DLL16&quot;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; #endif</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; long FAR PASCAL __export FooMe1(WORD w1, DWORD w2, WORD w3)</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; char buff[128];</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; sprintf( buff, &quot;FooMe1: w1=%hx, w2=%lx, w3=%hx&quot;,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; w1, w2, w3 );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; MessageBox( NULL, buff, DLL_ID, MB_OK );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return( w1 + w2 );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; }</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; long FAR PASCAL __export FooMe2( DWORD w1, WORD w2 )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; char buff[128];</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; sprintf( buff, &quot;FooMe2: w1=%lx, w2=%hx&quot;, w1, w2 );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; MessageBox( NULL, buff, DLL_ID, MB_OK );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return( w1 + 1 );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; }</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; #if defined(__386__)/* if we are doing a 32-bit DLL */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; long PASCAL WinMain( HANDLE hInstance,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; HANDLE hPrevInstance,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; LPSTR&nbsp; lpszCmdLine,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int&nbsp;&nbsp;&nbsp; nCmdShow )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if( DefineDLLEntry( 1, (void *) FooMe1, DLL_WORD,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DLL_DWORD,
DLL_WORD, DLL_ENDLIST )) {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return( 0 );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if( DefineDLLEntry( 2, (void *) FooMe2, DLL_DWORD,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DLL_WORD,
DLL_ENDLIST ) ) {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return( 0 );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; MessageBox( NULL, &quot;32-bit DLL Started&quot;, DLL_ID, MB_OK );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return( 1 );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; }</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; #else&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
/* else we are doing a 16-bit DLL */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; BOOL FAR PASCAL LibMain( HANDLE hInstance,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; WORD wDataSegment,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; WORD wHeapSize,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; LPSTR lpszCmdLine )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; #if 0</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /*</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; We can't use MessageBox here since static binding is</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; used and a message queue has not been created by the</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; time DLL16 is loaded.</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; MessageBox( NULL, &quot;16-bit DLL Started&quot;, DLL_ID, MB_OK );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; #endif</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return( TRUE );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; }</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; #endif</TT>
<BR><BR>To create a 16-bit DLL from this code, the following steps must be performed.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; C&gt;wcc dll /mc /bt=windows /zu /fo=dll16</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; C&gt;wlink system windows_dll file dll16</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; C&gt;wlib -n dll16 +dll16.dll</TT>
<BR><BR>To create a 32-bit DLL from this code, the following steps must be performed.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; C&gt;wcc386 dll /bt=windows /fo=dll32</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; C&gt;wlink system win386 file dll32</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; C&gt;wbind -n -d dll32</TT>
<BR><BR>There are two entry points defined,<TT> FooMe1</TT> (index number 1) and<TT> FooMe2</TT> (index number 2).<TT>&nbsp;
FooMe1</TT> accepts three arguments:&nbsp; a WORD, a DWORD, and a WORD.<TT>&nbsp; FooMe2</TT> accepts two arguments:&nbsp;
a DWORD and a WORD.
<BR><BR><TT>WinMain</TT> returns zero to notify Windows that the DLL initialization failed, and returns a one if initialization
succeeds.
<BR><BR><TT>WinMain</TT> accepts the same arguments as the<TT> WinMain</TT> procedure of a regular Windows program, however,
only two arguments are used.<TT>&nbsp; hInstance</TT> is the DLL handle and<TT> lpszCmdLine</TT> is the command line passed
to the DLL.
<H2 ID="Windows__Calling_Functions_in_a_32Mbit_DLL_from_a_16Mbit_Application"> Windows:&nbsp; Calling Functions in a 32-bit DLL from a 16-bit Application </H2>
<BR>The following is a 16-bit Windows program that demonstrates how to call the two routines defined in our DLL example.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; /*</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; *&nbsp; EXE16.C</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; #include &lt;stdio.h&gt;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; #include &lt;windows.h&gt;</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; #define Add3 1</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; #define Add2 2</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; typedef long (FAR PASCAL *FPROC)();</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; typedef long (FAR PASCAL *FARPROC1)(WORD, DWORD, WORD, int);</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; typedef long (FAR PASCAL *FARPROC2)(DWORD, WORD, int);</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; long FAR PASCAL FooMe1( WORD, DWORD, WORD );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; long FAR PASCAL FooMe2( DWORD, WORD );</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; int PASCAL WinMain( HANDLE hInstance,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp; HANDLE hPrevInstance,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp; LPSTR&nbsp; lpszCmdLine,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp; int&nbsp;&nbsp;&nbsp; nCmdShow )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; FPROC fp;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; HANDLE hlib;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; long cb;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; char buff[128];</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; MessageBox( NULL, &quot;16-bit EXE Started&quot;, &quot;EXE16&quot;, MB_OK );</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* Do the 16-bit demo using static binding */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cb = FooMe1( 0x666, 0x77777111, 0x6969 );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; sprintf( buff, &quot;RC1 = %lx&quot;, cb );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; MessageBox( NULL, buff, &quot;EXE16&quot;, MB_OK );</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cb = FooMe2( 0x12345678, 0x8888 );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; sprintf( buff, &quot;RC2 = %lx&quot;, cb );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; MessageBox( NULL, buff, &quot;EXE16&quot;, MB_OK );</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* Do the 32-bit demo */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; hlib = LoadLibrary( &quot;dll32.dll&quot; );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; fp = (FPROC) GetProcAddress( hlib, &quot;Win386LibEntry&quot; );</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cb = (*(FARPROC1)fp)( 0x666, 0x77777111, 0x6969, Add3 );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; sprintf( buff, &quot;RC1 = %lx&quot;, cb );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; MessageBox( NULL, buff, &quot;EXE16&quot;, MB_OK );</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cb = (*(FARPROC2)fp)( 0x12345678, 0x8888, Add2 );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; sprintf( buff, &quot;RC2 = %lx&quot;, cb );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; MessageBox( NULL, buff, &quot;EXE16&quot;, MB_OK );</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return( 0 );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; }</TT>
<BR><BR>Note that the last argument of a call to the 32-bit DLL routine is the index number of the 32-bit DLL routine to use.
&nbsp;To create the 16-bit sample Windows executable from this code, the following steps must be performed.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; C&gt;wcc exe16 /bt=windows</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; C&gt;wlink system windows file exe16 library dll16</TT>
<H2 ID="Windows__Writing_a_16Mbit_Cover_for_the_32Mbit_DLL"> Windows:&nbsp; Writing a 16-bit Cover for the 32-bit DLL </H2>
<BR>The following is a suggested way to make a 32-bit DLL behave just like a 16-bit DLL from the point of view of the person
trying to use the DLL.
<BR><BR>Create a library of cover functions for each of the entry points.&nbsp; Each library entry would call the 32-bit DLL
using the appropriate index number.
<BR><BR>For example, assume we have 3 functions in our DLL,<TT> Initialize, DoStuff,</TT> and<TT> Finish.</TT>&nbsp; Assume<TT>
Initialize</TT> takes an integer,<TT> DoStuff</TT> takes an integer and a pointer, and<TT> Finish</TT> takes nothing.&nbsp;
We could build a 16-bit library as follows:
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; #include &lt;windows.h&gt;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; typedef long (FAR PASCAL *FPROC)();</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; extern long FAR PASCAL Win386LibEntry();</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; FPROC LibEntry = Win386LibEntry;</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; BOOL Initialize( int parm )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return( LibEntry( parm, 1 ) );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; }</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; int DoStuff( int parm1, LPVOID parm2 )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return( LibEntry( parm1, parm2, 2 ) );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; }</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; void Finish( void )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; LibEntry( 3 );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; }</TT>
<H2 ID="Windows__Creating_and_Debugging_Dynamic_Link_Libraries"> Windows:&nbsp; Creating and Debugging Dynamic Link Libraries </H2>
<BR>In the following sections, we will take you through the steps of compiling, linking, and debugging both 16-bit and 32-bit
Dynamic Link Libraries (DLLs).
<BR><BR>We will use example programs that are provided in source-code form in the Open Watcom C/C++ package.&nbsp; The files
described in this chapter are located in the directory<TT> \WATCOM\SAMPLES\DLL.</TT>&nbsp; The following files are provided:
<DL>
<DT>GEN16.C
<DD>is the source code for a generic 16-bit Windows application that calls functions in a 32-bit Windows DLL.
<DT>GEN16.LNK
<DD>is the linker directive file for linking the 16-bit Windows application.
<DT>GEN32.C
<DD>is the source code for a generic 32-bit Windows application that calls functions in both 16-bit and 32-bit Windows DLLs.
<DT>GEN32.LNK
<DD>is the linker directive file for linking the 32-bit Windows application.
<DT>DLL16.C
<DD>is the source code for a simple 16-bit DLL containing one library routine.
<DT>DLL16.LNK
<DD>is the linker directive file for linking the 16-bit Windows DLL.
<DT>DLL32.C
<DD>is the source code for a more complex 32-bit DLL containing three library routines.
<DT>DLL32.LNK
<DD>is the linker directive file for linking the 32-bit Windows DLL.
<DT>EXE16.C
<DD>is the source code for a generic 16-bit Windows application that calls functions in both 16-bit and 32-bit Windows DLLs.
<DT>DLL.C
<DD>is the source code for a DLL containing three library routines.&nbsp; The source code for this DLL can be used to create both
16-bit and 32-bit DLLs.
<DT>MAKEFILE
<DD>is a makefile for compiling and linking the programs described above.
</DL>
<H3 ID="Windows__Building_the_Applications"> Windows:&nbsp; Building the Applications </H3>
<BR>To create the DLLs and test applications, we will use the WATCOM Open Watcom Make utility and the supplied makefile.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; C&gt;wmake -f makefile</TT>
<H3 ID="Windows__Installing_the_Examples_under_Windows"> Windows:&nbsp; Installing the Examples under Windows </H3>
<BR>Start up Microsoft Windows 3.x if you have not already done so.&nbsp; Add the<TT> EXE16.EXE</TT> file to one of your Window
groups using the Microsoft Program Manager.
<OL>
<LI>Select the &quot;New...&quot; entry from the &quot;File&quot; menu of the Microsoft Windows Program Manager.
<LI>Select &quot;Program Item&quot; from the &quot;New Program Object&quot; window and press the &quot;OK&quot; button.
<LI>Enter &quot;DLL Test&quot; as a description for the EXE16 program.&nbsp; Enter the full path to the EXE16 program as a
command line.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Description:&nbsp;&nbsp;&nbsp; Test</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Command Line:&nbsp;&nbsp; c:\work\dll\exe16.exe</TT>
</OL>
<H3 ID="Windows__Running_the_Examples"> Windows:&nbsp; Running the Examples </H3>
<BR>Start the 16-bit application by double clicking on its icon.&nbsp; A number of message boxes are presented.&nbsp; You
may wish to compare the output in each message box with the source code of the program to determine if the correct results
are being obtained.&nbsp; Click on the &quot;OK&quot; button as each of them are displayed.
<H3 ID="Windows__Debugging_a_32Mbit_DLL"> Windows:&nbsp; Debugging a 32-bit DLL </H3>
<BR>The Open Watcom Debugger can be used to debug a DLL.&nbsp; To debug a 32-bit DLL, a &quot;breakpoint&quot; instruction
must be inserted into the source code for the DLL at the &quot;WinMain&quot; entry point.&nbsp; This is done using the &quot;pragma&quot;
compiler directive.&nbsp; We have already added the breakpoint to the source code for the 32-bit DLL.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; extern void BreakPoint( void );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; #pragma aux BreakPoint = 0xcc;</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; int PASCAL WinMain( HANDLE hInstance,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp; HANDLE x1,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp; LPSTR lpCmdLine,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp; int x2 )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; {</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; BreakPoint();</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DefineDLLEntry( 1, (void *) Lib1,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DLL_WORD,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DLL_DWORD,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DLL_WORD,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;.</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;.</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;.</TT>
<BR><BR>Start up Microsoft Windows 3.x if you have not already done so.&nbsp; Start the debugger by double-clicking on the
Open Watcom Debugger icon.&nbsp; At the prompt, enter the path specification for the application.&nbsp; When the debugger
has successfully loaded EXE16, start execution of the program.&nbsp; When the breakpoint is encountered in the 32-bit DLL,
the debugger is re-entered.&nbsp; The debugger will automatically skip past the breakpoint.
<BR><BR>From this point on, you can symbolically debug the 32-bit DLL.&nbsp; You might, for example, set breakpoints at the
start of each DLL routine to debug each of them as they are called.
<H3 ID="Windows__Summary"> Windows:&nbsp; Summary </H3>
<BR>Note that the &quot;WinMain&quot; entry point is only called once, at the start of any application requesting it.&nbsp;
After this, the &quot;WinMain&quot; entry point is no longer called.&nbsp; You may have to restart Windows to debug this section
of code a second or third time.
<H1 ID="Windows__Interfacing_Visual_Basic_and_Open_Watcom_CDCPP_DLLs"> Windows:&nbsp; Interfacing Visual Basic and Open Watcom C/C++ DLLs </H1>
<BR>This chapter describes how to interface Microsoft Visual Basic 3.0 applications and 32-bit Dynamic Link Libraries (DLLs)
created by Open Watcom C/C++.&nbsp; It describes how to write functions for a 32-bit DLL, how to compile and link them, and
how to call these functions from Visual Basic.&nbsp; One of the proposed techniques involves the use of a set of cover functions
in a 16-bit DLL so, indirectly, this chapter also describes interfacing to 16-bit DLLs.
<BR><BR>It is possible to invoke the<TT> Win386LibEntry</TT> function (Open Watcom's 32-bit function entry point, described
below) directly from Visual Basic.&nbsp; However, this technique limits the arguments that can be passed to a 32-bit DLL.
&nbsp;The procedure and problems are explained below.
<BR><BR>To work around the problem, a 16-bit DLL can be created, that covers the 32-bit DLL.&nbsp; Within the 16-bit DLL,
we will place cover functions that will call the corresponding 32-bit function in the 32-bit DLL.&nbsp; We illustrate the
creation of the 16-bit DLL using the 16-bit C compiler in Open Watcom C/C++.
<BR><BR>Before we begin our example, there are some important technical issues to consider.
<BR><BR>The discussion in this chapter assumes that you, the developer, have a working knowledge of Visual Basic, including
how to bring up the general declarations screen, how to create command buttons, and how to associate code with command buttons.
&nbsp;You must use Visual Basic 3.0 or later.&nbsp; Visual Basic Version 2.x will not work because of a deficiency in this
product regarding the calling of functions in DLLs.
<BR><BR>For the purposes of the following discussion, you should have installed both the 16-bit and 32-bit versions of Open
Watcom C/C++, as well as version 3.0 or later of Visual Basic.&nbsp; Ensure that the<B> PATH,</B> <B> INCLUDE</B> and<B> WINDOWS_INCLUDE</B>
environment variables are defined to include at least the directories indicated.&nbsp; We have assumed that Open Watcom C/C++
is installed in the<TT> c:\watcom</TT> directory, and Visual Basic is in the<TT> c:\vb</TT> directory:
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; set path=c:\watcom\binw;c:\vb;c:\dos;c:\windows</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; set include=c:\watcom\h</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; set windows_include=c:\watcom\h\win</TT>
<BR><BR>Open Watcom's 32-bit DLL supervisor contains a general entry point for Windows applications to call into called<TT>
Win386LibEntry.</TT>&nbsp; It also contains 128 specific entry points called<TT> DLL1</TT> to<TT> DLL128</TT> which correspond
to the entry points established via<TT> DefineDLLEntry</TT> (the first argument to<TT> DefineDLLEntry</TT> is an index number
in the range 1 to 128).&nbsp; All applications call into the 32-bit DLL via these entry points.&nbsp; They build the necessary
stack frame and switch to the 32-bit DLL's data space.
<BR><BR>If you call via<TT> Win386LibEntry</TT> then you pass the DLL entry point number or index (1 to 128) as the last argument.<TT>
&nbsp;Win386LibEntry</TT> uses this index number to call the appropriate 32-bit DLL routine.
<BR><BR>In many languages and programs (such as C and Microsoft Excel), function calls are very flexible.&nbsp; In other words,
a function can be called with different argument types each time.&nbsp; This is generally necessary for calling<TT> Win386LibEntry</TT>
in a 32-bit extended DLL function.&nbsp; The reason is that this function takes the same arguments as the function being called,
as well as the index number of the called function.&nbsp; After the 32-bit flat model has been set up,<TT> Win386LibEntry</TT>
then calls this function.&nbsp; In Visual Basic, once a function is declared as having certain arguments, it cannot be redeclared.
&nbsp;For example, suppose we have a declaration as follows:
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Declare Function Win386LibEntry Lib &quot;c:\path\vbdll32.dll&quot;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; =&gt; (ByVal v1 As Integer, ByVal v2 As Long, ByVal</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; =&gt; v3 As Integer, ByVal I As Integer) As Long</TT>
<BR><BR>(Note:&nbsp; the =&gt; means to continue the statement on the same line.) In this example, we could only call a function
in any 32-bit extended DLL with a 16-bit integer as the first and third argument, and a 32-bit integer as the second argument.
&nbsp;There are three ways to work around this deficiency in Visual Basic:
<OL>
<LI>Use the Visual Basic &quot;Alias&quot; attribute to declare<TT> Win386LibEntry</TT> differently for each DLL routine.
&nbsp;Reference the different DLL routines using these aliases.
<LI>Use the specific entry point, one of<TT> DLL1</TT> through<TT> DLL128,</TT> corresponding to the DLL routine that you
want to call.&nbsp; Each entry point can be described to take different arguments.&nbsp; We can still use the &quot;Alias&quot;
attribute to make the link between the name we use in the Visual Basic function and the name in the 32-bit extended DLL.&nbsp;
This is the method that we will use in the &quot;Direct Call&quot; technique discussed below.&nbsp; It is simpler to use since
it requires one less argument (you don't require the index number).
<LI>Use a method which involves calling functions in a 16-bit &quot;cover&quot; DLL written in a flexible-argument language,
which then calls the functions in the 32-bit DLL.&nbsp; This is the &quot;Indirect Call&quot; method discussed below.
</OL>
<H2 ID="Windows__A_Working_Example"> Windows:&nbsp; A Working Example </H2>
<BR>The best way to demonstrate these techniques is through an example.&nbsp; This example consists of a Visual Basic application
with 3 push buttons.&nbsp; The first push button invokes a direct call to a 32-bit DLL which will display a message window
with its arguments, the second push button invokes an indirect call to the same function through a 16-bit DLL, and the third
button exits the Visual Basic application.
<DL>
<DT>To create a Visual Basic application:
<DD>
<DT>(1)
<DD><B> Start up a new project folder</B> from the &quot;File&quot; menu.
<DT>(2)
<DD><B> Select &quot;View Form&quot;</B> from the &quot;Project&quot; window.
<DT>(3)
<DD><B> Draw three command buttons</B> on the form by selecting command buttons from the &quot;Toolbox&quot; window.
<DT>(4)
<DD><B> Change the caption on each button.</B>&nbsp; To do this, highlight the first button.&nbsp; Then, open the &quot;Properties&quot;
window.&nbsp; Double click on the &quot;Caption window&quot;, and change the caption to &quot;Direct call&quot;.&nbsp; Highlight
the second button, and change its caption to &quot;Indirect call&quot;.&nbsp; Highlight the third, changing the caption to
&quot;Exit&quot;.
<BR><BR>Now, your Visual Basic application should have three push buttons, &quot;Direct call&quot;, &quot;Indirect call&quot;,
and &quot;Exit&quot;.
<DT>(5)
<DD><B> Double click on the &quot;Direct Call&quot; button.</B>
<BR><BR>An edit window will pop up.&nbsp; Enter the following code:
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Sub Command1_Click ()</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Dim var1, var2 As Integer</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Dim varlong, worked As Long</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; var1 = 230</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; varlong = 215</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; var2 = 32</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; worked = Add3(var1, varlong, var2)</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Print worked</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; worked = Add2(varlong, var2)</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Print worked</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; End Sub</TT>
<DT>(6)
<DD><B> Double click on the &quot;Indirect Call&quot; button.</B>
<BR><BR>Another edit window will pop up.&nbsp; Enter the following code:
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Sub Command2_Click ()</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Dim var1, var2 As Integer</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Dim varlong, worked As Long</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; var1 = 230</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; varlong = 215</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; var2 = 32</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; worked = Function1( var1, varlong, var2 )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Print worked</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; worked = Function2( varlong, var2 )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Print worked</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; End Sub</TT>
<DT>(7)
<DD><B> Double click on the &quot;Exit&quot; command button</B> and enter the following code in the pop-up window:
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Sub Command3_Click ()</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; End</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; End Sub</TT>
<DT>(8)
<DD><B> Select &quot;View Code&quot;</B> from the &quot;Project&quot; window.&nbsp; To interface these Visual Basic functions
to the DLLs, the following code is needed in the
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Object: [general] Proc: [declarations]</TT>
<BR><BR>section of the code.&nbsp; This code assumes that<TT> VBDLL32.DLL</TT> and<TT> COVER16.DLL</TT> are in the<TT> c:\path</TT>
directory.&nbsp; Modify the pathnames appropriately if this is not the case.&nbsp; (Note:&nbsp; the =&gt; means to continue
the statement on the same line.)
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Declare Function Function1 Lib &quot;c:\path\cover16.dll&quot;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; =&gt; (ByVal v1 As Integer, ByVal v2 As Long,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; =&gt; ByVal v3 As Integer) As Long</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Declare Function Function2 Lib &quot;c:\path\cover16.dll&quot;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; =&gt; (ByVal v1 As Long, ByVal v2 As Integer) As Long</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Declare Function Add3 Lib &quot;c:\path\vbdll32.dll&quot;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; =&gt; Alias &quot;DLL1&quot;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; =&gt; (ByVal v1 As Integer, ByVal v2 As Long,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; =&gt; ByVal v3 As Integer) As Long</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Declare Function Add2 Lib &quot;c:\path\vbdll32.dll&quot;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; =&gt; Alias &quot;DLL2&quot;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; =&gt; (ByVal v1 As Long, ByVal v2 As Integer) As Long</TT>
</DL>
<BR>Now, when all of the code below is compiled correctly, and the Visual Basic program is run, the &quot;Direct call&quot;
button will call the<TT> DLL1</TT> and<TT> DLL2</TT> functions directly, aliased as the functions<TT> Add3</TT> and<TT> Add2</TT>
respectively.&nbsp; The &quot;Indirect call&quot; button will call the 16-bit DLL, which will then call the 32-bit DLL, for
both<TT> Function1</TT> and<TT> Function2.</TT>&nbsp; To run the Visual Basic program, select &quot;Start&quot; from the &quot;Run&quot;
menu.
<H2 ID="Windows__Sample_Visual_Basic_DLL_Programs"> Windows:&nbsp; Sample Visual Basic DLL Programs </H2>
<BR>The sample programs provided below are for a 32-bit DLL, and a 16-bit cover DLL, which will call the two functions contained
in the 32-bit DLL.
<H3 ID="Windows__Source_Code_for_VBDLL32_DLL"> Windows:&nbsp; Source Code for VBDLL32.DLL </H3>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; /*</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; *&nbsp; VBDLL32.C</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; #include &lt;stdio.h&gt;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; #include &lt;windows.h&gt;&nbsp;&nbsp;&nbsp; /* required for all Windows applications */</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; long FAR PASCAL Add3( short var1, long varlong, short var2 )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; char buf[128];</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; sprintf( buf, &quot;Add3: var1=%d, varlong=%ld, var2=%d&quot;,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;var1, varlong, var2 );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; MessageBox( NULL, buf, &quot;VBDLL32&quot;, MB_OK | MB_TASKMODAL );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return( var1 + varlong + var2 );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; }</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; long FAR PASCAL Add2( long varlong, short var2 )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; char buf[128];</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; sprintf( buf, &quot;Add2: varlong=%ld, var2=%d&quot;, varlong, var2 );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; MessageBox( NULL, buf, &quot;VBDLL32&quot;, MB_OK | MB_TASKMODAL );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return( varlong + var2 );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; }</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; #pragma off (unreferenced);</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; int PASCAL WinMain(HANDLE hInstance, HANDLE x1, LPSTR lpCmdLine, int x2)</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; #pragma on (unreferenced);</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DefineDLLEntry( 1, (void *) Add3, DLL_WORD, DLL_DWORD, DLL_WORD,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DLL_ENDLIST );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DefineDLLEntry( 2, (void *) Add2, DLL_DWORD, DLL_WORD, DLL_ENDLIST );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return( 1 );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; }</TT>
<H3 ID="Windows__Source_code_for_COVER16_DLL"> Windows:&nbsp; Source code for COVER16.DLL </H3>
<BR>The functions in this 16-bit DLL will call the functions in the 32-bit DLL,<TT> VBDLL32.DLL,</TT> shown above, with the
appropriate<TT> Win386LibEntry</TT> call for each function.
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; /*</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; *&nbsp; COVER16.C</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; */</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; #include &lt;stdio.h&gt;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; #include &lt;windows.h&gt;&nbsp;&nbsp;&nbsp; /* required for all Windows applications */</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; typedef long (FAR PASCAL *FPROC)();</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; FPROC DLL_1;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; FPROC DLL_2;</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; long FAR PASCAL __export Function1( short var1,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; long
var2,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; short
var3 )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return( (long) DLL_1( var1, var2, var3 ) );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; }</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; long FAR PASCAL __export Function2( long var1, short var2 )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return( (long) DLL_2( var1, var2 ) );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; }</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; #pragma off (unreferenced);</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; BOOL FAR PASCAL LibMain( HANDLE hInstance, WORD wDataSegment,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; WORD wHeapSize, LPSTR lpszCmdLine )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; #pragma on (unreferenced);</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; HANDLE hlib;</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* Do our DLL initialization */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; hlib = LoadLibrary( &quot;vbdll32.dll&quot; );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if( hlib &lt; 32 ) {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; MessageBox( NULL,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp; &quot;Make sure your PATH contains VBDLL32.DLL&quot;,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp; &quot;COVER16&quot;, MB_OK | MB_ICONEXCLAMATION );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return( FALSE );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DLL_1 = (FPROC) GetProcAddress( hlib, &quot;DLL1&quot; );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DLL_2 = (FPROC) GetProcAddress( hlib, &quot;DLL2&quot; );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return( TRUE );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; }</TT>
<H2 ID="Windows__Compiling_and_Linking_the_Examples"> Windows:&nbsp; Compiling and Linking the Examples </H2>
<BR>To create the 32-bit DLL<TT> VBDLL32.DLL,</TT> type the following at the command line (make sure that<TT> VBDLL32.c</TT>
is in your current directory):
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; wcl386 vbdll32 -bt=windows -bd -d2 -l=win386</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; wbind vbdll32 -d -n</TT>
<BR><BR>To create the 16-bit DLL<TT> COVER16.DLL,</TT> type the following at the command line (make sure that<TT> COVER16.C</TT>
are in your current directory):
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; wcl cover16 -mc -bt=windows -bd -zu -d2 -l=windows_dll</TT>
<BR><BR><B>Notes:</B>
<OL>
<LI>The &quot;mc&quot; option selects the compact memory model (small code, big data).&nbsp; The code for 16-bit DLLs must
be compiled with one of the big data models.
<LI>The &quot;bd&quot; option indicates that a DLL will be created from the object files.
<LI>The &quot;bt&quot; option selects the &quot;windows&quot; target.&nbsp; This option causes the C or C++ compiler to generate
Windows prologue/epilogue code sequences which are required for Microsoft Windows applications.&nbsp; It also causes the compiler
to use the<B> WINDOWS_INCLUDE</B> environment variable for header file searches.&nbsp; It also causes the compiler to define
the macro<TT> __WINDOWS__</TT> and, for the 32-bit C or C++ compiler only, the macro<TT> __WINDOWS_386__</TT> .
<LI>The &quot;zu&quot; option is used when compiling 16-bit code that is to be placed in a Dynamic Link Library (DLL) since
the SS register points to the stack segment of the calling application upon entry to the function.
<LI>The &quot;d2&quot; option is used to disable optimizations and include debugging information in the object file and DLL.
&nbsp;The techniques for debugging DLLs are described in the chapter entitled <A HREF="#Windows__Windows_32MBit_Dynamic_Link_Libraries">Windows:&nbsp; Windows 32-Bit Dynamic Link Libraries</A>.
</OL>
<BR>You are now ready to run the Visual Basic application.
<H1 ID="Windows__WIN386_Library_Functions_and_Macros"> Windows:&nbsp; WIN386 Library Functions and Macros </H1>
<BR>Each special Windows function or macro in the Open Watcom C/C++ library is described in this chapter.&nbsp; Each description
consists of a number of subsections:
<DL>
<DT>Synopsis:
<DD>This subsection gives the header files that should be included within a source file that references the function or macro.
&nbsp;It also shows an appropriate declaration for the function or for a function that could be substituted for a macro.&nbsp;
This declaration is not included in your program; only the header file(s) should be included.
<BR><BR>When a pointer argument is passed to a function and that function does not modify the item indicated by that pointer,
the argument is shown with <TT> const</TT> before the argument.&nbsp; For example,
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; const char *string</TT>
<BR><BR>indicates that the array pointed at by<B> string</B> is not changed.
<DT>Description:
<DD>This subsection is a description of the function or macro.
<DT>Returns:
<DD>This subsection describes the return value (if any) for the function or macro.
<DT>Errors:
<DD>This subsection describes the possible <TT> errno</TT> values.
<DT>See Also:
<DD>This optional subsection provides a list of related functions or macros.
<DT>Example:
<DD>This optional subsection consists of one or more examples of the use of the function.&nbsp; The examples are often just fragments
of code (not complete programs) for illustration purposes.
<DT>Classification:
<DD>This subsection provides an indication of where the function or macro is commonly found.&nbsp; The functions or macros in
this section are all classified as &quot;WIN386&quot; (i.e., they pertain to 32-bit Windows programming).
</DL>
<H2 ID="AllocAlias16"> Windows:&nbsp; AllocAlias16 </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;windows.h&gt;</TT>
<BR><TT>DWORD AllocAlias16( void *ptr );</TT>
</DL>
<DL>
<DT>Description:
<DD>The AllocAlias16 function obtains a 16-bit far pointer equivalent of a 32-bit near pointer.&nbsp; These pointers are used
when passing data pointers to Windows through functions that have DWORD arguments, and for any pointers within data structures
passed this way.
</DL>
<DL>
<DT>Returns:
<DD>The AllocAlias16 function returns a 16-bit far pointer usable by Windows, or returns 0 if the alias cannot be allocated.
</DL>
<DL>
<DT>See Also:
<DD><A HREF="#FreeAlias16">FreeAlias16</A>
</DL>
<DL>
<DT>Example:
<DD>
<BR><TT>#include &lt;windows.h&gt;</TT>
<BR><BR><TT>&nbsp; DWORD mcs_16;</TT>
<BR><TT>&nbsp; /*</TT>
<BR><TT>&nbsp;&nbsp; * Send a message to a MDI client to create a window.</TT>
<BR><TT>&nbsp;&nbsp; * _16SendMessage is used for this example, since it will</TT>
<BR><TT>&nbsp;&nbsp; * not do any pointer conversions automatically.</TT>
<BR><TT>&nbsp;&nbsp; */</TT>
<BR><TT>&nbsp; MDICREATESTRUCT mcs;</TT>
<BR><TT>&nbsp; mcs.szTitle = (LPSTR) AllocAlias16( &quot;c:\\foo.bar&quot; );</TT>
<BR><TT>&nbsp; mcs.szClass = (LPSTR) AllocAlias16( &quot;mdichild&quot; );</TT>
<BR><TT>&nbsp; mcs.hOwner&nbsp; = hInst;</TT>
<BR><TT>&nbsp; mcs.x = mcs.cx = (int) CW_USEDEFAULT;</TT>
<BR><TT>&nbsp; mcs.y = mcs.cy = (int) CW_USEDEFAULT;</TT>
<BR><TT>&nbsp; mcs.style = 0;</TT>
<BR><BR><TT>&nbsp; /* tell the MDI Client to create the child */</TT>
<BR><TT>&nbsp; mcs_16 = AllocAlias16( &amp;mcs );</TT>
<BR><TT>&nbsp; hwnd = (WORD) _16SendMessage( hwndMDIClient,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; WM_MDICREATE,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (LONG) mcs_16 );</TT>
<BR><TT>&nbsp; FreeAlias16( mcs_16 );</TT>
<BR><TT>&nbsp; FreeAlias16( (DWORD) mcs.szClass );</TT>
<BR><TT>&nbsp; FreeAlias16( (DWORD) mcs.szTitle );</TT>
</DL>
<DL>
<DT>Classification:
<DD>WIN386
</DL>
<H2 ID="AllocHugeAlias16"> Windows:&nbsp; AllocHugeAlias16 </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;windows.h&gt;</TT>
<BR><TT>DWORD AllocHugeAlias16( void *ptr, DWORD size );</TT>
</DL>
<DL>
<DT>Description:
<DD>The AllocHugeAlias16 function obtains a 16-bit far pointer to a 32-bit memory object that is<B> size</B> bytes in size.&nbsp;
This is similar to the function <TT> AllocAlias16</TT>, except that <TT> AllocAlias16</TT> will only give 16-bit far pointers
to 32-bit memory objects of up to 64K in size.&nbsp; To get 16-bit far pointers to 32-bit memory objects larger than 64K,
<TT> AllocHugeAlias16</TT> should be used.
</DL>
<DL>
<DT>Returns:
<DD>The AllocHugeAlias16 function returns a 16-bit far pointer usable by Windows, or returns 0 if the alias cannot be allocated.
</DL>
<DL>
<DT>See Also:
<DD><A HREF="#AllocAlias16">AllocAlias16</A>, <A HREF="#FreeAlias16">FreeAlias16</A>, <A HREF="#FreeHugeAlias16">FreeHugeAlias16</A>
</DL>
<DL>
<DT>Example:
<DD>
<BR><TT>#include &lt;windows.h&gt;</TT>
<BR><TT>#include &lt;malloc.h&gt;</TT>
<BR><TT>#define SIZE 300000</TT>
<BR><BR><TT>&nbsp; DWORD alias;</TT>
<BR><TT>&nbsp; void *tmp;</TT>
<BR><BR><TT>&nbsp; tmp = malloc( SIZE );</TT>
<BR><TT>&nbsp; alias = AllocHugeAlias16( tmp, SIZE );</TT>
<BR><BR><TT>&nbsp; /* Windows calls using the alias ... */</TT>
<BR><BR><TT>&nbsp; FreeHugeAlias16( alias, SIZE );</TT>
</DL>
<DL>
<DT>Classification:
<DD>WIN386
</DL>
<H2 ID="_Call16"> Windows:&nbsp; _Call16 </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;windows.h&gt;</TT>
<BR><TT>DWORD _Call16( FARPROC lpFunc, char *fmt, ... );</TT>
</DL>
<DL>
<DT>Description:
<DD>The _Call16 function performs the same function as <TT> GetIndirectFunctionHandle</TT>, <TT> InvokeIndirectFunctionHandle</TT>
and <TT> FreeIndirectFunctionHandle</TT> but is much easier to use.&nbsp; The first argument<B> lpFunc</B> is the address
of the 16-bit function to be called.&nbsp; This address is usually obtained by calling <TT> GetProcAddress</TT> with the name
of the desired function.&nbsp; The second argument<TT> fmt</TT> is a string identifying the types of the parameters to be
passed to the 16-bit function.
<DL>
<DT><B><I>Character</I></B>
<DD><B><I>Parameter Type</I></B>
<DT>c
<DD>call a 'cdecl' function as opposed to a 'pascal' function (if specified, it must be listed first)
<DT>b
<DD>unsigned BYTE
<DT>w
<DD>16-bit WORD
<DT>d
<DD>32-bit DWORD
<DT>f
<DD>double precision floating-point
<DT>p
<DD>32-bit flat pointer (converted to 16:16 far pointer)
</DL>
<BR>The 16-bit function must use either the <TT> PASCAL</TT> or <TT> CDECL</TT> calling convention.&nbsp; <TT> PASCAL</TT>
calling convention is the default.&nbsp; If the function uses the <TT> CDECL</TT> calling convention, then you must specify
the letter &quot;c&quot; as the first character of the argument type string.
<BR><BR>Pointer types will automatically be converted from 32-bit near pointers to 16-bit far pointers before the function
is invoked.&nbsp; Note that this pointer is only valid over the period of the call; after control returns to the 32-bit application,
the 16-bit pointer created by the Supervisor is no longer valid.
</DL>
<DL>
<DT>Returns:
<DD>The _Call16 function returns a 32-bit DWORD which represents the return value from the 16-bit function that was called.
</DL>
<DL>
<DT>See Also:
<DD><A HREF="#GetIndirectFunctionHandle">GetIndirectFunctionHandle</A>, <A HREF="#FreeIndirectFunctionHandle">FreeIndirectFunctionHandle</A>
</DL>
<DL>
<DT>Example:
<DD>
<BR><TT>#include &lt;windows.h&gt;</TT>
<BR><TT>HANDLE hDrv;</TT>
<BR><TT>FARPROC lpfn;</TT>
<BR><TT>int cb;</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp; if( (hDrv = LoadLibrary (&quot;foo.dll&quot;)) &lt; 32 )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return FALSE;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; if( !(lpfn = GetProcAddress (hDrv, &quot;ExtDeviceMode&quot;)) )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return FALSE;</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp; /*</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; * now, invoke the function</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; cb = (WORD) _Call16(</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; lpfn,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // address of function</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &quot;wwdppddw&quot;,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp; // parameter type info</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; hwnd,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // parameters ...</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; hDrv,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; NULL,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &quot;POSTSCRIPT PRINTER&quot;,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &quot;LPT1&quot;,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; NULL,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; NULL,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; );</TT>
</DL>
<DL>
<DT>Classification:
<DD>WIN386
</DL>
<H2 ID="DefineDLLEntry"> Windows:&nbsp; DefineDLLEntry </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;windows.h&gt;</TT>
<BR><TT>int DefineDLLEntry( int index, void * routine, ... );</TT>
</DL>
<DL>
<DT>Description:
<DD>The DefineDLLEntry function defines an<B> index</B> number for the 32-bit DLL procedure<B> routine</B>.&nbsp; The parameter<B>
index</B> defines the index number that must be used in order to invoke the 32-bit FAR procedure<B> routine</B>.&nbsp; The
variable argument list defines the types of parameters that will be received by the 32-bit DLL<B> routine</B>.&nbsp; Valid
parameter types are:
<DL>
<DT>DLL_PTR
<DD>16-bit far pointer
<DT>DLL_DWORD
<DD>32-bits
<DT>DLL_WORD
<DD>16-bits
<DT>DLL_CHAR
<DD>8-bits
<DT>DLL_ENDLIST
<DD>Marks the end of the variable argument list.
</DL>
<BR>Note that all pointers are received as 16-bit far pointers.&nbsp; To access the data from the 32-bit DLL, the <TT> MK_FP32</TT>
macro must be applied.&nbsp; The data can then be accessed with the resulting 32-bit far pointer.
</DL>
<DL>
<DT>Returns:
<DD>The DefineDLLEntry function returns zero if successful, and a non-zero value otherwise.
</DL>
<DL>
<DT>Example:
<DD>
<BR><TT>#include &lt;windows.h&gt;</TT>
<BR><TT>int FAR PASCAL FooMe( WORD w1, DWORD w2, WORD w3 )</TT>
<BR><TT>{</TT>
<BR><TT>&nbsp; char str[128];</TT>
<BR><BR><TT>&nbsp; sprintf( str, &quot;w1=%hx, w2=%lx, w3=%hx&quot;, w1, w2, w3 );</TT>
<BR><TT>&nbsp; MessageBox( NULL, str, &quot;DLL Test&quot;, MB_OK );</TT>
<BR><TT>&nbsp; return( w1 + w2 );</TT>
<BR><TT>}</TT>
<BR><BR><TT>int PASCAL WinMain( HANDLE hInstance, HANDLE x1,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; LPSTR lpCmdLine, int x2 )</TT>
<BR><TT>{</TT>
<BR><TT>&nbsp; DefineDLLEntry( 1, (PROCPTR) FooMe, DLL_WORD,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DLL_DWORD,
DLL_WORD, DLL_ENDLIST );</TT>
<BR><TT>&nbsp; MessageBox( NULL, &quot;32-bit DLL Started&quot;, &quot;Test&quot;, MB_OK );</TT>
<BR><TT>&nbsp; return( 1 );</TT>
<BR><TT>}</TT>
</DL>
<DL>
<DT>Classification:
<DD>WIN386
</DL>
<H2 ID="DefineUserProc16"> Windows:&nbsp; DefineUserProc16 </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;windows.h&gt;</TT>
<BR><TT>int DefineUserProc16( int typ, PROCPTR routine, ... );</TT>
</DL>
<DL>
<DT>Description:
<DD>The DefineUserProc16 function defines the arguments accepted by the user defined callback procedure<B> routine</B>.&nbsp;
There may be up to 32 user defined callbacks.&nbsp; The parameter<B> typ</B> indicates which one of <TT> GETPROC_USERDEFINED_1</TT>
through <TT> GETPROC_USERDEFINED_32</TT> is being defined (see <TT> GetProc16</TT>).&nbsp; The callback routine must be declared
as FAR PASCAL, or as FAR cdecl.&nbsp; The variable argument list defines the types of parameters that will be received by
the user defined callback procedure<B> routine</B>.&nbsp; Valid parameter types are:
<DL>
<DT>UDP16_PTR
<DD>16-bit far pointer
<DT>UDP16_DWORD
<DD>32-bits
<DT>UDP16_WORD
<DD>16-bits
<DT>UDP16_CHAR
<DD>8-bits
<DT>UDP16_CDECL
<DD>callback routine will be declared as type <TT> cdecl</TT> rather than as type <TT> PASCAL</TT>.&nbsp; This keyword may be
placed anywhere before the <TT> UDP16_ENDLIST</TT> keyword.
<DT>UDP16_ENDLIST
<DD>Marks the end of the variable argument list.
</DL>
<BR>Once the DefineUserProc16 function has been used to declare the user callback routine, then <TT> GetProc16</TT> may be
used to get a 16-bit function pointer that may be used by Windows.
</DL>
<DL>
<DT>Returns:
<DD>The DefineUserProc16 function returns zero if it succeeds; and non-zero if it fails.
</DL>
<DL>
<DT>See Also:
<DD><A HREF="#GetProc16">GetProc16</A>
</DL>
<DL>
<DT>Example:
<DD>
<BR><TT>#include &lt;windows.h&gt;</TT>
<BR><BR><TT>WORD FAR PASCAL Test( DWORD a, WORD b )</TT>
<BR><TT>{</TT>
<BR><TT>&nbsp; char foo[128];</TT>
<BR><BR><TT>&nbsp; sprintf( foo, &quot;a=%lx, b=%hx&quot;, a, b );</TT>
<BR><TT>&nbsp; MessageBox( NULL, foo, &quot;TEST&quot;, MB_OK );</TT>
<BR><TT>&nbsp; return( 0x123 );</TT>
<BR><TT>}</TT>
<BR><BR><TT>int DefineTest( void )</TT>
<BR><TT>{</TT>
<BR><TT>&nbsp; FARPROC cb;</TT>
<BR><BR><TT>&nbsp; DefineUserProc16( GETPROC_USERDEFINED_1,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
(PROCPTR) Test,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
UDP16_DWORD,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
UDP16_WORD,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
UDP16_ENDLIST );</TT>
<BR><BR><TT>&nbsp; cb = GetProc16( (PROCPTR) Test, GETPROC_USERDEFINED_1 );</TT>
<BR><BR><TT>&nbsp; /*</TT>
<BR><TT>&nbsp;&nbsp; * cb may then be used whenever a pointer to the</TT>
<BR><TT>&nbsp;&nbsp; * callback is required by 16-bit Windows</TT>
<BR><TT>&nbsp;&nbsp; */</TT>
<BR><TT>}</TT>
</DL>
<DL>
<DT>Classification:
<DD>WIN386
</DL>
<H2 ID="FreeAlias16"> Windows:&nbsp; FreeAlias16 </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;windows.h&gt;</TT>
<BR><TT>void FreeAlias16( DWORD fp16 );</TT>
</DL>
<DL>
<DT>Description:
<DD>FreeAlias16 frees a 16-bit far pointer alias for a 32-bit near pointer that was allocated with <TT> AllocAlias16</TT>.&nbsp;
This is important to do when there is no further use for the pointer since there are a limited number of 16-bit aliases available
(due to limited space in the local descriptor table).
</DL>
<DL>
<DT>Returns:
<DD>The FreeAlias16 function returns nothing.
</DL>
<DL>
<DT>See Also:
<DD><A HREF="#AllocAlias16">AllocAlias16</A>
</DL>
<DL>
<DT>Example:
<DD>
<BR><TT>#include &lt;windows.h&gt;</TT>
<BR><BR><TT>&nbsp; DWORD mcs_16;</TT>
<BR><TT>&nbsp; /*</TT>
<BR><TT>&nbsp;&nbsp; * Send a message to a MDI client to create a window.</TT>
<BR><TT>&nbsp;&nbsp; * _16SendMessage is used for this example, since it will</TT>
<BR><TT>&nbsp;&nbsp; * not do any pointer conversions automatically.</TT>
<BR><TT>&nbsp;&nbsp; */</TT>
<BR><TT>&nbsp; MDICREATESTRUCT mcs;</TT>
<BR><TT>&nbsp; mcs.szTitle = (LPSTR) AllocAlias16( &quot;c:\\foo.bar&quot; );</TT>
<BR><TT>&nbsp; mcs.szClass = (LPSTR) AllocAlias16( &quot;mdichild&quot; );</TT>
<BR><TT>&nbsp; mcs.hOwner&nbsp; = hInst;</TT>
<BR><TT>&nbsp; mcs.x = mcs.cx = (int) CW_USEDEFAULT;</TT>
<BR><TT>&nbsp; mcs.y = mcs.cy = (int) CW_USEDEFAULT;</TT>
<BR><TT>&nbsp; mcs.style = 0;</TT>
<BR><BR><TT>&nbsp; /* tell the MDI Client to create the child */</TT>
<BR><TT>&nbsp; mcs_16 = AllocAlias16( &amp;mcs );</TT>
<BR><TT>&nbsp; hwnd = (WORD) _16SendMessage( hwndMDIClient,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; WM_MDICREATE,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (LONG) mcs_16 );</TT>
<BR><TT>&nbsp; FreeAlias16( mcs_16 );</TT>
<BR><TT>&nbsp; FreeAlias16( (DWORD) mcs.szClass );</TT>
<BR><TT>&nbsp; FreeAlias16( (DWORD) mcs.szTitle );</TT>
</DL>
<DL>
<DT>Classification:
<DD>WIN386
</DL>
<H2 ID="FreeHugeAlias16"> Windows:&nbsp; FreeHugeAlias16 </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;windows.h&gt;</TT>
<BR><TT>void FreeHugeAlias16( DWORD fp16, DWORD size );</TT>
</DL>
<DL>
<DT>Description:
<DD>FreeHugeAlias16 frees a 16-bit far pointer alias that was allocated with <TT> AllocHugeAlias16</TT>.&nbsp; The size of the
original 32-bit memory object must be specified.&nbsp; It is important to use <TT> FreeHugeAlias16</TT> when there is no further
use for the pointer, since there are a limited number of 16-bit aliases available (due to limited space in the local descriptor
table).
</DL>
<DL>
<DT>Returns:
<DD>The FreeHugeAlias16 function returns nothing.
</DL>
<DL>
<DT>See Also:
<DD><A HREF="#AllocHugeAlias16">AllocHugeAlias16</A>, <A HREF="#AllocAlias16">AllocAlias16</A>, <A HREF="#FreeAlias16">FreeAlias16</A>
</DL>
<DL>
<DT>Example:
<DD>
<BR><TT>#include &lt;windows.h&gt;</TT>
<BR><TT>#include &lt;malloc.h&gt;</TT>
<BR><TT>#define SIZE 300000</TT>
<BR><BR><TT>&nbsp; DWORD alias;</TT>
<BR><TT>&nbsp; void *tmp;</TT>
<BR><BR><TT>&nbsp; tmp = malloc( SIZE );</TT>
<BR><TT>&nbsp; alias = AllocHugeAlias16( tmp, SIZE );</TT>
<BR><BR><TT>&nbsp; /* windows calls using the alias ... */</TT>
<BR><BR><TT>&nbsp; FreeHugeAlias16( alias, SIZE );</TT>
</DL>
<DL>
<DT>Classification:
<DD>WIN386
</DL>
<H2 ID="FreeIndirectFunctionHandle"> Windows:&nbsp; FreeIndirectFunctionHandle </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;windows.h&gt;</TT>
<BR><TT>void FreeIndirectFunctionHandle( HINDIR handle );</TT>
</DL>
<DL>
<DT>Description:
<DD>FreeIndirectFunctionHandle frees a handle that was obtained using <TT> GetIndirectFunctionHandle</TT>.&nbsp; This is important
to do when there is no further use for the pointer since there are a limited number of 16-bit aliases available (due to limited
space in the local descriptor table).
</DL>
<DL>
<DT>Returns:
<DD>The FreeIndirectFunctionHandle function returns nothing.
</DL>
<DL>
<DT>See Also:
<DD><A HREF="#_Call16">_Call16</A>, <A HREF="#GetIndirectFunctionHandle">GetIndirectFunctionHandle</A>, <A HREF="#InvokeIndirectFunction">InvokeIndirectFunction</A>
</DL>
<DL>
<DT>Example:
<DD>
<BR><TT>#include &lt;windows.h&gt;</TT>
<BR><BR><TT>&nbsp; HANDLE hDrv;</TT>
<BR><TT>&nbsp; FARPROC lpfn;</TT>
<BR><BR><TT>&nbsp; if( (hDrv = LoadLibrary( &quot;foo.lib&quot; )) &lt; 32 )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return FALSE;</TT>
<BR><TT>&nbsp; if( !(lpfn = GetProcAddress( hDrv, &quot;ExtDeviceMode&quot; )) )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return FALSE;</TT>
<BR><BR><TT>#ifdef __WINDOWS_386__</TT>
<BR><TT>&nbsp; hIndir = GetIndirectFunctionHandle(</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; lpfn,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; INDIR_WORD,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; INDIR_WORD,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; INDIR_DWORD,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; INDIR_PTR,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; INDIR_PTR,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; INDIR_DWORD,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; INDIR_DWORD,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; INDIR_WORD,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; INDIR_ENDLIST );</TT>
<BR><BR><TT>&nbsp; cb = (WORD) InvokeIndirectFunction(</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; hIndir,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; hwnd,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; hDrv,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; NULL,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &quot;POSTSCRIPT PRINTER&quot;,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &quot;LPT1&quot;,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; NULL,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; NULL,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0 );</TT>
<BR><TT>&nbsp; FreeIndirectFunctionHandle( hIndir );</TT>
<BR><BR><TT>#else</TT>
<BR><TT>&nbsp; cb = lpfn( hwnd,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; hDrv,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; NULL,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &quot;POSTSCRIPT PRINTER&quot;,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &quot;LPT1&quot;,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; NULL,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; NULL,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0 );</TT>
<BR><TT>#endif</TT>
</DL>
<DL>
<DT>Classification:
<DD>WIN386
</DL>
<H2 ID="GetIndirectFunctionHandle"> Windows:&nbsp; GetIndirectFunctionHandle </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;windows.h&gt;</TT>
<BR><TT>HINDIR GetIndirectFunctionHandle( FARPROC prc, ... );</TT>
</DL>
<DL>
<DT>Description:
<DD>The GetIndirectFunctionHandle function gets a handle for a 16-bit procedure that is to be invoked indirectly.&nbsp; The procedure
is assumed to have PASCAL calling convention, unless the <TT> INDIR_CDECL</TT> parameter is used, to indicate that Microsoft
C calling convention is to be used.&nbsp; The 16-bit far pointer<B> prc</B> is supplied to GetIndirectFunctionHandle, and
a list of the type of each parameter (in the order that they will be passed to the 16-bit function).&nbsp; The parameter types
are:
<DL>
<DT>INDIR_DWORD
<DD>A DWORD will be passed.
<DT>INDIR_WORD
<DD>A WORD will be passed.
<DT>INDIR_CHAR
<DD>A char will be passed.
<DT>INDIR_PTR
<DD>A pointer will be passed.&nbsp; This is only used if pointer conversion from 32-bit to 16-bit is required, otherwise; INDIR_DWORD
is specified.
<DT>INDIR_CDECL
<DD>This option may be included anywhere in the list before the <TT> INDIR_ENDLIST</TT> keyword.&nbsp; When this is used, the
calling convention used to invoke the 16-bit function will be the Microsoft C calling convention.
<DT>INDIR_ENDLIST
<DD>Marks the end of the parameter list.
</DL>
<BR>There is no substitute for this function when compiling for 16-bit Windows.&nbsp; In order to make the code 16-bit Windows
compatible, conditional code (based on the __WINDOWS_386__ macro) should be placed around the GetIndirectFunctionHandle usage
(see the example).
<BR><BR>This handle is a data structure that was created using the <TT> malloc</TT> function.&nbsp; To free the handle, just
use one of the <TT> FreeIndirectFunctionHandle</TT> or <TT> free</TT> functions.
<BR><BR>You may find it easier to use <TT> _Call16</TT> rather than GetIndirectFunctionHandle followed by a call to <TT> InvokeIndirectFunction</TT>.
</DL>
<DL>
<DT>Returns:
<DD>The GetIndirectFunctionHandle function returns a handle to the indirect function, or NULL if a handle could not be allocated.
&nbsp;This handle is used in conjunction with <TT> InvokeIndirectFunction</TT> to call the 16-bit procedure.
</DL>
<DL>
<DT>See Also:
<DD><A HREF="#_Call16">_Call16</A>, <A HREF="#FreeIndirectFunctionHandle">FreeIndirectFunctionHandle</A>, <A HREF="#InvokeIndirectFunction">InvokeIndirectFunction</A>
</DL>
<DL>
<DT>Example:
<DD>
<BR><TT>#include &lt;windows.h&gt;</TT>
<BR><BR><TT>&nbsp; HANDLE hDrv;</TT>
<BR><TT>&nbsp; FARPROC lpfn;</TT>
<BR><BR><TT>&nbsp; if( (hDrv = LoadLibrary( &quot;foo.lib&quot; )) &lt; 32 )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return FALSE;</TT>
<BR><TT>&nbsp; if( !(lpfn = GetProcAddress( hDrv, &quot;ExtDeviceMode&quot; )) )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return FALSE;</TT>
<BR><BR><TT>#ifdef __WINDOWS_386__</TT>
<BR><TT>&nbsp; hIndir = GetIndirectFunctionHandle(</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; lpfn,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; INDIR_WORD,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; INDIR_WORD,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; INDIR_DWORD,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; INDIR_PTR,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; INDIR_PTR,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; INDIR_DWORD,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; INDIR_DWORD,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; INDIR_WORD,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; INDIR_ENDLIST );</TT>
<BR><BR><TT>&nbsp; cb = (WORD) InvokeIndirectFunction(</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; hIndir,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; hwnd,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; hDrv,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; NULL,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &quot;POSTSCRIPT PRINTER&quot;,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &quot;LPT1&quot;,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; NULL,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; NULL,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0 );</TT>
<BR><TT>&nbsp; FreeIndirectFunctionHandle( hIndir );</TT>
<BR><BR><TT>#else</TT>
<BR><TT>&nbsp; cb = lpfn( hwnd,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; hDrv,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; NULL,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &quot;POSTSCRIPT PRINTER&quot;,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &quot;LPT1&quot;,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; NULL,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; NULL,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0 );</TT>
<BR><TT>#endif</TT>
</DL>
<DL>
<DT>Classification:
<DD>WIN386
</DL>
<H2 ID="GetProc16"> Windows:&nbsp; GetProc16 </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;windows.h&gt;</TT>
<BR><TT>CALLBACKPTR GetProc16( PROCPTR fcn, long type );</TT>
</DL>
<DL>
<DT>Description:
<DD>The GetProc16 function returns a 16-bit far function pointer suitable for use as a Windows callback function.&nbsp; This callback
function will invoke the 32-bit far procedure specified by<B> fcn</B>.&nbsp; The types of callback functions that may be allocated
are:
<DL>
<DT>GETPROC_CALLBACK
<DD>This is the most common form of callback; suitable as the callback routine for a window.&nbsp; The callback has the form:
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; long FAR PASCAL WProc( HWND, unsigned,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; WORD, LONG );</TT>
<DT>GETPROC_ABORTPROC
<DD>This is the callback type used for trapping abort requests when printing.&nbsp; The callback has the form:
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; int FAR PASCAL AbortProc( HDC, WORD );</TT>
<DT>GETPROC_ENUMCHILDWINDOWS
<DD>This callback is used with the <TT> EnumChildWindows</TT> Windows function.&nbsp; The callback function has the form
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; BOOL FAR PASCAL EnumChildWindowsFunc(</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; HWND, DWORD );</TT>
<DT>GETPROC_ENUMFONTS
<DD>This callback type is used with the <TT> EnumFonts</TT> Windows function.&nbsp; The callback has the form:
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; int FAR PASCAL EnumFontsFunc( LPLOGFONT,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; LPTEXTMETRICS, short,
LPSTR );</TT>
<DT>GETPROC_ENUMMETAFILE
<DD>This callback is used with the <TT> EnumMetaFile</TT> Windows function.&nbsp; The callback function has the form:
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; int FAR PASCAL EnumMetaFileFunc( HDC,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; LPHANDLETABLE, LPMETARECORD,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; short, LPSTR );</TT>
<DT>GETPROC_ENUMOBJECTS
<DD>This callback is used with the <TT> EnumObjects</TT> Windows function.&nbsp; The callback function has the form:
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; int FAR PASCAL EnumObjectsFunc( LPSTR, LPSTR );</TT>
<DT>GETPROC_ENUMPROPS_FIXED_DS
<DD>This callback is used with the <TT> EnumProps</TT> Windows function, when the fixed data segments callback is needed.&nbsp;
The callback function has the form:
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; int FAR PASCAL EnumPropsFunc(</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; HWND, LPSTR, HANDLE
);</TT>
<DT>GETPROC_ENUMPROPS_MOVEABLE_DS
<DD>This callback is used with the <TT> EnumProps</TT> Windows function, when the moveable data segments callback is needed.&nbsp;
The callback function has the form:
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; int FAR PASCAL EnumPropsFunc(</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; HWND, WORD, PSTR,
HANDLE );</TT>
<DT>GETPROC_ENUMTASKWINDOWS
<DD>This callback is used with the <TT> EnumTaskWindows</TT> Windows function.&nbsp; The callback function has the form:
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; int FAR PASCAL EnumTaskWindowsFunc(</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; HWND, DWORD );</TT>
<DT>GETPROC_ENUMWINDOWS
<DD>This callback is used with the <TT> EnumWindows</TT> Windows function.&nbsp; The callback function has the form:
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; int FAR PASCAL EnumWindowsFunc( HWND, DWORD );</TT>
<DT>GETPROC_GLOBALNOTIFY
<DD>This callback is used with the <TT> GlobalNotify</TT> Windows function.&nbsp; The callback function has the form:
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; int FAR PASCAL GlobalNotifyFunc( HANDLE );</TT>
<DT>GETPROC_GRAYSTRING
<DD>This callback is used with the <TT> GrayString</TT> Windows function.&nbsp; The callback function has the form:
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; int FAR PASCAL GrayStringFunc(</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; HDC, DWORD, short
);</TT>
<DT>GETPROC_LINEDDA
<DD>This callback is used with the <TT> LineDDA</TT> Windows function.&nbsp; The callback function has the form:
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; void FAR PASCAL LineDDAFunc(</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; short, short, LPSTR
);</TT>
<DT>GETPROC_SETRESOURCEHANDLER
<DD>This callback is used with the <TT> SetResourceHandler</TT> Windows function.&nbsp; The callback function has the form:
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; int FAR PASCAL SetResourceHandlerFunc(</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; HANDLE, HANDLE, HANDLE
);</TT>
<DT>GETPROC_SETTIMER
<DD>This callback is used with the <TT> SetTimer</TT> Windows function.&nbsp; The callback function has the form:
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; int FAR PASCAL SetTimerFunc(</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; HWND, WORD, short,
DWORD );</TT>
<DT>GETPROC_SETWINDOWSHOOK
<DD>This callback is used with the <TT> SetWindowsHook</TT> Windows function.&nbsp; The callback function has the form:
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; int FAR PASCAL SetWindowsHookFunc(</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; short, WORD, DWORD
);</TT>
<DT>GETPROC_USERDEFINED_x
<DD>This callback is used in conjunction with <TT> DefineUserProc16</TT> function to create a callback routine with an arbitrary
set of parameters.&nbsp; Up to 32 user defined callbacks are allowed, they are identified by using GETPROC_USERDEFINED_1 through
GETPROC_USERDEFINED_32.&nbsp; The user defined callback must be declared as a FAR PASCAL function, or as a FAR cdecl function.
</DL>
</DL>
<DL>
<DT>Returns:
<DD>The GetProc16 function returns a 16-bit far pointer to a callback procedure.&nbsp; This pointer may then be fed to any Windows
function that requires a pointer to a function within the 32-bit program.&nbsp; Note that the callback function within the
32-bit program must be declared as <TT> FAR</TT>.
</DL>
<DL>
<DT>See Also:
<DD><A HREF="#ReleaseProc16">ReleaseProc16</A>
</DL>
<DL>
<DT>Example:
<DD>
<BR><TT>#include &lt;windows.h&gt;</TT>
<BR><BR><TT>&nbsp; CALLBACKPTR cbp;</TT>
<BR><TT>&nbsp; FARPROC lpProcAbout;</TT>
<BR><TT>&nbsp; /*</TT>
<BR><TT>&nbsp;&nbsp; * Get a 16-bit callback routine to point at</TT>
<BR><TT>&nbsp;&nbsp; * our About dialogue procedure, then create</TT>
<BR><TT>&nbsp;&nbsp; * the dialogue.&nbsp; We use _16 versions of</TT>
<BR><TT>&nbsp;&nbsp; * MakeProcInstance, DialogBox, and</TT>
<BR><TT>&nbsp;&nbsp; * FreeProcInstance because they do not do</TT>
<BR><TT>&nbsp;&nbsp; * any magic work on the callback routines.</TT>
<BR><TT>&nbsp;&nbsp; */</TT>
<BR><TT>&nbsp; cbp = GetProc16( (PROCPTR) About,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; GETPROC_CALLBACK
);</TT>
<BR><BR><TT>&nbsp; lpProcAbout = _16MakeProcInstance( cbp, hInst );</TT>
<BR><BR><TT>&nbsp; _16DialogBox( hInst,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &quot;AboutBox&quot;,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; hWnd,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; lpProcAbout );</TT>
<BR><BR><TT>&nbsp; _16FreeProcInstance( lpProcAbout );</TT>
<BR><TT>&nbsp; ReleaseProc16( cbp );</TT>
</DL>
<DL>
<DT>Classification:
<DD>WIN386
</DL>
<H2 ID="InvokeIndirectFunction"> Windows:&nbsp; InvokeIndirectFunction </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;windows.h&gt;</TT>
<BR><TT>long InvokeIndirectFunction( HINDIR handle, ... );</TT>
</DL>
<DL>
<DT>Description:
<DD>The InvokeIndirectFunction function invokes the 16-bit function pointed to by the specified handle.&nbsp; The handle must
have been previously allocated using the <TT> GetIndirectFunctionHandle</TT> function.&nbsp; The handle is followed by the
list of parameters to be passed to the 16-bit function.
<BR><BR>If you specified <TT> INDIR_PTR</TT> as a parameter when allocating the handle, then a 16-bit pointer is allocated
for a 32-bit pointer that you pass.&nbsp; However, this pointer is freed when the 16-bit function being invoked returns.
<BR><BR>There is no substitute for this function when compiling for 16-bit Windows.&nbsp; In order to make the code 16-bit
Windows compatible, conditional code (based on the __WINDOWS_386__ macro) should be placed around the InvokeIndirectFunction
usage (see the example).
</DL>
<DL>
<DT>Returns:
<DD>The InvokeIndirectFunction function returns the value which the 16-bit function returned.&nbsp; If the 16-bit function returns
a short rather than a long, the result must be typecast.
</DL>
<DL>
<DT>See Also:
<DD><A HREF="#_Call16">_Call16</A>, <A HREF="#FreeIndirectFunctionHandle">FreeIndirectFunctionHandle</A>, <A HREF="#GetIndirectFunctionHandle">GetIndirectFunctionHandle</A>
</DL>
<DL>
<DT>Example:
<DD>
<BR><TT>#include &lt;windows.h&gt;</TT>
<BR><BR><TT>&nbsp; HANDLE hDrv;</TT>
<BR><TT>&nbsp; FARPROC lpfn;</TT>
<BR><TT>&nbsp; HINDIR hIndir;</TT>
<BR><TT>&nbsp; int cb;</TT>
<BR><BR><TT>&nbsp; if( (hDrv = LoadLibrary( &quot;foo.lib&quot; )) &lt; 32 )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return FALSE;</TT>
<BR><TT>&nbsp; if( !(lpfn = GetProcAddress( hDrv, &quot;ExtDeviceMode&quot; )) )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return FALSE;</TT>
<BR><TT>#ifdef __WINDOWS_386__</TT>
<BR><BR><TT>&nbsp; hIndir = GetIndirectFunctionHandle(</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; lpfn,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; INDIR_WORD,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; INDIR_WORD,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; INDIR_DWORD,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; INDIR_PTR,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; INDIR_PTR,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; INDIR_DWORD,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; INDIR_DWORD,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; INDIR_WORD,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; INDIR_ENDLIST );</TT>
<BR><BR><TT>&nbsp; cb = (WORD) InvokeIndirectFunction(</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; hIndir,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; hwnd,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; hDrv,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; NULL,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &quot;POSTSCRIPT PRINTER&quot;,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &quot;LPT1&quot;,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; NULL,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; NULL,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0 );</TT>
<BR><TT>&nbsp; FreeIndirectFunctionHandle( hIndir );</TT>
<BR><TT>#else</TT>
<BR><BR><TT>&nbsp; cb = lpfn( hwnd,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; hDrv,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; NULL,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &quot;POSTSCRIPT PRINTER&quot;,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &quot;LPT1&quot;,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; NULL,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; NULL,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0 );</TT>
<BR><TT>#endif</TT>
</DL>
<DL>
<DT>Classification:
<DD>WIN386
</DL>
<H2 ID="MapAliasToFlat"> Windows:&nbsp; MapAliasToFlat </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;windows.h&gt;</TT>
<BR><TT>void *MapAliasToFlat( DWORD alias );</TT>
</DL>
<DL>
<DT>Description:
<DD>The MapAliasToFlat function returns a 32-bit near pointer equivalent of a pointer allocated previously with <TT> AllocAlias16</TT>
or <TT> AllocHugeAlias16</TT>.&nbsp; This is useful if you are communicating with a 16-bit application that is returning pointers
that you previously gave it.
</DL>
<DL>
<DT>Returns:
<DD>The MapAliasToFlat function returns a 32-bit near pointer usable by the 32-bit application.
</DL>
<DL>
<DT>See Also:
<DD><A HREF="#AllocAlias16">AllocAlias16</A>, <A HREF="#AllocHugeAlias16">AllocHugeAlias16</A>
</DL>
<DL>
<DT>Example:
<DD>
<BR><TT>#include &lt;windows.h&gt;</TT>
<BR><BR><TT>&nbsp; DWORD alias;</TT>
<BR><TT>&nbsp; void&nbsp; *ptr;</TT>
<BR><BR><TT>&nbsp; alias = (DWORD) AllocAlias16( &amp;alias );</TT>
<BR><TT>&nbsp; alias += 5;</TT>
<BR><TT>&nbsp; ptr = MapAliasToFlat( alias );</TT>
<BR><TT>&nbsp; if( ptr == ((char *)&amp;alias + 5) ) {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; MessageBox( NULL,&quot;It Worked&quot;,&quot;&quot;,MB_OK );</TT>
<BR><TT>&nbsp; } else {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; MessageBox( NULL,&quot;It Failed&quot;,&quot;&quot;,MB_OK );</TT>
<BR><TT>&nbsp; }</TT>
</DL>
<DL>
<DT>Classification:
<DD>WIN386
</DL>
<H2 ID="MK_FP16"> Windows:&nbsp; MK_FP16 </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;windows.h&gt;</TT>
<BR><TT>DWORD MK_FP16( void far * fp32 );</TT>
</DL>
<DL>
<DT>Description:
<DD>The MK_FP16 function converts a 32-bit far pointer to a 16-bit far pointer.&nbsp; The 16-bit pointer is created by simply
removing the high word of the offset of the 32-bit pointer.
<BR><BR>The 32-bit far pointer must be one that was obtained by using <TT> MK_FP32</TT> to extend a 16-bit pointer.
<BR><BR>This is useful whenever it is necessary to pass a 16-bit far pointer a parameter to a Windows function though an _16
function.
</DL>
<DL>
<DT>Returns:
<DD>The MK_FP16 returns a 16-bit far pointer.
</DL>
<DL>
<DT>See Also:
<DD><A HREF="#MK_LOCAL32">MK_LOCAL32</A>, <A HREF="#MK_FP32">MK_FP32</A>
</DL>
<DL>
<DT>Example:
<DD>
<BR><TT>#include &lt;windows.h&gt;</TT>
<BR><BR><TT>&nbsp; DRAWITEMSTRUCT&nbsp;&nbsp;&nbsp; FAR *lpdis;</TT>
<BR><TT>&nbsp; RECT&nbsp; rc;</TT>
<BR><TT>&nbsp; DWORD alias;</TT>
<BR><TT>&nbsp; /*</TT>
<BR><TT>&nbsp;&nbsp; * The drawitem struct was passed as a long, so we</TT>
<BR><TT>&nbsp;&nbsp; * have to convert it to a 32 bit far pointer.</TT>
<BR><TT>&nbsp;&nbsp; * Then, we want the 16 bit far pointer of the rcItem</TT>
<BR><TT>&nbsp;&nbsp; * element so we can pass it to CopyRect (_16CopyRect</TT>
<BR><TT>&nbsp;&nbsp; * is a version of CopyRect that does not convert</TT>
<BR><TT>&nbsp;&nbsp; * the pointers it was given).</TT>
<BR><TT>&nbsp;&nbsp; */</TT>
<BR><TT>&nbsp; case WM_DRAWITEM:</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; lpdis = MK_FP32( (void *) lParam );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; alias = AllocAlias16( &gt; );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; _16CopyRect( (LPRECT) alias,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (LPRECT) MK_FP16(
&amp;lpdis-&gt;rcItem ) );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; FreeAlias16( alias );</TT>
</DL>
<DL>
<DT>Classification:
<DD>WIN386
</DL>
<H2 ID="MK_FP32"> Windows:&nbsp; MK_FP32 </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;windows.h&gt;</TT>
<BR><TT>void far *MK_FP32( void * fp16 );</TT>
</DL>
<DL>
<DT>Description:
<DD>The MK_FP32 function converts a 16-bit far pointer to a 32-bit far pointer.&nbsp; This is needed whenever Windows returns
a 16-bit far pointer, and access to the data is needed by the 32-bit program.
</DL>
<DL>
<DT>Returns:
<DD>The MK_FP32 returns a 32-bit far pointer.
</DL>
<DL>
<DT>See Also:
<DD><A HREF="#MK_LOCAL32">MK_LOCAL32</A>, <A HREF="#MK_FP16">MK_FP16</A>
</DL>
<DL>
<DT>Example:
<DD>
<BR><TT>#include &lt;windows.h&gt;</TT>
<BR><BR><TT>&nbsp; MEASUREITEMSTRUCT far *mis;</TT>
<BR><BR><TT>&nbsp; case WM_MEASUREITEM:</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; /*</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; * Windows has passed us a 16 bit far pointer</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; * to the measure item data structure.&nbsp; We</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; * use MK_FP32 to make that pointer a 32-bit far</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; * pointer, which enables us to access the data.</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; mis = MK_FP32( (void *) lParam );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; mis-&gt;itemHeight = MEASUREITEMHEIGHT;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; mis-&gt;itemWidth&nbsp; = MEASUREITEMWIDTH;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; return TRUE;</TT>
</DL>
<DL>
<DT>Classification:
<DD>WIN386
</DL>
<H2 ID="MK_LOCAL32"> Windows:&nbsp; MK_LOCAL32 </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;windows.h&gt;</TT>
<BR><TT>void far *MK_LOCAL32( void * fp16 );</TT>
</DL>
<DL>
<DT>Description:
<DD>The MK_LOCAL32 function converts a 16-bit near pointer to a 32-bit far pointer.&nbsp; This is needed whenever Windows returns
a 16-bit near pointer that is to be accessed by the 32-bit program.
</DL>
<DL>
<DT>Returns:
<DD>The MK_LOCAL32 returns a 32-bit far pointer.
</DL>
<DL>
<DT>See Also:
<DD><A HREF="#MK_FP32">MK_FP32</A>, <A HREF="#MK_FP16">MK_FP16</A>
</DL>
<DL>
<DT>Example:
<DD>
<BR><TT>#include &lt;windows.h&gt;</TT>
<BR><BR><TT>&nbsp; WORD ich,cch;</TT>
<BR><TT>&nbsp; char *pch;</TT>
<BR><TT>&nbsp; char far *fpch;</TT>
<BR><TT>&nbsp; HANDLE hT;</TT>
<BR><BR><TT>&nbsp; /*</TT>
<BR><TT>&nbsp;&nbsp; * Request the data from an edit window; copy it</TT>
<BR><TT>&nbsp;&nbsp; * into a local buffer so that it can be passed</TT>
<BR><TT>&nbsp;&nbsp; * to TextOut</TT>
<BR><TT>&nbsp;&nbsp; */</TT>
<BR><TT>&nbsp; ich = (WORD) SendMessage( hwndEdit,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; EM_LINEINDEX,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; iLine,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0L );</TT>
<BR><TT>&nbsp; cch = (WORD) SendMessage( hwndEdit,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; EM_LINELENGTH,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ich,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0L );</TT>
<BR><TT>&nbsp; fpch = MK_LOCAL32( LocalLock( hT ) ) ;</TT>
<BR><TT>&nbsp; pch = alloca( cch );</TT>
<BR><TT>&nbsp; _fmemcpy( pch, fpch + ich, cch );</TT>
<BR><BR><TT>&nbsp; TextOut( hdc, 0, yExtSoFar, (LPSTR) pch, cch );</TT>
<BR><TT>&nbsp; LocalUnlock( hT );</TT>
</DL>
<DL>
<DT>Classification:
<DD>WIN386
</DL>
<H2 ID="PASS_WORD_AS_POINTER"> Windows:&nbsp; PASS_WORD_AS_POINTER </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;windows.h&gt;</TT>
<BR><TT>void *PASS_WORD_AS_POINTER( DWORD dw );</TT>
</DL>
<DL>
<DT>Description:
<DD>Some Windows API functions have pointer parameters that do not always take pointers.&nbsp; Sometimes these parameters are
pure data.&nbsp; In order to stop the supervisor from trying to convert the data into a 16-bit far pointer, the PASS_WORD_AS_POINTER
function is used.
</DL>
<DL>
<DT>Returns:
<DD>The PASS_WORD_AS_POINTER returns a 32-bit &quot;near&quot; pointer, that is really the parameter<B> dw</B>.
</DL>
<DL>
<DT>Example:
<DD>
<BR><TT>#include &lt;windows.h&gt;</TT>
<BR><BR><TT>&nbsp; Func( PASS_WORD_AS_POINTER( 1 ) );</TT>
</DL>
<DL>
<DT>Classification:
<DD>WIN386
</DL>
<H2 ID="ReleaseProc16"> Windows:&nbsp; ReleaseProc16 </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;windows.h&gt;</TT>
<BR><TT>void ReleaseProc16( CALLBACKPTR cbp );</TT>
</DL>
<DL>
<DT>Description:
<DD>ReleaseProc16 releases the callback function allocated by <TT> GetProc16</TT>.&nbsp; Since the callback routines are a limited
resource, it is important to release the routines when they are no longer required.
</DL>
<DL>
<DT>Returns:
<DD>The ReleaseProc16 function returns nothing.
</DL>
<DL>
<DT>See Also:
<DD><A HREF="#GetProc16">GetProc16</A>
</DL>
<DL>
<DT>Example:
<DD>
<BR><TT>#include &lt;windows.h&gt;</TT>
<BR><BR><TT>&nbsp; CALLBACKPTR cbp;</TT>
<BR><TT>&nbsp; FARPROC lpProcAbout;</TT>
<BR><TT>&nbsp; /*</TT>
<BR><TT>&nbsp;&nbsp; * Get a 16-bit callback routine to point at</TT>
<BR><TT>&nbsp;&nbsp; * our About dialogue procedure, then create</TT>
<BR><TT>&nbsp;&nbsp; * the dialogue.&nbsp; We use _16 versions of</TT>
<BR><TT>&nbsp;&nbsp; * MakeProcInstance, DialogBox, and</TT>
<BR><TT>&nbsp;&nbsp; * FreeProcInstance because they do not do</TT>
<BR><TT>&nbsp;&nbsp; * any magic work on the callback routines.</TT>
<BR><TT>&nbsp;&nbsp; */</TT>
<BR><TT>&nbsp;&nbsp; cbp = GetProc16( (PROCPTR) About,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
GETPROC_CALLBACK );</TT>
<BR><BR><TT>&nbsp;&nbsp; lpProcAbout = _16MakeProcInstance( cbp, hInst );</TT>
<BR><BR><TT>&nbsp;&nbsp; _16DialogBox( hInst,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &quot;AboutBox&quot;,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; hWnd,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; lpProcAbout );</TT>
<BR><BR><TT>&nbsp;&nbsp; _16FreeProcInstance( lpProcAbout );</TT>
<BR><TT>&nbsp;&nbsp; ReleaseProc16( cbp );</TT>
</DL>
<DL>
<DT>Classification:
<DD>WIN386
</DL>
<H1 ID="Windows__32Mbit_Extended_Windows_Application_Development"> Windows:&nbsp; 32-bit Extended Windows Application Development </H1>
<BR>The purpose of this chapter is to anticipate some common questions about 32-bit Windows application development.
<BR><BR>The following topics are discussed in this chapter:
<UL>
<LI>Can you call 16-bit code from a 32-bit code?
<LI>Can I WinExec another Windows application?
<LI>How do I add my Windows resources?
<LI>What size of function pointers passed to Windows?
<LI>Why are 32-bit callback routines FAR?
<LI>Why use the _16 API functions?
<LI>What about pointers in structures?
<LI>When do I use MK_FP32?
<LI>What is the difference between AllocAlias16 and MK_FP16?
</UL>
<H2 ID="Windows__Can_you_call_16Mbit_code_from_a_32Mbit_code_"> Windows:&nbsp; Can you call 16-bit code from a 32-bit code? </H2>
<BR>A 32-bit Windows application can make a call to 16-bit code through the use of the Open Watcom <TT> _Call16</TT> or <TT>
InvokeIndirectFunction</TT> procedures.&nbsp; These functions ensure that the Open Watcom Windows Supervisor prepares the
stack for the 16-bit call and return to the 32-bit code.&nbsp; The 32-bit application uses <TT> LoadLibrary</TT> function
to bring the 16-bit DLL into memory and then calls the 16-bit procedures.&nbsp; To invoke 16-bit procedures, use <TT> GetProcAddress</TT>
to get the 16-bit far pointer to the function.&nbsp; Use the <TT> _Call16</TT> procedure to call the 16-bit function since
it is simpler to use than the <TT> GetIndirectFunctionHandle</TT>, <TT> InvokeIndirectFunction</TT>, and <TT> FreeIndirectFunctionHandle</TT>
sequence.&nbsp; An example of this process is provided under the <TT> _Call16</TT> Windows library function description.
<BR><BR>This method can be used to call any 16-bit Dynamic Link Library (DLL) procedure or any 32-bit extended DLL procedure
from within a 32-bit application, including DLLs that are available as products through Independent Software Vendors (ISVs).
<H2 ID="Windows__Can_I_WinExec_another_Windows_application_"> Windows:&nbsp; Can I WinExec another Windows application? </H2>
<BR>As far as Windows is concerned, the WinExec was made by a 16-bit application, and the application specified will be started.
&nbsp;This new application can be a 16-bit application or another 32-bit application that was implemented with Open Watcom
C/C++
<H2 ID="Windows__How_do_I_add_my_Windows_resources_"> Windows:&nbsp; How do I add my Windows resources? </H2>
<BR>The <TT> WBIND</TT> utility automatically runs the resource compiler to add the resources to the 32-bit Windows supervisor
(since the supervisor is a 16-bit Windows application).&nbsp; Note that resource compiler options may be specified by using
the &quot;R&quot; option of <TT> WBIND</TT>.
<H2 ID="Windows__What_size_of_function_pointers_passed_to_Windows_"> Windows:&nbsp; What size of function pointers passed to Windows? </H2>
<BR>All function pointers passed to Windows must be 16-bit far pointers since no translation is applied to any function pointers
passed to Windows.&nbsp; Translation is often not possible, since any functions that Windows is to call back must be exported,
and only 16-bit functions can be exported.
<BR><BR>A 16-bit far pointer to a function is obtained in one of two ways:&nbsp; either Windows gives it to you (via <TT>
GetProcAddr</TT>, for example), or you obtain a pointer from the supervisor, via <TT> GetProc16</TT>.
<BR><BR>Function pointers obtained from Windows may either be fed into other Windows functions requiring function pointers,
or called indirectly by using <TT> _Call16</TT> or by using the <TT> GetIndirectFunctionHandle</TT>, <TT> InvokeIndirectFunction</TT>,
and <TT> FreeIndirectFunctionHandle</TT> sequence.
<BR><BR>The function <TT> GetProc16</TT> returns a 16-bit far pointer to a callback function that Windows can use.&nbsp; This
callback function will direct control into the desired 32-bit routine.
<H2 ID="Windows__Why_are_32Mbit_callback_routines_FAR_"> Windows:&nbsp; Why are 32-bit callback routines FAR? </H2>
<BR>The callback routines are declared as FAR so that the compiler will generate a far return from the procedure.&nbsp; This
is necessary since the 32-bit callback routine is &quot;far&quot; called from the supervisor.
<BR><BR>The callback routine is still &quot;near&quot; in the sense that it lies within the 32-bit flat address space of the
application.&nbsp; This means that <TT> GetProc16</TT> only needs the offset of the 32-bit callback function in order to set
up the 16-bit procedure to call back correctly.&nbsp; Thus, <TT> GetProc16</TT> accepts type <TT> PROCPTR</TT> which is in
fact only 4 bytes long.&nbsp; The compiler will provide the offset only, which is, as already stated, all that is needed.
<H2 ID="Windows__Why_use_the__16_API_functions_"> Windows:&nbsp; Why use the _16 API functions? </H2>
<BR>The regular Windows API functions used in Open Watcom C/C++ automatically convert any pointers to 16-bit far pointers
for use by Windows.&nbsp; Sometimes, you may have a set of pointers that are 16-bit far pointers already (e.g., obtained from
<TT> GlobalLock</TT>), and do not need any conversion.&nbsp; The &quot;_16...&quot; API functions do not convert pointers,
they simply pass them on directly to Windows.&nbsp; See the appendix entitled <A HREF="#Special_Windows_API_Functions">Special Windows API Functions</A>
for a list of the &quot;_16...&quot; API functions.
<H2 ID="Windows__What_about_pointers_in_structures_"> Windows:&nbsp; What about pointers in structures? </H2>
<BR>Pointers in structures will be converted if the Windows API function actually takes a pointer to that structure (i.e.,
if it is possible for the supervisor to identify that structure).&nbsp; There are few functions that accept pointers to structures
containing pointers.&nbsp; One such function is<B> RegisterClass</B> which accepts a pointer to a WNDCLASS structure.
<BR><BR>If Windows has you passing a pointer to a structure through a 32-bit integer argument, then it is not possible for
the supervisor to identify that as a pointer that needs conversion.&nbsp; It is also not possible for the supervisor to convert
any pointers contained in the structure, since it is not aware that it is a structure (as far as the supervisor is concerned,
that data is what Windows said it was - a 32-bit integer).&nbsp; In this case, it is necessary to get 16-bit far pointer equivalents
to the 32-bit near pointers that you want to pass.&nbsp; Use <TT> AllocAlias16</TT> for this.
<H2 ID="Windows__When_do_I_use_MK_FP32_"> Windows:&nbsp; When do I use MK_FP32? </H2>
<BR><TT> MK_FP32</TT> is used to convert all 16-bit far pointers to 32-bit far pointers that can be used by your 32-bit application.
&nbsp;For example, to access the memory returned by <TT> GlobalLock</TT> requires the use of <TT> MK_FP32</TT>.&nbsp; To access
any pointer passed to you (in a callback routine) requires the use of <TT> MK_FP32</TT> if you want access to that data in
your 32-bit application.
<H2 ID="Windows__What_is_the_difference_between_AllocAlias16_and_MK_FP16_"> Windows:&nbsp; What is the difference between AllocAlias16 and MK_FP16? </H2>
<BR><TT> AllocAlias16</TT> actually gets a new selector that points at the same memory as the 32-bit near pointer, whereas
<TT> MK_FP16</TT> squishes a 32-bit far pointer back into a 16-bit far pointer (i.e., it reverses <TT> MK_FP32</TT>).
<H2 ID="Windows__Tell_Me_More_About_Thunking_and_Aliases"> Windows:&nbsp; Tell Me More About Thunking and Aliases </H2>
<BR>Consider the following example.
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; dwAlias = AllocAlias16( pszSomething );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; hwnd = CreateWindowEx(</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0L,&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // extendedStyle</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &quot;classname&quot;,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // class name</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &quot;&quot;,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; WS_POPUP|WS_VISIBLE|WS_CLIPSIBLINGS|WS_HSCROLL|</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; WS_BORDER|WS_CAPTION|WS_SYSMENU,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; x, y, 0, 0,&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // x, y, cx, cy</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; hwndParent,&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // hwndParent</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; NULL,&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // control ID</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; g_app.hinst,&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // hInstance</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (void FAR*)dwAlias);
&nbsp;&nbsp; // lpCreateParams</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; FreeAlias16( dwAlias );</TT>
<BR><BR>When I get the<TT> lpCreateParams</TT> parameter in<TT> WM_CREATE,</TT> I don't get the original<TT> dwAlias</TT>
but something else which looks like another alias to me.&nbsp; So the question is:&nbsp; Must the<TT> CreateWindowEx</TT>
parameter<TT> lpCreateParams</TT> be &quot;thunked&quot; or is this done automatically by the supervisor?
<BR><BR>Thunks are always created for function pointers.&nbsp; Aliases are always created for data pointers.&nbsp; There are
3 data pointer parameters in the<TT> CreateWindowEx</TT> function call.&nbsp; Aliases are created for all three pointers.
&nbsp;The<TT> lpCreateParams</TT> argument is a pointer to a struct which contains 3 pointers.&nbsp; Aliases are not created
for the 3 pointers inside the struct.&nbsp; If you need to have this done, then you will have to create the aliases yourself.
&nbsp;If you create aliases for the parameters to<TT> CreateWindowEx,</TT> then you must call the<TT> _16CreateWindowEx</TT>
function which will not create any aliases.
<BR><BR>Here is some further information on thunks (which are created for function pointers).&nbsp; There is code in the supervisor
that<B> trys</B> (note the word<B> trys</B>) to determine if the user has already created a thunk and, if so, avoids creating
a double thunk which will always generate a GPF.&nbsp; The best policy is to let the supervisor automatically create all thunks
for you unless you have a very specific reason not to, in which case you should call the _16 version of the function.
<BR><BR>Here is some further information on aliases (which are created for data pointers).&nbsp; There is no way for the supervisor
to determine if a value is a 32-bit flat pointer or an alias for the pointer.&nbsp; So if you pass in an alias to the non
_16 version of the function, the supervisor will create an alias for the alias which will end up pointing to the wrong memory
location.&nbsp; If you are going to create the alias, then you must call the _16 version of the function.
<H1 ID="Special_Variables_for_Windows_Programming"> Special Variables for Windows Programming </H1>
<DL>
<DT>__A000
<DD>A selector for addressing the real-mode segment 0xA000.
<DT>__B000
<DD>A selector for addressing the real-mode segment 0xB000.
<DT>__B800
<DD>A selector for addressing the real-mode segment 0xB800.
<DT>__C000
<DD>A selector for addressing the real-mode segment 0xC000.
<DT>__D000
<DD>A selector for addressing the real-mode segment 0xD000.
<DT>__E000
<DD>A selector for addressing the real-mode segment 0xE000.
<DT>__F000
<DD>A selector for addressing the real-mode segment 0xF000.
<DT>LocalPtr
<DD>The selector for the supervisor's data area.
</DL>
<H1 ID="Definitions_of_Windows_Terms"> Definitions of Windows Terms </H1>
<DL>
<DT>CALLBACKPTR
<DD>Pointer to a 16-bit callback routine; used to call into 32-bit functions.
<DT>DWORD
<DD>An unsigned long.
<DT>HINDIR
<DD>A handle to 16-bit function that needs to be called indirectly.
<DT>PROCPTR
<DD>A pointer to a 32-bit callback routine.&nbsp; Although the callback routine is declared as far, only the 32-bit offset is
used.
<DT>WORD
<DD>An unsigned short.
</DL>
<H1 ID="Special_Windows_API_Functions"> Special Windows API Functions </H1>
<BR>On rare occasions, you want to use 16-bit far pointers directly in a Windows function.&nbsp; Since all Windows functions
in the 32-bit environment are expecting 32-bit near pointers, you cannot simply use the 16-bit far pointer directly in the
function.
<BR><BR>The following functions are special versions of Windows API functions that do NOT convert any of the pointers from
32-bit to 16-bit.&nbsp; There are _16 versions of all Windows API functions that accept data pointers.
<UL>
<LI>_16AddAtom
<LI>_16AddFontResource
<LI>_16AdjustWindowRect
<LI>_16AdjustWindowRectEx
<LI>_16AnimatePalette
<LI>_16AnsiLower
<LI>_16AnsiLowerBuff
<LI>_16AnsiToOem
<LI>_16AnsiToOemBuff
<LI>_16AnsiUpper
<LI>_16AnsiUpperBuff
<LI>_16BuildCommDCB
<LI>_16CallMsgFilter
<LI>_16ChangeMenu
<LI>_16ClientToScreen
<LI>_16ClipCursor
<LI>_16CopyMetaFile
<LI>_16CopyRect
<LI>_16CreateBitmap
<LI>_16CreateBitmapIndirect
<LI>_16CreateBrushIndirect
<LI>_16CreateCursor
<LI>_16CreateDC
<LI>_16CreateDialog
<LI>_16CreateDialogIndirect
<LI>_16CreateDialogIndirectParam
<LI>_16CreateDialogParam
<LI>_16CreateDIBitmap
<LI>_16CreateEllipticRgnIndirect
<LI>_16CreateFont
<LI>_16CreateFontIndirect
<LI>_16CreateIC
<LI>_16CreateIcon
<LI>_16CreateMetaFile
<LI>_16CreatePalette
<LI>_16CreatePenIndirect
<LI>_16CreatePolygonRgn
<LI>_16CreatePolyPolygonRgn
<LI>_16CreateRectRgnIndirect
<LI>_16CreateWindow
<LI>_16CreateWindowEx
<LI>_16DialogBox
<LI>_16DialogBoxIndirect
<LI>_16DialogBoxIndirectParam
<LI>_16DialogBoxParam
<LI>_16DispatchMessage
<LI>_16DlgDirList
<LI>_16DlgDirListComboBox
<LI>_16DlgDirSelect
<LI>_16DlgDirSelectComboBox
<LI>_16DPtoLP
<LI>_16DrawFocusRect
<LI>_16DrawText
<LI>_16EndPaint
<LI>_16EnumChildWindows
<LI>_16EnumFonts
<LI>_16EnumMetaFile
<LI>_16EnumObjects
<LI>_16EnumProps
<LI>_16EnumTaskWindows
<LI>_16EnumWindows
<LI>_16EqualRect
<LI>_16Escape
<LI>_16ExtTextOut
<LI>_16FillRect
<LI>_16FindAtom
<LI>_16FindResource
<LI>_16FindWindow
<LI>_16FrameRect
<LI>_16FreeProcInstance
<LI>_16GetAtomName
<LI>_16GetBitmapBits
<LI>_16GetCaretPos
<LI>_16GetCharWidth
<LI>_16GetClassInfo
<LI>_16GetClassName
<LI>_16GetClientRect
<LI>_16GetClipboardFormatName
<LI>_16GetClipBox
<LI>_16GetCodeInfo
<LI>_16GetCommError
<LI>_16GetCommState
<LI>_16GetCursorPos
<LI>_16GetDIBits
<LI>_16GetDlgItemInt
<LI>_16GetDlgItemText
<LI>_16GetEnvironment
<LI>_16GetKeyboardState
<LI>_16GetKeyNameText
<LI>_16GetMenuString
<LI>_16GetMetaFile
<LI>_16GetModuleFileName
<LI>_16GetModuleHandle
<LI>_16GetObject
<LI>_16GetPaletteEntries
<LI>_16GetPriorityClipboardFormat
<LI>_16GetPrivateProfileInt
<LI>_16GetPrivateProfileString
<LI>_16GetProcAddress
<LI>_16GetProfileInt
<LI>_16GetProfileString
<LI>_16GetProp
<LI>_16GetRgnBox
<LI>_16GetScrollRange
<LI>_16GetSystemDirectory
<LI>_16GetSystemPaletteEntries
<LI>_16GetTabbedTextExtent
<LI>_16GetTempFileName
<LI>_16GetTextExtent
<LI>_16GetTextFace
<LI>_16GetTextMetrics
<LI>_16GetUpdateRect
<LI>_16GetWindowRect
<LI>_16GetWindowsDirectory
<LI>_16GetWindowText
<LI>_16GlobalAddAtom
<LI>_16GlobalFindAtom
<LI>_16GlobalGetAtomName
<LI>_16GlobalNotify
<LI>_16GrayString
<LI>_16InflateRect
<LI>_16IntersectRect
<LI>_16InvalidateRect
<LI>_16InvertRect
<LI>_16IsDialogMessage
<LI>_16IsRectEmpty
<LI>_16LineDDA
<LI>_16LoadAccelerators
<LI>_16LoadBitmap
<LI>_16LoadCursor
<LI>_16LoadIcon
<LI>_16LoadLibrary
<LI>_16LoadMenu
<LI>_16LoadMenuIndirect
<LI>_16LoadModule
<LI>_16LoadString
<LI>_16LPtoDP
<LI>_16MakeProcInstance
<LI>_16MapDialogRect
<LI>_16MessageBox
<LI>_16OemToAnsi
<LI>_16OemToAnsiBuff
<LI>_16OffsetRect
<LI>_16OpenComm
<LI>_16OpenFile
<LI>_16OutputDebugString
<LI>_16PlayMetaFileRecord
<LI>_16Polygon
<LI>_16Polyline
<LI>_16PolyPolygon
<LI>_16PtInRect
<LI>_16ReadComm
<LI>_16RectInRegion
<LI>_16RectVisible
<LI>_16RegisterClipboardFormat
<LI>_16RegisterWindowMessage
<LI>_16RemoveFontResource
<LI>_16RemoveProp
<LI>_16ScreenToClient
<LI>_16ScrollDC
<LI>_16ScrollWindow
<LI>_16SetBitmapBits
<LI>_16SetCommState
<LI>_16SetDIBits
<LI>_16SetDIBitsToDevice
<LI>_16SetDlgItemText
<LI>_16SetEnvironment
<LI>_16SetKeyboardState
<LI>_16SetPaletteEntries
<LI>_16SetProp
<LI>_16SetRect
<LI>_16SetRectEmpty
<LI>_16SetResourceHandler
<LI>_16SetSysColors
<LI>_16SetTimer
<LI>_16SetWindowsHook
<LI>_16SetWindowText
<LI>_16StretchDIBits
<LI>_16TabbedTextOut
<LI>_16TextOut
<LI>_16ToAscii
<LI>_16TrackPopupMenu
<LI>_16TranslateAccelerator
<LI>_16TranslateMDISysAccel
<LI>_16TranslateMessage
<LI>_16UnhookWindowsHook
<LI>_16UnionRect
<LI>_16UnregisterClass
<LI>_16ValidateRect
<LI>_16WinExec
<LI>_16WinHelp
<LI>_16WriteComm
<LI>_16WritePrivateProfileString
<LI>_16WriteProfileString
<LI>_16_lread
<LI>_16_lwrite
</UL>
<H1 ID="NT__Windows_NT_Programming_Overview"> NT:&nbsp; Windows NT Programming Overview </H1>
<BR>Windows NT supports both non-windowed character-mode applications and windowed Graphical User Interface (GUI) applications.
&nbsp;In addition, Windows NT supports Dynamic Link Libraries and applications with multiple threads of execution.
<BR><BR>We have supplied all the necessary tools for native development on Windows NT.&nbsp; You can also cross develop for
Windows NT using either the DOS-hosted compilers and tools, the Windows 95-hosted compilers and tools, or the OS/2-hosted
compilers and tools.
<BR><BR>Note - If you are on the host with operating system other then 32-bit Windows, you should setup INCLUDE environment
variable correctly to compile for 32-bit Windows target.
<BR><BR>You can do that by command (DOS, OS/2, Windows 3.x)
<BR><BR>set INCLUDE=%WATCOM%\h;%WATCOM%\h\nt
<BR><BR>or by command (LINUX)
<BR><BR>export INCLUDE=$WATCOM/h:$WATCOM/h/nt
<BR><BR>Testing and debugging of your Windows NT application must be done on Windows NT or Windows 95.
<BR><BR>If you are creating a character-mode application, you may also be interested in a special DOS extender from Phar Lap
(TNT) that can run your Windows NT character-mode application under DOS.
<H2 ID="NT__Windows_NT_Programming_Note"> NT:&nbsp; Windows NT Programming Note </H2>
<BR>When doing Win32 programming, you should use the /ei and /zp4 options to compile C and C++ code with the Open Watcom compilers
since this adjusts the compilers to match the default Microsoft compiler behaviour.&nbsp; Some Microsoft software relies on
the default behaviour of their own compiler regarding the treatment of enums and structure packing alignment.
<H2 ID="NT__Windows_NT_CharacterMmode_Versus_GUI"> NT:&nbsp; Windows NT Character-mode Versus GUI </H2>
<BR>Basically, there are two classes of C/C++ applications that can run in a windowed environment like Windows NT.
<BR><BR>The first are those C/C++ applications that do not use any of the Win32 API functions; they are strictly C/C++ applications
that do not rely on the features of a particular operating system.
<UL>
<LI>This Application must be created as Windows NT Character-mode Application.
</UL>
<BR>The second class of C/C++ applications are those that actually call Win32 API functions directly.&nbsp; These are applications
that have been tailored for the Win32 operating environment.&nbsp; There can occure two application types.
<UL>
<LI>First one uses GUI interface then it must be created as Windows NT GUI Application.
<LI>Second one uses only character console (no GUI) then it must be created as Windows NT Character-mode Application
</UL>
<BR>A subsequent chapters deal with the creation of different application types for Windows NT target.
<H1 ID="NT__Creating_Windows_NT_GUI_Applications"> NT:&nbsp; Creating Windows NT GUI Applications </H1>
<BR>This chapter describes how to compile and link Windows NT GUI applications simply and quickly.&nbsp; In this chapter,
we look at applications written to exploit the Windows NT Application Programming Interface (API).
<BR><BR>We will illustrate the steps to creating Windows NT GUI applications by taking a small sample application and showing
you how to compile, link, run and debug it.
<H2 ID="NT__The_Sample_GUI_Application"> NT:&nbsp; The Sample GUI Application </H2>
<BR>To demonstrate the creation of Windows NT GUI applications, we introduce a simple sample program.&nbsp; The following
example is the &quot;hello&quot; program adapted for Windows.
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; #include &lt;windows.h&gt;</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; int PASCAL WinMain( HANDLE hInstance, HANDLE hPrevInst,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp; LPSTR lpCmdLine, int nCmdShow )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; MessageBox( NULL, &quot;Hello world&quot;,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&quot;Open Watcom C/C++ for Windows&quot;,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;MB_OK | MB_TASKMODAL );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return( 0 );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; }</TT>
<BR><BR>The goal of this program is to display the message &quot;Hello world&quot; on the screen.&nbsp; The<TT> MessageBox</TT>
Windows API function is used to accomplish this task.&nbsp; We will take you through the steps necessary to produce this result.
<H2 ID="NT__Building_and_Running_the_GUI_Application"> NT:&nbsp; Building and Running the GUI Application </H2>
<BR>To compile and link our example program which is stored in the file<TT> hello.c</TT>, enter the following command:
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; C&gt;wcl386 -l=nt_win -bt=nt&nbsp; hello.c</TT>
<BR><BR>The typical messages that appear on the screen are shown in the following illustration.
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; C&gt;wcl386 -l=nt_win -bt=nt&nbsp; hello.c</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Open Watcom C/C++32 Compile and Link Utility</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Copyright (c) 2002-2019 the Open Watcom Contributors. All Rights Reserved.</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Portions Copyright (c) 1988-2002 Sybase, Inc. All Rights Reserved.</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Source code is available under the Sybase Open Watcom Public License.</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; See http://www.openwatcom.org/ for details.</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; wcc386 hello.c&nbsp; -bt=nt </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Open Watcom C32 Optimizing Compiler</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Copyright (c) 2002-2019 the Open Watcom Contributors. All Rights Reserved.</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Portions Copyright (c) 1984-2002 Sybase, Inc. All Rights Reserved.</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Source code is available under the Sybase Open Watcom Public License.</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; See http://www.openwatcom.org/ for details.</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; hello.c: 10 lines, included 6500, 0 warnings, 0 errors</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Code size: 41</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Open Watcom Linker</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Copyright (c) 2002-2019 the Open Watcom Contributors. All Rights Reserved.</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Portions Copyright (c) 1985-2002 Sybase, Inc. All Rights Reserved.</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Source code is available under the Sybase Open Watcom Public License.</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; See http://www.openwatcom.org/ for details.</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; loading object files</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; searching libraries</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; creating a Windows NT windowed executable</TT>
<BR><BR>If you examine the current directory, you will find that two files have been created.&nbsp; These are<TT> hello.obj</TT>
(the result of compiling<TT> hello.c</TT>) and<TT> hello.exe</TT> (the result of linking<TT> hello.obj</TT> with the appropriate
Open Watcom C/C++ libraries).
<BR><BR>The resultant Windows NT GUI application<TT> HELLO.EXE</TT> can now be run under Windows NT.
<H2 ID="NT__Debugging_the_GUI_Application"> NT:&nbsp; Debugging the GUI Application </H2>
<BR>Let us assume that you wish to debug your application in order to locate an error in programming.&nbsp; In the previous
section, the &quot;hello&quot; program was compiled with default compile and link options.&nbsp; When debugging an application,
it is useful to refer to the symbolic names of routines and variables.&nbsp; It is also convenient to debug at the source
line level rather than the machine language level.&nbsp; To do this, we must direct both the compiler and linker to include
additional debugging information in the object and executable files.&nbsp; Using the <TT> WCL386</TT> command, this is fairly
straightforward.&nbsp; <TT> WCL386</TT> recognizes the Open Watcom C/C++ compiler &quot;debug&quot; options and will create
the appropriate debug directives for the Open Watcom Linker.
<BR><BR>For example, to compile and link the &quot;hello&quot; program with debugging information, the following command may
be issued.
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; C&gt;wcl386 -l=nt_win -bt=nt&nbsp; -d2 hello.c</TT>
<BR><BR>The typical messages that appear on the screen are shown in the following illustration.
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; C&gt;wcl386 -l=nt_win -bt=nt&nbsp; -d2 hello.c</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Open Watcom C/C++32 Compile and Link Utility</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Copyright (c) 2002-2019 the Open Watcom Contributors. All Rights Reserved.</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Portions Copyright (c) 1988-2002 Sybase, Inc. All Rights Reserved.</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Source code is available under the Sybase Open Watcom Public License.</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; See http://www.openwatcom.org/ for details.</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; wcc386 hello.c -bt=nt&nbsp; -d2</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Open Watcom C32 Optimizing Compiler</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Copyright (c) 2002-2019 the Open Watcom Contributors. All Rights Reserved.</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Portions Copyright (c) 1984-2002 Sybase, Inc. All Rights Reserved.</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Source code is available under the Sybase Open Watcom Public License.</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; See http://www.openwatcom.org/ for details.</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; hello.c: 10 lines, included 6500, 0 warnings, 0 errors</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Code size: 66</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Open Watcom Linker</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Copyright (c) 2002-2019 the Open Watcom Contributors. All Rights Reserved.</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Portions Copyright (c) 1985-2002 Sybase, Inc. All Rights Reserved.</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Source code is available under the Sybase Open Watcom Public License.</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; See http://www.openwatcom.org/ for details.</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; loading object files</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; searching libraries</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; creating a Windows NT windowed executable</TT>
<BR><BR>The &quot;d2&quot; option requests the maximum amount of debugging information that can be provided by the Open Watcom
C/C++ compiler.&nbsp; <TT> WCL386</TT> will make sure that this debugging information is included in the executable file that
is produced by the linker.
<BR><BR>The &quot;Code size&quot; value is larger than in the previous example since selection of the &quot;d2&quot; option
results in fewer code optimizations by default.&nbsp; You can request more optimization by specifying the appropriate options.
&nbsp;However, you do so at the risk of making it more difficult for yourself to determine the relationship between the object
code and the original source language code.
<BR><BR>To request the Open Watcom Debugger to assist in debugging the application, select the Open Watcom Debugger icon.
&nbsp;It would be too ambitious to describe the debugger in this introductory chapter so we refer you to the book entitled<B><I>
Open Watcom Debugger User's Guide.</I></B>
<H1 ID="NT__Creating_Windows_NT_CharacterMmode_Applications"> NT:&nbsp; Creating Windows NT Character-mode Applications </H1>
<BR>This chapter describes how to compile and link Windows NT Character-mode applications simply and quickly.&nbsp; In this
chapter, we look at applications written to exploit the Windows NT Application Programming Interface (API).
<BR><BR>We will illustrate the steps to creating Windows NT Character-mode applications by taking a small sample application
and showing you how to compile, link, run and debug it.
<H2 ID="NT__The_Sample_CharacterMmode_Application"> NT:&nbsp; The Sample Character-mode Application </H2>
<BR>To demonstrate the creation of Windows NT Character-mode applications, we introduce a simple sample program.&nbsp; The
following example is the &quot;hello&quot; program adapted for Windows.
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; #include &lt;stdio.h&gt;</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; void main()</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;Hello world\n&quot; );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; }</TT>
<BR><BR>The goal of this program is to display the message &quot;Hello world&quot; on the screen.&nbsp; The C library<TT>
printf</TT> routine is used to accomplish this task.&nbsp; We will take you through the steps necessary to produce this result.
<H2 ID="NT__Building_and_Running_the_CharacterMmode_Application"> NT:&nbsp; Building and Running the Character-mode Application </H2>
<BR>To compile and link our example program which is stored in the file<TT> hello.c</TT>, enter the following command:
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; C&gt;wcl386 -l=nt -bt=nt hello.c</TT>
<BR><BR>The typical messages that appear on the screen are shown in the following illustration.
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; C&gt;wcl386 -l=nt -bt=nt hello.c</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Open Watcom C/C++32 Compile and Link Utility</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Copyright (c) 2002-2019 the Open Watcom Contributors. All Rights Reserved.</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Portions Copyright (c) 1988-2002 Sybase, Inc. All Rights Reserved.</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Source code is available under the Sybase Open Watcom Public License.</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; See http://www.openwatcom.org/ for details.</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; wcc386 hello.c&nbsp; -bt=nt</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Open Watcom C32 Optimizing Compiler</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Copyright (c) 2002-2019 the Open Watcom Contributors. All Rights Reserved.</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Portions Copyright (c) 1984-2002 Sybase, Inc. All Rights Reserved.</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Source code is available under the Sybase Open Watcom Public License.</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; See http://www.openwatcom.org/ for details.</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; hello.c: 10 lines, included 6500, 0 warnings, 0 errors</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Code size: 41</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Open Watcom Linker</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Copyright (c) 2002-2019 the Open Watcom Contributors. All Rights Reserved.</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Portions Copyright (c) 1985-2002 Sybase, Inc. All Rights Reserved.</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Source code is available under the Sybase Open Watcom Public License.</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; See http://www.openwatcom.org/ for details.</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; loading object files</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; searching libraries</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; creating a Windows NT Character-mode executable</TT>
<BR><BR>If you examine the current directory, you will find that two files have been created.&nbsp; These are<TT> hello.obj</TT>
(the result of compiling<TT> hello.c</TT>) and<TT> hello.exe</TT> (the result of linking<TT> hello.obj</TT> with the appropriate
Open Watcom C/C++ libraries).
<BR><BR>The resultant Windows NT Character-mode application<TT> HELLO.EXE</TT> can now be run under Windows NT.
<H2 ID="NT__Debugging_the_CharacterMmode_Application"> NT:&nbsp; Debugging the Character-mode Application </H2>
<BR>Let us assume that you wish to debug your application in order to locate an error in programming.&nbsp; In the previous
section, the &quot;hello&quot; program was compiled with default compile and link options.&nbsp; When debugging an application,
it is useful to refer to the symbolic names of routines and variables.&nbsp; It is also convenient to debug at the source
line level rather than the machine language level.&nbsp; To do this, we must direct both the compiler and linker to include
additional debugging information in the object and executable files.&nbsp; Using the <TT> WCL386</TT> command, this is fairly
straightforward.&nbsp; <TT> WCL386</TT> recognizes the Open Watcom C/C++ compiler &quot;debug&quot; options and will create
the appropriate debug directives for the Open Watcom Linker.
<BR><BR>For example, to compile and link the &quot;hello&quot; program with debugging information, the following command may
be issued.
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; C&gt;wcl386 -l=nt -bt=nt -d2 hello.c</TT>
<BR><BR>The typical messages that appear on the screen are shown in the following illustration.
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; C&gt;wcl386 -l=nt -bt=nt -d2 hello.c</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Open Watcom C/C++32 Compile and Link Utility</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Copyright (c) 2002-2019 the Open Watcom Contributors. All Rights Reserved.</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Portions Copyright (c) 1988-2002 Sybase, Inc. All Rights Reserved.</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Source code is available under the Sybase Open Watcom Public License.</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; See http://www.openwatcom.org/ for details.</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; wcc386 hello.c -bt=nt -d2</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Open Watcom C32 Optimizing Compiler</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Copyright (c) 2002-2019 the Open Watcom Contributors. All Rights Reserved.</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Portions Copyright (c) 1984-2002 Sybase, Inc. All Rights Reserved.</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Source code is available under the Sybase Open Watcom Public License.</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; See http://www.openwatcom.org/ for details.</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; hello.c: 10 lines, included 6500, 0 warnings, 0 errors</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Code size: 66</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Open Watcom Linker</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Copyright (c) 2002-2019 the Open Watcom Contributors. All Rights Reserved.</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Portions Copyright (c) 1985-2002 Sybase, Inc. All Rights Reserved.</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Source code is available under the Sybase Open Watcom Public License.</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; See http://www.openwatcom.org/ for details.</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; loading object files</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; searching libraries</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; creating a Windows NT Character-mode executable</TT>
<BR><BR>The &quot;d2&quot; option requests the maximum amount of debugging information that can be provided by the Open Watcom
C/C++ compiler.&nbsp; <TT> WCL386</TT> will make sure that this debugging information is included in the executable file that
is produced by the linker.
<BR><BR>The &quot;Code size&quot; value is larger than in the previous example since selection of the &quot;d2&quot; option
results in fewer code optimizations by default.&nbsp; You can request more optimization by specifying the appropriate options.
&nbsp;However, you do so at the risk of making it more difficult for yourself to determine the relationship between the object
code and the original source language code.
<BR><BR>To request the Open Watcom Debugger to assist in debugging the application, select the Open Watcom Debugger icon.
&nbsp;It would be too ambitious to describe the debugger in this introductory chapter so we refer you to the book entitled<B><I>
Open Watcom Debugger User's Guide.</I></B>
<H1 ID="NT__Windows_NT_MultiMthreaded_Applications"> NT:&nbsp; Windows NT Multi-threaded Applications </H1>
<BR>This chapter describes how to create multi-threaded applications.&nbsp; A multi-threaded application is one whose tasks
are divided among several threads of execution.&nbsp; A process is an executing application and the resources it uses.&nbsp;
A thread is the smallest unit of execution within a process.&nbsp; Each thread has its own stack and a set of machine registers
and shares all resources with its parent process.&nbsp; The path of execution of one thread does not affect that of another;
each thread is an independent entity.
<BR><BR>Typically, an application has a single thread of execution.&nbsp; In this type of application, all tasks, once initiated,
are completed before the next task begins.&nbsp; In contrast, tasks in a multi-threaded application can be performed concurrently
since more than one thread is executing at once.&nbsp; For example, each thread may be designed to perform a separate task.
<H2 ID="NT__Programming_Considerations"> NT:&nbsp; Programming Considerations </H2>
<BR>Since a multi-threaded application consists of many threads of execution, there are a number of issues that you must consider.
<BR><BR>Since threads share the resources of its parent, it may be necessary to serialize access to these resources.&nbsp;
For example, if your application has a function that displays information on the console and is used by all threads, it is
necessary to allow only one thread to use that function at any time.&nbsp; That is, once a thread calls that function, the
function should ensure that no other thread displays information until all information for the initial thread has been displayed.
&nbsp;An example of such a function is the<TT> printf</TT> library function.
<BR><BR>Another issue that must be considered when creating multi-threaded applications is global variables.&nbsp; If you
have global variables that contain thread-specific information, there must be an instance of each global variable for each
thread.&nbsp; An example of such a variable is the<TT> errno</TT> global variable defined in the run-time libraries.&nbsp;
If an error condition was created by a thread, you would not want it to affect the execution of other threads.&nbsp; Therefore,
each thread should contain its own instance of this variable.
<H2 ID="NT__Creating_Threads"> NT:&nbsp; Creating Threads </H2>
<BR>Each application initially contains a single thread.&nbsp; The run-time libraries contain two functions that create and
terminate threads of execution.&nbsp; The function<TT> _beginthread</TT> creates a thread of execution and the function<TT>
_endthread</TT> ends a thread of execution.&nbsp; The macro<TT> _threadid</TT> can be used to determine the current thread
identifier.
<HR>
<BR><B><I>&nbsp; WARNING!</I></B>&nbsp; If any thread calls a library function, you must use the<TT> _beginthread</TT> function
to create the thread.&nbsp; Do not use the<TT> CreateThread</TT> API function.
<HR>
<H3 ID="NT__Creating_a_New_Thread"> NT:&nbsp; Creating a New Thread </H3>
<BR>The<TT> _beginthread</TT> function creates a new thread.&nbsp; It is defined as follows.
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; unsigned long _beginthread( void (*start_address)(void *),</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; unsigned stack_size,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; void *arglist);</TT>
<DL>
<DT>where
<DD><B>description</B>
<DT>start_address
<DD>is the address of the function that will be called when the newly created thread is executed.&nbsp; When the thread returns
from that function, the thread will be terminated.&nbsp; Note that a call to the<TT> _endthread</TT> function will also terminate
the thread.
<DT>stack_size
<DD>specifies the size of the stack to be allocated by the operating system for the new thread.&nbsp; The stack size should be
a multiple of 4K.
<DT>arglist
<DD>is passed as an argument to the function specified by<TT> start_address.</TT>&nbsp; If no argument is required, a value of
NULL can be specified.
</DL>
<BR>If a new thread is successfully created, the thread identifier of the new thread is returned.&nbsp; Otherwise, a value
of -1 is returned.
<BR><BR>The header file<TT> process.h</TT> contains the definition of the<TT> _beginthread</TT> function.
<BR><BR>Another thread related function for Windows NT is<TT> _beginthreadex.</TT>&nbsp; See the<B><I> Open Watcom C Library
Reference</I></B> for more information.
<H3 ID="NT__Terminating_the_Current_Thread"> NT:&nbsp; Terminating the Current Thread </H3>
<BR>The<TT> _endthread</TT> function terminates the current thread.&nbsp; It is defined as follows.
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; void _endthread( void )</TT>
<BR><BR>The header file<TT> process.h</TT> contains the definition of the<TT> _endthread</TT> function.
<H3 ID="NT__Getting_the_Current_Thread_Identifier"> NT:&nbsp; Getting the Current Thread Identifier </H3>
<BR>The<TT> _threadid</TT> macro can be used to determine the current thread identifier.&nbsp; It is defined as follows.
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; int *__threadid(void);</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; #define _threadid (__threadid())</TT>
<BR><BR>The header file<TT> stddef.h</TT> contains the definition of the<TT> _threadid</TT> macro.
<H2 ID="NT__A_MultiMthreaded_Example"> NT:&nbsp; A Multi-threaded Example </H2>
<BR>Let us create a simple multi-threaded application.
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; #include &lt;process.h&gt;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; #include &lt;stdio.h&gt;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; #include &lt;stddef.h&gt;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; #include &lt;windows.h&gt;</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; static&nbsp; volatile int&nbsp;&nbsp;&nbsp; NumThreads;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; static&nbsp; volatile int&nbsp;&nbsp;&nbsp; HoldThreads;</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; CRITICAL_SECTION CriticalSection;</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; #define NUM_THREADS&nbsp;&nbsp;&nbsp;&nbsp; 5</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; #define STACK_SIZE&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 8192</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; static void a_thread( void *arglist )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; /***********************************/</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; while( HoldThreads ) {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Sleep( 1 );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;Hi from thread %d\n&quot;, *_threadid );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; EnterCriticalSection( &amp;CriticalSection );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; --NumThreads;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; LeaveCriticalSection( &amp;CriticalSection );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; _endthread();</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; }</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; int main( void )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; /**************/</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; i;</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;Initial thread id = %d\n&quot;, *_threadid );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; NumThreads = 0;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; HoldThreads = 1;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; InitializeCriticalSection( &amp;CriticalSection );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* initial thread counts as 1 */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for( i = 2; i &lt;= NUM_THREADS; ++i ) {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if( _beginthread( a_thread, STACK_SIZE, NULL
) == -1 ) {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;creation
of thread %d failed\n&quot;, i );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; } else {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ++NumThreads;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; HoldThreads = 0;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; while( NumThreads != 0 ) {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Sleep( 1 );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DeleteCriticalSection( &amp;CriticalSection );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return( 0 );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; }</TT>
<BR><BR><B>Note:</B>
<OL>
<LI>In the function<TT> a_thread, EnterCriticalSection</TT> and<TT> LeaveCriticalSection</TT> are called when we modify the
variable<TT> NumThreads.</TT>&nbsp; This ensures that the action of extracting the value of<TT> NumThreads</TT> from memory,
incrementing the value, and storing the new result into memory, occurs without interruption.&nbsp; If these functions were
not called, it would be possible for two threads to extract the value of<TT> NumThreads</TT> from memory before an update
occurred.
</OL>
<BR>Let us assume that the file<TT> mthread.c</TT> contains the above example.&nbsp; Before compiling the file, make sure
that the<B> WATCOM</B> environment variable is set to the directory in which you installed Open Watcom C/C++.&nbsp; Also,
the<B> INCLUDE</B> environment variable must include the<TT> \watcom\h\nt</TT> and<TT> \watcom\h</TT> directories (&quot;\WATCOM&quot;
is the directory in which Open Watcom C/C++ was installed).
<BR><BR>We can now compile and link the application by issuing the following command.
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; C:\&gt;wcl386 -bt=nt -bm -l=nt mthread</TT>
<BR><BR>The &quot;bm&quot; option must be specified since we are creating a multi-threaded application.&nbsp; If your multi-threaded
application contains more than one module, each module must be compiled using the &quot;bm&quot; switch.
<BR><BR>The &quot;l&quot; option specifies the target system for which the application is to be linked.&nbsp; The system name<TT>
nt</TT> is defined in the file<TT> wlsystem.lnk</TT> which is located in the &quot;BINW&quot; subdirectory of the directory
in which you installed Open Watcom C/C++.
<BR><BR>The multi-threaded application is now ready to be run.
<H1 ID="NT__Windows_NT_Dynamic_Link_Libraries"> NT:&nbsp; Windows NT Dynamic Link Libraries </H1>
<BR>A dynamic link library, like a standard library, is a library of functions.&nbsp; When an application uses functions from
a standard library, the library functions referenced by the application become part of the executable module.&nbsp; This form
of linking is called static linking.&nbsp; When an application uses functions from a dynamic link library, the library functions
referenced by the application are not included in the executable module.&nbsp; Instead, the executable module contains references
to these functions which are resolved when the application is loaded.&nbsp; This form of linking is called dynamic linking.
<BR><BR>Let us consider some of the advantages of using dynamic link libraries over standard libraries.
<OL>
<LI>Functions in dynamic link libraries are not linked into your program.&nbsp; Only references to the functions in dynamic
link libraries are placed in the program module.&nbsp; These references are called import definitions.&nbsp; As a result,
the linking time is reduced and disk space is saved.&nbsp; If many applications reference the same dynamic link library, the
saving in disk space can be significant.
<LI>Since program modules only reference dynamic link libraries and do not contain the actual executable code, a dynamic link
library can be updated without re-linking your application.&nbsp; When your application is executed, it will use the updated
version of the dynamic link library.
<LI>Dynamic link libraries also allow sharing of code and data between the applications that use them.&nbsp; If many applications
that use the same dynamic link library are executing concurrently, the sharing of code and data segments improves memory utilization.
</OL>
<H2 ID="NT__Creating_Dynamic_Link_Libraries"> NT:&nbsp; Creating Dynamic Link Libraries </H2>
<BR>Once you have developed the source for a library of functions, a number of steps are required to create a dynamic link
library containing those functions.
<BR><BR>First, you must compile your source using the &quot;bd&quot; compiler option.&nbsp; This option tells the compiler
that the module you are compiling is part of a dynamic link library.&nbsp; Once you have successfully compiled your source,
you must create a linker directive file that describes the attributes of your dynamic link library.&nbsp; The following lists
the most common linker directives required to create a dynamic link library.
<OL>
<LI>The &quot;SYSTEM&quot; directive is used to specify that a dynamic link library is to be created.
<LI>The &quot;EXPORT&quot; directive is used to to specify which functions in the dynamic link library are to be exported.
<DL>
<DT>Specifying exports in the source code
<DD>
<BR><BR>The &quot;EXPORT&quot; directive need not be used when the symbols to be exported are declared with the<TT> __declspec(
dllexport )</TT> modifier in the source code.&nbsp; Such symbols are exported automatically, through special records inserted
into the object files by the compiler.
<DT>Exporting C++ symbols and classes
<DD>
<BR><BR>Symbols exported via the &quot;EXPORT&quot; directive have to be entered in their mangled form.&nbsp; This makes it
rather awkward to export C++ functions, classes or global objects.&nbsp; These symbols also often reference other compiler-generated
symbols (invisible to the user) that need be exported together with the class/object.&nbsp; Using the<TT> __declspec( dllexport
)</TT> method of exporting symbols is the preferred solution.
</DL>
<LI>The &quot;OPTION&quot; directive is used to specify attributes such as the name of the dynamic link library and how to
allocate the automatic data segment when the dynamic link library is referenced.
<LI>The &quot;SEGMENT&quot; directive is used to specify attributes of segments.&nbsp; For example, a segment may be read-only
or read-write.
</OL>
<BR>Once the dynamic link library is created, you must allow access to the dynamic link library to client applications that
wish to use it.&nbsp; This can be done by creating an import library for the dynamic link library or creating a linker directive
file that contains &quot;IMPORT&quot; directives for each of the entry points in the dynamic link library.
<H2 ID="NT__Creating_a_Sample_Dynamic_Link_Library"> NT:&nbsp; Creating a Sample Dynamic Link Library </H2>
<BR>Let us now create a dynamic link library using the following example.
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; #include &lt;stdio.h&gt;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; #include &lt;windows.h&gt;</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; #if defined(__cplusplus)</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; #define EXPORTED extern &quot;C&quot; __declspec( dllexport )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; #else</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; #define EXPORTED __declspec( dllexport )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; #endif</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; DWORD TlsIndex; /* Global Thread Local Storage index */</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; /* Error checking should be performed in following code */</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; BOOL APIENTRY LibMain( HANDLE hinstDLL,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DWORD&nbsp; fdwReason,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; LPVOID lpvReserved )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; switch( fdwReason ) {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; case DLL_PROCESS_ATTACH:</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* do process initialization */</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* create TLS index */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; TlsIndex = TlsAlloc();</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; case DLL_THREAD_ATTACH:</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* do thread initialization */</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* allocate private storage for thread
*/</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* and save pointer to it */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; TlsSetValue( TlsIndex, malloc(200) );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; case DLL_THREAD_DETACH:</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* do thread cleanup */</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* get the TLS value and free associated
memory */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; free( TlsGetValue( TlsIndex ) );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; case DLL_PROCESS_DETACH:</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* do process cleanup */</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* free TLS index */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; TlsFree( TlsIndex );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return( 1 );&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* indicate
success */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* returning 0 indicates initialization failure */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; }</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; EXPORTED void dll_entry_1( void )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;Hi from dll entry #1\n&quot; );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; }</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; EXPORTED void dll_entry_2( void )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;Hi from dll entry #2\n&quot; );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; }</TT>
<DL>
<DT>Arguments:
<DD>
<DT>hinstDLL
<DD>This is a handle for the DLL.&nbsp; It can be used as a argument to other functions such as <TT> GetModuleFileName</TT>.
<DT>fdwReason
<DD>This argument indicates why <TT> LibMain</TT> is being called.&nbsp; It can have one of the following values:
<DL>
<DT>Value
<DD>Meaning
<DT>DLL_PROCESS_ATTACH
<DD>This value indicates that the DLL is attaching to the address space of the current process as a result of the process starting
up or as a result of a call to <TT> LoadLibrary</TT>.&nbsp; A DLL can use this opportunity to initialize any instance data
or to use the <TT> TlsAlloc</TT> function to allocate a Thread Local Storage (TLS) index.
<BR><BR>During initial process startup or after a call to <TT> LoadLibrary</TT>, the operating system scans the list of loaded
DLLs for the process.&nbsp; For each DLL that has not already been called with the<TT> DLL_PROCESS_ATTACH</TT> value, the
system calls the DLL's <TT> LibMain</TT> entry-point.&nbsp; This call is made in the context of the thread that caused the
process address space to change, such as the primary thread of the process or the thread that called <TT> LoadLibrary</TT>.
<DT>DLL_THREAD_ATTACH
<DD>This value indicates that the current process is creating a new thread.&nbsp; When this occurs, the system calls the <TT>
LibMain</TT> entry-point of all DLLs currently attached to the process.&nbsp; The call is made in the context of the new thread.
&nbsp;DLLs can use this opportunity to initialize a Thread Local Storage (TLS) slot for the thread.&nbsp; A thread calling
the DLL's<TT> LibMain</TT> with the<TT> DLL_PROCESS_ATTACH</TT> value does not call <TT> LibMain</TT> with the<TT> DLL_THREAD_ATTACH</TT>
value.&nbsp; Note that <TT> LibMain</TT> is called with this value only by threads created after the DLL is attached to the
process.&nbsp; When a DLL is attached by <TT> LoadLibrary</TT>, existing threads do not call the <TT> LibMain</TT> entry-point
of the newly loaded DLL.
<DT>DLL_THREAD_DETACH
<DD>This value indicates that a thread is exiting normally.&nbsp; If the DLL has stored a pointer to allocated memory in a TLS
slot, it uses this opportunity to free the memory.&nbsp; The operating system calls the <TT> LibMain</TT> entry-point of all
currently loaded DLLs with this value.&nbsp; The call is made in the context of the exiting thread.&nbsp; There are cases
in which <TT> LibMain</TT> is called for a terminating thread even if the DLL never attached to the thread.&nbsp; For example,
<TT> LibMain</TT> is never called with the<TT> DLL_THREAD_ATTACH</TT> value in the context of the thread in either of these
two situations:
<UL>
<LI>The thread was the initial thread in the process, so the system called <TT> LibMain</TT> with the<TT> DLL_PROCESS_ATTACH</TT>
value.
<LI>The thread was already running when a call to the <TT> LoadLibrary</TT> function was made, so the system never called
<TT> LibMain</TT> for it.
</UL>
<DT>DLL_PROCESS_DETACH
<DD>This value indicates that the DLL is detaching from the address space of the calling process as a result of either a normal
termination or of a call to <TT> FreeLibrary</TT>.&nbsp; The DLL can use this opportunity to call the <TT> TlsFree</TT> function
to free any TLS indices allocated by using <TT> TlsAlloc</TT> and to free any thread local data.&nbsp; When a DLL detaches
from a process as a result of process termination or as a result of a call to <TT> FreeLibrary</TT>, the operating system
does not call the DLL's <TT> LibMain</TT> with the<TT> DLL_THREAD_DETACH</TT> value for the individual threads of the process.
&nbsp;The DLL is only given<TT> DLL_PROCESS_DETACH</TT> notification.&nbsp; DLLs can take this opportunity to clean up all
resources for all threads attached and known to the DLL.
</DL>
<DT>lpvReserved
<DD>This argument specifies further aspects of DLL initialization and cleanup.&nbsp; If<TT> fdwReason</TT> is<TT> DLL_PROCESS_ATTACH,
lpvReserved</TT> is NULL for dynamic loads and non-NULL for static loads.&nbsp; If<TT> fdwReason</TT> is<TT> DLL_PROCESS_DETACH,
lpvReserved</TT> is NULL if <TT> LibMain</TT> has been called by using <TT> FreeLibrary</TT> and non-NULL if <TT> LibMain</TT>
has been called during process termination.
<DT>Return Value
<DD>When the system calls the<TT> LibMain</TT> function with the<TT> DLL_PROCESS_ATTACH</TT> value, the function returns TRUE
(1) if initialization succeeds or FALSE (0) if initialization fails.
<BR><BR>If the return value is FALSE (0) when <TT> LibMain</TT> is called because the process uses the <TT> LoadLibrary</TT>
function, <TT> LoadLibrary</TT> returns NULL.
<BR><BR>If the return value is FALSE (0) when <TT> LibMain</TT> is called during process initialization, the process terminates
with an error.&nbsp; To get extended error information, call <TT> GetLastError</TT>.
<BR><BR>When the system calls <TT> LibMain</TT> with any value other than<TT> DLL_PROCESS_ATTACH,</TT> the return value is
ignored.
</DL>
<BR>Assume the above example is contained in the file<TT> dllsamp.c.</TT>&nbsp; We can compile the file using the following
command.&nbsp; Note that we must specify the &quot;bd&quot; compiler option.
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; C:\&gt;wcc386 -bd dllsamp</TT>
<BR><BR>Before we can link our example, we must create a linker directive file that describes the attributes and entry points
of our dynamic link library.&nbsp; The following is a linker directive file, called<TT> dllsamp.lnk,</TT> that can be used
to create the dynamic link library.
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; system nt_dll initinstance terminstance</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; export dll_entry_1_</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; export dll_entry_2_</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; file dllsamp</TT>
<BR><BR><B>Notes:</B>
<OL>
<LI>The &quot;SYSTEM&quot; directive specifies that we are creating a Windows NT dynamic link library.
<LI>When a dynamic link library uses the Open Watcom C/C++ run-time libraries, an automatic data segment is created each time
a new process accesses the dynamic link library.&nbsp; For this reason, initialization code must be executed when a process
accesses the dynamic link library for the first time.&nbsp; To achieve this, &quot;INITINSTANCE&quot; must be specified in
the &quot;SYSTEM&quot; directive.&nbsp; Similarly, &quot;TERMINSTANCE&quot; must be specified so that the termination code
is executed when a process has completed its access to the dynamic link library.&nbsp; If the Open Watcom C/C++ run-time libraries
are not used, these options are not required.
<LI>The &quot;EXPORT&quot; directive specifies the entry points into the dynamic link library.&nbsp; Note that the names specified
in the &quot;EXPORT&quot; directive are appended with an underscore.&nbsp; This is the default naming convention used when
compiling using the register-based calling convention.&nbsp; No underscore is required when compiling using the stack-based
calling convention.
</OL>
<BR>We can now create our dynamic link library by issuing the following command.
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; C:\&gt;wlink @dllsamp</TT>
<BR><BR>A file called<TT> dllsamp.dll</TT> will be created.
<H2 ID="NT__Using_Dynamic_Link_Libraries"> NT:&nbsp; Using Dynamic Link Libraries </H2>
<BR>It is assumed that all symbols imported by a client application were declared with a<TT> __declspec( dllimport )</TT>
modifier when the client application was compiled.&nbsp; At the link stage we have to tell the linker which dynamic libraries
the client application should link to.&nbsp; Once we have created a dynamic link library, we must allow other applications
to access the functions available in the dynamic link library.&nbsp; There are two ways to achieve this.
<BR><BR>The first method is to create a linker directive file which contains an &quot;IMPORT&quot; directive for all entry
points in the dynamic link library.&nbsp; The &quot;IMPORT&quot; directive provides the name of the entry point and the name
of the dynamic link library.&nbsp; When creating an application that references a function in the dynamic link library, this
linker directive file would be included as part of the linking process that created the application.
<BR><BR>The second method is to use import libraries.&nbsp; An import library is a standard library that is created from a
dynamic link library by using the Open Watcom Library Manager.&nbsp; It contains object modules that describe the entry points
in a dynamic link library.&nbsp; The resulting import library can then be specified in a &quot;LIBRARY&quot; directive in
the same way one would specify a standard library.
<BR><BR>Using an import library is the preferred method of providing references to functions in dynamic link libraries.&nbsp;
When a dynamic link library is modified, typically the import library corresponding to the modified dynamic link library is
updated to reflect the changes.&nbsp; Hence, any directive file that specifies the import library in a &quot;LIBRARY&quot;
directive need not be modified.&nbsp; However, if you are using &quot;IMPORT&quot; directives, you may have to modify the
&quot;IMPORT&quot; directives to reflect the changes in the dynamic link library.
<BR><BR>Let us create an import library for our sample dynamic link library we created in the previous section.&nbsp; We do
this by issuing the following command.
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; C:\&gt;wlib dllsamp +dllsamp.dll</TT>
<BR><BR>A standard library called<TT> dllsamp.lib</TT> will be created.
<BR><BR>Suppose the following sample program, contained in the file<TT> dlltest.c,</TT> calls the functions from our sample
dynamic link library.
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; #include &lt;stdio.h&gt;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; #include &lt;process.h&gt;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; #if defined(__cplusplus)</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; #define IMPORTED extern &quot;C&quot; __declspec( dllimport )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; #else</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; #define IMPORTED __declspec( dllimport )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; #endif</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; IMPORTED void dll_entry_1( void );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; IMPORTED void dll_entry_2( void );</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; #define STACK_SIZE&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 8192</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; static void thread( void *arglist )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;Hi from thread\n&quot; );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; _endthread();</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; }</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; int main( void )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; unsigned long&nbsp;&nbsp; tid;</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; dll_entry_1();</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tid = _beginthread( thread, STACK_SIZE, NULL );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; dll_entry_2();</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return( 0 );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; }</TT>
<BR><BR>We can compile and link our sample application by issuing the following command.
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; C:\&gt;wcl386 -bm -l=nt dlltest dllsamp.lib</TT>
<BR><BR>If we had created a linker directive file of &quot;IMPORT&quot; directives instead of an import library for the dynamic
link library, the linker directive file, say<TT> dllimps.lnk,</TT> would be as follows.
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; import dll_entry_1_ dllsamp</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; import dll_entry_2_ dllsamp</TT>
<BR><BR>Note that the names specified in the &quot;IMPORT&quot; directive are appended with an underscore.&nbsp; This is the
default naming convention used when compiling using the register-based calling convention.&nbsp; No underscore is required
when compiling using the stack-based calling convention.
<BR><BR>To compile and link our sample application, we would issue the following command.
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; C:\&gt;wcl386 -bm -l=nt dlltest -&quot;@dllimps&quot;</TT>
<H2 ID="NT__The_Dynamic_Link_Library_Data_Area"> NT:&nbsp; The Dynamic Link Library Data Area </H2>
<BR>The Open Watcom C/C++ 32-bit run-time library does not support the general case operation of DLLs in an execution environment
where there is only one instance of the DATA segment (DGROUP) for that DLL.
<BR><BR>There are two cases that can lead to a DLL executing with only one instance of the DGROUP.
<OL>
<LI>DLLs linked for 32-bit OS/2 without the MANYAUTODATA option.
<LI>DLLs linked for the Win32 API and executing under Win32s.
</OL>
<BR>In these cases the run-time library startup code detects that there is only one instance of the DGROUP when a second process
attempts to attach to the DLL.&nbsp; At that point, it issues a diagnostic for the user and then notifies the operating system
that the second process cannot attach to the DLL.
<BR><BR>Developers who require DLLs to operate when there is only one instance of the DGROUP can suppress the function which
issues the diagnostic and notifies the operating system that the second process cannot attach to the DLL.
<BR><BR>Doing so requires good behaviour on the part of processes attaching to the DLL.&nbsp; This good behaviour consists
primarily of ensuring that the first process to attach to the DLL is also the last process to detach from the DLL thereby
ensuring that the DATA segment is not released back to the free memory pool.
<BR><BR>To suppress the function which issues the diagnostic and notifies the operating system that the second process cannot
attach to the DLL, the developer must provide a replacement entry point with the following prototype:
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; int __disallow_single_dgroup( int );</TT>
<BR><BR>This function should return zero to indicate that the detected single copy of the DATA segment is allowed.
<H1 ID="NT__Creating_Windows_NT_POSIX_Applications"> NT:&nbsp; Creating Windows NT POSIX Applications </H1>
<BR>This chapter describes how to compile and link POSIX applications for Windows NT.&nbsp; There are a number of issues to
consider.
<OL>
<LI>Open Watcom does not provide its own POSIX libraries.&nbsp; You must use those included with the Microsoft Win32 SDK.
&nbsp;They are<TT> libcpsx.lib, psxdll.lib</TT> and<TT> psxrtl.lib.</TT>&nbsp; If you installed the Win32 SDK component when
you installed the Open Watcom software, you will find these libraries in the<TT> %WATCOM%\lib386\nt</TT> directory.
<LI>Since you will be using Microsoft POSIX libraries compiled by the Microsoft compiler, you must follow the calling conventions
used by Microsoft (i.e., the<TT> __cdecl</TT> convention).&nbsp; The Open Watcom compiler can generate these calling conventions
provided that the POSIX library routines are all properly prototyped.
<LI>Open Watcom does not provide its own header files for use with the Microsoft POSIX libraries.&nbsp; The Microsoft Win32
SDK includes only a subset of the headers required for calling the POSIX library routines.&nbsp; If you installed the Win32
SDK component when you installed the Open Watcom software, you will find these headers in the<TT> %WATCOM%\sdk\posix\h</TT>
and<TT> %WATCOM%\sdk\posix\h\sys</TT> directories.&nbsp; Take a look at these directories to see what is and what is not included.
<LI>If you have the Microsoft compiler, then you will likely have access to the missing header files.&nbsp; If you do not
have the Microsoft compiler, then you will have to define prototypes for any of the POSIX library routines that you use for
which no prototypes are defined in any of the POSIX header files.
<LI>There is one exception to the generation of the<TT> __cdecl</TT> calling convention for appropriately prototyped functions.
&nbsp;This is the<TT> main</TT> function.&nbsp; Since many Microsoft sample programs inappropriately declare the<TT> main</TT>
function as<TT> __cdecl,</TT> it was necessary to make a special case in the Open Watcom compilers to ignore the<TT> __cdecl</TT>
attribute when used for this entry point.&nbsp; To work around this problem, a special pragma is used.&nbsp; This is shown
in the following example.
<LI>Since we are going to use the Microsoft POSIX libraries rather than the Open Watcom libraries, we will use the &quot;zl&quot;
compile option to instruct the Open Watcom compiler not to include references to Open Watcom libraries in the object files.
</OL>
<BR>To illustrate the creation of a POSIX application, we will use a simple example.&nbsp; This program displays an identifying
banner and then displays its arguments one at a time.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; [POSIXSMP.C]</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; #include &lt;unistd.h&gt;</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; // The Win32 SDK doesn't provide a complete set of</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; // headers for the libraries (e.g., no stdio.h).</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; extern int __cdecl printf( char *, ... );</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; // Note: the &quot;__cdecl&quot; attribute is ignored for main().</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; int __cdecl main( int argc, char **argv )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int i;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;POSIX sample program\n&quot; );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for( i = 0 ; i &lt; argc ; i++ ) {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;%d: %s\n&quot;, i, argv[i]
);</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return 0;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; }</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; // Since the &quot;__cdecl&quot; attribute is ignored,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; // make sure that parms go on the stack for main</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; // and that main gets the _ in the right place by</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; // using a pragma to do so.</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; #pragma aux main &quot;_*&quot; __parm [];</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; // The compiler emits references to these symbols,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; // so make sure they get defined here to prevent</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; // unresolved references.</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; int _cstart_;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; #pragma aux _cstart_ &quot;*&quot;;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; int __argc;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; #pragma aux __argc &quot;*&quot;;</TT>
<BR><BR>The example program illustrates some of the special considerations required for using the Microsoft POSIX libraries
rather than the Open Watcom libraries.&nbsp; There are also some special link time issues and these are addressed in the following
sample &quot;makefile&quot;.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; [MAKEFILE]</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; posixsmp.exe : posixsmp.c posix.add makefile.</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; set nt_include=</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; set include=$(%watcom)\sdk\posix\h;$(%watcom)\sdk\posix\h\sys</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; wcc386 -bt=nt -oaxt -zl posixsmp.c</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; wlink @posix.add file posixsmp sys nt_posix option map</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; posix.add :</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; %create posix.add</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; %append posix.add system begin nt_posix</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; %append posix.add&nbsp;&nbsp; option osname='Windows NT character-mode posix'</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; %append posix.add&nbsp;&nbsp; libpath %WATCOM%\lib386\nt</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; %append posix.add&nbsp;&nbsp; option nodefaultlib</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; %append posix.add&nbsp;&nbsp; option start=___PosixProcessStartup</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; %append posix.add&nbsp;&nbsp; lib { libcpsx.lib psxrtl.lib psxdll.lib }</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; %append posix.add&nbsp;&nbsp; format windows nt ^</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; %append posix.add&nbsp;&nbsp; runtime posix</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; %append posix.add end</TT>
<BR><BR>A new &quot;nt_posix&quot; system is defined in the<TT> posix.add</TT> file.&nbsp; This file is generated automatically
by the makefile.
<BR><BR>That is about all there is to creating a Windows NT POSIX application.&nbsp; One final note - make sure when using
the Microsoft headers that all the library routines that you use are declared as<TT> __cdecl</TT> otherwise your application
will not run correctly.
<H1 ID="16Mbit_OSD2__Creating_16Mbit_OSD2_1_x_Applications"> 16-bit OS/2:&nbsp; Creating 16-bit OS/2 1.x Applications </H1>
<BR><BR>An OS/2 application can be one of the following; a fullscreen application, a PM-compatible application, or a Presentation
Manager application.&nbsp; A fullscreen application runs in its own screen group.&nbsp; A PM-compatible application will run
in an OS/2 fullscreen environment or in a window in the Presentation Manager screen group but does not take direct advantage
of menus, mouse or other features available in the Presentation Manager.&nbsp; A Presentation Manager application has full
access to the complete set of user-interface tools such as menus, icons, scroll bars, etc.
<BR><BR>This chapter deals with the creation of OS/2 fullscreen applications.&nbsp; For information on creating Presentation
Manager applications, refer to the section entitled <A HREF="#OSD2__Programming_for_OSD2_Presentation_Manager">OS/2:&nbsp; Programming for OS/2 Presentation Manager</A>.
<BR><BR>We will illustrate the steps to creating 16-bit OS/2 1.x applications by taking a small sample application and showing
you how to compile, link, run and debug it.
<H2 ID="16Mbit_OSD2__The_Sample_Application"> 16-bit OS/2:&nbsp; The Sample Application </H2>
<BR>To demonstrate the creation of 16-bit OS/2 1.x applications using command-line oriented tools, we introduce a simple sample
program.&nbsp; For our example, we are going to use the famous &quot;hello&quot; program.
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; #include &lt;stdio.h&gt;</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; void main()</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;Hello world\n&quot; );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; }</TT>
<BR><BR>The C++ version of this program follows:
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; #include &lt;iostream.h&gt;</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; void main()</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cout &lt;&lt; &quot;Hello world&quot; &lt;&lt; endl;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; }</TT>
<BR><BR>The goal of this program is to display the message &quot;Hello world&quot; on the screen.&nbsp; The C version uses
the C library<TT> printf</TT> routine to accomplish this task.&nbsp; The C++ version uses the &quot;iostream&quot; library
to accomplish this task.&nbsp; We will take you through the steps necessary to produce this result.
<H2 ID="16Mbit_OSD2__Building_and_Running_the_Sample_OSD2_1_x_Application"> 16-bit OS/2:&nbsp; Building and Running the Sample OS/2 1.x Application </H2>
<BR>To compile and link our example program which is stored in the file<TT> hello.c</TT>, enter the following command:
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; [C:\]wcl -l=os2 hello.c</TT>
<BR><BR>The typical messages that appear on the screen are shown in the following illustration.
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; [C:\]wcl -l=os2&nbsp; hello.c</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Open Watcom C/C++16 Compile and Link Utility</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Copyright (c) 2002-2019 the Open Watcom Contributors. All Rights Reserved.</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Portions Copyright (c) 1988-2002 Sybase, Inc. All Rights Reserved.</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Source code is available under the Sybase Open Watcom Public License.</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; See http://www.openwatcom.org/ for details.</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; wcc hello.c&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Open Watcom C16 Optimizing Compiler</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Copyright (c) 2002-2019 the Open Watcom Contributors. All Rights Reserved.</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Portions Copyright (c) 1984-2002 Sybase, Inc. All Rights Reserved.</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Source code is available under the Sybase Open Watcom Public License.</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; See http://www.openwatcom.org/ for details.</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; hello.c: 6 lines, included 155, 0 warnings, 0 errors</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Code size: 17</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Open Watcom Linker</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Copyright (c) 2002-2019 the Open Watcom Contributors. All Rights Reserved.</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Portions Copyright (c) 1985-2002 Sybase, Inc. All Rights Reserved.</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Source code is available under the Sybase Open Watcom Public License.</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; See http://www.openwatcom.org/ for details.</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; loading object files</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; searching libraries</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; creating an OS/2 16-bit executable</TT>
<BR><BR>Provided that no errors were encountered during the compile or link phases, the &quot;hello&quot; program may now
be run.
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; [C:\]hello</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Hello world</TT>
<BR><BR>If you examine the current directory, you will find that two files have been created.&nbsp; These are<TT> hello.obj</TT>
(the result of compiling<TT> hello.c</TT>) and<TT> hello.exe</TT> (the result of linking<TT> hello.obj</TT> with the appropriate
Open Watcom C/C++ libraries).&nbsp; It is<TT> hello.exe</TT> that is run by OS/2 when you enter the &quot;hello&quot; command.
<H2 ID="16Mbit_OSD2__Debugging_the_Sample_OSD2_1_x_Application"> 16-bit OS/2:&nbsp; Debugging the Sample OS/2 1.x Application </H2>
<BR>Let us assume that you wish to debug your application in order to locate an error in programming.&nbsp; In the previous
section, the &quot;hello&quot; program was compiled with default compile and link options.&nbsp; When debugging an application,
it is useful to refer to the symbolic names of routines and variables.&nbsp; It is also convenient to debug at the source
line level rather than the machine language level.&nbsp; To do this, we must direct both the compiler and linker to include
additional debugging information in the object and executable files.&nbsp; Using the <TT> WCL</TT> command, this is fairly
straightforward.&nbsp; <TT> WCL</TT> recognizes the Open Watcom C/C++ compiler &quot;debug&quot; options and will create the
appropriate debug directives for the Open Watcom Linker.
<BR><BR>For example, to compile and link the &quot;hello&quot; program with debugging information, the following command may
be issued.
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; [C:\]wcl -l=os2 -d2 hello.c</TT>
<BR><BR>The typical messages that appear on the screen are shown in the following illustration.
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; [C:\]wcl -l=os2&nbsp; -d2 hello.c</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Open Watcom C/C++16 Compile and Link Utility</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Copyright (c) 2002-2019 the Open Watcom Contributors. All Rights Reserved.</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Portions Copyright (c) 1988-2002 Sybase, Inc. All Rights Reserved.</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Source code is available under the Sybase Open Watcom Public License.</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; See http://www.openwatcom.org/ for details.</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; wcc hello.c&nbsp; -d2</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Open Watcom C16 Optimizing Compiler</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Copyright (c) 2002-2019 the Open Watcom Contributors. All Rights Reserved.</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Portions Copyright (c) 1984-2002 Sybase, Inc. All Rights Reserved.</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Source code is available under the Sybase Open Watcom Public License.</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; See http://www.openwatcom.org/ for details.</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; hello.c: 6 lines, included 155, 0 warnings, 0 errors</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Code size: 23</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Open Watcom Linker</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Copyright (c) 2002-2019 the Open Watcom Contributors. All Rights Reserved.</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Portions Copyright (c) 1985-2002 Sybase, Inc. All Rights Reserved.</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Source code is available under the Sybase Open Watcom Public License.</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; See http://www.openwatcom.org/ for details.</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; loading object files</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; searching libraries</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; creating an OS/2 16-bit executable</TT>
<BR><BR>The &quot;d2&quot; option requests the maximum amount of debugging information that can be provided by the Open Watcom
C/C++ compiler.&nbsp; <TT> WCL</TT> will make sure that this debugging information is included in the executable file that
is produced by the linker.
<BR><BR>The &quot;Code size&quot; value is larger than in the previous example since selection of the &quot;d2&quot; option
results in fewer code optimizations by default.&nbsp; You can request more optimization by specifying the appropriate options.
&nbsp;However, you do so at the risk of making it more difficult for yourself to determine the relationship between the object
code and the original source language code.
<BR><BR>For OS/2, you should also include the<TT> BINP\DLL</TT> directory in the &quot;LIBPATH&quot; directive of the system
configuration file<TT> CONFIG.SYS.</TT>&nbsp; It contains the Open Watcom Debugger Dynamic Link Libraries (DLLs).
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; libpath=c:\watcom\binp\dll</TT>
<BR><BR>To request the Open Watcom Debugger to assist in debugging the application, the following command may be issued.
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; [C:\]wd hello</TT>
<BR><BR>It would be too ambitious to describe the debugger in this introductory chapter so we refer you to the book entitled<B><I>
Open Watcom Debugger User's Guide.</I></B>
<H1 ID="32Mbit_OSD2__Creating_32Mbit_OSD2_Applications"> 32-bit OS/2:&nbsp; Creating 32-bit OS/2 Applications </H1>
<BR>An OS/2 application can be one of the following; a fullscreen application, a PM-compatible application, or a Presentation
Manager application.&nbsp; A fullscreen application runs in its own screen group.&nbsp; A PM-compatible application will run
in an OS/2 fullscreen environment or in a window in the Presentation Manager screen group but does not take direct advantage
of menus, mouse or other features available in the Presentation Manager.&nbsp; A Presentation Manager application has full
access to the complete set of user-interface tools such as menus, icons, scroll bars, etc.
<BR><BR>This chapter deals with the creation of OS/2 fullscreen applications.&nbsp; For information on creating Presentation
Manager applications, refer to the section entitled <A HREF="#OSD2__Programming_for_OSD2_Presentation_Manager">OS/2:&nbsp; Programming for OS/2 Presentation Manager</A>.
<BR><BR>We will illustrate the steps to creating 32-bit OS/2 applications by taking a small sample application and showing
you how to compile, link, run and debug it.
<H2 ID="32Mbit_OSD2__The_Sample_Application"> 32-bit OS/2:&nbsp; The Sample Application </H2>
<BR>To demonstrate the creation of 32-bit OS/2 applications using command-line oriented tools, we introduce a simple sample
program.&nbsp; For our example, we are going to use the famous &quot;hello&quot; program.
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; #include &lt;stdio.h&gt;</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; void main()</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;Hello world\n&quot; );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; }</TT>
<BR><BR>The C++ version of this program follows:
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; #include &lt;iostream.h&gt;</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; void main()</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cout &lt;&lt; &quot;Hello world&quot; &lt;&lt; endl;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; }</TT>
<BR><BR>The goal of this program is to display the message &quot;Hello world&quot; on the screen.&nbsp; The C version uses
the C library<TT> printf</TT> routine to accomplish this task.&nbsp; The C++ version uses the &quot;iostream&quot; library
to accomplish this task.&nbsp; We will take you through the steps necessary to produce this result.
<H2 ID="32Mbit_OSD2__Building_and_Running_the_Sample_OSD2_Application"> 32-bit OS/2:&nbsp; Building and Running the Sample OS/2 Application </H2>
<BR>To compile and link our example program which is stored in the file<TT> hello.c</TT>, enter the following command:
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; [C:\]wcl386 -l=os2v2 hello.c</TT>
<BR><BR>The typical messages that appear on the screen are shown in the following illustration.
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; [C:\]wcl386 -l=os2v2&nbsp; hello.c</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Open Watcom C/C++32 Compile and Link Utility</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Copyright (c) 2002-2019 the Open Watcom Contributors. All Rights Reserved.</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Portions Copyright (c) 1988-2002 Sybase, Inc. All Rights Reserved.</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Source code is available under the Sybase Open Watcom Public License.</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; See http://www.openwatcom.org/ for details.</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; wcc386 hello.c&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Open Watcom C32 Optimizing Compiler</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Copyright (c) 2002-2019 the Open Watcom Contributors. All Rights Reserved.</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Portions Copyright (c) 1984-2002 Sybase, Inc. All Rights Reserved.</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Source code is available under the Sybase Open Watcom Public License.</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; See http://www.openwatcom.org/ for details.</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; hello.c: 6 lines, included 174, 0 warnings, 0 errors</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Code size: 24</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Open Watcom Linker</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Copyright (c) 2002-2019 the Open Watcom Contributors. All Rights Reserved.</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Portions Copyright (c) 1985-2002 Sybase, Inc. All Rights Reserved.</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Source code is available under the Sybase Open Watcom Public License.</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; See http://www.openwatcom.org/ for details.</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; loading object files</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; searching libraries</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; creating an OS/2 32-bit executable</TT>
<BR><BR>Provided that no errors were encountered during the compile or link phases, the &quot;hello&quot; program may now
be run.
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; [C:\]hello</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Hello world</TT>
<BR><BR>If you examine the current directory, you will find that two files have been created.&nbsp; These are<TT> hello.obj</TT>
(the result of compiling<TT> hello.c</TT>) and<TT> hello.exe</TT> (the result of linking<TT> hello.obj</TT> with the appropriate
Open Watcom C/C++ libraries).&nbsp; It is<TT> hello.exe</TT> that is run by OS/2 when you enter the &quot;hello&quot; command.
<H2 ID="32Mbit_OSD2__Debugging_the_Sample_OSD2_Application"> 32-bit OS/2:&nbsp; Debugging the Sample OS/2 Application </H2>
<BR>Let us assume that you wish to debug your application in order to locate an error in programming.&nbsp; In the previous
section, the &quot;hello&quot; program was compiled with default compile and link options.&nbsp; When debugging an application,
it is useful to refer to the symbolic names of routines and variables.&nbsp; It is also convenient to debug at the source
line level rather than the machine language level.&nbsp; To do this, we must direct both the compiler and linker to include
additional debugging information in the object and executable files.&nbsp; Using the <TT> WCL386</TT> command, this is fairly
straightforward.&nbsp; <TT> WCL386</TT> recognizes the Open Watcom C/C++ compiler &quot;debug&quot; options and will create
the appropriate debug directives for the Open Watcom Linker.
<BR><BR>For example, to compile and link the &quot;hello&quot; program with debugging information, the following command may
be issued.
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; [C:\]wcl386 -l=os2v2 -d2 hello.c</TT>
<BR><BR>The typical messages that appear on the screen are shown in the following illustration.
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; [C:\]wcl386 -l=os2v2&nbsp; -d2 hello.c</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Open Watcom C/C++32 Compile and Link Utility</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Copyright (c) 2002-2019 the Open Watcom Contributors. All Rights Reserved.</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Portions Copyright (c) 1988-2002 Sybase, Inc. All Rights Reserved.</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Source code is available under the Sybase Open Watcom Public License.</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; See http://www.openwatcom.org/ for details.</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; wcc386 hello.c&nbsp; -d2</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Open Watcom C32 Optimizing Compiler</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Copyright (c) 2002-2019 the Open Watcom Contributors. All Rights Reserved.</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Portions Copyright (c) 1984-2002 Sybase, Inc. All Rights Reserved.</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Source code is available under the Sybase Open Watcom Public License.</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; See http://www.openwatcom.org/ for details.</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; hello.c: 6 lines, included 174, 0 warnings, 0 errors</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Code size: 45</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Open Watcom Linker</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Copyright (c) 2002-2019 the Open Watcom Contributors. All Rights Reserved.</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Portions Copyright (c) 1985-2002 Sybase, Inc. All Rights Reserved.</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Source code is available under the Sybase Open Watcom Public License.</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; See http://www.openwatcom.org/ for details.</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; loading object files</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; searching libraries</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; creating an OS/2 32-bit executable</TT>
<BR><BR>The &quot;d2&quot; option requests the maximum amount of debugging information that can be provided by the Open Watcom
C/C++ compiler.&nbsp; <TT> WCL386</TT> will make sure that this debugging information is included in the executable file that
is produced by the linker.
<BR><BR>The &quot;Code size&quot; value is larger than in the previous example since selection of the &quot;d2&quot; option
results in fewer code optimizations by default.&nbsp; You can request more optimization by specifying the appropriate options.
&nbsp;However, you do so at the risk of making it more difficult for yourself to determine the relationship between the object
code and the original source language code.
<BR><BR>To request the Open Watcom Debugger to assist in debugging the application, the following command may be issued.
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; [C:\]wd hello</TT>
<BR><BR>It would be too ambitious to describe the debugger in this introductory chapter so we refer you to the book entitled<B><I>
Open Watcom Debugger User's Guide.</I></B>
<H1 ID="OSD2__OSD2_2_x_MultiMthreaded_Applications"> OS/2:&nbsp; OS/2 2.x Multi-threaded Applications </H1>
<BR>This chapter describes how to create multi-threaded applications.&nbsp; A multi-threaded application is one whose tasks
are divided among several threads of execution.&nbsp; A process is an executing application and the resources it uses.&nbsp;
A thread is the smallest unit of execution within a process.&nbsp; Each thread has its own stack and a set of machine registers
and shares all resources with its parent process.&nbsp; The path of execution of one thread does not affect that of another;
each thread is an independent entity.
<BR><BR>Typically, an application has a single thread of execution.&nbsp; In this type of application, all tasks, once initiated,
are completed before the next task begins.&nbsp; In contrast, tasks in a multi-threaded application can be performed concurrently
since more than one thread is executing at once.&nbsp; For example, each thread may be designed to perform a separate task.
<H2 ID="OSD2__Programming_Considerations"> OS/2:&nbsp; Programming Considerations </H2>
<BR>Since a multi-threaded application consists of many threads of execution, there are a number of issues that you must consider.
<BR><BR>Since threads share the resources of its parent, it may be necessary to serialize access to these resources.&nbsp;
For example, if your application has a function that displays information on the console and is used by all threads, it is
necessary to allow only one thread to use that function at any time.&nbsp; That is, once a thread calls that function, the
function should ensure that no other thread displays information until all information for the initial thread has been displayed.
&nbsp;An example of such a function is the<TT> printf</TT> library function.
<BR><BR>Another issue that must be considered when creating multi-threaded applications is global variables.&nbsp; If you
have global variables that contain thread-specific information, there must be an instance of each global variable for each
thread.&nbsp; An example of such a variable is the<TT> errno</TT> global variable defined in the run-time libraries.&nbsp;
If an error condition was created by a thread, you would not want it to affect the execution of other threads.&nbsp; Therefore,
each thread should contain its own instance of this variable.
<H2 ID="OSD2__Creating_Threads"> OS/2:&nbsp; Creating Threads </H2>
<BR>Each application initially contains a single thread.&nbsp; The run-time libraries contain two functions that create and
terminate threads of execution.&nbsp; The function<TT> _beginthread</TT> creates a thread of execution and the function<TT>
_endthread</TT> ends a thread of execution.&nbsp; The macro<TT> _threadid</TT> can be used to determine the current thread
identifier.
<HR>
<BR><B><I>&nbsp; WARNING!</I></B>&nbsp; If any thread calls a library function, you must use the<TT> _beginthread</TT> function
to create the thread.&nbsp; Do not use the<TT> DosCreateThread</TT> API function.
<HR>
<H3 ID="OSD2__Creating_a_New_Thread"> OS/2:&nbsp; Creating a New Thread </H3>
<BR>The<TT> _beginthread</TT> function creates a new thread.&nbsp; It is defined as follows.
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; int _beginthread( void (*start_address)(void *),</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp; void *stack_bottom,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp; unsigned stack_size,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp; void *arglist );</TT>
<DL>
<DT>where
<DD><B>description</B>
<DT>start_address
<DD>is the address of the function that will be called when the newly created thread is executed.&nbsp; When the thread returns
from that function, the thread will be terminated.&nbsp; Note that a call to the<TT> _endthread</TT> function will also terminate
the thread.
<DT>stack_bottom
<DD>specifies the bottom of the stack to be used by the thread.&nbsp; Note that this argument is ignored as it is only needed
to simplify the port of OS/2 1.x multi-threaded applications to OS/2 2.x.&nbsp; Under OS/2 2.x, the operating system allocates
the stack for the new thread.&nbsp; A value of NULL may be specified.
<DT>stack_size
<DD>specifies the size of the stack to be allocated by the operating system for the new thread.&nbsp; The stack size should be
a multiple of 4K.
<DT>arglist
<DD>is passed as an argument to the function specified by<TT> start_address.</TT>&nbsp; If no argument is required, a value of
NULL can be specified.
</DL>
<BR>If a new thread is successfully created, the thread identifier of the new thread is returned.&nbsp; Otherwise, a value
of -1 is returned.
<BR><BR>The header file<TT> process.h</TT> contains the definition of the<TT> _beginthread</TT> function.
<H3 ID="OSD2__Terminating_the_Current_Thread"> OS/2:&nbsp; Terminating the Current Thread </H3>
<BR>The<TT> _endthread</TT> function terminates the current thread.&nbsp; It is defined as follows.
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; void _endthread( void )</TT>
<BR><BR>The header file<TT> process.h</TT> contains the definition of the<TT> _endthread</TT> function.
<H3 ID="OSD2__Getting_the_Current_Thread_Identifier"> OS/2:&nbsp; Getting the Current Thread Identifier </H3>
<BR>The<TT> _threadid</TT> macro can be used to determine the current thread identifier.&nbsp; It is defined as follows.
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; int *__threadid(void);</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; #define _threadid (__threadid())</TT>
<BR><BR>The header file<TT> stddef.h</TT> contains the definition of the<TT> _threadid</TT> macro.
<H2 ID="OSD2__A_MultiMthreaded_Example"> OS/2:&nbsp; A Multi-threaded Example </H2>
<BR>Let us create a simple multi-threaded application.&nbsp; The source code for this example can be found in<TT> \watcom\samples\os2.</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; #include &lt;process.h&gt;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; #include &lt;stdio.h&gt;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; #include &lt;stddef.h&gt;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; #define INCL_DOS</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; #include &lt;os2.h&gt;</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; static&nbsp; volatile int&nbsp;&nbsp;&nbsp; NumThreads;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; static&nbsp; volatile int&nbsp;&nbsp;&nbsp; HoldThreads;</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; #define NUM_THREADS&nbsp;&nbsp;&nbsp;&nbsp; 5</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; #define STACK_SIZE&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 32768</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; static void a_thread( void *arglist )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; /***********************************/</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; while( HoldThreads ) {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DosSleep( 1 );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;Hi from thread %d\n&quot;, *_threadid );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DosEnterCritSec();</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; --NumThreads;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DosExitCritSec();</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; _endthread();</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; }</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; int main( void )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; /**************/</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; i;</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;Initial thread id = %d\n&quot;, *_threadid );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; NumThreads = 0;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; HoldThreads = 1;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* initial thread counts as 1 */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for( i = 2; i &lt;= NUM_THREADS; ++i ) {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if( _beginthread( a_thread, NULL, STACK_SIZE,
NULL ) == -1 ) {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;creation
of thread %d failed\n&quot;, i );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; } else {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ++NumThreads;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; HoldThreads = 0;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; while( NumThreads != 0 ) {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DosSleep( 1 );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return( 0 );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; }</TT>
<BR><BR><B>Note:</B>
<OL>
<LI>In the function<TT> a_thread, DosEnterCritSec</TT> and<TT> DosExitCritSec</TT> are called when we modify the variable<TT>
NumThreads.</TT>&nbsp; This ensures that the action of extracting the value of<TT> NumThreads</TT> from memory, incrementing
the value, and storing the new result into memory, occurs without interruption.&nbsp; If these functions were not called,
it would be possible for two threads to extract the value of<TT> NumThreads</TT> from memory before an update occurred.
</OL>
<BR>Let us assume that the file<TT> mthread.c</TT> contains the above example.&nbsp; Before compiling the file, make sure
that the<B> WATCOM</B> environment variable is set to the directory in which you installed Open Watcom C/C++.&nbsp; Also,
the<B> INCLUDE</B> environment variable must include the<TT> \watcom\h\os2</TT> and<TT> \watcom\h</TT> directories (&quot;\WATCOM&quot;
is the directory in which Open Watcom C/C++ was installed).
<BR><BR>We can now compile and link the application by issuing the following command.
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; [C:\]wcl386 -bt=os2 -bm -l=os2v2 mthread</TT>
<BR><BR>The &quot;bm&quot; option must be specified since we are creating a multi-threaded application.&nbsp; If your multi-threaded
application contains more than one module, each module must be compiled using the &quot;bm&quot; switch.
<BR><BR>The &quot;l&quot; option specifies the target system for which the application is to be linked.&nbsp; The system name<TT>
os2v2</TT> is defined in the file<TT> wlsystem.lnk</TT> which is located in the &quot;BINW&quot; subdirectory of the directory
in which you installed Open Watcom C/C++.
<BR><BR>The multi-threaded application is now ready to be run.
<H2 ID="OSD2__Thread_Limits"> OS/2:&nbsp; Thread Limits </H2>
<BR>There is a limit to the number of threads an application can create under 16-bit OS/2.&nbsp; The default limit is 32.
&nbsp;This limit can be adjusted by statically initializing the unsigned global variable<TT> __MaxThreads.</TT>
<BR><BR>Under 32-bit OS/2, there is no limit to the number of threads an application can create.&nbsp; However, due to the
way in which multiple threads are supported in the Open Watcom libraries, there is a small performance penalty once the number
of threads exceeds the default limit of 32 (this number includes the initial thread).&nbsp; If you are creating more than
32 threads and wish to avoid this performance penalty, you can redefine the threshold value of 32.&nbsp; You can statically
initialize the global variable<TT> __MaxThreads.</TT>
<BR><BR>By adding the following line to your multi-threaded application, the new threshold value will be set to 48.
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; unsigned __MaxThreads = { 48 };</TT>
<H1 ID="OSD2__OSD2_2_x_Dynamic_Link_Libraries"> OS/2:&nbsp; OS/2 2.x Dynamic Link Libraries </H1>
<BR>A dynamic link library, like a standard library, is a library of functions.&nbsp; When an application uses functions from
a standard library, the library functions referenced by the application become part of the executable module.&nbsp; This form
of linking is called static linking.&nbsp; When an application uses functions from a dynamic link library, the library functions
referenced by the application are not included in the executable module.&nbsp; Instead, the executable module contains references
to these functions which are resolved when the application is loaded.&nbsp; This form of linking is called dynamic linking.
<BR><BR>Let us consider some of the advantages of using dynamic link libraries over standard libraries.
<OL>
<LI>Functions in dynamic link libraries are not linked into your program.&nbsp; Only references to the functions in dynamic
link libraries are placed in the program module.&nbsp; These references are called import definitions.&nbsp; As a result,
the linking time is reduced and disk space is saved.&nbsp; If many applications reference the same dynamic link library, the
saving in disk space can be significant.
<LI>Since program modules only reference dynamic link libraries and do not contain the actual executable code, a dynamic link
library can be updated without re-linking your application.&nbsp; When your application is executed, it will use the updated
version of the dynamic link library.
<LI>Dynamic link libraries also allow sharing of code and data between the applications that use them.&nbsp; If many applications
that use the same dynamic link library are executing concurrently, the sharing of code and data segments improves memory utilization.
</OL>
<H2 ID="OSD2__Creating_Dynamic_Link_Libraries"> OS/2:&nbsp; Creating Dynamic Link Libraries </H2>
<BR>Once you have developed the source for a library of functions, a number of steps are required to create a dynamic link
library containing those functions.
<BR><BR>First, you must compile your source using the &quot;bd&quot; compiler option.&nbsp; This option tells the compiler
that the module you are compiling is part of a dynamic link library.&nbsp; Once you have successfully compiled your source,
you must create a linker directive file that describes the attributes of your dynamic link library.&nbsp; The following lists
the most common linker directives required to create a dynamic link library.
<OL>
<LI>The &quot;SYSTEM&quot; directive is used to specify that a dynamic link library is to be created.
<LI>The &quot;EXPORT&quot; directive is used to to specify which functions in the dynamic link library are to be exported.
<DL>
<DT>Specifying exports in the source code
<DD>
<BR><BR>The &quot;EXPORT&quot; directive need not be used when the symbols to be exported are declared with the<TT> __export</TT>
type qualifier in the source code.&nbsp; Such symbols are exported automatically, through special records inserted into the
object files by the compiler.
</DL>
<LI>The &quot;OPTION&quot; directive is used to specify attributes such as the name of the dynamic link library and how to
allocate the automatic data segment when the dynamic link library is referenced.
<LI>The &quot;SEGMENT&quot; directive is used to specify attributes of segments.&nbsp; For example, a segment may be read-only
or read-write.
</OL>
<BR>Once the dynamic link library is created, you must allow access to the dynamic link library to client applications that
wish to use it.&nbsp; This can be done by creating an import library for the dynamic link library or creating a linker directive
file that contains &quot;IMPORT&quot; directives for each of the entry points in the dynamic link library.
<H2 ID="OSD2__Creating_a_Sample_Dynamic_Link_Library"> OS/2:&nbsp; Creating a Sample Dynamic Link Library </H2>
<BR>Let us now create a dynamic link library using the following example.
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; #include &lt;stdio.h&gt;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; #include &lt;os2.h&gt;</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; #if defined(__cplusplus)</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; #define EXTERNC extern &quot;C&quot;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; #else</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; #define EXTERNC</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; #endif</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; unsigned APIENTRY LibMain( unsigned hmod, unsigned termination )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if( termination ) {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* DLL is detaching from process */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; } else {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* DLL is attaching to process */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return( 1 );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; }</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; EXTERNC void dll_entry_1( void )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;Hi from dll entry #1\n&quot; );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; }</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; EXTERNC void dll_entry_2( void )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;Hi from dll entry #2\n&quot; );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; }</TT>
<BR><BR>32-bit OS/2 DLLs can include a <TT> LibMain</TT> entry point when you are using the Open Watcom C/C++ run-time libraries.
<DL>
<DT>Arguments:
<DD>
<DT>hmod
<DD>This is a handle for the DLL.
<DT>termination
<DD>A 0 value indicates that the DLL is attaching to the address space of the current process as a result of the process starting
up or as a result of a call to <TT> DosLoadModule</TT>.&nbsp; A DLL can use this opportunity to initialize any instance data.
<BR><BR>A non-zero value indicates that the DLL is detaching from the address space of the calling process as a result of
either a normal termination or of a call to <TT> DosFreeModule</TT>.
<DT>Return Value
<DD>The<TT> LibMain</TT> function returns 1 if initialization succeeds or 0 if initialization fails.
<BR><BR>If the return value is 0 when <TT> LibMain</TT> is called because the process uses the <TT> DosLoadModule</TT> function,
<TT> DosLoadModule</TT> returns an error.
<BR><BR>If the return value is 0 when <TT> LibMain</TT> is called during process initialization, the process terminates with
an error.
</DL>
<BR>Assume the above example is contained in the file<TT> dllsamp.c.</TT>&nbsp; We can compile the file using the following
command.&nbsp; Note that we must specify the &quot;bd&quot; compiler option.
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; [C:\]wcc386 -bd dllsamp</TT>
<BR><BR>Before we can link our example, we must create a linker directive file that describes the attributes and entry points
of our dynamic link library.&nbsp; The following is a linker directive file, called<TT> dllsamp.lnk,</TT> that can be used
to create the dynamic link library.
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; system os2v2 dll initinstance terminstance</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; option manyautodata</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; export dll_entry_1_</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; export dll_entry_2_</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; file dllsamp</TT>
<BR><BR><B>Notes:</B>
<OL>
<LI>The &quot;SYSTEM&quot; directive specifies that we are creating a 32-bit OS/2 dynamic link library.
<LI>The &quot;MANYAUTODATA&quot; option specifies that the automatic data segment is allocated for every instance of the dynamic
link library.&nbsp; This option must be specified only for a dynamic link library that uses the Open Watcom C/C++ run-time
libraries.&nbsp; If the Open Watcom C/C++ run-time libraries are not used, this option is not required.&nbsp; Our example
does use the Open Watcom C/C++ run-time libraries so we must specify the &quot;MANYAUTODATA&quot; option.
<BR><BR>As was just mentioned, when a dynamic link library uses the Open Watcom C/C++ run-time libraries, an automatic data
segment is created each time a process accesses the dynamic link library.&nbsp; For this reason, initialization code must
be executed when a process accesses the dynamic link library for the first time.&nbsp; To achieve this, &quot;INITINSTANCE&quot;
must be specified in the &quot;SYSTEM&quot; directive.&nbsp; Similarly, &quot;TERMINSTANCE&quot; must be specified so that
the termination code is executed when a process has completed its access to the dynamic link library.&nbsp; If the Open Watcom
C/C++ run-time libraries are not used, these options are not required.
<LI>The &quot;EXPORT&quot; directive specifies the entry points into the dynamic link library.&nbsp; Note that the names specified
in the &quot;EXPORT&quot; directive are appended with an underscore.&nbsp; This is the default naming convention used when
compiling using the register-based calling convention.&nbsp; No underscore is required when compiling using the stack-based
calling convention.
</OL>
<BR>We can now create our dynamic link library by issuing the following command.
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; [C:\]wlink @dllsamp</TT>
<BR><BR>A file called<TT> dllsamp.dll</TT> will be created.
<H2 ID="OSD2__Using_Dynamic_Link_Libraries"> OS/2:&nbsp; Using Dynamic Link Libraries </H2>
<BR>Once we have created a dynamic link library, we must allow other applications to access the functions available in the
dynamic link library.&nbsp; There are two ways to achieve this.
<BR><BR>The first method is to create a linker directive file which contains an &quot;IMPORT&quot; directive for all entry
points in the dynamic link library.&nbsp; The &quot;IMPORT&quot; directive provides the name of the entry point and the name
of the dynamic link library.&nbsp; When creating an application that references a function in the dynamic link library, this
linker directive file would be included as part of the linking process that created the application.
<BR><BR>The second method is to use import libraries.&nbsp; An import library is a standard library that is created from a
dynamic link library by using the Open Watcom Library Manager.&nbsp; It contains object modules that describe the entry points
in a dynamic link library.&nbsp; The resulting import library can then be specified in a &quot;LIBRARY&quot; directive in
the same way one would specify a standard library.
<BR><BR>Using an import library is the preferred method of providing references to functions in dynamic link libraries.&nbsp;
When a dynamic link library is modified, typically the import library corresponding to the modified dynamic link library is
updated to reflect the changes.&nbsp; Hence, any directive file that specifies the import library in a &quot;LIBRARY&quot;
directive need not be modified.&nbsp; However, if you are using &quot;IMPORT&quot; directives, you may have to modify the
&quot;IMPORT&quot; directives to reflect the changes in the dynamic link library.
<BR><BR>Let us create an import library for our sample dynamic link library we created in the previous section.&nbsp; We do
this by issuing the following command.
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; [C:\]wlib dllsamp +dllsamp.dll</TT>
<BR><BR>A standard library called<TT> dllsamp.lib</TT> will be created.
<BR><BR>Suppose the following sample program, contained in the file<TT> dlltest.c,</TT> calls the functions from our sample
dynamic link library.
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; #include &lt;stdio.h&gt;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; #if defined(__cplusplus)</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; #define EXTERNC extern &quot;C&quot;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; #else</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; #define EXTERNC</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; #endif</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; EXTERNC void dll_entry_1( void );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; EXTERNC void dll_entry_2( void );</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; int main( void )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; dll_entry_1();</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; dll_entry_2();</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return( 0 );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; }</TT>
<BR><BR>We can compile and link our sample application by issuing the following command.
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; [C:\]wcl386 -l=os2v2 dlltest dllsamp.lib</TT>
<BR><BR>If we had created a linker directive file of &quot;IMPORT&quot; directives instead of an import library for the dynamic
link library, the linker directive file, say<TT> dllimps.lnk,</TT> would be as follows.
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; import dll_entry_1_ dllsamp</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; import dll_entry_2_ dllsamp</TT>
<BR><BR>Note that the names specified in the &quot;IMPORT&quot; directive are appended with an underscore.&nbsp; This is the
default naming convention used when compiling using the register-based calling convention.&nbsp; No underscore is required
when compiling using the stack-based calling convention.
<BR><BR>To compile and link our sample application, we would issue the following command.
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; [C:\]wcl386 -l=os2v2 dlltest -&quot;@dllimps&quot;</TT>
<H2 ID="OSD2__The_Dynamic_Link_Library_Data_Area"> OS/2:&nbsp; The Dynamic Link Library Data Area </H2>
<BR>The Open Watcom C/C++ 32-bit run-time library does not support the general case operation of DLLs in an execution environment
where there is only one instance of the DATA segment (DGROUP) for that DLL.
<BR><BR>There are two cases that can lead to a DLL executing with only one instance of the DGROUP.
<OL>
<LI>DLLs linked for 32-bit OS/2 without the MANYAUTODATA option.
<LI>DLLs linked for the Win32 API and executing under Win32s.
</OL>
<BR>In these cases the run-time library startup code detects that there is only one instance of the DGROUP when a second process
attempts to attach to the DLL.&nbsp; At that point, it issues a diagnostic for the user and then notifies the operating system
that the second process cannot attach to the DLL.
<BR><BR>Developers who require DLLs to operate when there is only one instance of the DGROUP can suppress the function which
issues the diagnostic and notifies the operating system that the second process cannot attach to the DLL.
<BR><BR>Doing so requires good behaviour on the part of processes attaching to the DLL.&nbsp; This good behaviour consists
primarily of ensuring that the first process to attach to the DLL is also the last process to detach from the DLL thereby
ensuring that the DATA segment is not released back to the free memory pool.
<BR><BR>To suppress the function which issues the diagnostic and notifies the operating system that the second process cannot
attach to the DLL, the developer must provide a replacement entry point with the following prototype:
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; int __disallow_single_dgroup( int );</TT>
<BR><BR>This function should return zero to indicate that the detected single copy of the DATA segment is allowed.
<H2 ID="OSD2__Dynamic_Link_Library_InitializationDTermination"> OS/2:&nbsp; Dynamic Link Library Initialization/Termination </H2>
<BR>Each dynamic link library (DLL) has an initialization and termination routine associated with it.&nbsp; The initialization
routine can either be called the first time any process accesses the DLL (&quot;INITGLOBAL&quot; is specified at link time)
or each time a process accesses the DLL (&quot;INITINSTANCE&quot; is specified at link time).&nbsp; Similarly, the termination
routine can either be called when all processes have completed their access of the DLL (&quot;TERMGLOBAL&quot; is specified
at link time) or each time a process completes its access of the DLL (&quot;TERMINSTANCE&quot; is specified at link time).
<BR><BR>For a DLL that uses the C/C++ run-time libraries, initialization and termination of the C/C++ run-time environment
is performed automatically.&nbsp; It is also possible for a DLL to do its own special initialization and termination process.
<BR><BR>The C/C++ run-time environment provides two methods for calling user-written DLL initialization and termination code.
<OL>
<LI>If you provide your own version of<TT> LibMain</TT> then it will be called for initialization and termination.&nbsp; The
use of<TT> LibMain</TT> is described earlier in this chapter.
<LI>If you do not provide your own version of<TT> LibMain</TT> then a default version is linked in from the library.&nbsp;
This version will call <TT> __dll_initialize</TT> for DLL initialization and <TT> __dll_terminate</TT> for DLL termination.
&nbsp;Default stub versions of these two routines are included in the run-time library.&nbsp; If you wish to perform additional
initialization/termination that is specific to your dynamic link library, you may write your own versions of these routines.
</OL>
<BR>Once the C/C++ run-time environment is initialized, the routine<TT> __dll_initialize</TT> is called.&nbsp; After the C/C++
run-time environment is terminated, the routine<TT> __dll_terminate</TT> is called.&nbsp; This last point is important since
it means that you cannot do any run-time calls in the termination routine.
<BR><BR>The initialization and termination routines return an integer.&nbsp; A value of 0 indicates failure; a value of 1
indicates success.&nbsp; The following example illustrates sample initialization/termination routines.
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; #include &lt;stdlib.h&gt;</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; #define WORKING_SIZE (64 * 1024)</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; char *WorkingStorage;</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; #if defined(__cplusplus)</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; #define EXTERNC extern &quot;C&quot;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; #else</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; #define EXTERNC</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; #endif</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; void __dll_finalize( void );</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; EXTERNC int __dll_initialize( void )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; WorkingStorage = malloc( WORKING_SIZE );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if( WorkingStorage == NULL ) return( 0 );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; atexit( __dll_finalize );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return( 1 );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; }</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; void __dll_finalize( void )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; free( WorkingStorage );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; }</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; EXTERNC int __dll_terminate( void )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return( 1 );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; }</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; EXTERNC void dll_entry( void )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* use array WorkingStorage */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; }</TT>
<BR><BR>In the above example, the process initialization routine allocates storage that the dynamic link library needs, the
routine<TT> dll_entry</TT> uses the storage, and the process termination routine frees the storage allocated in the initialization
routine.
<H1 ID="OSD2__Programming_for_OSD2_Presentation_Manager"> OS/2:&nbsp; Programming for OS/2 Presentation Manager </H1>
<BR>Basically, there are two classes of C/C++ applications that can run in a windowed environment.
<BR><BR>The first are those C/C++ applications that do not use any of the Presentation Manager API functions; they are strictly
C/C++ applications that do not rely on the features of a particular operating system.
<BR><BR>The second class of C/C++ applications are those that actually call Presentation Manager API functions directly.&nbsp;
These are applications that have been tailored for the Presentation Manager operating environment.
<BR><BR>It is assumed that the reader is familiar with the concepts of Presentation Manager programming.
<H2 ID="OSD2__Porting_Existing_CDCPP_Applications"> OS/2:&nbsp; Porting Existing C/C++ Applications </H2>
<BR>Suppose you have a set of C/C++ applications that previously ran under DOS and you now wish to run them under OS/2.&nbsp;
To achieve this, simply recompile your application and link with the appropriate libraries.&nbsp; Depending on the method
with which you linked your application, it can run in an OS/2 fullscreen environment, a PM-compatible window, or as a Presentation
Manager application.&nbsp; An OS/2 fullscreen application runs in its own screen group.&nbsp; A PM-compatible application
will run in an OS/2 fullscreen environment or in a window in the Presentation Manager screen group but does not take direct
advantage of menus, mouse or other features available in the Presentation Manager.&nbsp; A Presentation Manager application
has full access to the complete set of user-interface tools such as menus, icons, scroll bars, etc.&nbsp; However, porting
a console oriented application to Presentation Manager often requires significant effort and a substantial redesign of the
application.
<H3 ID="OSD2__An_Example"> OS/2:&nbsp; An Example </H3>
<BR>Very little effort is required to port an existing C/C++ application to OS/2.&nbsp; Let us try to run the following sample
program (contained in the file<TT> hello.c</TT>).
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; #include &lt;stdio.h&gt;</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; int main( void )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; /**************/</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;Hello world!\n&quot; );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return( 0 );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; }</TT>
<BR><BR>An equivalent C++ program follows:
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; #include &lt;iostream.h&gt;</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; int main( void )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cout &lt;&lt; &quot;Hello world&quot; &lt;&lt; endl;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return( 0 );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; }</TT>
<BR><BR>First we must compile the file<TT> hello.c</TT> by issuing the following command.
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; [C:\]wcc386 hello</TT>
<BR><BR>Once we have successfully compiled the file, we can link it by issuing the following command.
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; [C:\]wlink sys os2v2 file hello</TT>
<BR><BR>It is also possible to compile and link in one step, by issuing the following command.
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; [C:\]wcl386 -l=os2v2 hello</TT>
<BR><BR>This will create a PM-compatible application.&nbsp; If you wish to create a fullscreen application, link with the
following command.
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; [C:\]wlink sys os2v2 fullscreen file hello</TT>
<H2 ID="OSD2__Calling_Presentation_Manager_API_Functions"> OS/2:&nbsp; Calling Presentation Manager API Functions </H2>
<BR>It is also possible for a C/C++ application to create its own windowing environment.&nbsp; This is achieved by calling
PM API functions directly from your C/C++ program.&nbsp; The techniques for developing these applications can be found in
the<B><I> OS/2 Technical Library.</I></B>
<BR><BR>A number of C/C++ include files (files with extension<TT> .h</TT>) are provided which define Presentation Manager
data structures and constants.&nbsp; They are located in the<TT> \watcom\h\os2</TT> directory.&nbsp; These include files are
roughly equivalent to the C/C++ header files that are available with the IBM OS/2 Developer's Toolkit.
<BR><BR>A sample C/C++ Presentation Manager application is also located in the<TT> \watcom\samples\os2</TT> directory.&nbsp;
It is contained in the files<TT> shapes.c</TT> (C variant) and<TT> shapes.cpp</TT> (C++ variant, nearly identical).&nbsp;
The file<TT> shapes.c</TT> contains the following.
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; #include &lt;stdlib.h&gt;</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; #define INCL_WIN</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; #define INCL_GPI</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; #include &lt;os2.h&gt;</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; int&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; SizeX;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; int&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; SizeY;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; HWND&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; FrameHandle;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; HMQ&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; hMessageQueue;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; HAB&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; AnchorBlock;</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; static int&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Random( int high )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return( ( (double)rand() / 32767 ) * high );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; }</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; static void NewColor( HPS ps )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; GpiSetColor( ps, Random( 15 ) + 1 );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; }</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; /* Draw a rectangular shape of random size and color at random position */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; static void DrawEllipse(HWND hwndWindow)</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; POINTL&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ptl;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; HPS&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ps;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; static int&nbsp; Odd = 0;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; parm1,parm2;</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ps = WinGetPS( hwndWindow );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ptl.x = Random( SizeX );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ptl.y = Random( SizeY );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; GpiMove( ps, &amp;ptl );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ptl.x = Random( SizeX );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ptl.y = Random( SizeY );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; parm1 = Random( 50 );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; parm2 = Random( 50 );</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if( Random( 10 ) &gt;= 5 ) {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; NewColor( ps );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; GpiBox( ps, DRO_FILL, &amp;ptl, 0, 0 );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; NewColor( ps );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; GpiBox( ps, DRO_OUTLINE, &amp;ptl, 0, 0 );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; } else {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; NewColor( ps );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; GpiBox( ps, DRO_FILL, &amp;ptl, parm1, parm2
);</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; NewColor( ps );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; GpiBox( ps, DRO_OUTLINE, &amp;ptl, parm1,
parm2 );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Odd++;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Odd &amp;= 1;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; WinReleasePS( ps );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; }</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; /* Client window procedure */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; MRESULT EXPENTRY MainDriver( HWND hwnd, USHORT msg, MPARAM mp1, MPARAM mp2 )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; HPS&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ps;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; RECTL&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rcl;</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; switch( msg ) {</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; case WM_CREATE:</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* Start a 150ms timer on window creation
*/</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; WinStartTimer( AnchorBlock, hwnd, 1, 150
) ;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; case WM_TIMER:</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* Draw another ellipse on each timer tick
*/</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DrawEllipse( hwnd );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return( 0 );</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; case WM_SIZE:</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* Remember new dimensions when window is
resized */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; SizeX = SHORT1FROMMP( mp2 );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; SizeY = SHORT2FROMMP( mp2 );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return( 0 );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; case WM_PAINT:</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* Handle paint events */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ps = WinBeginPaint( hwnd, NULL, NULL );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; WinQueryWindowRect( hwnd, &amp;rcl );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; WinFillRect( ps, &amp;rcl, CLR_WHITE );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; WinEndPaint( ps );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return( 0 );</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* Let the default window procedure handle all other messages */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return( WinDefWindowProc( hwnd, msg, mp1, mp2 ) );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; }</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; int&nbsp;&nbsp;&nbsp;&nbsp; main()</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ULONG&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; style;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; QMSG&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; qmsg;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; HWND&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; WinHandle;</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* Initialize windowing and create message queue */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; AnchorBlock = WinInitialize( 0 );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if( AnchorBlock == 0 ) return( 0 );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; hMessageQueue = WinCreateMsgQueue( AnchorBlock, 0 );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if( hMessageQueue == 0 ) return( 0 );</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* Register window class */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if( !WinRegisterClass( AnchorBlock, &quot;Watcom&quot;, (PFNWP)MainDriver,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CS_SIZEREDRAW, 0 ) ) {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return( 0 );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* Create frame and client windows */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; style = FCF_TITLEBAR | FCF_SYSMENU | FCF_SIZEBORDER | FCF_MINMAX
|</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; FCF_SHELLPOSITION
| FCF_TASKLIST;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; FrameHandle = WinCreateStdWindow( HWND_DESKTOP, WS_VISIBLE, &amp;style,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&quot;Watcom&quot;,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&quot;Shapes - C sample&quot;,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;0, NULL, 0, &amp;WinHandle );</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* If window creation failed, exit immediately! */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if( FrameHandle == 0 ) return( 0 );</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* Message loop */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; while( WinGetMsg( AnchorBlock, &amp;qmsg, NULL, 0, 0 ) ) {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; WinDispatchMsg( AnchorBlock, &amp;qmsg );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* Shut down and clean up */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; WinDestroyWindow( FrameHandle );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; WinDestroyMsgQueue( hMessageQueue );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; WinTerminate( AnchorBlock );</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return( 1 );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; }</TT>
<BR><BR>You can compile, link and run this demonstration by issuing the following commands.
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; [C:\]wcl386 -l=os2v2_pm shapes</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; [C:\]shapes</TT>
<H1 ID="OSD2__Developing_an_OSD2_Physical_Device_Driver"> OS/2:&nbsp; Developing an OS/2 Physical Device Driver </H1>
<BR>In this chapter, we discuss the development of Physical Device Drivers (PDD) for OS/2.&nbsp; The tools used in the creation
of the sample PDD are:
<UL>
<LI>the 16-bit Open Watcom C compiler
<LI>the Open Watcom Assembler
<LI>the Open Watcom Make utility
</UL>
<BR>The sample Physical Device Driver that we are going to build,<TT> HRTIMER.SYS,</TT> provides access to a high resolution
timer.&nbsp; Additional sources of information on PDDs can be found in the following:
<OL>
<LI><B><I> OS/2 2.0 Technical Library - Physical Device Driver Reference</I></B>
<LI><B><I> Writing OS/2 2.1 Device Drivers in C</I></B> by Steve J.&nbsp; Mastrianni
<LI><B><I> An OS/2 High Resolution Software Timer</I></B> by Derek Williams, an article which appeared in the Fall 1991 issue
of<B><I> IBM Personal Systems Developer</I></B> magazine.&nbsp; The source code for this device driver was adapted from the
magazine article.&nbsp; For detailed information on the way this device driver works, please read that article.
</OL>
<BR><TT>HRTIMER.SYS</TT> is a 16-bit device driver which runs under OS/2 1.x and 2.x/3.x.&nbsp; It has a resolution of 840
nanoseconds (i.e., 1 tick of the Intel 8253/8254 timer = 840 nanoseconds).
<BR><BR>Here are some notes on creating Physical Device Drivers using Open Watcom software tools.
<OL>
<LI>A Physical Device Driver is linked as a DLL.
<LI>The first segment must be a data segment, the next a code segment.
<LI>By default only the first two segments remain after initialization, extra segments have to be marked IOPL.
<LI>The assembler file,<TT> DEVSEGS.ASM,</TT> defines the segment ordering.
<LI><TT> #pragma dataseg</TT> and<TT> #pragma codeseg</TT> are used to get various pieces of code and data into the correct
segments.
<LI>The<TT> _HEADER</TT> segment contains the device header and must be at the beginning of the data segment.
<LI>The<TT> _INITCODE</TT> and<TT> _INITDATA</TT> segments are used to place initialization code and data at the end so it
can be discarded by OS/2.
</OL>
<BR>To compile the source code for the 16-bit Physical Device Drivers, we use the following options:
<DL>
<DT>-bt=os2
<DD>build target is OS/2
<DT>-ms
<DD>16-bit small code/small data model
<DT>-5
<DD>Pentium optimizations (this is optional)
<DT>-omi
<DD>inline math and intrinsic functions (this is optional)
<DT>-s
<DD>no stack checking
<DT>-zdp
<DD>DS is pegged to DGROUP
<DT>-zff
<DD>FS floats, i.e.&nbsp; not fixed to a segment
<DT>-zgf
<DD>GS floats, i.e.&nbsp; not fixed to a segment
<DT>-zu
<DD>SS != DGROUP
<DT>-zl
<DD>remove default library information
</DL>
<BR>To link the object code for the 16-bit Physical Device Drivers, we use the following options:
<DL>
<DT>name hrtimer.sys
<DD>to name the executable file.
<DT>sys os2 dll initglobal
<DD>to link a 16-bit OS/2 DLL.&nbsp; Specifying INITGLOBAL will cause the initialization routine to be called the first time the
dynamic link library is loaded.
<DT>option map
<DD>to generate a map file.
<DT>option quiet
<DD>to minimize the number of linker informational messages.
<DT>lib os2
<DD>to include the 16-bit<TT> OS2.LIB</TT> library file.
<DT>file ...
<DD>to include the component object files of the device driver.
</DL>
<BR>The sample files used to create the Physical Device Driver and the programs that use it are located in the<TT> \WATCOM\SRC\OS2\PDD</TT>
directory.&nbsp; The Physical Device Driver files are:
<DL>
<DT>DEVSEGS.ASM
<DD>This small assembler file orders the segment definitions in the executable file.
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Data Segments&nbsp;&nbsp; _HEADER</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;CONST</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;CONST2</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;_DATA</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;_BSS</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;_INITDATA (discardable)</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Code Segments&nbsp;&nbsp; _TEXT</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;_INITCODE (discardable)</TT>
<DT>HEADER.C
<DD>The first thing that must follow the EXE Header is the Device Driver Header.
<DT>STRATEGY.C
<DD>This is the resident portion of the Strategy routine.
<DT>STRATINI.C
<DD>This is the discardable portion of the Strategy routine, the initialization code and data.
<DT>HRTIMER.H
<DD>This file contains the definition of the timer &quot;timestamp&quot; structure.
<DT>HRDEV.H
<DD>This file contains definitions for the Intel 8253 hardware timer.
<DT>DEVHDR.H
<DD>This file contains definitions for the Device Driver Header structure (see page 3-2, &quot;Physical Device Driver Header&quot;
of PDD Reference).
<DT>DEVDEFS.H
<DD>This file provides type definitions.
<DT>DEVREQP.H
<DD>This file contains definitions for the Device Driver Request Packets.
<DT>DEVAUX.H
<DD>This file contains definitions for the Device Driver Help (DevHlp) routines.
</DL>
<BR>The demonstration program files are:
<DL>
<DT>HRTEST.C
<DD>This file is a sample C program that shows how to use the device driver to calculate elapsed times.&nbsp; It demonstrates
how to open the device driver, read timestamps from it and close it.&nbsp; It factors in the overhead of the read and has
a function that is used to calculate elapsed time from a start and stop timestamp.
<DT>TIMER.C
<DD>This file is a sample C program that can be used to time other applications.&nbsp; It also uses the device driver.
</DL>
<BR>To build the device driver and demonstration programs, set your current directory to<TT> \WATCOM\SRC\OS2\PDD</TT> and
type:
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; wmake</TT>
<BR><BR>To install the device driver, put the following statement in your<TT> CONFIG.SYS</TT> file.&nbsp; 
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; DEVICE=\WATCOM\SRC\OS2\PDD\HRTIMER.SYS</TT>
<BR><BR>You must then reboot OS/2.
<BR><BR>To run the test program, use the following command-line:
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; HRTEST [milliseconds]</TT>
<BR><BR>For<TT> [milliseconds],</TT> you can enter any number (e.g., 2000 which is 2 seconds).
<BR><BR><TT> HRTEST.EXE</TT> will issue a DosSleep for the amount of milliseconds specified or will use a default if no command-line
parameter is given.&nbsp; It will get a timestamp from the device driver before and after the DosSleep and will calculate
the elapsed time of that sleep and display the results.&nbsp; It will do this continuously until Ctrl/C or Ctrl/Break is pressed.
<BR><BR>Keep in mind that DosSleep has a granularity of 32 milliseconds.&nbsp; Any discrepancy between the number of milliseconds
used for the DosSleep and the elapsed time results from the timer are the fault of this granularity, not a problem with the
timer.&nbsp; DosSleep is used solely as a convenient method of displaying the capabilities of the driver.
<BR><BR>To run the timer program, use the following command-line:
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; TIMER program_name [program_args]</TT>
<BR><BR>For example, to time an OS/2 Directory command, issue the following command.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; timer cmd /c dir c:</TT>
<H1 ID="Creating_NetWare_386_NLM_Applications"> Creating NetWare 386 NLM Applications </H1>
<BR>Open Watcom C/C++ supports version 4.0 of the Netware 386 API.&nbsp; We include the following components:
<DL>
<DT>header files
<DD>Header files for the Netware 4.0 API are located in the<TT> \WATCOM\NOVH</TT> directory.
<DT>import libraries
<DD>Import libraries for the Netware 4.0 API are located in the<TT> \WATCOM\NOVI</TT> directory.
<DT>libraries
<DD>The C/C++ libraries for Netware 4.0 is located in the<TT> \WATCOM\LIB386</TT> and<TT> \WATCOM\LIB386\NETWARE</TT> directories.
<DT>debug servers
<DD>Servers for remote debugging of Netware 4.0 NLMs are located in the<TT> \WATCOM\NLM</TT> directory.&nbsp; The same directory
also contains the Open Watcom Execution Sampler for NLMs.
</DL>
<BR>Applications built for version 4.0 will run on 4.1.&nbsp; We do not include support for any API specific to version 4.1.
&nbsp;Netware developers must use the support included with Open Watcom C/C++ version 10.0 or greater since the version supplied
by Novell only works with Open Watcom C/C++ version 9.5.&nbsp; Netware 4.1 support requires modification to the header files
supplied by Novell.&nbsp; Contact Novell for more information.
<BR><BR>The following special notes apply to developing applications for NetWare.
<OL>
<LI>You must compile your source files with the &quot;-bt=NETWARE&quot; option.&nbsp; This will cause the compiler to:
<UL>
<LI>use the small memory model instead of the flat memory model,
<LI>use stack-based calling conventions,
<LI>search the<B> NETWARE_INCLUDE</B> environment variable before searching the<B> INCLUDE</B> environment variable, and
<LI>reference a special startup symbol, <TT> __WATCOM_Prelude</TT>, in the libraries.
</UL>
<LI>You must compile your source files with the small memory model option (&quot;ms&quot;).&nbsp; This is accomplished by
specifying the &quot;-bt=NETWARE&quot; option.
<LI>You must compile your source files with one of the stack-based calling convention options (&quot;3s&quot;, &quot;4s&quot;
or &quot;5s&quot;).&nbsp; This is accomplished by specifying the &quot;-bt=NETWARE&quot; option.
<LI>You must set the<B> NETWARE_INCLUDE</B> environment variable to point to the<TT> \WATCOM\NOVH</TT> directory.&nbsp; This
environment variable will be searched first when you compile with the &quot;-bt=NETWARE&quot; option.&nbsp; Alternatively,
you can set the<B> INCLUDE</B> environment variable to include<TT> \WATCOM\NOVH</TT> before other include directories.
<LI>If you are using the compile and link utility WCL386, you must use the following options:&nbsp; &quot;-l=NETWARE -bt=NETWARE&quot;.
<LI>You must specify
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; system NETWARE</TT>
<BR><BR>when linking an NLM.&nbsp; This is automatic if you are using WCL386 and the &quot;-l=NETWARE&quot; option.
<LI>If you are using other Netware APIs such as NWSNUT, then you must include <TT> module</TT> and <TT> import</TT> statements
as input to the Open Watcom Linker.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; module nwsnut</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; import @%WATCOM%\novi\nwsnut.imp</TT>
<BR><BR>This is done automatically for the C Library (CLIB.IMP).&nbsp; The following import lists have been provided for Netware
API libraries.
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; AIO.IMP</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; APPLETLK.IMP</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; BSD.IMP</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; CLIB.IMP</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; DSAPI.IMP</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; MATHLIB.IMP</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; NWSNUT.IMP</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; SOCKLIB.IMP</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; STREAMS.IMP</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; TLI.IMP</TT>
</OL>
<H1 ID="InterMLanguage_calls__C_and_FORTRAN"> Inter-Language calls:&nbsp; C and FORTRAN </H1>
<BR>The purpose of this chapter is to anticipate common questions about mixed-language development using Open Watcom C/C++
and Open Watcom FORTRAN 77.
<BR><BR>The following topics are discussed in this chapter:
<UL>
<LI>Symbol Naming Convention
<LI>Argument Passing Convention
<LI>Memory Model Compatibility
<LI>Integer Type Compatibility
<LI>How do I pass integers from C to a FORTRAN function?
<LI>How do I pass integers from FORTRAN to a C function?
<LI>How do I pass a string from a C function to FORTRAN?
<LI>How do I pass a string from FORTRAN to a C function?
<LI>How do I access a FORTRAN common block from within C?
<LI>How do I call a C function that accepts a variable number of arguments?
</UL>
<H2 ID="Symbol_Naming_Convention"> Symbol Naming Convention </H2>
<BR>The symbol naming convention describes how a symbol in source form is mapped to its object form.&nbsp; Because of this
mapping, the name generated in the object file may differ from its original source form.
<BR><BR>Default symbol naming conventions vary between compilers.&nbsp; Open Watcom C/C++ prefixes an underscore character
to the beginning of variable names and appends an underscore to the end of function names during the compilation process.
&nbsp;Open Watcom FORTRAN 77 converts symbols to upper case.&nbsp; Auxiliary pragmas can be used to resolve this inconsistency.
<BR><BR>Pragmas are compiler directives which can provide several capabilities, one of which is to provide information used
for code generation.&nbsp; When calling a FORTRAN subprogram from C, we want to instruct the compiler NOT to append the underscore
at the end of the function name and to convert the name to upper case.&nbsp; This is achieved by using the following C auxiliary
pragma:
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; #pragma aux ftnname &quot;^&quot;;</TT>
<BR><BR>The &quot;^&quot; character tells the compiler to convert the symbol name &quot;ftnname&quot; to upper case; no underscore
character will be appended.&nbsp; This solves potential linker problems with &quot;ftnname&quot; since (by C convention) the
linker would attempt to resolve a reference to &quot;ftnname_&quot;.
<BR><BR>When calling C functions from FORTRAN, we need to instruct the compiler to add the underscore at the end of the function
name, and to convert the name to lower case.&nbsp; Since the FORTRAN compiler automatically converts identifiers to uppercase,
it is necessary to force the compiler to emit an equivalent lowercase name.&nbsp; Both of these things can be done with the
following FORTRAN auxiliary pragma:
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; *$pragma aux CNAME &quot;!_&quot;</TT>
<BR><BR>There is another less convenient way to do this as shown in the following:
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; *$pragma aux CNAME &quot;cname_&quot;</TT>
<BR><BR>In the latter example, the case of the name in quotation marks is preserved.
<BR><BR>Use of these pragmas resolves the naming differences, however, the issue of argument passing must still be resolved.
<H2 ID="Argument_Passing_Convention"> Argument Passing Convention </H2>
<BR>In general, C uses call-by-value (passes argument values) while FORTRAN uses call-by-reference (passes pointers to argument
values).&nbsp; This implies that to pass arguments to a FORTRAN subprogram we must pass the addresses of arguments rather
than their values.&nbsp; C uses the &quot;&amp;&quot; character to signify &quot;address of&quot;.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; result = ftnname( &amp;arg );</TT>
<BR><BR>When calling a C function from FORTRAN, the pragma used to correct the naming conventions must also instruct the compiler
that the C function is expecting values, not addresses.
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; *$pragma aux CNAME &quot;!_&quot; parm (value)</TT>
<BR><BR>The &quot;parm (value)&quot; addition instructs the FORTRAN compiler to pass values, instead of addresses.
<BR><BR>Character data (strings) are an exception to the general case when used as arguments.&nbsp; In C, strings are not
thought of as a whole entity, but rather as an &quot;array of characters&quot;.&nbsp; Since strings are not considered scalar
arguments, they are referenced differently in both C and FORTRAN.&nbsp; This is described in more detail in a following section.
<H2 ID="Memory_Model_Compatibility"> Memory Model Compatibility </H2>
<BR>While it is really not an issue with the 32-bit compilers (both use the default &quot;flat&quot; memory model), it is
important to know that the default memory model used in Open Watcom FORTRAN 77 applications is the &quot;large&quot; memory
model (&quot;ml&quot;) with &quot;medium&quot; and &quot;huge&quot; memory models as options.&nbsp; Since the 16-bit Open
Watcom C/C++ default is the &quot;small&quot; memory model, you must specify the correct memory model when compiling your
C/C++ code with the 16-bit C or C++ compiler.
<H2 ID="Linking_Considerations"> Linking Considerations </H2>
<BR>When both C/C++ and FORTRAN object files are combined into an executable program or dynamic link library, it is important
that you list a least one of the FORTRAN object files first in the Open Watcom Linker (WLINK) &quot;FILES&quot; directive
to guarantee the proper search order of the FORTRAN and C run-time libraries.&nbsp; If you place a C/C++ object file first,
you may inadvertently cause the wrong version of run-time initialization routines to be loaded by the linker.
<H2 ID="Integer_Type_Compatibility"> Integer Type Compatibility </H2>
<BR>In general, the number of bytes used to store an integer type is implementation dependent.&nbsp; In FORTRAN, the default
size of an integer type is always 4 bytes, while in C/C++, the size is architecture dependent.&nbsp; The size of an &quot;int&quot;
is 2 bytes for the 16-bit Open Watcom C/C++ compilers and 4 bytes for the 32-bit compilers while the size of a &quot;long&quot;
is 4 bytes regardless of architecture.&nbsp; It is safest to prototype the function in C, specifying exactly what size integers
are being used.&nbsp; The byte sizes are as follows:
<OL>
<LI>LONG - 4 bytes
<LI>SHORT - 2 bytes
</OL>
<BR>Since FORTRAN uses a default of 4 bytes, we should specify the &quot;long&quot; keyword in C for integer types.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; long int ftnname( long int *, long int *, long int * );</TT>
<BR><BR>In this case, &quot;ftnname&quot; takes three &quot;pointers to long ints&quot; as arguments, and returns a &quot;long
int&quot;.&nbsp; By specifying that the arguments are pointers, and not values, and by specifying &quot;long int&quot; for
the return type, this prototype has solved the problems of argument passing and integer type compatibility.
<H2 ID="How_do_I_pass_integers_from_C_to_a_FORTRAN_function_"> How do I pass integers from C to a FORTRAN function? </H2>
<BR>The following Open Watcom C/C++ routine passes three integers to a FORTRAN function that returns an integer value.
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; /* MIX1C.C - This C program calls a FORTRAN function to</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; *&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; compute the max of three
numbers.</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; *</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; * Compile/Link: wcl /ml mix1c mix1f.obj /fe=mix1</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; *&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
wcl386&nbsp; mix1c mix1f.obj /fe=mix1</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; */</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; #include &lt;stdio.h&gt;</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; #pragma aux tmax3 &quot;^&quot;;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; long int tmax3( long int *, long int *, long int * );</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; void main()</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; long int&nbsp; result;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; long int&nbsp; i, j, k;</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; i = -1;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; j = 12;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; k = 5;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; result = tmax3( &amp;i, &amp;j, &amp;k );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;Maximum is %ld\n&quot;, result );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; }</TT>
<BR><BR>The FORTRAN function:
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; * MIX1F.FOR - This FORTRAN function accepts three integer</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; *&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; arguments and returns
their maximum.</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; * Compile: wfc[386] mix1f.for</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; integer function tmax3( arga, argb, argc
)</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; integer arga, argb, argc</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tmax3 = arga</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if ( argb .gt. tmax3 ) tmax3 = argb</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if ( argc .gt. tmax3 ) tmax3 = argc</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; end</TT>
<H2 ID="How_do_I_pass_integers_from_FORTRAN_to_a_C_function_"> How do I pass integers from FORTRAN to a C function? </H2>
<BR>The following Open Watcom FORTRAN 77 routine passes three integers to a Open Watcom C/C++ function that returns an integer
value.
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; *&nbsp; MIX2F.FOR - This FORTRAN program calls a C function to</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; *&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; compute the
max of three numbers.</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; *</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; * Compile/Link: wfl[386] mix2f mix2c.obj /fe=mix2</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; *$pragma aux tmax3 &quot;!_&quot; parm (value)</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; program mix2f</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; integer*4&nbsp; tmax3</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; integer*4&nbsp; result</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; integer*4&nbsp; i, j, k</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; i = -1</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; j = 12</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; k = 5</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; result = tmax3( i, j, k )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; print *, 'Maximum is ', result</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; end</TT>
<BR><BR>The C function &quot;tmax3&quot; is shown below.
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; /* MIX2C.C - This C function accepts 3 integer arguments</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; *&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; and returns their maximum.</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; *</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; * Compile: wcc /ml mix2c</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; *&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; wcc386&nbsp; mix2c</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; */</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; long int tmax3( long int arga,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;long int argb,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;long int argc )</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; long int&nbsp;&nbsp; result;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; result = arga;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if( argb &gt; result ) result = argb;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if( argc &gt; result ) result = argc;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return( result );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; }</TT>
<H2 ID="How_do_I_pass_a_string_from_a_C_function_to_FORTRAN_"> How do I pass a string from a C function to FORTRAN? </H2>
<BR>Character strings are referenced differently in C and FORTRAN.&nbsp; The C language terminates its strings with a null
character as an End-Of-String (EOS) marker.&nbsp; In this case, C need not store the length of the string in memory.&nbsp;
FORTRAN, however, does not use any EOS marker; hence it must store each string's length in memory.
<BR><BR>The structure FORTRAN uses to keep track of character data is called a &quot;string descriptor&quot; which consists
of a pointer to the character data (2, 4, or 6 bytes, depending on the data model) followed by an unsigned integer length
(2 bytes or 4 bytes, depending on the data model).
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; system option&nbsp;&nbsp; size of pointer&nbsp;&nbsp;&nbsp;&nbsp;
size of length</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ------ ------&nbsp;&nbsp; ---------------&nbsp;&nbsp;&nbsp;&nbsp;
--------------</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 16-bit /MM&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 16 bits&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 16 bits</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 16-bit /ML&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 32 bits&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 16 bits</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 32-bit /MF&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 32 bits&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 32 bits</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 32-bit /ML&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 48 bits&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 32 bits</TT>
<BR><BR>In order to access character data, FORTRAN needs to have access to the data's string descriptor.&nbsp; Hence, FORTRAN
expects a pointer to a string descriptor to be passed as an argument for character data.
<BR><BR>Passing string arguments between C and FORTRAN is a simple task of describing a struct type in C containing the two
fields described above.&nbsp; The first field must contain the pointer to the character data, and the second field must contain
the length of the string being passed.&nbsp; A pointer to this structure can then be passed to FORTRAN.
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; * MIX3F.FOR - This FORTRAN program calls a function written</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; *&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; in C that passes
back a string.</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; *</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; * Compile/Link: wfl[386] mix3f mix3c.obj /fe=mix3</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; program mix3f</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; character*80 sendstr</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; character*80 cstring</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cstring = sendstr()</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; print *, cstring(1:lentrim(cstring))</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; end</TT>
<BR><BR>The C function &quot;sendstr&quot; is shown below.
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; /* MIX3C.C - This C function passes a string back to its</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; *&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; calling FORTRAN program.</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; *</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; * Compile: wcc /ml mix3c</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; *&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; wcc386&nbsp; mix3c</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; */</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; #include &lt;string.h&gt;</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; #pragma aux sendstr &quot;^&quot;;</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; typedef struct descriptor {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; char&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; *addr;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; unsigned&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; len;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; } descriptor;</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; void sendstr( descriptor *ftn_str_desc )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ftn_str_desc-&gt;addr = &quot;This is a C string&quot;;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ftn_str_desc-&gt;len&nbsp; = strlen( ftn_str_desc-&gt;addr );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; }</TT>
<H2 ID="How_do_I_pass_a_string_from_FORTRAN_to_a_C_function_"> How do I pass a string from FORTRAN to a C function? </H2>
<BR>By default, FORTRAN passes the address of the string descriptor when passing strings.&nbsp; If the C function knows it
is being passed a string descriptor address, then it is very similar to the above example.&nbsp; If the C function is expecting
normal C-type strings, then a FORTRAN pragma can be used to pass the string correctly.&nbsp; When the Open Watcom FORTRAN
77 compiler pragma to pass by value is used for strings, then just a pointer to the string is passed.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; *$pragma aux cname &quot;!_&quot; parm (value)</TT>
<BR><BR>The following example FORTRAN mainline defines a string, and passes it to a C function that prints it out.
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; * MIX4F.FOR - This FORTRAN program calls a function written</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; *&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; in C and passes
it a string.</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; *</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; * Compile/Link: wfl[386] mix4f mix4c.obj /fe=mix4</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; *$pragma aux cstr &quot;!_&quot; parm (value)</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; program mix4f</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; character*80 forstring</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; forstring = 'This is a FORTRAN string'//char(0)</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call cstr( forstring )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; end</TT>
<BR><BR>The C function:
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; /* MIX4C.C - This C function prints a string passed from</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; *&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; FORTRAN.</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; *</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; * Compile: wcc /ml mix4c</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; *&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; wcc386&nbsp; mix4c</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; */</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; #include &lt;stdio.h&gt;</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; void cstr( char *instring )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;%s\n&quot;, instring );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; }</TT>
<H2 ID="How_do_I_access_a_FORTRAN_common_block_from_within_C_"> How do I access a FORTRAN common block from within C? </H2>
<BR>The following code demonstrates a technique for accessing a FORTRAN common block in a C routine.&nbsp; The C routine defines
an extern struct to correspond to the FORTRAN common block.
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; * MIX5F.FOR - This program shows how a FORTRAN common</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; *&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; block can be accessed
from C.</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; *</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; * Compile/Link: wfl[386] mix5f mix5c.obj /fe=mix5</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; program mix5f</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; external put</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; common/cblk/i,j</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; i=12</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; j=10</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call put</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; print *, 'i = ', i</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; print *, 'j = ', j</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; end</TT>
<BR><BR>The C function:
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; /* MIX5C.C - This code shows how to access a FORTRAN</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; *&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; common block from C.</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; *</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; * Compile: wcc /ml mix5c</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; *&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; wcc386&nbsp; mix5c</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; #include &lt;stdio.h&gt;</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; #pragma aux put &quot;^&quot;;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; #pragma aux cblk &quot;^&quot;;</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; #ifdef __386__</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; #define FAR</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; #else</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; #define FAR far</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; #endif</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; extern struct cb {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; long int i,j;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; } FAR cblk;</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; void put( void )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;i = %ld\n&quot;, cblk.i );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;j = %ld\n&quot;, cblk.j );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cblk.i++;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cblk.j++;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; }</TT>
<BR><BR>For the 16-bit C compiler, the common block &quot;cblk&quot; is described as <TT> far</TT> to force a load of the
segment portion of the address.&nbsp; Otherwise, since the object is smaller than 32K (the default data threshold), it is
assumed to be located in the DGROUP group which is accessed through the SS segment register.
<H2 ID="How_do_I_call_a_C_function_that_accepts_a_variable_number_of_arguments_"> How do I call a C function that accepts a variable number of arguments? </H2>
<BR>One capability that C possesses is the ability to define functions that accept variable number of arguments.&nbsp; This
feature is not present, however, in the definition of the FORTRAN 77 language.&nbsp; As a result, a special pragma is required
to call these kinds of functions.
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; *$pragma aux printf &quot;!_&quot; parm (value) caller []</TT>
<BR><BR>The &quot;caller&quot; specifies that the caller will pop the arguments from the stack.&nbsp; The &quot;[]&quot; indicates
that there are no arguments passed in registers because the<TT> printf</TT> function takes a variable number of arguments
passed on the stack.&nbsp; The following example is a FORTRAN function that uses this pragma.&nbsp; It calls the<TT> printf</TT>
function to print the value 47 on the screen.
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; * MIX6.FOR - This FORTRAN program calls the C</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; *&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf function.</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; * Compile/Link: wfl[386] mix6</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; *$pragma aux printf &quot;!_&quot; parm (value) caller []</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; program mix6</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; character cr/z0d/, nullchar/z00/</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call printf( 'Value is %ld.'//cr//nullchar,
47 )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; end</TT>
<BR><BR>For more information on the pragmas that are used extensively during inter-language programming, please refer to the
chapter entitled &quot;Pragmas&quot; in both the<B> Open Watcom C/C++ User's Guide</B> and the<B> Open Watcom FORTRAN 77 User's
Guide.</B>
<H1 ID="Commonly_Asked_Questions_and_Answers"> Commonly Asked Questions and Answers </H1>
<BR>As with any sophisticated piece of software, there are topics that are not directly addressed by the descriptive portions
of the manuals.&nbsp; The purpose of this chapter is to anticipate common questions concerning Open Watcom C/C++.&nbsp; It
is difficult to predict what topics will prove to be useful but with that in mind, we hope that this chapter will help our
customers make full use of Open Watcom C/C++.
<BR><BR>A number of example programs are presented throughout.&nbsp; The source text for these files can be found in the<TT>
\WATCOM\SAMPLES\GOODIES</TT> directory.
<BR><BR>The purpose of this chapter is to present some of the more commonly asked questions from our users and the answers
to these questions.&nbsp; The following topics are discussed:
<UL>
<LI>How do I determine my current patch level?
<LI>How do I convert to Open Watcom C/C++?
<LI>What should I know about optimization?
<LI>Why can't the compiler find &quot;stdio.h&quot;?
<LI>How do I resolve an &quot;Undefined Reference&quot; linker error?
<LI>Why aren't my variables set to zero?
<LI>What does &quot;size of DGROUP exceeds 64K&quot; mean for 16-bit applications?
<LI>What does &quot;NULL assignment detected&quot; mean in 16-bit applications?
<LI>What does &quot;Stack Overflow!&quot; mean?
<LI>Why do I get redefinition errors from WLINK?
<LI>How can I open more than 20 files at a time?
<LI>How can I see my source files in the debugger?
<LI>What is the difference between the &quot;d1&quot; and &quot;d2&quot; compiler options?
</UL>
<H2 ID="Determining_my_current_patch_level"> Determining my current patch level </H2>
<BR>In an effort to immediately correct any problems discovered in the originally shipped product, Open Watcom provides patches
as a continued service to its customers.&nbsp; To determine the current patch level of your Open Watcom software, a TECHINFO
utility program has been provided.&nbsp; This program will display your current environment variables, the patch level of
various Open Watcom software programs, and other pertinent information, such as your<TT> AUTOEXEC.BAT</TT> and<TT> CONFIG.SYS</TT>
files.&nbsp; This information proves to be very useful when reporting a problem to the Technical Support team.
<BR><BR>To run TECHINFO, you must ensure the Open Watcom environment variable has been set to the directory where your Open
Watcom software has been installed.&nbsp; TECHINFO will pause after each screenful of information.&nbsp; The output is also
placed in the file<TT> TECHINFO.OUT.</TT>
<BR><BR>Below is an example of some partial output produced by running the TECHINFO utility:
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; WATCOM's Techinfo Utility, Version 1.4</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Current Time: Thu Oct 27 15:58:34 1994</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; WATCOM&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Phone: (519) 884-0702</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; 415 Phillip St.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp; Fax: (519) 747-4971</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Waterloo, Ontario</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; CANADA&nbsp;&nbsp;&nbsp; N2L 3X2</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; -------------WATCOM C Environment Variables -------------</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; WATCOM=&lt;c:\watcom&gt;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; EDPATH=&lt;c:\watcom\eddat&gt;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; INCLUDE=&lt;c:\watcom\h;c:\watcom\h\os2&gt;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; FINCLUDE=&lt;c:\watcom\src\fortran;c:\watcom\src\fortran\win&gt;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; LIBOS2=&lt;c:\watcom\lib286\os2;c:\watcom\lib286&gt;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; PATH=&lt;c:\dos;c:\windows;c:\watcom\binw&gt;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; TMP=&lt;h:\temp&gt;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; File 'c:\watcom\binw\wcc386.exe' has been patched to level '.d'</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; ...etc...</TT>
<BR><BR>In this example, the software has been patched to level &quot;d&quot;.&nbsp; In most cases, all tools will share a
common patch level.&nbsp; However, there are instances where certain tools have been patched to one level while others are
patched to a different level.&nbsp; For example, the compiler may be patched to level &quot;d&quot; while the debugger is
only patched to level &quot;c&quot;.&nbsp; Basically, this means that there were no debugger changes in the D-level patches.
<BR><BR>If you run the TECHINFO utility, and determine that you are not at the current patch level, it is recommended that
you update your software.&nbsp; Patches are available on Open Watcom's bulletin board, Open Watcom's FTP site and CompuServe.
&nbsp;They are available 24 hours a day.&nbsp; Patches are also available on the current release CD-ROM.&nbsp; Each patch
will include a batch file that allows you to apply the patches to your existing software.&nbsp; Note that patches must be
applied in sequential order, as each patch depends on the previous one.
<H2 ID="Converting_to_Open_Watcom_CDCPP"> Converting to Open Watcom C/C++ </H2>
<BR>There are some common steps involved in converting C programs written for other compilers.&nbsp; Conversion from UNIX
and other IBM-compatible PC compilers will be covered in detail later.&nbsp; There are six major problems with most programs
that are ported to Open Watcom C/C++.&nbsp; The assumptions that most foreign programs make that may be invalid when using
Open Watcom C/C++ are:
<OL>
<LI>sizeof( pointer ) == sizeof( int )
<BR><BR>(true for 16-bit systems except &quot;far&quot; pointers, true for 32-bit systems except &quot;far&quot; pointers)
<LI>sizeof( long ) == sizeof( int )
<BR><BR>(not true for 16-bit systems)
<LI>sizeof( short ) == sizeof( int )
<BR><BR>(not true for 32-bit systems)
<LI>arguments are always passed on the stack
<LI>dereferencing the<TT> NULL</TT> pointer
<LI>&quot;char&quot; is either signed or unsigned
</OL>
<BR>These assumptions are very easy to make when developing programs for only one system.&nbsp; The first point becomes important
when you move a program to 80x86 systems.&nbsp; Depending on the memory model, the size of an integer might not equal the
size of a pointer.&nbsp; You might ask how this assumption is made in programs.&nbsp; The C language will assume that a function
returns an integer unless told otherwise.&nbsp; If a programmer does not declare a function as returning a pointer, the compiler
will generate code which would convert an integer to a pointer.&nbsp; On other systems, where the size of an integer is equal
to the size of a pointer this would amount to nothing because no conversion was necessary (to change size).&nbsp; The older
C compilers did not worry about warning the programmer about this condition and as such this error is imbedded in a lot of
older C code.&nbsp; As C was moved to other machines, it became apparent that this assumption was no longer valid for all
machines.&nbsp; The 80x86 architecture can have 16-bit integers and 32-bit pointers (in the compact, large, and huge memory
models), which means that more care must be taken when working with declarations (converting an int to a 32-bit pointer will
result in a segment value of 0x0000 or 0xffff).&nbsp; Similarly, the 386 architecture can have 32-bit integers and 48-bit
pointers.
<BR><BR>The Open Watcom C/C++ compiler will complain about incorrect pointer and integer mixing thus making programs compiled
with Open Watcom C/C++ much more portable.&nbsp; For instance, if the Open Watcom C/C++ compiler complains about your usage
of the &quot;malloc&quot; memory allocation function then you probably forgot to include &quot;&lt;stdlib.h&gt;&quot; which
contains the prototype of the &quot;malloc&quot; function.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; extern void *malloc( unsigned );</TT>
<BR><BR>The Open Watcom C/C++ compiler was complaining about you trying to assign an integer (the value returned by &quot;malloc&quot;)
to a pointer.&nbsp; By including the header file with the correct prototype, the Open Watcom C/C++ compiler can validate that
you are in fact assigning a pointer value to a pointer.
<BR><BR>Passing arguments on the stack has been the method used by most older compilers because it allowed the C library function
&quot;printf&quot; to work with a variable number of arguments.&nbsp; Older C compilers catered to a few functions by forcing
all the argument handling to be handled by the caller of the function.&nbsp; With the advent of the ANSI (and later ISO) standard,
which forced all functions expecting a variable number of arguments to be declared properly, compilers can generate smaller
code for routines that did not require a variable number of arguments.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; /* function accepting two arguments */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; extern FILE *fopen( char *, char * );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; /* function accepting a variable number of arguments */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; extern int printf( char *, ... );</TT>
<BR><BR>The Open Watcom C/C++ compiler takes advantage of this part of the ISO/ANSI standard by passing arguments in registers
(for the first few arguments).&nbsp; If there are not enough registers for all of the arguments, the rest of the arguments
are passed on the stack but the routine being called is responsible for removing them from the stack.&nbsp; By default, the
Open Watcom C/C++ compiler uses this calling convention because it results in faster procedure calls and smaller code.&nbsp;
The Open Watcom C/C++ calling convention carries with it a responsibility to ensure that all functions are prototyped correctly
before they are used.&nbsp; For instance, if a procedure is called with too few arguments, the assumptions that the code generator
made (while generating the code) will be invalidated.&nbsp; The code generator assumes that AX (EAX for the 32-bit compiler)
and any other registers used to pass arguments will be modified by the called function.&nbsp; The code generator also assumes
that the exact amount of arguments pushed on the stack will be removed by the function that is called.&nbsp; It is important
to recognize this aspect of the Open Watcom C/C++ compiler because the program will simply not work unless the caller and
the function being called strictly agree on the number and types of the arguments being passed.&nbsp; See the &quot;Assembly
Language Considerations&quot; chapter in the<B><I> Open Watcom C/C++ User's Guide</I></B> for more details.
<BR><BR>Some compilers allow the<TT> NULL</TT> pointer to be dereferenced and return<TT> NULL</TT> (we have never understood
the rationale behind this, nor why some compilers continue to support this type of code).&nbsp; Leaving the aesthetics of
this type of code behind, using the<TT> NULL</TT> dereferencing assumption in a program will ensure that the program will
not be portable.&nbsp; Source code which contains the<TT> NULL</TT> dereferencing assumption must be corrected before it will
work with Open Watcom C/C++.
<BR><BR>Programs that assume that the &quot;char&quot; type is &quot;signed&quot; should use the Open Watcom C/C++ compiler
&quot;j&quot; option.&nbsp; The &quot;j&quot; option will indicate to the Open Watcom C/C++ compiler that the &quot;char&quot;
type is &quot;signed&quot; rather than the default &quot;unsigned&quot;.
<H3 ID="Conversion_from_UNIX_compilers"> Conversion from UNIX compilers </H3>
<BR>The ISO/ANSI standard for C (which Open Watcom C/C++ adheres to) is very similar to UNIX C.&nbsp; Most of the effort in
converting UNIX C programs will involve replacing references to library functions (such as the CURSES library).&nbsp; There
are many third-party libraries which are implementations of UNIX libraries on IBM-compatible Personal Computers.&nbsp; There
is a common problem which many older UNIX programs exhibit, namely, functions that accept a variable number of arguments are
coded in many different ways.&nbsp; Functions accepting a variable number of arguments must be coded according to the ISO
standard if they are to work with Open Watcom C/C++.&nbsp; We will code an example of a function which will return the maximum
of a list of positive integers.&nbsp; 
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; /*</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; variable number of arguments example</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; #include &lt;stdarg.h&gt;</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; int MaxList( int how_many, ... )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; va_list args;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int max;</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; max = 0;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; va_start( args, how_many );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; while( how_many &gt; 0 ) {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; value = va_arg( args, int );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if( value &gt; max ) {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; max = value;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; va_end( args );</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return( max );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; }</TT>
<BR><BR>Notice that the standard header file<TT> STDARG.H</TT> must be included in any source file which defines a function
that handles a variable number of arguments.&nbsp; The function &quot;MaxList&quot; must be prototyped correctly in other
source files external to the source file containing the definition of &quot;MaxList&quot;.
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; extern int MaxList( int how_many, ... );</TT>
<BR><BR>See the<B><I> Open Watcom C Library Reference</I></B> manual description of &quot;va_arg&quot; for a more complete
description of variable number of arguments handling.
<H3 ID="Conversion_from_IBMMcompatible_PC_compilers"> Conversion from IBM-compatible PC compilers </H3>
<BR>Most of the compilers available for IBM-compatible PCs have been following the ISO/ANSI standard and, as such, the majority
of programs will not require extensive source changes.&nbsp; There are problems with programs that use compiler-specific library
functions.&nbsp; The use of compiler-specific library functions can be dealt with in two different ways:
<OL>
<LI>use equivalent Open Watcom C/C++ library functions
<LI>write your own library functions
</OL>
<BR>If portability must be maintained with the other compiler, the predefined macro<TT> &quot;__WATCOMC__&quot;</TT> can be
used to conditionally compile the correct code for the Open Watcom C/C++ compiler.
<BR><BR>The default calling convention for the Open Watcom C/C++ compiler is different from the calling convention used by
other compilers for Intel-based personal computers.&nbsp; The Open Watcom C/C++ calling convention is different because it
will pass some arguments in registers (thus reducing the overhead of a function call) rather than pushing all of the arguments
on the stack.&nbsp; The Open Watcom C/C++ compiler is flexible enough to use different calling conventions on a per function
basis.&nbsp; Converting code from other compilers usually involves recompiling the C source files and setting up prototypes
(to use the older calling convention) for functions written in assembly language.&nbsp; For instance, if you have the functions
&quot;video_init&quot;, &quot;video_put&quot;, and &quot;video_get&quot; written in assembly language, you can use the following
prototypes in any source file which uses these functions.&nbsp; 
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; #include &lt;stddef.h&gt;</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; extern int&nbsp; cdecl video_init( void );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; extern void cdecl video_put( int row,int col,char ch,int attr );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; extern char cdecl video_get( int row,int col );</TT>
<BR><BR>The inclusion of the<TT> STDDEF.H</TT> header file defines the &quot;cdecl&quot; calling convention.&nbsp; The Open
Watcom C/C++ compiler will ensure that any calls to these three functions will adhere to the &quot;cdecl&quot; calling conventions.
&nbsp;The Open Watcom C/C++ compiler will put a trailing underscore &quot;_&quot; character (as opposed to the beginning of
the name for the &quot;cdecl&quot; convention) on any function names to ensure that the program will not link register calling
convention calls to &quot;cdecl&quot; convention functions (or vice versa).&nbsp; If the linker indicates that functions defined
in assembler files cannot be resolved, it could be a result of not prototyping the functions properly as &quot;cdecl&quot;
functions.
<BR><BR><B><I>Hint:</I></B>&nbsp; (16-bit applications only) Most 16-bit C compilers (including Open Watcom C/C++) have a
&quot;large&quot; memory model which means that four byte pointers are used for both code and data references.&nbsp; A subtle
point to watch out for involves differences between memory model definitions of different compilers.&nbsp; The &quot;cdecl&quot;
calling convention allows functions to assume that the DS segment register points to the group &quot;DGROUP&quot;.&nbsp; The
Open Watcom C/C++ large memory model has what is called a &quot;floating DS&quot;.&nbsp; Any function used for the large memory
model cannot assume that the DS segment register points to the group &quot;DGROUP&quot;.&nbsp; There are a few possible recourses.
<OL>
<LI>The assembly code could save and restore the DS segment register and set DS to DGROUP in order to conform to the Open
Watcom C/C++ convention.&nbsp; If there are only a few accesses to DGROUP data, it is advisable to use the SS segment register
which points to DGROUP in the large memory model.&nbsp; 
<LI>The assembly function could be described using a pragma that states that DS should point to &quot;DGROUP&quot; before
calling the function.&nbsp; 
<BR><BR><B>#pragma aux _Setcolor __parm __loadds</B>
<BR><BR>In the above example,<B> _Setcolor</B> is the sample function being described.
<LI>The final alternative would be the use of the &quot;zdp&quot; compiler option.&nbsp; The &quot;zdp&quot; option informs
the code generator that the DS register must always point to &quot;DGROUP&quot;.&nbsp; This is the default in the small, medium
and flat memory models.&nbsp; Note that &quot;flat&quot; is a 32-bit memory model only.
</OL>
<H2 ID="What_you_should_know_about_optimization"> What you should know about optimization </H2>
<BR>The C/C++ language contains features which allow simpler compilers to generate code of reasonable quality.&nbsp; Register
declarations and imbedding assignments in expressions are two of the ways that C allows the programmer to &quot;help&quot;
the compiler generate good quality code.&nbsp; An important point about the Open Watcom C/C++ compiler is that it is not as
important (as it is with other compilers) to &quot;help&quot; the compiler.&nbsp; In order to make good decisions about code
generation, the Open Watcom C/C++ compiler uses modern optimization techniques.&nbsp; 
<BR><BR><B><I>Hint:</I></B>&nbsp; The definitive reference on compiler design is the &quot;dragon&quot; book &quot;Compilers
- Principles, Techniques, and Tools&quot;, Alfred V.&nbsp; Aho, Ravi Sethi, and Jeffrey D.&nbsp; Ullman, published by Addison-Wesley,
Reading, Massachusetts, 1986.&nbsp; The authors of the &quot;dragon&quot; book advocate a conservative approach to code generation
where optimizations must preserve the semantics of the original program.&nbsp; The conservative approach is used throughout
the Open Watcom C/C++ compiler to ensure that programmers can use the compiler without worrying about the semantics of their
program being changed.&nbsp; The programmer can request that potentially unsafe optimizations be performed.&nbsp; With regard
to the &quot;oa&quot; (ignore aliasing) option provided by the Open Watcom C/C++ compiler, the compiler only ignores aliasing
of global variables rather than ignore aliasing totally like other compilers.
<BR><BR>There are certain pieces of information which the compiler cannot derive from the source code.&nbsp; The &quot;#pragma&quot;
compiler directive is used to provide extra information to the compiler.&nbsp; It is necessary to have a complete understanding
of both C/C++ and the machine architecture (i.e., 80x86) before using the powerful pragma compiler directives.&nbsp; See the
&quot;Pragmas&quot; chapter in the<B><I> Open Watcom C/C++ User's Guide</I></B> for more details.
<BR><BR>Debugging optimized programs is difficult because variables can be assigned to different locations (i.e., memory or
registers) in different parts of the function.&nbsp; The &quot;d2&quot; compiler option will restrict the amount of optimization
so that variables occupy one location and can be easily displayed.&nbsp; It follows that the &quot;d2&quot; option is useful
for initial development but production programs should be compiled with only the &quot;d1&quot; option for the best code quality.
&nbsp;Before you distribute your application to others, you may wish to use the Open Watcom Strip Utility (WSTRIP) to remove
debugging information from the executable image on disk thereby reducing disk space requirements.&nbsp; 
<BR><BR><B><I>Hint:</I></B>&nbsp; The &quot;d2&quot; compiler option will generate symbolic information (for every local variable)
and line number information for the source file.&nbsp; The &quot;d1&quot; compiler option will only generate line number information
for the source file.&nbsp; The use of these options determines what kind of information will be available for the particular
module during the debugging session.
<BR><BR>Incorrect programs can sometimes work when compiled with the &quot;d2&quot; option and not work when compiled with
the &quot;d1&quot; option.&nbsp; One way this sort of problem arises involves local arrays.&nbsp; 
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; void example( void )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int i;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int a[10];</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for( i = 0; i &lt;= 10; ++i )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; a[i] = i;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; do_something( a );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; }</TT>
<BR><BR>The &quot;for&quot; loop initializes one too many array elements but the version compiled with the &quot;d2&quot;
option will overwrite the variable &quot;i&quot; without causing any problems.&nbsp; The same function compiled with the &quot;d1&quot;
option would have the variable &quot;i&quot; in a register.&nbsp; The erroneous access of &quot;a[10]&quot; would modify a
value that is used to restore a register when the function returns.&nbsp; The register would be &quot;restored&quot; with
an incorrect value and this would affect the execution of the function that called this function.&nbsp; The above example
shows how a program can work when compiled with the &quot;d2&quot; option and stop working when compiled with the &quot;d1&quot;
option.&nbsp; You should always test your program fully with all the modules compiled with the &quot;d1&quot; option to protect
yourself from any surprises.
<H2 ID="The_compiler_cannot_find__stdio_h_"> The compiler cannot find &quot;stdio.h&quot; </H2>
<BR>The standard header files are usually located in the sub-directory that the Open Watcom C/C++ compiler is installed in.
&nbsp;Suppose that the header files are located in the sub-directory<TT> c:\watcom\h.</TT>&nbsp; If the compiler indicates
(through an error message) that it is unable to locate the file<TT> STDIO.H</TT>, we have forgotten something.&nbsp; There
are two ways to indicate to the Open Watcom C/C++ compiler the location of the standard header files.
<OL>
<LI>use the<B> INCLUDE</B> environment variable
<LI>use the &quot;i&quot; option (Open Watcom C/C++, Open Watcom Compile and Link)
</OL>
<BR>The use of the environment variable is the simplest way to ensure that the include files will be found.&nbsp; For instance,
if you include the following line in your system initialization file,<TT> AUTOEXEC.BAT,</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; set include=c:\watcom\h</TT>
<BR><BR>the Open Watcom C/C++ compiler will be able to find the standard include files.&nbsp; The use of the &quot;i&quot;
option is another way to give the directory name of the standard include files.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; C&gt;wcc myfile.c -ic:\watcom\h</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; or</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; C&gt;wcc386 myfile.c -ic:\watcom\h</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; or</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; C&gt;wpp myfile.cpp -ic:\watcom\h</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; or</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; C&gt;wpp386 myfile.cpp -ic:\watcom\h</TT>
<BR><BR>The usual manner that these methods are combined is as follows.&nbsp; The<B> INCLUDE</B> environment variable is used
to give the location of the standard C library header files.&nbsp; Any directories of header files local to a specific programming
project are often candidates for the &quot;i&quot; option method.&nbsp; See the &quot;Open Watcom C/C++ #include File Processing&quot;
section of the chapter entitled &quot;The Open Watcom C/C++ Compilers&quot; in the<B><I> Open Watcom C/C++ User's Guide</I></B>
for more details.
<H2 ID="Resolving_an__Undefined_Reference__linker_error"> Resolving an &quot;Undefined Reference&quot; linker error </H2>
<BR>The Open Watcom Linker builds an executable file by a process of resolving references to functions or data items that
are declared in other source files.&nbsp; Certain conditions arise that cause the linker to generate an &quot;Undefined Reference&quot;
error message.&nbsp; An &quot;Undefined Reference&quot; error message will be displayed by the linker when it cannot find
a function or data item that was referenced in the program.&nbsp; Verify that you have included all the required object modules
in the linker command and that you are linking with the correct libraries.&nbsp; There are a couple of &quot;undefined references&quot;
that require some explanation.
<DL>
<DT>_cstart_
<DD>The unresolved reference for <TT> _cstart_</TT> indicates that the linker cannot find the C/C++ run-time libraries.&nbsp;
The 16-bit C run-time libraries for the small memory model are<TT> clibs.lib</TT> and, either<TT> maths.lib,</TT> or<TT> math87s.lib.</TT>
&nbsp;The 32-bit C run-time libraries for the flat memory model compiled for the register-based argument passing model are<TT>
clib3r.lib</TT> and, either<TT> math3r.lib,</TT> or<TT> math387r.lib.</TT>&nbsp; Ensure that the<B> WATCOM</B> environment
variable is set to the directory that Open Watcom C/C++ was installed in.&nbsp; 
<DT>_fltused_
<DD>The<TT> _fltused_</TT> undefined reference indicates that floating-point arithmetic has been used in the modules that exhibit
this error.&nbsp; The remedy is to ensure that the linker can find the appropriate math library.&nbsp; For the 16-bit small
memory model, it is either<TT> maths.lib,</TT> or<TT> math87s.lib</TT> For the 32-bit register-based argument passing model,
it is either<TT> math3r.lib,</TT> or<TT> math387r.lib</TT> depending on which floating-point option is used.&nbsp; Ensure
that the<B> WATCOM</B> environment variable is set to the directory that Open Watcom C/C++ was installed in.&nbsp; 
<DT>_small_code_
<DD>If this undefined reference occurs when you are trying to create a 16-bit application, we have saved you many hours of debugging!
&nbsp;The reason for this undefined reference is that the &quot;main&quot; entry point has been compiled for a big code model
(in any one of medium, large, or huge memory models).&nbsp; Any of the modules that have this undefined reference have been
compiled for a small code model (in any one of small or compact memory models) and as such do not have the correct return
instructions.&nbsp; You should recompile the modules so that all the modules are compiled for the same memory model.&nbsp;
Combining source modules compiled for different memory models is very difficult and often leads to strange bugs.&nbsp; If
your program has special considerations and this reference causes you problems, there is a &quot;work-around&quot;.&nbsp;
You could resolve the reference with a PUBLIC declaration in an assembler file or code the following in Open Watcom C/C++.
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; /* rest of your module */</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; void _small_code( void )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; {}</TT>
<BR><BR>The code generator will generate a single RET instruction with the public symbol<TT> _small_code_</TT> attached to
it.&nbsp; The common epilogue optimizations will probably combine this function with another function's RET instruction and
you will not even pay the small penalty of one byte of extra code.
<BR><BR>There may be another cause of this problem, the &quot;main&quot; function must be entered in lower case letters (&quot;Main&quot;
or &quot;MAIN&quot; are not identified as being the same as &quot;main&quot; by the compiler).&nbsp; The compiler will identify
the module that contains the definition of the function &quot;main&quot; by creating the public definition of either<TT> _small_code_</TT>
or<TT> _big_code_</TT> depending on the memory model it was compiled in.&nbsp; 
<DT>_big_code_
<DD>Your module that contains the &quot;main&quot; entry point has been compiled with a 16-bit small code model (small or compact).
&nbsp;The modules that have this undefined reference have been compiled in 16-bit big code models (medium, large, or huge).
&nbsp;You should recompile the modules so that all the modules are compiled in the same memory model.&nbsp; See the explanation
for<TT> _small_code_</TT> for more details.&nbsp; 
<DT>main_
<DD>All C programs, except applications developed specifically for Microsoft Windows, must have a function called &quot;main&quot;.
&nbsp;The name &quot;main&quot; must be in lower case for the compiler to generate the appropriate information in the &quot;main&quot;
module.
<DT>WINMAIN
<DD>All Windows programs must have a function called &quot;WinMain&quot;.&nbsp; The function &quot;WinMain&quot; must be declared
&quot;pascal&quot; in order that the compiler generate the appropriate name in the &quot;WinMain&quot; module.
</DL>
<H2 ID="Why_my_variables_are_not_set_to_zero"> Why my variables are not set to zero </H2>
<BR>The linker is the program that handles the organization of code and data and builds the executable file.&nbsp; C guarantees
that all global and static uninitialized data will contain zeros.&nbsp; The &quot;BSS&quot; region contains all uninitialized
global and static data for C programs (the name &quot;BSS&quot; is a remnant of the early UNIX C compilers).&nbsp; Most C
compilers take advantage of this situation by not explicitly storing all the zeros to achieve smaller executable file sizes.
&nbsp;In order for the program to work correctly, there must be some code (that will be executed before &quot;main&quot;)
that will clear the &quot;BSS&quot; region.&nbsp; The code that is executed before &quot;main&quot; is called &quot;startup&quot;
code.&nbsp; The linker must indicate to the startup code where the &quot;BSS&quot; region is located.&nbsp; In order to do
this, the Open Watcom Linker (WLINK) treats the &quot;BSS&quot; segment (region) in a special manner.&nbsp; The special variables
'_edata' and '_end' are constructed by the Open Watcom Linker so that the startup code knows the beginning and end of the
&quot;BSS&quot; region.
<BR><BR>Some users may prefer to use the linker provided by another compiler vendor for development.&nbsp; In order to have
the program execute correctly, some extra care must be taken with other linkers.&nbsp; For instance, with the Microsoft linker
(LINK) you must ensure that the '/DOSSEG' command line option is used.&nbsp; With the Phar Lap Linker, you must use the &quot;-DOSORDER&quot;
command line option.&nbsp; In general, if you must use other linkers, extract the module that contains<TT> _cstart</TT> from<TT>
clib?.lib</TT> (?&nbsp; will change depending on the memory model) and specify the object file containing<TT> _cstart</TT>
as the first object file to be processed by the linker.&nbsp; The object file will contain the information necessary for the
linker to build the executable file correctly.
<H2 ID="What_does__size_of_DGROUP_exceeds_64K__mean_for_16Mbit_applications_"> What does &quot;size of DGROUP exceeds 64K&quot; mean for 16-bit applications? </H2>
<BR>This question applies to 16-bit applications.&nbsp; There are two types of segments in which data is stored.&nbsp; The
two types of segments are classified as &quot;near&quot; and &quot;far&quot;.&nbsp; There is only one &quot;near&quot; segment
while there may be many &quot;far&quot; segments.&nbsp; The single &quot;near&quot; segment is provided for quick access to
data but is limited to less than 64K in size.&nbsp; Conversely, the &quot;far&quot; segments can hold more than 64K of data
but suffer from a slight execution time penalty for accessing the data.&nbsp; The &quot;near&quot; segment is linked by arranging
for the different parts of the &quot;near&quot; segment to fall into a group called DGROUP.&nbsp; See the section entitled
&quot;Memory Layout&quot; in the<B><I> Open Watcom Linker User's Guide</I></B> for more details.
<BR><BR>The 8086 architecture cannot support segments larger than 64K.&nbsp; As a result, if the size of DGROUP exceeds 64K,
the program cannot execute correctly.&nbsp; The basic idea behind solving this problem is to move data out of the single &quot;near&quot;
segment into one or more &quot;far&quot; segments.&nbsp; Of course, this solution does not come without any penalties.&nbsp;
The penalty is paid in decreased execution speed as a result of accessing &quot;far&quot; data items.&nbsp; The magnitude
of this execution speed penalty depends on the behavior of the program and, as such, cannot be predicted (i.e., we cannot
say that the program will take precisely 5% longer to execute).&nbsp; The specific solution to this problem depends on the
memory model being used in the compilation of the program.
<BR><BR>If you are compiling with the tiny, small, or medium memory models then there are two possible solutions.&nbsp; The
first solution involves changing the program source code so that any large data items are declared as &quot;far&quot; data
items and accessed with &quot;far&quot; pointers.&nbsp; The addition of the &quot;far&quot; keyword into the source code makes
the source code non-portable but this might be an acceptable tradeoff.&nbsp; See the &quot;Advanced Types&quot; chapter in
the<B><I> Open Watcom C Language Reference</I></B> manual for details on the use of the &quot;near&quot; and &quot;far&quot;
keywords.&nbsp; The second solution is to change memory models and use the large or compact memory model.&nbsp; The use of
the large or compact memory model allows the compiler to use &quot;far&quot; segments to store data items that are larger
than 32K.
<BR><BR>The large and compact memory models will only allocate data items into &quot;far&quot; segments if the size of the
data item exceeds 32K.&nbsp; If the size of DGROUP exceeds 64K then a good solution is to reduce the size threshold so that
smaller data items will be stored into &quot;far&quot; segments.&nbsp; The relevant compiler option to accomplish this task
is &quot;zt&lt;num&gt;&quot;.&nbsp; The &quot;zt&quot; option sets a data size threshold which, if exceeded, will allocate
the data item in &quot;far&quot; segments.&nbsp; For instance, if the option &quot;zt100&quot; is used, any data item larger
than 100 bytes will be allocated in &quot;far&quot; segments.&nbsp; A good starting value for the data threshold is 32 bytes
(i.e., &quot;zt32&quot;).&nbsp; The number of compilations necessary to reduce the size of DGROUP for a successful link with
WLINK depends on the program.&nbsp; Minimally, any files which allocate a lot of data items should be recompiled.&nbsp; The
&quot;zt&lt;num&gt;&quot; option should be used for all subsequent compiles, but the recompilation of all the source files
in the program is not necessary.&nbsp; If the &quot;DGROUP exceeds 64K&quot; WLINK error persists, the threshold used in the
&quot;zt&lt;num&gt;&quot; option should be reduced and all of the source files should be recompiled.
<H2 ID="What_does__NULL_assignment_detected__mean_in_16Mbit_applications_"> What does &quot;NULL assignment detected&quot; mean in 16-bit applications? </H2>
<BR>This question applies to 16-bit applications.&nbsp; The C language makes use of the concept of a<TT> NULL</TT> pointer.
&nbsp;The<TT> NULL</TT> pointer cannot be dereferenced according to the ISO standard.&nbsp; The Open Watcom C/C++ compiler
cannot signal the programmer when the<TT> NULL</TT> address has been written to or read from because the Intel-based personal
computers do not have the necessary hardware support.&nbsp; The best that the run-time system can do is help programmers find
these sorts of errors through indirect means.&nbsp; The lower 32 bytes of &quot;near&quot; memory have been seeded with 32
bytes of the value 0x01.&nbsp; The C run-time function &quot;_exit&quot; checks these 32 bytes to ensure that they have not
been written over.&nbsp; Any modification of these 32 bytes results in the &quot;NULL assignment error&quot; being printed
before the program terminates.
<BR><BR>Here is an overview of a good debugging technique for this sort of error:
<OL>
<LI>use the Open Watcom Debugger to debug the program
<LI>let the program execute
<LI>find out what memory has been incorrectly modified
<LI>set a watchpoint on the modified memory address
<LI>restart the program with the watchpoint active
<LI>let the program execute, for a second time
<LI>when the memory location is modified, execution will be suspended
</OL>
<BR>We will go through the commands that are executed for this debugging session.&nbsp; First of all, we invoke the Open Watcom
Debugger from the command line as follows:
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; C&gt;wd myprog</TT>
<BR><BR>Once we are in the debugger type:
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; DBG&gt;go</TT>
<BR><BR>The program will now execute to completion.&nbsp; At this point we can look at the output screen with the debugger
command, &quot;FLIP&quot;.
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; DBG&gt;flip</TT>
<BR><BR>We would see that the program had the run-time error &quot;NULL assignment detected&quot;.&nbsp; At this point, all
we have to do is find out what memory locations were modified by the program.
<BR><BR>The following command will display the lower 16 bytes of &quot;near&quot; memory.
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; DBG&gt;examine __nullarea</TT>
<BR><BR>The command should display 16 bytes of value 0x01.&nbsp; Press the space bar to display the next 16 bytes of memory.
&nbsp;This should also display 16 bytes of value 0x01.&nbsp; Notice that the following data has two bytes which have been
erroneously modified by the program.
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; __nullarea&nbsp;&nbsp;&nbsp;&nbsp; 01 01 56 12 01 01 01 01-01 01 01 01 01 01 01 01</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; __nullarea+16&nbsp; 01 01 01 01 01 01 01 01-01 01 01 01 01 01 01 01</TT>
<BR><BR>The idea behind this debugging technique is to set a watchpoint on the modified memory so that execution of the program
will be suspended when it modifies the memory.&nbsp; The following command will &quot;watch&quot; the memory for you.
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; DBG&gt;watch __nullarea+2</TT>
<BR><BR>There has to be a way to restart the program without leaving the Open Watcom Debugger so that the watchpoint is active
during a subsequent execution of the program.&nbsp; The Open Watcom Debugger command &quot;NEW&quot; will reload the program
and prepare for a new invocation of the program.
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; DBG&gt;new</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; DBG&gt;go</TT>
<BR><BR>The Open Watcom Debugger command &quot;GO&quot; will start execution of the program.&nbsp; You may notice that the
program executes much slower than usual but eventually the debugger will show the part of the program that modified the two
bytes.&nbsp; At this point, you might want to clear the watchpoint and proceed to debug why the memory was modified.&nbsp;
The command to clear the watchpoint is:
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; DBG&gt;watch/clear 1</TT>
<BR><BR>The &quot;1&quot; indicates that you want watchpoint number 1 to be cleared.&nbsp; Typing &quot;WATCH&quot; by itself
will print out all active watchpoints.&nbsp; The above technique is generally useful for any type of memory overwrite error
provided you know which memory location has been overwritten.
<BR><BR><B><I>Hint:</I></B>&nbsp; The Open Watcom Debugger allows many commands to have short forms.&nbsp; For instance, the
&quot;EXAMINE&quot; command can be shortened to an &quot;E&quot;.&nbsp; We used the full commands in the examples for clarity.
<H2 ID="What__Stack_Overflow___means"> What &quot;Stack Overflow!&quot; means </H2>
<BR>The memory used for local variables is allocated from the function call stack although the Open Watcom compilers will
often use registers for local variables.&nbsp; The size of the function call stack is limited at link-time and it is possible
to exceed the amount of stack space during execution.&nbsp; The Open Watcom run-time library will perform checks whenever
a large amount of stack space is required by a function but it is up to the user to check stack requirements before calling
a Open Watcom run-time function.&nbsp; Compiling programs with stack checking will ensure that there is enough stack space
to call a Open Watcom run-time function.
<BR><BR>There are various ways of protecting against stack overflow errors.&nbsp; First, one should minimize the number of
recursive functions used in an application program.&nbsp; This can be done by recoding recursive functions to use loops.&nbsp;
Keep the amount of stack used in functions to a minimum by using and reusing static arrays whenever possible.&nbsp; These
techniques will reduce the amount of stack space required but there still may be times where the default amount of stack space
is insufficient.&nbsp; The Open Watcom Linker (WLINK) allows the user to set the amount of stack space at link-time through
the directive &quot;OPTION STACK=size&quot; where size may be specified in bytes with an optional &quot;k&quot; suffix for
kilobytes (1024 bytes).
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; option stack=9k</TT>
<BR><BR>Debugging a program that reports a stack overflow error can be accomplished with the following sequence.
<OL>
<LI>Load your application into the debugger
<LI>Set a breakpoint at<TT> __STKOVERFLOW</TT>
<LI>Run the application until the breakpoint at<TT> __STKOVERFLOW</TT> is triggered
<LI>Issue the debugger &quot;show calls&quot; command.&nbsp; This will display a stack traceback giving you the path of calls
that led up to the stack overflow situation.
</OL>
<BR>The solution to the stack overflow problem at this point depends on the programmer.
<H2 ID="Why_redefinition_errors_are_issued_from_WLINK"> Why redefinition errors are issued from WLINK </H2>
<BR>This question comes up often in discussions about porting old UNIX or Microsoft C programs.&nbsp; The problem stems from
the forgiving nature of early UNIX linkers.&nbsp; In early C code, it was common to define header files like this:
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; /* define global variables */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; int line_count;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; int word_count;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; int char_count;</TT>
<BR><BR>The header file would then be included in many different modules.&nbsp; The C compiler would generate a definition
of each variable in each module and leave it to the linker to pick one and resolve all references to one variable.&nbsp; The
development of the ANSI C standard made this practice non-conforming.&nbsp; The Open Watcom C compiler is an ISO/ANSI C compiler
and as such, is not required to support this obsolete behavior.&nbsp; The effect is that WLINK will report redefinition errors.
&nbsp;The header file must be coded in such a way that the variables are defined in one module.&nbsp; One way to do this is
as follows:
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; #ifdef DEFINE_HERE</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; #define GLOBAL</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; #else</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; #define GLOBAL&nbsp; extern</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; #endif</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; /* define global variables */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; GLOBAL int line_count;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; GLOBAL int word_count;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; GLOBAL int char_count;</TT>
<BR><BR>In most modules, the macro &quot;DEFINE_HERE&quot; will not be defined so the file will be equivalent to:
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; /* define global variables */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; extern int line_count;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; extern int word_count;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; extern int char_count;</TT>
<BR><BR>In one module, the macro &quot;DEFINE_HERE&quot; must be defined before the header file is included.&nbsp; This can
be done by defining the macro on the command line or by coding like this:
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; #define DEFINE_HERE</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; #include &quot;globals.h&quot;</TT>
<H2 ID="How_more_than_20_files_at_a_time_can_be_opened"> How more than 20 files at a time can be opened </H2>
<BR>The number of file handles allowed by Open Watcom C/C++ is initialized to 20 in<TT> stdio.h,</TT> but this can be changed
by the application developer.&nbsp; To change the number of file handles allowed with Open Watcom C/C++, follow the steps
outlined below.
<OL>
<LI>Let<TT> n</TT> represent the number of files the application developer wishes to have open.&nbsp; Ensure that the<B> stdin,
stdout, stderr, stdaux,</B> and<B> stdprn</B> files are included in the count.
<LI>Change the<TT> CONFIG.SYS</TT> file to include &quot;files=n&quot; where &quot;n&quot; is the number of file handles required
by the application plus an additional 5 handles for the standard files (this applies to DOS 5.0).&nbsp; The number &quot;n&quot;
may vary depending on your operating system and version.&nbsp; If you are running a network such as Novell's NetWare, this
will also affect the number of available file handles.&nbsp; In this case, you may have to increase the number specified in
the &quot;files=n&quot; statement.
<LI>Add a call to<TT> _grow_handles</TT> in your application.
</OL>
<BR>The following example illustrates the use of<TT> _grow_handles.</TT>
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; /*</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; *&nbsp; HANDLES.C</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; *&nbsp; This C program grows the number of file handles so</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; *&nbsp; more than 16 files can be opened. This program</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; *&nbsp; illustrates the interaction between _grow_handles and</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; *&nbsp; the DOS 5.0 file system. If you are running a network</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; *&nbsp; such as Novell's NetWare, this will also affect the</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; *&nbsp; number of available file handles. In the actual trial,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; *&nbsp; FILES=40 was specified in CONFIG.SYS.</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; */</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; #include &lt;stdio.h&gt;</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; void main()</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int&nbsp;&nbsp;&nbsp; i, j, maxh, maxo;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; FILE&nbsp; *temp_files[50];</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for( i = 25; i &lt; 40; i++ ) {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* count 5 for stdin,stdout,stderr,stdaux,stdprn
*/</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;Trying for %2.2d handles...&quot;,
5 + i );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; maxh = _grow_handles( 5 + i );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; maxo = 0;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for( j = 0; j &lt; maxh; j++ ) {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; temp_files[j] = tmpfile();</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if( temp_files[j]
== NULL )break;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; maxo++;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot; %d/%d temp files opened\n&quot;,
maxo, maxh );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for( j = 0; j &lt; maxo; j++ ) {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; fclose( temp_files[j]
);</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; }</TT>
<H2 ID="How_source_files_can_be_seen_in_the_debugger"> How source files can be seen in the debugger </H2>
<BR>The selection and use of debugging information is important for getting the most out of the Open Watcom Debugger.&nbsp;
If you are not able to see your source code in the Open Watcom Debugger source window, there are three areas where things
may have gone wrong, namely:
<OL>
<LI>using the correct option for the Open Watcom C/C++.
<LI>using the correct directives for the Open Watcom Linker.
<LI>using the right commands in the Open Watcom Debugger.
</OL>
<BR>The Open Watcom C/C++ compiler takes C/C++ source and creates an object file containing the generated code.&nbsp; By default,
no debugging information is included in the object file.&nbsp; The compiler will output debugging information into the object
file if you specify a debugging option during the compile.&nbsp; There are two levels of debugging information that the compiler
can generate:&nbsp; 
<OL>
<LI>Line numbers and local variables (&quot;d2&quot; option)
<LI>Line numbers (&quot;d1&quot; option)
</OL>
<BR>The options are used to determine how much debugging information will be visible when you are debugging a particular module.
&nbsp;If you use the &quot;d2&quot; option, you will be able to see your source file and display your local variables.&nbsp;
The &quot;d1&quot; option will display the source but will not give you access to local variable information.
<BR><BR>The Open Watcom Linker (WLINK) is the tool that puts together a complete program and sets up the debugging information
for all the modules in the executable file.&nbsp; There is a linker directive that indicates to the linker when it should
include debugging information from the modules.&nbsp; There are five levels of debugging information that can be collected
during the link.&nbsp; These are:
<OL>
<LI>global names (DEBUG)
<LI>global names, line numbers (DEBUG LINE)
<LI>global names, types (DEBUG TYPES)
<LI>global names, local variables (DEBUG LOCALS)
<LI>all of the above (DEBUG ALL)
</OL>
<BR>Notice that global names will always be included in any request for debugging information.&nbsp; The debugging options
can be combined
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; DEBUG LINE, TYPES</TT>
<BR><BR>with the above directive resulting in full line number and typing information being available during debugging.&nbsp;
The directives are position dependent so you must precede any object files and libraries with the debugging directive.&nbsp;
For instance, if the file<TT> mylink.lnk</TT> contained:
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; #</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; # invoke with: wlink @mylink</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; #</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; file main</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; debug line</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; file input, output</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; debug all</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; file process</TT>
<BR><BR>then the modules<TT> input</TT> and<TT> output</TT> will have global names and source line information available during
debugging.&nbsp; All debugging information in the module<TT> process</TT> will be available during debugging.
<BR><BR><B><I>Hint:</I></B>&nbsp; A subtle point to debugging information is that all the modules will have global names available
if any debugging directive is used.&nbsp; In the above example, the module<TT> main</TT> will have global name information
even though it does not have a DEBUG directive preceding it.
<BR><BR>It is preferable to have one DEBUG directive before any FILE and LIBRARY directives.&nbsp; You might wonder if this
increases the size of the executable file so that it will occupy too much memory during debugging.&nbsp; The debugging information
is loaded &quot;on demand&quot; by the debugger during the debugging session.&nbsp; A small amount of memory (40k default,
selectable with the Open Watcom Debugger &quot;dynamic&quot; command line option) is used to hold the most recently used module
debugging information.&nbsp; In practice, this approach saves a lot of memory because most debugging information is never
used.&nbsp; The overhead of accessing the disk for debugging information is negligible compared to accessing the source file
information.&nbsp; In other words, you can have as much debugging information as you want included in the executable file
without sacrificing memory required by the program.&nbsp; See the section entitled &quot;The DEBUG Directive&quot; in the<B><I>
Open Watcom Linker User's Guide</I></B> for more details.
<BR><BR>If the previous steps have been followed, you should be well on your way to debugging your programs with source line
information.&nbsp; There are instances where the Open Watcom Debugger cannot find the appropriate source file even though
it knows all the line numbers.&nbsp; The problem that has surfaced involves how the source file is associated with the debugging
information of the module.&nbsp; The original location of the source file is included in the debugging information for a module.
&nbsp;The name that is included in the debugging information is the original name that was on the Open Watcom C/C++ command
line.&nbsp; If the original filename is no longer valid (i.e., you have moved the executable to another directory), the Open
Watcom Debugger must be told where to find the source files.&nbsp; The Open Watcom Debugger &quot;Source Path&quot; menu item
(under &quot;File&quot;) can be used to supply new directories to search for source files.&nbsp; If your source files are
located in two directories, the following paths can be added in the Open Watcom Debugger:
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; c:\program\c\*.c</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; c:\program\new\c\*.c</TT>
<BR><BR>The &quot;*&quot; character indicates where the module name will be inserted while the Open Watcom Debugger is searching
for the source file.&nbsp; See the description of the &quot;Source Path&quot; menu item in the<B><I> Open Watcom Debugger
User's Guide</I></B> for more details.
<H2 ID="The_difference_between_the__d1__and__d2__compiler_options"> The difference between the &quot;d1&quot; and &quot;d2&quot; compiler options </H2>
<BR>The reason that there are two levels of debugging information available is that the code optimizer can perform many more
optimizations and still maintain &quot;d1&quot; (line) information.&nbsp; The &quot;d2&quot; option forces the code optimizer
to ensure that any local variable can be displayed at any time in the function.&nbsp; To illustrate why this results in less
optimum code being generated for a function, let us look at a simple array initialization.&nbsp; 
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; extern int a[100];</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; void init_a( void )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int i;</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for( i = 0; i &lt; 100; ++i ) {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; a[i] = 3*i;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; }</TT>
<BR><BR>The code optimizer will ensure that you can print the value of the variable &quot;i&quot; at any time during the execution
of the loop.&nbsp; The &quot;d2&quot; option will always generate code and debugging information so that you can print the
value of any variable during the execution of the function.&nbsp; In order to get the best code possible and still see your
source file while debugging, the &quot;d1&quot; option only generates line number information into the object file.&nbsp;
With line number information, much better code can be generated.&nbsp; Here is the C equivalent of the code generated for
the array initialization example.
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; extern int a[100];</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; void init_a( void )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int *t1;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int t2;</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* for( i = 0; i &lt; 100; ++i ) { */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; t1 = a;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; t2 = 0;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; do {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* a[i] = 3*i; */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; *t1 = t2;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ++t1;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; t2 += 3;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* } */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; } while( t1 != a + 100 );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; }</TT>
<BR><BR>The above code executes very quickly but notice that the variable &quot;i&quot; has been split into two different
variables.&nbsp; One of the variables handles the use of &quot;i&quot; as an array index and the other handles the calculation
of &quot;3*i&quot;.&nbsp; The debugging of programs that have undergone extensive optimization can be difficult, but with
the source line information it is much easier.&nbsp; To summarize, use the &quot;d2&quot; compiler option if you are developing
a module and you would like to be able to display each local variable.&nbsp; The &quot;d1&quot; compiler option will give
you line number information and the best generated code possible.&nbsp; There is absolutely no reason not to specify the &quot;d1&quot;
option because the code quality will be identical to code generated without the &quot;d1&quot; option.
</BODY>
