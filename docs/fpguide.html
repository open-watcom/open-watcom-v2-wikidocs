<HEAD>
<TITLE> Open Watcom 2.0 FORTRAN 77 Programmer's Guide </TITLE>
</HEAD>
<BODY>
<H1 ID="Index_of_Topics"> Index of Topics </H1>
<DL>
<DT>- 1 -
<DD><A HREF="#16Mbit_OSD2__Building_and_Running_the_Sample_OSD2_1_x_Application">16-bit OS/2:&nbsp; Building and Running the Sample OS/2 1.x Application</A>
<BR><A HREF="#16Mbit_OSD2__Creating_16Mbit_OSD2_1_x_Applications">16-bit OS/2:&nbsp; Creating 16-bit OS/2 1.x Applications</A>
<BR><A HREF="#16Mbit_OSD2__Debugging_the_Sample_OSD2_1_x_Application">16-bit OS/2:&nbsp; Debugging the Sample OS/2 1.x Application</A>
<BR><A HREF="#16Mbit_OSD2__The_Sample_Application">16-bit OS/2:&nbsp; The Sample Application</A>
<BR><A HREF="#16Mbit_Windows__Building_and_Running_the_GUI_Application">16-bit Windows:&nbsp; Building and Running the GUI Application</A>
<BR><A HREF="#16Mbit_Windows__Building_and_Running_the_NonMGUI_Application">16-bit Windows:&nbsp; Building and Running the Non-GUI Application</A>
<BR><A HREF="#16Mbit_Windows__Console_Device_in_a_Windowed_Environment">16-bit Windows:&nbsp; Console Device in a Windowed Environment</A>
<BR><A HREF="#16Mbit_Windows__Creating_16Mbit_Windows_3_x_Applications">16-bit Windows:&nbsp; Creating 16-bit Windows 3.x Applications</A>
<BR><A HREF="#16Mbit_Windows__Debugging_the_GUI_Application">16-bit Windows:&nbsp; Debugging the GUI Application</A>
<BR><A HREF="#16Mbit_Windows__Debugging_the_NonMGUI_Application">16-bit Windows:&nbsp; Debugging the Non-GUI Application</A>
<BR><A HREF="#16Mbit_Windows__Default_Windowing_Library_Functions">16-bit Windows:&nbsp; Default Windowing Library Functions</A>
<BR><A HREF="#16Mbit_Windows__Porting_NonMGUI_Applications_to_16Mbit_Windows_3_x">16-bit Windows:&nbsp; Porting Non-GUI Applications to 16-bit Windows 3.x</A>
<BR><A HREF="#16Mbit_Windows__The_Sample_GUI_Application">16-bit Windows:&nbsp; The Sample GUI Application</A>
<BR><A HREF="#16Mbit_Windows__The_Sample_NonMGUI_Application">16-bit Windows:&nbsp; The Sample Non-GUI Application</A>
<DT>- 3 -
<DD><A HREF="#32Mbit_Extended_DOS_Application_Development">32-bit Extended DOS Application Development</A>
<BR><A HREF="#32Mbit_OSD2__Building_and_Running_the_Sample_OSD2_Application">32-bit OS/2:&nbsp; Building and Running the Sample OS/2 Application</A>
<BR><A HREF="#32Mbit_OSD2__Creating_32Mbit_OSD2_Applications">32-bit OS/2:&nbsp; Creating 32-bit OS/2 Applications</A>
<BR><A HREF="#32Mbit_OSD2__Debugging_the_Sample_OSD2_Application">32-bit OS/2:&nbsp; Debugging the Sample OS/2 Application</A>
<BR><A HREF="#32Mbit_OSD2__The_Sample_Application">32-bit OS/2:&nbsp; The Sample Application</A>
<BR><A HREF="#32Mbit_Windows__Building_and_Running_the_GUI_Application">32-bit Windows:&nbsp; Building and Running the GUI Application</A>
<BR><A HREF="#32Mbit_Windows__Building_and_Running_the_NonMGUI_Application">32-bit Windows:&nbsp; Building and Running the Non-GUI Application</A>
<BR><A HREF="#32Mbit_Windows__Console_Device_in_a_Windowed_Environment">32-bit Windows:&nbsp; Console Device in a Windowed Environment</A>
<BR><A HREF="#32Mbit_Windows__Creating_32Mbit_Windows_3_x_Applications">32-bit Windows:&nbsp; Creating 32-bit Windows 3.x Applications</A>
<BR><A HREF="#32Mbit_Windows__Debugging_the_GUI_Application">32-bit Windows:&nbsp; Debugging the GUI Application</A>
<BR><A HREF="#32Mbit_Windows__Debugging_the_NonMGUI_Application">32-bit Windows:&nbsp; Debugging the Non-GUI Application</A>
<BR><A HREF="#32Mbit_Windows__Default_Windowing_Library_Functions">32-bit Windows:&nbsp; Default Windowing Library Functions</A>
<BR><A HREF="#32Mbit_Windows__Porting_NonMGUI_Applications_to_32Mbit_Windows_3_x">32-bit Windows:&nbsp; Porting Non-GUI Applications to 32-bit Windows 3.x</A>
<BR><A HREF="#32Mbit_Windows__The_Sample_GUI_Application">32-bit Windows:&nbsp; The Sample GUI Application</A>
<BR><A HREF="#32Mbit_Windows__The_Sample_NonMGUI_Application">32-bit Windows:&nbsp; The Sample Non-GUI Application</A>
<DT>- A -
<DD><A HREF="#Argument_Passing_Convention">Argument Passing Convention</A>
<DT>- C -
<DD><A HREF="#Commonly_Asked_Questions_and_Answers">Commonly Asked Questions and Answers</A>
<BR><A HREF="#The_compiler_cannot_find_my_include_files">The compiler cannot find my include files</A>
<BR><A HREF="#Converting_to_Open_Watcom_F77">Converting to Open Watcom F77</A>
<BR><A HREF="#Creating_NetWare_386_NLM_Applications">Creating NetWare 386 NLM Applications</A>
<DT>- D -
<DD><A HREF="#Determining_my_current_patch_level">Determining my current patch level</A>
<BR><A HREF="#The_difference_between_the__d1__and__d2__compiler_options">The difference between the &quot;d1&quot; and &quot;d2&quot; compiler options</A>
<BR><A HREF="#The_difference_between_the__debug__and__d2__compiler_options">The difference between the &quot;debug&quot; and &quot;d2&quot; compiler options</A>
<BR><A HREF="#DOSD4GW__32MBit_Gates">DOS/4GW:&nbsp; 32-Bit Gates</A>
<BR><A HREF="#DOSD4GW__Access_to_Technical_Support">DOS/4GW:&nbsp; Access to Technical Support</A>
<BR><A HREF="#DOSD4GW__Addressing">DOS/4GW:&nbsp; Addressing</A>
<BR><A HREF="#DOSD4GW__Building_and_Running_the_Sample_DOSD4GW_Application">DOS/4GW:&nbsp; Building and Running the Sample DOS/4GW Application</A>
<BR><A HREF="#DOSD4GW__Chaining_16Mbit_and_32Mbit_Handlers">DOS/4GW:&nbsp; Chaining 16-bit and 32-bit Handlers</A>
<BR><A HREF="#DOSD4GW__Changing_the_Defaults">DOS/4GW:&nbsp; Changing the Defaults</A>
<BR><A HREF="#DOSD4GW__Changing_the_Switch_Mode_Setting">DOS/4GW:&nbsp; Changing the Switch Mode Setting</A>
<BR><A HREF="#DOSD4GW__Compatibility">DOS/4GW:&nbsp; Compatibility</A>
<BR><A HREF="#DOSD4GW__Configuring_DOSD4GW">DOS/4GW:&nbsp; Configuring DOS/4GW</A>
<BR><A HREF="#DOSD4GW__Controlling_Address_Line_20">DOS/4GW:&nbsp; Controlling Address Line 20</A>
<BR><A HREF="#DOSD4GW__Coprocessor_Status">DOS/4GW:&nbsp; Coprocessor Status</A>
<BR><A HREF="#DOSD4GW__Creating_32Mbit_DOSD4GW_Applications">DOS/4GW:&nbsp; Creating 32-bit DOS/4GW Applications</A>
<BR><A HREF="#DOSD4GW__Debugging">DOS/4GW:&nbsp; Debugging</A>
<BR><A HREF="#DOSD4GW__Debugging_the_Sample_DOSD4GW_Application">DOS/4GW:&nbsp; Debugging the Sample DOS/4GW Application</A>
<BR><A HREF="#DOSD4GW__Demand_Paging_Performance_Tuning_Services">DOS/4GW:&nbsp; Demand Paging Performance Tuning Services</A>
<BR><A HREF="#DOSD4GW__Differences_Within_the_DOSD4G_Product_Line">DOS/4GW:&nbsp; Differences Within the DOS/4G Product Line</A>
<BR><A HREF="#DOSD4GW__DOS_Memory_Management_Services">DOS/4GW:&nbsp; DOS Memory Management Services</A>
<BR><A HREF="#DOSD4GW__DOS__BIOS__and_Mouse_Services">DOS/4GW:&nbsp; DOS, BIOS, and Mouse Services</A>
<BR><A HREF="#DOSD4GW__DOSD4G_Errors">DOS/4GW:&nbsp; DOS/4G Errors</A>
<BR><A HREF="#DOSD4GW__DOSD4GW_Commonly_Asked_Questions">DOS/4GW:&nbsp; DOS/4GW Commonly Asked Questions</A>
<BR><A HREF="#DOSD4GW__DOS4GW">DOS/4GW:&nbsp; DOS4GW</A>
<BR><A HREF="#DOSD4GW__DPMI_Version">DOS/4GW:&nbsp; DPMI Version</A>
<BR><A HREF="#DOSD4GW__Error_Messages">DOS/4GW:&nbsp; Error Messages</A>
<BR><A HREF="#DOSD4GW__Fine_Control_of_Memory_Usage">DOS/4GW:&nbsp; Fine Control of Memory Usage</A>
<BR><A HREF="#DOSD4GW__Functions_25H_and_35H__Interrupt_Handling_in_Protected_Mode">DOS/4GW:&nbsp; Functions 25H and 35H:&nbsp; Interrupt Handling in Protected Mode</A>
<BR><A HREF="#DOSD4GW__Getting_the_Address_of_the_Interrupt_Handler">DOS/4GW:&nbsp; Getting the Address of the Interrupt Handler</A>
<BR><A HREF="#DOSD4GW__Int31H_Function_Calls">DOS/4GW:&nbsp; Int31H Function Calls</A>
<BR><A HREF="#DOSD4GW__Interrupt_21H_Functions">DOS/4GW:&nbsp; Interrupt 21H Functions</A>
<BR><A HREF="#DOSD4GW__Interrupt_31H_DPMI_Functions">DOS/4GW:&nbsp; Interrupt 31H DPMI Functions</A>
<BR><A HREF="#DOSD4GW__Interrupt_and_Exception_Handling">DOS/4GW:&nbsp; Interrupt and Exception Handling</A>
<BR><A HREF="#DOSD4GW__Interrupt_Services">DOS/4GW:&nbsp; Interrupt Services</A>
<BR><A HREF="#DOSD4GW__Kernel_Error_Messages">DOS/4GW:&nbsp; Kernel Error Messages</A>
<BR><A HREF="#DOSD4GW__Linear_Executables">DOS/4GW:&nbsp; Linear Executables</A>
<BR><A HREF="#DOSD4GW__Local_Descriptor_Table_LLDTR_Management_Services">DOS/4GW:&nbsp; Local Descriptor Table (LDT) Management Services</A>
<BR><A HREF="#DOSD4GW__Memory_Management">DOS/4GW:&nbsp; Memory Management</A>
<BR><A HREF="#DOSD4GW__Memory_Management_Services">DOS/4GW:&nbsp; Memory Management Services</A>
<BR><A HREF="#DOSD4GW__Memory_Use">DOS/4GW:&nbsp; Memory Use</A>
<BR><A HREF="#DOSD4GW__Page_Locking_Services">DOS/4GW:&nbsp; Page Locking Services</A>
<BR><A HREF="#DOSD4GW__Physical_Address_Mapping">DOS/4GW:&nbsp; Physical Address Mapping</A>
<BR><A HREF="#DOSD4GW__PMINFO">DOS/4GW:&nbsp; PMINFO</A>
<BR><A HREF="#DOSD4GW__PRIVATXM">DOS/4GW:&nbsp; PRIVATXM</A>
<BR><A HREF="#DOSD4GW__RMINFO">DOS/4GW:&nbsp; RMINFO</A>
<BR><A HREF="#DOSD4GW__Setting_Runtime_Options">DOS/4GW:&nbsp; Setting Runtime Options</A>
<BR><A HREF="#DOSD4GW__Specifying_a_Range_of_Extended_Memory">DOS/4GW:&nbsp; Specifying a Range of Extended Memory</A>
<BR><A HREF="#DOSD4GW__The__VMC_File">DOS/4GW:&nbsp; The .VMC File</A>
<BR><A HREF="#DOSD4GW__The_DOS4G_Environment_Variable">DOS/4GW:&nbsp; The DOS4G Environment Variable</A>
<BR><A HREF="#DOSD4GW__The_Linear_Executable_Format">DOS/4GW:&nbsp; The Linear Executable Format</A>
<BR><A HREF="#DOSD4GW__The_Sample_Application">DOS/4GW:&nbsp; The Sample Application</A>
<BR><A HREF="#DOSD4GW__The_Stub_Program">DOS/4GW:&nbsp; The Stub Program</A>
<BR><A HREF="#DOSD4GW__The_Tenberry_Software_DOSD4GW_DOS_Extender">DOS/4GW:&nbsp; The Tenberry Software DOS/4GW DOS Extender</A>
<BR><A HREF="#DOSD4GW__Translation_Services">DOS/4GW:&nbsp; Translation Services</A>
<BR><A HREF="#DOSD4GW__Using_Extra_Memory">DOS/4GW:&nbsp; Using Extra Memory</A>
<BR><A HREF="#DOSD4GW__Using_Interrupt_31H_Function_Calls">DOS/4GW:&nbsp; Using Interrupt 31H Function Calls</A>
<BR><A HREF="#DOSD4GW__Utilities">DOS/4GW:&nbsp; Utilities</A>
<BR><A HREF="#DOSD4GW__Vendor_Specific_Extensions">DOS/4GW:&nbsp; Vendor Specific Extensions</A>
<BR><A HREF="#DOSD4GW__Virtual_Interrupt_State_Functions">DOS/4GW:&nbsp; Virtual Interrupt State Functions</A>
<BR><A HREF="#DOSD4GW__Virtual_Memory">DOS/4GW:&nbsp; Virtual Memory</A>
<BR><A HREF="#DOSD4GW__VMM">DOS/4GW:&nbsp; VMM</A>
<BR><A HREF="#DOSD4GW__VMM_Default_Parameters">DOS/4GW:&nbsp; VMM Default Parameters</A>
<BR><A HREF="#DOS__Building_and_Running_the_Sample_DOS_Application">DOS:&nbsp; Building and Running the Sample DOS Application</A>
<BR><A HREF="#DOS__Creating_16Mbit_DOS_Applications">DOS:&nbsp; Creating 16-bit DOS Applications</A>
<BR><A HREF="#DOS__Debugging_the_Sample_DOS_Application">DOS:&nbsp; Debugging the Sample DOS Application</A>
<BR><A HREF="#DOS__The_Sample_Application">DOS:&nbsp; The Sample Application</A>
<DT>- H -
<DD><A HREF="#How_can_I_write_directly_to_video_memory_using_a_DOS_extender_">How can I write directly to video memory using a DOS extender?</A>
<BR><A HREF="#How_do_I_access_a_FORTRAN_common_block_from_within_C_">How do I access a FORTRAN common block from within C?</A>
<BR><A HREF="#How_do_I_call_a_C_function_that_accepts_a_variable_number_of_arguments_">How do I call a C function that accepts a variable number of arguments?</A>
<BR><A HREF="#How_do_I_get_information_about_free_memory_in_the_32Mbit_environment_">How do I get information about free memory in the 32-bit environment?</A>
<BR><A HREF="#How_do_I_issue_interrupts_in_a_DOSD4GW_application_">How do I issue interrupts in a DOS/4GW application?</A>
<BR><A HREF="#How_do_I_pass_a_string_from_a_C_function_to_FORTRAN_">How do I pass a string from a C function to FORTRAN?</A>
<BR><A HREF="#How_do_I_pass_a_string_from_FORTRAN_to_a_C_function_">How do I pass a string from FORTRAN to a C function?</A>
<BR><A HREF="#How_do_I_pass_integers_from_C_to_a_FORTRAN_function_">How do I pass integers from C to a FORTRAN function?</A>
<BR><A HREF="#How_do_I_pass_integers_from_FORTRAN_to_a_C_function_">How do I pass integers from FORTRAN to a C function?</A>
<BR><A HREF="#How_more_than_20_files_at_a_time_can_be_opened">How more than 20 files at a time can be opened</A>
<BR><A HREF="#How_source_files_can_be_seen_in_the_debugger">How source files can be seen in the debugger</A>
<DT>- I -
<DD><A HREF="#Integer_Type_Compatibility">Integer Type Compatibility</A>
<BR><A HREF="#InterMLanguage_calls__C_and_FORTRAN">Inter-Language calls:&nbsp; C and FORTRAN</A>
<DT>- L -
<DD><A HREF="#The_linker_reports_a__stack_segment_not_found__error">The linker reports a &quot;stack segment not found&quot; error</A>
<BR><A HREF="#Linking_Considerations">Linking Considerations</A>
<DT>- M -
<DD><A HREF="#Memory_Model_Compatibility">Memory Model Compatibility</A>
<DT>- N -
<DD><A HREF="#NT__A_MultiMthreaded_Example">NT:&nbsp; A Multi-threaded Example</A>
<BR><A HREF="#NT__Building_and_Running_the_CharacterMmode_Application">NT:&nbsp; Building and Running the Character-mode Application</A>
<BR><A HREF="#NT__Creating_a_New_Thread">NT:&nbsp; Creating a New Thread</A>
<BR><A HREF="#NT__Creating_a_Sample_Dynamic_Link_Library">NT:&nbsp; Creating a Sample Dynamic Link Library</A>
<BR><A HREF="#NT__Creating_Dynamic_Link_Libraries">NT:&nbsp; Creating Dynamic Link Libraries</A>
<BR><A HREF="#NT__Creating_Threads">NT:&nbsp; Creating Threads</A>
<BR><A HREF="#NT__Creating_Windows_NT_CharacterMmode_Applications">NT:&nbsp; Creating Windows NT Character-mode Applications</A>
<BR><A HREF="#NT__Debugging_the_CharacterMmode_Application">NT:&nbsp; Debugging the Character-mode Application</A>
<BR><A HREF="#NT__Dynamic_Link_Library_InitializationDTermination">NT:&nbsp; Dynamic Link Library Initialization/Termination</A>
<BR><A HREF="#NT__Getting_the_Current_Thread_Identifier">NT:&nbsp; Getting the Current Thread Identifier</A>
<BR><A HREF="#NT__Programming_Considerations">NT:&nbsp; Programming Considerations</A>
<BR><A HREF="#NT__Terminating_the_Current_Thread">NT:&nbsp; Terminating the Current Thread</A>
<BR><A HREF="#NT__The_Dynamic_Link_Library_Data_Area">NT:&nbsp; The Dynamic Link Library Data Area</A>
<BR><A HREF="#NT__The_Sample_CharacterMmode_Application">NT:&nbsp; The Sample Character-mode Application</A>
<BR><A HREF="#NT__Using_Dynamic_Link_Libraries">NT:&nbsp; Using Dynamic Link Libraries</A>
<BR><A HREF="#NT__Windows_NT_CharacterMmode_Versus_GUI">NT:&nbsp; Windows NT Character-mode Versus GUI</A>
<BR><A HREF="#NT__Windows_NT_Dynamic_Link_Libraries">NT:&nbsp; Windows NT Dynamic Link Libraries</A>
<BR><A HREF="#NT__Windows_NT_MultiMthreaded_Applications">NT:&nbsp; Windows NT Multi-threaded Applications</A>
<BR><A HREF="#NT__Windows_NT_Programming_Overview">NT:&nbsp; Windows NT Programming Overview</A>
<DT>- O -
<DD><A HREF="#Open_Watcom_FORTRAN_77_Application_Development">Open Watcom FORTRAN 77 Application Development</A>
<BR><A HREF="#OSD2__A_MultiMthreaded_Example">OS/2:&nbsp; A Multi-threaded Example</A>
<BR><A HREF="#OSD2__An_Example">OS/2:&nbsp; An Example</A>
<BR><A HREF="#OSD2__Calling_Presentation_Manager_API_Functions">OS/2:&nbsp; Calling Presentation Manager API Functions</A>
<BR><A HREF="#OSD2__Creating_a_New_Thread">OS/2:&nbsp; Creating a New Thread</A>
<BR><A HREF="#OSD2__Creating_a_Sample_Dynamic_Link_Library">OS/2:&nbsp; Creating a Sample Dynamic Link Library</A>
<BR><A HREF="#OSD2__Creating_Dynamic_Link_Libraries">OS/2:&nbsp; Creating Dynamic Link Libraries</A>
<BR><A HREF="#OSD2__Creating_Threads">OS/2:&nbsp; Creating Threads</A>
<BR><A HREF="#OSD2__Dynamic_Link_Library_InitializationDTermination">OS/2:&nbsp; Dynamic Link Library Initialization/Termination</A>
<BR><A HREF="#OSD2__Getting_the_Current_Thread_Identifier">OS/2:&nbsp; Getting the Current Thread Identifier</A>
<BR><A HREF="#OSD2__OSD2_2_x_Dynamic_Link_Libraries">OS/2:&nbsp; OS/2 2.x Dynamic Link Libraries</A>
<BR><A HREF="#OSD2__OSD2_2_x_MultiMthreaded_Applications">OS/2:&nbsp; OS/2 2.x Multi-threaded Applications</A>
<BR><A HREF="#OSD2__Porting_Existing_FORTRAN_77_Applications">OS/2:&nbsp; Porting Existing FORTRAN 77 Applications</A>
<BR><A HREF="#OSD2__Programming_Considerations">OS/2:&nbsp; Programming Considerations</A>
<BR><A HREF="#OSD2__Programming_for_OSD2_Presentation_Manager">OS/2:&nbsp; Programming for OS/2 Presentation Manager</A>
<BR><A HREF="#OSD2__Terminating_the_Current_Thread">OS/2:&nbsp; Terminating the Current Thread</A>
<BR><A HREF="#OSD2__The_Dynamic_Link_Library_Data_Area">OS/2:&nbsp; The Dynamic Link Library Data Area</A>
<BR><A HREF="#OSD2__Thread_Limits">OS/2:&nbsp; Thread Limits</A>
<BR><A HREF="#OSD2__Using_Dynamic_Link_Libraries">OS/2:&nbsp; Using Dynamic Link Libraries</A>
<DT>- P -
<DD><A HREF="#Phar_Lap__Building_and_Running_the_Sample_386_DOSMExtender_Application">Phar Lap:&nbsp; Building and Running the Sample 386|DOS-Extender Application</A>
<BR><A HREF="#Phar_Lap__Creating_32Mbit_Phar_Lap_386_DOSMExtender_Applications">Phar Lap:&nbsp; Creating 32-bit Phar Lap 386|DOS-Extender Applications</A>
<BR><A HREF="#Phar_Lap__Debugging_the_Sample_386_DOSMExtender_Application">Phar Lap:&nbsp; Debugging the Sample 386|DOS-Extender Application</A>
<BR><A HREF="#Phar_Lap__The_Sample_Application">Phar Lap:&nbsp; The Sample Application</A>
<DT>- R -
<DD><A HREF="#Reading_a_stream_of_binary_data_from_a_file">Reading a stream of binary data from a file</A>
<BR><A HREF="#Redefining_math_error_handling_with_Open_Watcom_F77">Redefining math error handling with Open Watcom F77</A>
<BR><A HREF="#Resolving_an__Undefined_Reference__linker_error">Resolving an &quot;Undefined Reference&quot; linker error</A>
<DT>- S -
<DD><A HREF="#Special_Windows_API_Functions">Special Windows API Functions</A>
<BR><A HREF="#Symbol_Naming_Convention">Symbol Naming Convention</A>
<DT>- W -
<DD><A HREF="#What__Stack_Overflow___means">What &quot;Stack Overflow!&quot; means</A>
<BR><A HREF="#What_are_the_probable_causes_of_a_General_Protection_Fault_in_32Mbit_applications_">What are the probable causes of a General Protection Fault in 32-bit applications?</A>
<BR><A HREF="#What_you_should_know_about_optimization">What you should know about optimization</A>
<BR><A HREF="#Which_floatingMpoint_compiler_option_should_I_use_for_my_application_">Which floating-point compiler option should I use for my application?</A>
<BR><A HREF="#Why_local_variable_values_are_not_maintained_between_subprogram_calls">Why local variable values are not maintained between subprogram calls</A>
<BR><A HREF="#Windows__32Mbit_Extended_Windows_Application_Development">Windows:&nbsp; 32-bit Extended Windows Application Development</A>
<BR><A HREF="#Windows___16_Functions">Windows:&nbsp; _16 Functions</A>
<BR><A HREF="#_Call16">Windows:&nbsp; _Call16</A>
<BR><A HREF="#Windows__A_Sample_32Mbit_DLL">Windows:&nbsp; A Sample 32-bit DLL</A>
<BR><A HREF="#Windows__A_Sample_32Mbit_DLL_Using_a_Structure">Windows:&nbsp; A Sample 32-bit DLL Using a Structure</A>
<BR><A HREF="#Windows__A_Working_Example">Windows:&nbsp; A Working Example</A>
<BR><A HREF="#AllocAlias16">Windows:&nbsp; AllocAlias16</A>
<BR><A HREF="#AllocHugeAlias16">Windows:&nbsp; AllocHugeAlias16</A>
<BR><A HREF="#Windows__Building_the_Applications">Windows:&nbsp; Building the Applications</A>
<BR><A HREF="#Windows__Callback_Function_Pointers">Windows:&nbsp; Callback Function Pointers</A>
<BR><A HREF="#Windows__Calling_16Mbit_DLLs">Windows:&nbsp; Calling 16-bit DLLs</A>
<BR><A HREF="#Windows__Calling_Functions_in_a_32Mbit_DLL_from_a_16Mbit_Application">Windows:&nbsp; Calling Functions in a 32-bit DLL from a 16-bit Application</A>
<BR><A HREF="#Windows__Calling_Functions_in_a_32Mbit_DLL_from_a_32Mbit_Application">Windows:&nbsp; Calling Functions in a 32-bit DLL from a 32-bit Application</A>
<BR><A HREF="#Windows__Can_you_call_16Mbit_code_from_a_32Mbit_code_">Windows:&nbsp; Can you call 16-bit code from a 32-bit code?</A>
<BR><A HREF="#Windows__Compiling_and_Linking_the_Examples">Windows:&nbsp; Compiling and Linking the Examples</A>
<BR><A HREF="#Windows__Creating_and_Debugging_Dynamic_Link_Libraries">Windows:&nbsp; Creating and Debugging Dynamic Link Libraries</A>
<BR><A HREF="#Windows__Debugging_a_32Mbit_DLL">Windows:&nbsp; Debugging a 32-bit DLL</A>
<BR><A HREF="#DefineDLLEntry">Windows:&nbsp; DefineDLLEntry</A>
<BR><A HREF="#DefineUserProc16">Windows:&nbsp; DefineUserProc16</A>
<BR><A HREF="#Windows__Environment_Notes">Windows:&nbsp; Environment Notes</A>
<BR><A HREF="#Windows__FloatingMpoint_Emulation">Windows:&nbsp; Floating-point Emulation</A>
<BR><A HREF="#FreeAlias16">Windows:&nbsp; FreeAlias16</A>
<BR><A HREF="#FreeHugeAlias16">Windows:&nbsp; FreeHugeAlias16</A>
<BR><A HREF="#FreeIndirectFunctionHandle">Windows:&nbsp; FreeIndirectFunctionHandle</A>
<BR><A HREF="#GetIndirectFunctionHandle">Windows:&nbsp; GetIndirectFunctionHandle</A>
<BR><A HREF="#GetProc16">Windows:&nbsp; GetProc16</A>
<BR><A HREF="#Windows__GlobalAlloc_and_LocalAlloc">Windows:&nbsp; GlobalAlloc and LocalAlloc</A>
<BR><A HREF="#Windows__How_do_I_add_my_Windows_resources_">Windows:&nbsp; How do I add my Windows resources?</A>
<BR><A HREF="#Windows__Implementation_Overview">Windows:&nbsp; Implementation Overview</A>
<BR><A HREF="#Windows__Installing_the_Examples_under_Windows">Windows:&nbsp; Installing the Examples under Windows</A>
<BR><A HREF="#Windows__Interfacing_Visual_Basic_and_Open_Watcom_FORTRAN_77_DLLs">Windows:&nbsp; Interfacing Visual Basic and Open Watcom FORTRAN 77 DLLs</A>
<BR><A HREF="#InvokeIndirectFunction">Windows:&nbsp; InvokeIndirectFunction</A>
<BR><A HREF="#MapAliasToFlat">Windows:&nbsp; MapAliasToFlat</A>
<BR><A HREF="#Windows__Multiple_Instances">Windows:&nbsp; Multiple Instances</A>
<BR><A HREF="#PASS_WORD_AS_POINTER">Windows:&nbsp; PASS_WORD_AS_POINTER</A>
<BR><A HREF="#Windows__Pointer_Handling">Windows:&nbsp; Pointer Handling</A>
<BR><A HREF="#Windows__Pointers">Windows:&nbsp; Pointers</A>
<BR><A HREF="#ReleaseProc16">Windows:&nbsp; ReleaseProc16</A>
<BR><A HREF="#Windows__Running_the_Examples">Windows:&nbsp; Running the Examples</A>
<BR><A HREF="#Windows__Sample_Visual_Basic_DLL_Programs">Windows:&nbsp; Sample Visual Basic DLL Programs</A>
<BR><A HREF="#Windows__SendMessage_and_SendDlgItemMessage">Windows:&nbsp; SendMessage and SendDlgItemMessage</A>
<BR><A HREF="#Windows__Source_code_for_COVER16_DLL">Windows:&nbsp; Source code for COVER16.DLL</A>
<BR><A HREF="#Windows__Source_Code_for_VBDLL32_DLL">Windows:&nbsp; Source Code for VBDLL32.DLL</A>
<BR><A HREF="#Windows__Steps_to_Obtaining_a_32Mbit_Application">Windows:&nbsp; Steps to Obtaining a 32-bit Application</A>
<BR><A HREF="#Windows__Summary">Windows:&nbsp; Summary</A>
<BR><A HREF="#Windows__System_Overview">Windows:&nbsp; System Overview</A>
<BR><A HREF="#Windows__System_Structure">Windows:&nbsp; System Structure</A>
<BR><A HREF="#Windows__The_Open_Watcom_32Mbit_Windows_3_x_Extender">Windows:&nbsp; The Open Watcom 32-bit Windows 3.x Extender</A>
<BR><A HREF="#Windows__What_size_of_function_pointers_passed_to_Windows_">Windows:&nbsp; What size of function pointers passed to Windows?</A>
<BR><A HREF="#Windows__When_To_Convert_Incoming_Pointers">Windows:&nbsp; When To Convert Incoming Pointers</A>
<BR><A HREF="#Windows__When_To_Convert_Outgoing_Pointers">Windows:&nbsp; When To Convert Outgoing Pointers</A>
<BR><A HREF="#Windows__Why_are_32Mbit_callback_routines_FAR_">Windows:&nbsp; Why are 32-bit callback routines FAR?</A>
<BR><A HREF="#Windows__Why_use_the__16_API_functions_">Windows:&nbsp; Why use the _16 API functions?</A>
<BR><A HREF="#Windows__WIN386_Library_Subprograms">Windows:&nbsp; WIN386 Library Subprograms</A>
<BR><A HREF="#Windows__WINAPI_FI">Windows:&nbsp; WINAPI.FI</A>
<BR><A HREF="#Windows__Window_SubMclassing">Windows:&nbsp; Window Sub-classing</A>
<BR><A HREF="#Windows__Windows_3_x_32Mbit_Programming_Overview">Windows:&nbsp; Windows 3.x 32-bit Programming Overview</A>
<BR><A HREF="#Windows__Windows_32MBit_Dynamic_Link_Libraries">Windows:&nbsp; Windows 32-Bit Dynamic Link Libraries</A>
</DL>
<H1 ID="Open_Watcom_FORTRAN_77_Application_Development"> Open Watcom FORTRAN 77 Application Development </H1>
<BR><IMG SRC="fpguide.bmp">
<BR>This document contains guides to application development for several environments including 16-bit DOS, 32-bit extended
DOS, Windows 3.x, 32-bit extended Windows 3.x, Windows NT/2000/XP, Win9x, OS/2, and Novell NLMs.&nbsp; It also describes mixed
language (C, FORTRAN) application development.&nbsp; It concludes with a chapter on some general questions and the answers
to them.
<BR><BR>This document covers the following topics:
<UL>
<LI>DOS Programming Guide
<DL>
<DT>Creating 16-bit DOS Applications
<DD>
<DT>Creating 32-bit Phar Lap 386|DOS-Extender Applications
<DD>
<DT>Creating 32-bit DOS/4GW Applications
<DD>
<DT>32-bit Extended DOS Application Development
<DD>
</DL>
<LI>The DOS/4GW DOS Extender
<DL>
<DT>The Tenberry Software DOS/4GW DOS Extender
<DD>
<DT>Linear Executables
<DD>
<DT>Configuring DOS/4GW
<DD>
<DT>VMM
<DD>
<DT>Interrupt 21H Functions
<DD>
<DT>Interrupt 31H DPMI Functions
<DD>
<DT>Utilities
<DD>
<DT>Error Messages
<DD>
<DT>DOS/4GW Commonly Asked Questions
<DD>
</DL>
<LI>Windows 3.x Programming Guide
<DL>
<DT>Creating 16-bit Windows 3.x Applications
<DD>
<DT>Porting Non-GUI Applications to 16-bit Windows 3.x
<DD>
<DT>Creating 32-bit Windows 3.x Applications
<DD>
<DT>Porting Non-GUI Applications to 32-bit Windows 3.x
<DD>
<DT>The Open Watcom 32-bit Windows Extender
<DD>
<DT>Windows 3.x 32-bit Programming Overview
<DD>
<DT>Windows 32-Bit Dynamic Link Libraries
<DD>
<DT>Interfacing Visual Basic and Open Watcom FORTRAN 77 DLLs
<DD>
<DT>WIN386 Library Subprograms
<DD>
<DT>32-bit Extended Windows Application Development
<DD>
<DT>Special Windows API Functions
<DD>
</DL>
<LI>Windows NT Programming Guide
<DL>
<DT>Windows NT Programming Overview
<DD>
<DT>Creating Windows NT GUI Applications
<DD>
<DT>Porting Non-GUI Applications to Windows NT GUI
<DD>
<DT>Windows NT Multi-threaded Applications
<DD>
<DT>Windows NT Dynamic Link Libraries
<DD>
</DL>
<LI>OS/2 Programming Guide
<DL>
<DT>Creating 16-bit OS/2 1.x Applications
<DD>
<DT>Creating 32-bit OS/2 Applications
<DD>
<DT>OS/2 Multi-threaded Applications
<DD>
<DT>OS/2 Dynamic Link Libraries
<DD>
<DT>Programming for OS/2 Presentation Manager
<DD>
</DL>
<LI>Novell NLM Programming Guide
<DL>
<DT>Creating NetWare 386 NLM Applications
<DD>
</DL>
<LI>Mixed Language Programming
<DL>
<DT>Inter-Language calls:&nbsp; C and FORTRAN
<DD>
</DL>
<LI>Common Problems
<DL>
<DT>Commonly Asked Questions and Answers
<DD>
</DL>
</UL>
<H1 ID="DOS__Creating_16Mbit_DOS_Applications"> DOS:&nbsp; Creating 16-bit DOS Applications </H1>
<BR>This chapter describes how to compile and link 16-bit DOS applications simply and quickly.
<BR><BR>We will illustrate the steps to creating 16-bit DOS applications by taking a small sample application and showing
you how to compile, link, run and debug it.
<H2 ID="DOS__The_Sample_Application"> DOS:&nbsp; The Sample Application </H2>
<BR>To demonstrate the creation of 16-bit DOS applications using command-line oriented tools, we introduce a simple sample
program.&nbsp; For our example, we are going to use the &quot;sieve&quot; program.
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; * This program computes the prime numbers between 1 and 10,000</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; * using the Sieve of Eratosthenes algorithm.</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; IMPLICIT NONE</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; INTEGER UPBOUND</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; PARAMETER (UPBOUND=10000)</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; INTEGER I, K, PRIMES</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; LOGICAL*1 NUMBERS(2:UPBOUND)</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CHARACTER*11 FORM</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; PARAMETER (FORM='(A,I5,A,I5)')</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DO I = 2, UPBOUND</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; NUMBERS(I) = .TRUE.</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ENDDO</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; PRIMES = 0</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DO I = 2, UPBOUND</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; IF( NUMBERS(I) )THEN</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; PRIMES
= PRIMES + 1</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DO K
= I + I, UPBOUND, I</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp; NUMBERS(K) = .FALSE.</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ENDDO</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ENDIF</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ENDDO</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; PRINT FORM, 'The Number of Primes between 1 and ', UPBOUND,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;' are: ', PRIMES</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; END</TT>
<BR><BR>The goal of this program is to count the prime numbers between 1 and 10,000.&nbsp; It uses the famous<B> Sieve of
Eratosthenes</B> algorithm to accomplish this task.&nbsp; We will take you through the steps necessary to produce this result.
<H2 ID="DOS__Building_and_Running_the_Sample_DOS_Application"> DOS:&nbsp; Building and Running the Sample DOS Application </H2>
<BR>To compile and link our example program which is stored in the file<TT> sieve.for</TT>, enter the following command:
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; C&gt;wfl -l=dos sieve.for</TT>
<BR><BR>The typical messages that appear on the screen are shown in the following illustration.
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; C&gt;wfl -l=dos&nbsp; sieve.for</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Open Watcom F77/16 Compile and Link Utility</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Copyright (c) 2002-2019 the Open Watcom Contributors. All Rights Reserved.</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Portions Copyright (c) 1990-2002 Sybase, Inc. All Rights Reserved.</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Source code is available under the Sybase Open Watcom Public License.</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; See http://www.openwatcom.org/ for details.</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; wfc sieve.for </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Open Watcom FORTRAN 77/16 Optimizing Compiler</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Copyright (c) 2002-2019 the Open Watcom Contributors. All Rights Reserved.</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Portions Copyright (c) 1984-2002 Sybase, Inc. All Rights Reserved.</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Source code is available under the Sybase Open Watcom Public License.</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; See http://www.openwatcom.org/ for details.</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; sieve.for: 21 statements, 311 bytes, 6 extensions, 0 warnings, 0 errors</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Open Watcom Linker</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Copyright (c) 2002-2019 the Open Watcom Contributors. All Rights Reserved.</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Portions Copyright (c) 1985-2002 Sybase, Inc. All Rights Reserved.</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Source code is available under the Sybase Open Watcom Public License.</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; See http://www.openwatcom.org/ for details.</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; loading object files</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; searching libraries</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; creating a DOS executable</TT>
<BR><BR>Provided that no errors were encountered during the compile or link phases, the &quot;sieve&quot; program may now
be run.
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; C&gt;sieve</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; The Number of Primes between 1 and 10000 are:&nbsp; 1229</TT>
<BR><BR>If you examine the current directory, you will find that two files have been created.&nbsp; These are<TT> sieve.obj</TT>
(the result of compiling<TT> sieve.for</TT>) and<TT> sieve.exe</TT> (the result of linking<TT> sieve.obj</TT> with the appropriate
Open Watcom FORTRAN 77 libraries).&nbsp; It is<TT> sieve.exe</TT> that is run by DOS when you enter the &quot;sieve&quot;
command.
<H2 ID="DOS__Debugging_the_Sample_DOS_Application"> DOS:&nbsp; Debugging the Sample DOS Application </H2>
<BR>Let us assume that you wish to debug your application in order to locate an error in programming.&nbsp; In the previous
section, the &quot;sieve&quot; program was compiled with default compile and link options.&nbsp; When debugging an application,
it is useful to refer to the symbolic names of routines and variables.&nbsp; It is also convenient to debug at the source
line level rather than the machine language level.&nbsp; To do this, we must direct both the compiler and linker to include
additional debugging information in the object and executable files.&nbsp; Using the<B><I> WFL</I></B> command, this is fairly
straightforward.<B><I>&nbsp; WFL</I></B> recognizes the Open Watcom F77 compiler &quot;debug&quot; options and will create
the appropriate debug directives for the Open Watcom Linker.
<BR><BR>For example, to compile and link the &quot;sieve&quot; program with debugging information, the following command may
be issued.
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; C&gt;wfl -l=dos -d2 sieve.for</TT>
<BR><BR>The typical messages that appear on the screen are shown in the following illustration.
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; C&gt;wfl -l=dos&nbsp; -d2 sieve.for</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Open Watcom F77/16 Compile and Link Utility</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Copyright (c) 2002-2019 the Open Watcom Contributors. All Rights Reserved.</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Portions Copyright (c) 1990-2002 Sybase, Inc. All Rights Reserved.</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Source code is available under the Sybase Open Watcom Public License.</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; See http://www.openwatcom.org/ for details.</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; wfc sieve.for&nbsp; -d2</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Open Watcom FORTRAN 77/16 Optimizing Compiler</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Copyright (c) 2002-2019 the Open Watcom Contributors. All Rights Reserved.</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Portions Copyright (c) 1984-2002 Sybase, Inc. All Rights Reserved.</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Source code is available under the Sybase Open Watcom Public License.</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; See http://www.openwatcom.org/ for details.</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; sieve.for: 21 statements, 392 bytes, 6 extensions, 0 warnings, 0 errors</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Open Watcom Linker</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Copyright (c) 2002-2019 the Open Watcom Contributors. All Rights Reserved.</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Portions Copyright (c) 1985-2002 Sybase, Inc. All Rights Reserved.</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Source code is available under the Sybase Open Watcom Public License.</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; See http://www.openwatcom.org/ for details.</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; loading object files</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; searching libraries</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; creating a DOS executable</TT>
<BR><BR>The &quot;d2&quot; option requests the maximum amount of debugging information that can be provided by the Open Watcom
F77 compiler.<B><I>&nbsp; WFL</I></B> will make sure that this debugging information is included in the executable file that
is produced by the linker.
<BR><BR>The &quot;bytes&quot; value is larger than in the previous example since selection of the &quot;d2&quot; option results
in fewer code optimizations by default.&nbsp; You can request more optimization by specifying the appropriate options.&nbsp;
However, you do so at the risk of making it more difficult for yourself to determine the relationship between the object code
and the original source language code.
<BR><BR>To request the Open Watcom Debugger to assist in debugging the application, the following command may be issued.
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; C&gt;wd sieve</TT>
<BR><BR>It would be too ambitious to describe the debugger in this introductory chapter so we refer you to the book entitled<B><I>
Open Watcom Debugger User's Guide.</I></B>
<H1 ID="Phar_Lap__Creating_32Mbit_Phar_Lap_386_DOSMExtender_Applications"> Phar Lap:&nbsp; Creating 32-bit Phar Lap 386|DOS-Extender Applications </H1>
<BR>This chapter describes how to compile and link 32-bit Phar Lap 386|DOS-Extender applications simply and quickly.
<BR><BR>We will illustrate the steps to creating 32-bit Phar Lap 386|DOS-Extender applications by taking a small sample application
and showing you how to compile, link, run and debug it.
<H2 ID="Phar_Lap__The_Sample_Application"> Phar Lap:&nbsp; The Sample Application </H2>
<BR>To demonstrate the creation of 32-bit Phar Lap 386|DOS-Extender applications using command-line oriented tools, we introduce
a simple sample program.&nbsp; For our example, we are going to use the &quot;sieve&quot; program.
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; * This program computes the prime numbers between 1 and 10,000</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; * using the Sieve of Eratosthenes algorithm.</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; IMPLICIT NONE</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; INTEGER UPBOUND</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; PARAMETER (UPBOUND=10000)</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; INTEGER I, K, PRIMES</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; LOGICAL*1 NUMBERS(2:UPBOUND)</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CHARACTER*11 FORM</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; PARAMETER (FORM='(A,I5,A,I5)')</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DO I = 2, UPBOUND</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; NUMBERS(I) = .TRUE.</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ENDDO</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; PRIMES = 0</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DO I = 2, UPBOUND</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; IF( NUMBERS(I) )THEN</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; PRIMES
= PRIMES + 1</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DO K
= I + I, UPBOUND, I</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp; NUMBERS(K) = .FALSE.</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ENDDO</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ENDIF</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ENDDO</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; PRINT FORM, 'The Number of Primes between 1 and ', UPBOUND,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;' are: ', PRIMES</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; END</TT>
<BR><BR>The goal of this program is to count the prime numbers between 1 and 10,000.&nbsp; It uses the famous<B> Sieve of
Eratosthenes</B> algorithm to accomplish this task.&nbsp; We will take you through the steps necessary to produce this result.
<H2 ID="Phar_Lap__Building_and_Running_the_Sample_386_DOSMExtender_Application"> Phar Lap:&nbsp; Building and Running the Sample 386|DOS-Extender Application </H2>
<BR>To compile and link our example program which is stored in the file<TT> sieve.for</TT>, enter the following command:
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; C&gt;wfl386 -l=pharlap sieve.for</TT>
<BR><BR>The typical messages that appear on the screen are shown in the following illustration.
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; C&gt;wfl386 -l=pharlap sieve.for</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Open Watcom F77/32 Compile and Link Utility</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Copyright (c) 2002-2019 the Open Watcom Contributors. All Rights Reserved.</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Portions Copyright (c) 1990-2002 Sybase, Inc. All Rights Reserved.</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Source code is available under the Sybase Open Watcom Public License.</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; See http://www.openwatcom.org/ for details.</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; wfc386 sieve.for </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Open Watcom FORTRAN 77/32 Optimizing Compiler</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Copyright (c) 2002-2019 the Open Watcom Contributors. All Rights Reserved.</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Portions Copyright (c) 1984-2002 Sybase, Inc. All Rights Reserved.</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Source code is available under the Sybase Open Watcom Public License.</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; See http://www.openwatcom.org/ for details.</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; sieve.for: 21 statements, 172 bytes, 6 extensions, 0 warnings, 0 errors</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Open Watcom Linker</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Copyright (c) 2002-2019 the Open Watcom Contributors. All Rights Reserved.</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Portions Copyright (c) 1985-2002 Sybase, Inc. All Rights Reserved.</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Source code is available under the Sybase Open Watcom Public License.</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; See http://www.openwatcom.org/ for details.</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; loading object files</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; searching libraries</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; creating a Phar Lap simple executable</TT>
<BR><BR>Provided that no errors were encountered during the compile or link phases, the &quot;sieve&quot; program may now
be run.
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; C&gt;run386 sieve</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; The Number of Primes between 1 and 10000 are:&nbsp; 1229</TT>
<BR><BR>If you examine the current directory, you will find that two files have been created.&nbsp; These are<TT> sieve.obj</TT>
(the result of compiling<TT> sieve.for</TT>) and<TT> sieve.exp</TT> (the result of linking<TT> sieve.obj</TT> with the appropriate
Open Watcom FORTRAN 77 libraries).&nbsp; It is<TT> sieve.exp</TT> that is run by DOS when you enter the &quot;run386 sieve&quot;
command.
<H2 ID="Phar_Lap__Debugging_the_Sample_386_DOSMExtender_Application"> Phar Lap:&nbsp; Debugging the Sample 386|DOS-Extender Application </H2>
<BR>Let us assume that you wish to debug your application in order to locate an error in programming.&nbsp; In the previous
section, the &quot;sieve&quot; program was compiled with default compile and link options.&nbsp; When debugging an application,
it is useful to refer to the symbolic names of routines and variables.&nbsp; It is also convenient to debug at the source
line level rather than the machine language level.&nbsp; To do this, we must direct both the compiler and linker to include
additional debugging information in the object and executable files.&nbsp; Using the<B><I> WFL386</I></B> command, this is
fairly straightforward.<B><I>&nbsp; WFL386</I></B> recognizes the Open Watcom F77 compiler &quot;debug&quot; options and will
create the appropriate debug directives for the Open Watcom Linker.
<BR><BR>For example, to compile and link the &quot;sieve&quot; program with debugging information, the following command may
be issued.
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; C&gt;wfl386 -l=pharlap -d2 sieve.for</TT>
<BR><BR>The typical messages that appear on the screen are shown in the following illustration.
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; C&gt;wfl386 -l=pharlap -d2 sieve.for</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Open Watcom F77/32 Compile and Link Utility</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Copyright (c) 2002-2019 the Open Watcom Contributors. All Rights Reserved.</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Portions Copyright (c) 1990-2002 Sybase, Inc. All Rights Reserved.</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Source code is available under the Sybase Open Watcom Public License.</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; See http://www.openwatcom.org/ for details.</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; wfc386 sieve.for&nbsp; -d2</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Open Watcom FORTRAN 77/32 Optimizing Compiler</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Copyright (c) 2002-2019 the Open Watcom Contributors. All Rights Reserved.</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Portions Copyright (c) 1984-2002 Sybase, Inc. All Rights Reserved.</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Source code is available under the Sybase Open Watcom Public License.</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; See http://www.openwatcom.org/ for details.</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; sieve.for: 21 statements, 237 bytes, 6 extensions, 0 warnings, 0 errors</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Open Watcom Linker</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Copyright (c) 2002-2019 the Open Watcom Contributors. All Rights Reserved.</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Portions Copyright (c) 1985-2002 Sybase, Inc. All Rights Reserved.</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Source code is available under the Sybase Open Watcom Public License.</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; See http://www.openwatcom.org/ for details.</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; loading object files</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; searching libraries</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; creating a Phar Lap simple executable</TT>
<BR><BR>The &quot;d2&quot; option requests the maximum amount of debugging information that can be provided by the Open Watcom
F77 compiler.<B><I>&nbsp; WFL386</I></B> will make sure that this debugging information is included in the executable file
that is produced by the linker.
<BR><BR>The &quot;bytes&quot; value is larger than in the previous example since selection of the &quot;d2&quot; option results
in fewer code optimizations by default.&nbsp; You can request more optimization by specifying the appropriate options.&nbsp;
However, you do so at the risk of making it more difficult for yourself to determine the relationship between the object code
and the original source language code.
<BR><BR>To request the Open Watcom Debugger to assist in debugging the application, the following command may be issued.
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; C&gt;wd /trap=pls sieve</TT>
<BR><BR>It would be too ambitious to describe the debugger in this introductory chapter so we refer you to the book entitled<B><I>
Open Watcom Debugger User's Guide.</I></B>
<H1 ID="DOSD4GW__Creating_32Mbit_DOSD4GW_Applications"> DOS/4GW:&nbsp; Creating 32-bit DOS/4GW Applications </H1>
<BR>This chapter describes how to compile and link 32-bit DOS/4GW applications simply and quickly.
<BR><BR>We will illustrate the steps to creating 32-bit DOS/4GW applications by taking a small sample application and showing
you how to compile, link, run and debug it.
<H2 ID="DOSD4GW__The_Sample_Application"> DOS/4GW:&nbsp; The Sample Application </H2>
<BR>To demonstrate the creation of 32-bit DOS/4GW applications using command-line oriented tools, we introduce a simple sample
program.&nbsp; For our example, we are going to use the &quot;sieve&quot; program.
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; * This program computes the prime numbers between 1 and 10,000</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; * using the Sieve of Eratosthenes algorithm.</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; IMPLICIT NONE</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; INTEGER UPBOUND</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; PARAMETER (UPBOUND=10000)</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; INTEGER I, K, PRIMES</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; LOGICAL*1 NUMBERS(2:UPBOUND)</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CHARACTER*11 FORM</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; PARAMETER (FORM='(A,I5,A,I5)')</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DO I = 2, UPBOUND</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; NUMBERS(I) = .TRUE.</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ENDDO</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; PRIMES = 0</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DO I = 2, UPBOUND</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; IF( NUMBERS(I) )THEN</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; PRIMES
= PRIMES + 1</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DO K
= I + I, UPBOUND, I</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp; NUMBERS(K) = .FALSE.</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ENDDO</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ENDIF</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ENDDO</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; PRINT FORM, 'The Number of Primes between 1 and ', UPBOUND,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;' are: ', PRIMES</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; END</TT>
<BR><BR>The goal of this program is to count the prime numbers between 1 and 10,000.&nbsp; It uses the famous<B> Sieve of
Eratosthenes</B> algorithm to accomplish this task.&nbsp; We will take you through the steps necessary to produce this result.
<H2 ID="DOSD4GW__Building_and_Running_the_Sample_DOSD4GW_Application"> DOS/4GW:&nbsp; Building and Running the Sample DOS/4GW Application </H2>
<BR>To compile and link our example program which is stored in the file<TT> sieve.for</TT>, enter the following command:
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; C&gt;wfl386 -l=dos4g sieve.for</TT>
<BR><BR>The typical messages that appear on the screen are shown in the following illustration.
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; C&gt;wfl386 -l=dos4g sieve.for</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Open Watcom F77/32 Compile and Link Utility</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Copyright (c) 2002-2019 the Open Watcom Contributors. All Rights Reserved.</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Portions Copyright (c) 1990-2002 Sybase, Inc. All Rights Reserved.</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Source code is available under the Sybase Open Watcom Public License.</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; See http://www.openwatcom.org/ for details.</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; wfc386 sieve.for </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Open Watcom FORTRAN 77/32 Optimizing Compiler</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Copyright (c) 2002-2019 the Open Watcom Contributors. All Rights Reserved.</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Portions Copyright (c) 1984-2002 Sybase, Inc. All Rights Reserved.</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Source code is available under the Sybase Open Watcom Public License.</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; See http://www.openwatcom.org/ for details.</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; sieve.for: 21 statements, 172 bytes, 6 extensions, 0 warnings, 0 errors</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Open Watcom Linker</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Copyright (c) 2002-2019 the Open Watcom Contributors. All Rights Reserved.</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Portions Copyright (c) 1985-2002 Sybase, Inc. All Rights Reserved.</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Source code is available under the Sybase Open Watcom Public License.</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; See http://www.openwatcom.org/ for details.</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; loading object files</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; searching libraries</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; creating a DOS/4G executable</TT>
<BR><BR>Provided that no errors were encountered during the compile or link phases, the &quot;sieve&quot; program may now
be run.
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; C&gt;sieve</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; The Number of Primes between 1 and 10000 are:&nbsp; 1229</TT>
<BR><BR>If you examine the current directory, you will find that two files have been created.&nbsp; These are<TT> sieve.obj</TT>
(the result of compiling<TT> sieve.for</TT>) and<TT> sieve.exe</TT> (the result of linking<TT> sieve.obj</TT> with the appropriate
Open Watcom FORTRAN 77 libraries).&nbsp; It is<TT> sieve.exe</TT> that is run by DOS when you enter the &quot;sieve&quot;
command.
<H2 ID="DOSD4GW__Debugging_the_Sample_DOSD4GW_Application"> DOS/4GW:&nbsp; Debugging the Sample DOS/4GW Application </H2>
<BR>Let us assume that you wish to debug your application in order to locate an error in programming.&nbsp; In the previous
section, the &quot;sieve&quot; program was compiled with default compile and link options.&nbsp; When debugging an application,
it is useful to refer to the symbolic names of routines and variables.&nbsp; It is also convenient to debug at the source
line level rather than the machine language level.&nbsp; To do this, we must direct both the compiler and linker to include
additional debugging information in the object and executable files.&nbsp; Using the<B><I> WFL386</I></B> command, this is
fairly straightforward.<B><I>&nbsp; WFL386</I></B> recognizes the Open Watcom F77 compiler &quot;debug&quot; options and will
create the appropriate debug directives for the Open Watcom Linker.
<BR><BR>For example, to compile and link the &quot;sieve&quot; program with debugging information, the following command may
be issued.
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; C&gt;wfl386 -l=dos4g -d2 sieve.for</TT>
<BR><BR>The typical messages that appear on the screen are shown in the following illustration.
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; C&gt;wfl386 -l=dos4g -d2 sieve.for</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Open Watcom F77/32 Compile and Link Utility</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Copyright (c) 2002-2019 the Open Watcom Contributors. All Rights Reserved.</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Portions Copyright (c) 1990-2002 Sybase, Inc. All Rights Reserved.</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Source code is available under the Sybase Open Watcom Public License.</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; See http://www.openwatcom.org/ for details.</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; wfc386 sieve.for&nbsp; -d2</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Open Watcom FORTRAN 77/32 Optimizing Compiler</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Copyright (c) 2002-2019 the Open Watcom Contributors. All Rights Reserved.</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Portions Copyright (c) 1984-2002 Sybase, Inc. All Rights Reserved.</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Source code is available under the Sybase Open Watcom Public License.</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; See http://www.openwatcom.org/ for details.</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; sieve.for: 21 statements, 237 bytes, 6 extensions, 0 warnings, 0 errors</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Open Watcom Linker</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Copyright (c) 2002-2019 the Open Watcom Contributors. All Rights Reserved.</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Portions Copyright (c) 1985-2002 Sybase, Inc. All Rights Reserved.</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Source code is available under the Sybase Open Watcom Public License.</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; See http://www.openwatcom.org/ for details.</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; loading object files</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; searching libraries</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; creating a DOS/4G executable</TT>
<BR><BR>The &quot;d2&quot; option requests the maximum amount of debugging information that can be provided by the Open Watcom
F77 compiler.<B><I>&nbsp; WFL386</I></B> will make sure that this debugging information is included in the executable file
that is produced by the linker.
<BR><BR>The &quot;bytes&quot; value is larger than in the previous example since selection of the &quot;d2&quot; option results
in fewer code optimizations by default.&nbsp; You can request more optimization by specifying the appropriate options.&nbsp;
However, you do so at the risk of making it more difficult for yourself to determine the relationship between the object code
and the original source language code.
<BR><BR>To request the Open Watcom Debugger to assist in debugging the application, the following command may be issued.
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; C&gt;wd /trap=rsi sieve</TT>
<BR><BR>It would be too ambitious to describe the debugger in this introductory chapter so we refer you to the book entitled<B><I>
Open Watcom Debugger User's Guide.</I></B>
<H1 ID="32Mbit_Extended_DOS_Application_Development"> 32-bit Extended DOS Application Development </H1>
<BR>The purpose of this chapter is to anticipate common programming questions for 32-bit extended DOS application development.
&nbsp;Note that these programming solutions may be DOS-extender specific and therefore may not work for other DOS extenders.
<BR><BR>The following topics are discussed in this chapter:
<UL>
<LI>How can I write directly to video memory using DOS/4GW?
<LI>How do I issue interrupts in a DOS/4GW application?
<LI>How do I get information about free memory with DOS/4GW?
</UL>
<BR>Please refer to the<B><I> DOS Protected-Mode Interface (DPMI) Specification</I></B> for information on DPMI services.
&nbsp;In the past, the DPMI specification could be obtained free of charge by contacting Intel Literature JP26 at 800-548-4725
or by writing to the address below.&nbsp; We have been advised that the DPMI specification is no longer available in printed
form.
<BR><BR>&nbsp;&nbsp;&nbsp;&nbsp; Intel Literature JP26
<BR>&nbsp;&nbsp;&nbsp;&nbsp; 3065 Bowers Avenue
<BR>&nbsp;&nbsp;&nbsp;&nbsp; P.O. Box 58065
<BR>&nbsp;&nbsp;&nbsp;&nbsp; Santa Clara, California
<BR>&nbsp;&nbsp;&nbsp;&nbsp; U.S.A. 95051-8065
<BR><BR>However, the DPMI 1.0 specification can be obtained from the Intel ftp site.&nbsp; Here is the URL.
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; ftp://ftp.intel.com/pub/IAL/software_specs/dpmiv1.zip</TT>
<BR><BR>This ZIP file contains a Postscript version of the DPMI 1.0 specification.
<H2 ID="How_can_I_write_directly_to_video_memory_using_a_DOS_extender_"> How can I write directly to video memory using a DOS extender? </H2>
<BR>Many programmers require access to video RAM in order to directly manipulate data on the screen.&nbsp; Under DOS, it was
standard practice to use a far pointer, with the segment part of the far pointer set to the screen segment.&nbsp; Under DOS
extenders, this practice is not so standard.&nbsp; Each DOS extender provides its own method for accessing video memory.&nbsp;
The following program demonstrates the method used with DOS/4GW.
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; * FSCREEN.FOR</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; * The following program shows how to access screen memory</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; * from a FORTRAN program under the DOS/4GW DOS extender.</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; * Compile &amp; Link: wfl386 -l=dos4g fscreen</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; program screen</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; * Allocatable arrays must be declared by specifying their</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; * dimensions using colons only (see Open Watcom FORTRAN 77</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; * Language Reference on the ALLOCATE statement for details).</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; character*1 screen(:,:)</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; integer SCRSIZE, i</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; parameter ( SCRSIZE = 80*25 )</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; * Under DOS/4GW, the first megabyte of physical memory - the</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; * real memory - is mapped as a shared linear address space.</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; * This allows your application to access video RAM using its</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; * linear address.&nbsp; The DOS segment:offset of B800:0000</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; * corresponds to a linear address of B8000.</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; allocate( screen(0:1,0:SCRSIZE-1), location='B8000'x
)</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; do i = 0, SCRSIZE - 1</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; screen(0,i) = '*'</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; enddo</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; end</TT>
<H2 ID="How_do_I_issue_interrupts_in_a_DOSD4GW_application_"> How do I issue interrupts in a DOS/4GW application? </H2>
<BR>The Open Watcom F77 library files contain the FINTR and the FINTRF subroutines which allows the user to perform interrupt
calls within a FORTRAN 77 program.&nbsp; This subroutine is described in the Subprogram Library section of the<B><I> Open
Watcom FORTRAN 77 User's Guide.</I></B>
<BR><BR>The following sample program illustrates the use of the FINTR subroutine to set up the register information required
for Interrupt 21h.&nbsp; The register information is loaded into the regs structure.&nbsp; This structure is defined in the
DOS.FI file located in the \WATCOM\SRC\FORTRAN\DOS directory.&nbsp; Assign values to the register elements according to the
interrupt call requirements.&nbsp; For example, Interrupt 21h, function 4Eh needs valid values for the AH, ECX, DS and EDX
to set up the registers for the Interrupt 21h call.&nbsp; This procedure can be used to perform any interrupt calls that are
supported in protected mode by DOS/4GW.
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; * DTA.FOR</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; * This program demonstrates the use of the FINTR</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; * function to list the files of the current directory.</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; * Interrupt 21 Functions for FIND FIRST, FIND NEXT,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; * and GET DTA are used.</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; * Compile &amp; Link: set finclude=\watcom\src\fortran\dos</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; *&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;wfl386 -l=dos4g dta</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; *$pragma aux GetDS = &quot;mov ax,ds&quot; value [ax]</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; program dta</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; implicit integer*2 (i-n)</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; integer*2 res</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; integer*2 GetDS</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; integer*4 dir,addr</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; integer*1 dta(:)</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; character fname*1(12), fname2*12</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; equivalence (fname, fname2)</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; * DTA is declared as a FAR array.&nbsp; When referencing an array</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; * element, the pointer to the array is a FAR pointer.&nbsp; With a</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; * character variable, the result is a pointer to a string</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; * control block (SCB).&nbsp; The run-time library expects the SCB</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; * to contain a near pointer.&nbsp; To get around the problem, we</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; * define the DTA as a byte array, then use the CHAR function</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; * to get the character equivalent for printing a filename.</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; *$pragma array dta far</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; include 'dos.fi'</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; *</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; * Listing of current directory</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; *</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call fsystem( 'dir/w *.*'//char(0) )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; dir = loc( '*.*'//char(0) )</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; i = 0</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; 10&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; i = i + 1</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if( i .eq. 1 )then</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; *</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; * Find first file</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; *</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; AH = '4E'x</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ECX = 0</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DS = GetDS()</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; EDX = dir</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; *</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; * Find next file</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; *</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; AH = '4F'x</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; endif</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call fintr( '21'x, regs )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; res = AX</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if( res .eq. 0 )then</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; *</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; * Extract filename from DTA</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; *</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; AH = '2F'x</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call fintr( '21'x,
regs )</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; addr = ISHL(
IAND( INT( ES ), '0000FFFF'x ), 16 )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; addr = IOR( addr,
IAND( INT( BX ), '0000FFFF'x ) )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; allocate( dta(0:42),
location=addr )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; fname2 = ' '</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; do j = 30, 41</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;if( dta(j) .eq. 0 ) goto 20</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;fname(j - 29) = char( dta(j) )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; enddo</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; 20&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; print *, fname2</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; deallocate( dta )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; goto 10</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; endif</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; end</TT>
<H2 ID="How_do_I_get_information_about_free_memory_in_the_32Mbit_environment_"> How do I get information about free memory in the 32-bit environment? </H2>
<BR>Under a virtual memory system, programmers are often interested in the amount of physical memory they can allocate.&nbsp;
Information about the amount of free memory that is available is always provided under a DPMI host, however, the manner in
which this information is provided may differ under various environments.&nbsp; Keep in mind that in a multi-tasking environment,
the information returned to your task from the DPMI host can easily become obsolete if other tasks allocate memory independently
of your task.
<BR><BR>DOS/4GW provides a DPMI interface through interrupt 0x31.&nbsp; This allows you to use DPMI service 0x0500 to get
free memory information.&nbsp; The following program illustrates this procedure.
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; * FMEMORY.FOR</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; * This example shows how to get information about free</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; * memory using DPMI call 0500h under DOS/4GW using Open Watcom</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; * FORTRAN 77.&nbsp; Note that only the first field of the</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; * structure is guaranteed to contain a valid value; any</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; * field not returned by DOS/4GW is set to -1 (0FFFFFFFFh).</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; * Compile &amp; Link:&nbsp;&nbsp; set finclude=\watcom\src\fortran\dos</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; *&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp; wfl386 -l=dos4g fmemory</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; * Pragma to get the default data segment</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; *$pragma aux GetDS = &quot;mov ax,ds&quot; value [ax] modify exact [ax]</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; program memory</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; implicit none</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; include 'dos.fi'</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; structure /meminfo/</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; integer*4 LargestBlockAvail</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; integer*4 MaxUnlockedPage</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; integer*4 LargestLockablePage</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; integer*4 LinAddrSpace</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; integer*4 NumFreePagesAvail</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; integer*4 NumPhysicalPagesFree</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; integer*4 TotalPhysicalPages</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; integer*4 FreeLinAddrSpace</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; integer*4 SizeOfPageFile</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; integer*4 Reserved1</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; integer*4 Reserved2</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; end structure</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; * Set up the register information for the interrupt call</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; record /meminfo/ MemInfo</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; integer interrupt_no</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; integer*2 GetDS</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; parameter( interrupt_no='31'x)</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DS = FS = GS = 0</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; EAX = '00000500'x</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ES = GetDS()</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; EDI = loc(MemInfo)</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call fintr( interrupt_no, regs)</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; * Report the information returned by the DPMI host</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; print *,'------------------------------------------'</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; print *,'Largest available block (in bytes): ',</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &amp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Meminfo.LargestBlockAvail</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; print *,'Maximum unlocked page allocation: ',</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &amp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; MemInfo.MaxUnlockedPage</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; print *,'Pages that can be allocated and locked: ',</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &amp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; MemInfo.LargestLockablePage</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; print *,'Total linear address space including' //</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &amp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ' allocated
pages:', MemInfo.LinAddrSpace</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; print *,'Number of free pages available: ',</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &amp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; MemInfo.NumFreePagesAvail</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; print *,'Number of physical pages not in use: ',</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &amp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; MemInfo.NumPhysicalPagesFree</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; print *,'Total physical pages managed by host: ',</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &amp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; MemInfo.TotalPhysicalPages</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; print *,'Free linear address space (pages): ',</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &amp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; MemInfo.FreeLinAddrSpace</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; print *,'Size of paging/file partition (pages): ',</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &amp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; MemInfo.SizeOfPageFile</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; end</TT>
<H1 ID="DOSD4GW__The_Tenberry_Software_DOSD4GW_DOS_Extender"> DOS/4GW:&nbsp; The Tenberry Software DOS/4GW DOS Extender </H1>
<BR><BR>The chapters in this section describe the 32-bit Tenberry Software<B> DOS/4GW</B> DOS Extender which is provided with
the Open Watcom F77 package.<B>&nbsp; DOS/4GW</B> is a subset of Tenberry Software's DOS/4G product.<B>&nbsp; DOS/4GW</B>
is customized for use with the Open Watcom F77 package.&nbsp; Key differences are:
<UL>
<LI><B> DOS/4GW</B> will only execute programs built with a Open Watcom 32-bit compiler such as Open Watcom F77 and linked
with its run-time libraries.
<LI>The<B> DOS/4GW</B> virtual memory manager (VMM), included in the package, is restricted to 32MB of memory.
<LI><B> DOS/4GW</B> does not provide extra functionality such as TSR capability and VMM performance tuning enhancements.
</UL>
<BR>If your application has requirements beyond those provided by<B> DOS/4GW</B>, you may wish to acquire DOS/4GW Professional
or DOS/4G from:
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Tenberry Software, Inc.</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; PO Box 20050</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Fountain Hills, Arizona</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; U.S.A&nbsp; 85269-0050</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; WWW:&nbsp;&nbsp;&nbsp; http://www.tenberry.com/dos4g/</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Email:&nbsp; info@tenberry.com</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Phone:&nbsp; 1.480.767.8868</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Fax:&nbsp;&nbsp;&nbsp; 1.480.767.8709</TT>
<BR><BR>Programs developed to use the restricted version of<B> DOS/4GW</B> which is included in the Open Watcom F77 package
can be distributed on a royalty-free basis, subject to the licensing terms of the product.
<H1 ID="DOSD4GW__Linear_Executables"> DOS/4GW:&nbsp; Linear Executables </H1>
<BR>To build a linear executable, compile and link it as described in the chapter entitled &quot;Creating 32-bit DOS/4GW Executables&quot;.
&nbsp;The resulting file will not run independently:&nbsp; you can run it under the Open Watcom Debugger, Tenberry Software
Instant-D debugger, or with the standalone &quot;DOS4GW.EXE&quot;.
<H2 ID="DOSD4GW__The_Linear_Executable_Format"> DOS/4GW:&nbsp; The Linear Executable Format </H2>
<BR><B> DOS/4GW</B> works with files that use the Linear Executable (LE) file format.&nbsp; The format represents a protected-mode
program in the context of a 32-bit 386 runtime environment with linear to physical address translation hardware enabled.&nbsp;
It uses a flat address space.
<BR><BR>This file format is similar to the Segmented Executable (NE) format used in OS/2 1.x and MS Windows.&nbsp; Both support
Dynamic Linking, Resources, and are geared toward protected-mode programs.&nbsp; Both formats use tables of &quot;counted
ASCII&quot; names, and they use similar relocation formats.
<BR><BR>Both formats begin with a DOS style stub program that sophisticated loaders skip.&nbsp; This stub program executes
when the<B> DOS/4GW</B> loader is not present, displaying the message,<B> This program cannot run in DOS mode.</B>
<BR><BR>When the Open Watcom Linker is used to link a<B> DOS/4GW</B> application, it automatically replaces the default stub
program with one that calls DOS4GW.
<H3 ID="DOSD4GW__The_Stub_Program"> DOS/4GW:&nbsp; The Stub Program </H3>
<BR>The stub at the beginning of a linear executable is a real-mode program that you can modify as you like.&nbsp; For example,
you can:
<UL>
<LI>make the stub program do a checksum on the &quot;DOS4GW.EXE&quot; file to make sure it's the correct version.
<LI>copy protect your program.
<LI>specify a search path for the &quot;DOS4GW.EXE&quot; file.
<LI>add command line arguments.
</UL>
<BR>The SRC directory contains source code for a sample stub program.&nbsp; &quot;WSTUB.C&quot; is a simple example, a good
base to start from when you construct your own stub.&nbsp; Please note that you will require a 16-bit C compiler to compile
a new stub program.&nbsp; Following is the code in &quot;WSTUB.C&quot;:&nbsp; 
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; #include &lt;stdio.h&gt;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; #include &lt;stdlib.h&gt;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; #include &lt;process.h&gt;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; #include &lt;errno.h&gt;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; #include &lt;string.h&gt;</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; /* Add environment strings to be searched here */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; char *paths_to_check[] = {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &quot;DOS4GPATH&quot;,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &quot;PATH&quot;};</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; char *dos4g_path()</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; static char fullpath[80];</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int i;</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for( i = 0;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; i &lt; sizeof( paths_to_check ) / sizeof(
paths_to_check[0] );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; i++ ) {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; _searchenv( &quot;dos4gw.exe&quot;, paths_to_check[i],
fullpath );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if( fullpath[0] ) return( &amp;fullpath );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for( i = 0;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; i &lt; sizeof( paths_to_check ) / sizeof(
paths_to_check[0] );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; i++ ) {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; _searchenv( &quot;dos4g.exe&quot;, paths_to_check[i],
fullpath );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if( fullpath[0] ) return( &amp;fullpath );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return( &quot;dos4gw.exe&quot; );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; }</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; main( int argc, char *argv[] )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; char&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; *av[4];</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; auto char&nbsp;&nbsp; cmdline[128];</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; av[0] = dos4g_path();&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* Locate the DOS/4G loader */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; av[1] = argv[0];&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* name of executable to run */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; av[2] = getcmd( cmdline );&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp; /* command line */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; av[3] = NULL;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* end of list */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; #ifdef QUIET</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; putenv( &quot;DOS4G=QUIET&quot; );&nbsp;&nbsp;&nbsp; /* disables
DOS/4G Copyright banner */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; #endif</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; execvp( av[0], av );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; puts( &quot;Stub exec failed:&quot; );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; puts( av[0] );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; puts( strerror( errno ) );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; exit( 1 );&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* indicate error */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; }</TT>
<BR><BR>If you do not have a C compiler, you can create an assembly language version of the above sample stub program and
use it to create your own version of the stub program.
<H2 ID="DOSD4GW__Memory_Use"> DOS/4GW:&nbsp; Memory Use </H2>
<BR>This section explains how a<B> DOS/4GW</B> application uses the memory on a 386-based PC/AT.&nbsp; The basic memory layout
of an AT machine consists of 640KB of DOS memory, 384KB of upper memory, and an undetermined amount of extended memory.&nbsp;
DOS memory and upper memory together compose real memory, the memory that can be addressed when the processor is running in
real mode.
<BR><BR><TT><IMG SRC="mem1.bmp" ALIGN=MIDDLE></TT>
<BR><B><I>Figure 1.</I></B><B><I></I></B><B> Basic Memory Layout</B>
<BR><BR>Under<B> DOS/4GW</B>, the first megabyte of physical memory - the real memory - is mapped as a shared linear address
space.&nbsp; This allows your application to use absolute addresses in real memory, to access video RAM or BIOS ROM, for example.
&nbsp;Because the real memory is available to all processes, you are not guaranteed to be able to allocate a particular area
in real memory:&nbsp; another process may have allocated it already.
<BR><BR>Most code and data is placed in a paged linear address space starting at 4MB.&nbsp; The linear address space starts
at 4MB, the first address in the second page table, to avoid conflicts with VCPI system software.
<BR><BR>This split mapping - an executable that is linked to start at 4MB in the linear address space, with the first MB in
the address space mapped to the first MB of physical memory - is called a<B> split flat model.</B>
<BR><BR>The illustration below shows the layout of physical memory on the left, and the layout of the linear address space
on the right.
<BR><BR><TT><IMG SRC="mem2.bmp" ALIGN=MIDDLE></TT>
<BR><B><I>Figure 2.</I></B><B><I></I></B><B> Physical Memory/Linear Address Space</B>
<BR><BR>The 1KB label in the diagram indicates the top of the real-mode interrupt vectors.&nbsp; 4KB marks the end of the
first page.
<H1 ID="DOSD4GW__Configuring_DOSD4GW"> DOS/4GW:&nbsp; Configuring DOS/4GW </H1>
<BR>This chapter explains various options that can be specified with the<B> DOS4G</B> environment variable including how to
suppress the banner that is displayed by<B> DOS/4GW</B> at startup.&nbsp; It also explains how to use the<B> DOS16M</B> environment
variable to select the switch mode setting, if necessary, and to specify the range of extended memory in which<B> DOS/4GW</B>
will operate.<B>&nbsp; DOS/4GW</B> is based on Tenberry Software's DOS/16M 16-bit Protected-Mode support; hence the<B> DOS16M</B>
environment variable name remains unchanged.
<H2 ID="DOSD4GW__The_DOS4G_Environment_Variable"> DOS/4GW:&nbsp; The DOS4G Environment Variable </H2>
<BR>A number of options can be selected by setting the<B> DOS4G</B> environment variable.&nbsp; The syntax for setting options
is:
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; set DOS4G=option1,option2,...</TT>
<BR><BR>Do not insert a space between<B> DOS4G</B> and the equal sign.&nbsp; A space to the right of the equal sign is optional.
<DL>
<DT>Options:
<DD>
<DT>QUIET
<DD>Use this option to suppress the<B> DOS/4GW</B> banner.
<BR><BR>The banner that is displayed by<B> DOS/4GW</B> at startup can be suppressed by issuing the following command:
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; set DOS4G=quiet</TT>
<BR><BR><B><I>Note:</I></B>&nbsp; Use of the quiet switch is only permitted pursuant to the terms and conditions of the WATCOM
Software License Agreement and the additional redistribution rights described in the<B><I> Getting Started</I></B> manual.
&nbsp;Under these terms, suppression of the copyright by using the quiet switch is not permitted for applications which you
distribute to others.
<DT>VERBOSE
<DD>Use this option to maximize the information available for postmortem debugging.
<BR><BR>Before running your application, issue the following command:
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; set DOS4G=verbose</TT>
<BR><BR>Reproduce the crash and record the output.
<DT>NULLP
<DD>Use this option to trap references to the first sixteen bytes of physical memory.
<BR><BR>Before running your application, issue the following command:
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; set DOS4G=nullp</TT>
</DL>
<BR>To select a combination of options, list them with commas as separators.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; set DOS4G=nullp,verbose</TT>
<H2 ID="DOSD4GW__Changing_the_Switch_Mode_Setting"> DOS/4GW:&nbsp; Changing the Switch Mode Setting </H2>
<BR>In almost all cases,<B> DOS/4GW</B> programs can detect the type of machine that is running and automatically choose an
appropriate real- to protected-mode switch technique.&nbsp; For the few cases in which this default setting does not work
we provide the<B> DOS16M</B> DOS environment variable, which overrides the default setting.
<BR><BR>Change the switch mode settings by issuing the following command:
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; set DOS16M=value</TT>
<BR><BR>Do not insert a space between<B> DOS16M</B> and the equal sign.&nbsp; A space to the right of the equal sign is optional.
<BR><BR>The table below lists the machines and the settings you would use with them.&nbsp; Many settings have mnemonics, listed
in the column &quot;Alternate Name&quot;, that you can use instead of the number.&nbsp; Settings that you must set with the<B>
DOS16M</B> variable have the notation<B> req'd</B> in the first column.&nbsp; Settings you may use are marked<B> option,</B>
and settings that will automatically be set are marked<B> auto.</B>
<BR><BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Alternate
<BR> Status&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Machine&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;Setting&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Name
<BR> Comment&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
<BR><BR> auto&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 386/486 w/ DPMI 0&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; None
<BR> Set automatically if DPMI is active&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp; 
<BR> req'd&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; NEC 98-series&nbsp;&nbsp; 1&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 9801
<BR> Must be set for NEC 98-series&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
<BR> auto&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; PS/2&nbsp;&nbsp;&nbsp; 2&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp; None&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Set
automatically for PS/2
<BR> auto&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 386/486&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp; 3&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;386,
<BR>80386 Set automatically for 386 or 486&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp; 
<BR> auto&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 386&nbsp;&nbsp;&nbsp;&nbsp; INBOARD None
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 386 with Intel Inboard
<BR> req'd&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Fujitsu FMR-70&nbsp; 5&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; None
<BR> Must be set for Fujitsu FMR-70&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
<BR> auto&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 386/486 w/ VCPI 11&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; None
<BR> Set automatically if VCPI detected&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
<BR> req'd&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Hitachi B32&nbsp;&nbsp;&nbsp;&nbsp; 14&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; None
<BR> Must be set for Hitachi B32&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
<BR> req'd&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; OKI if800&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
15&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; None
<BR> Must be set for OKI if800&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
<BR> option&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; IBM PS/55&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 16&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; None
<BR> May be needed for some PS/55s&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
<BR><BR>The following procedure shows you how to test the switch mode setting.
<OL>
<LI>If you have one of the machines listed below, set the<B> DOS16M</B> environment variable to the value shown for that machine
and specify a range of extended memory.&nbsp; For example, if your machine is a NEC 98-series, set<TT> DOS16M=1 @2M-4M.</TT>
&nbsp;See the section entitled <A HREF="#DOSD4GW__Fine_Control_of_Memory_Usage">DOS/4GW:&nbsp; Fine Control of Memory Usage</A>
in this chapter for more information about setting the memory range.
<BR><BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Machine&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp; Setting&nbsp; 
<BR><BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; NEC 98-series&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 1&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp; 
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Fujitsu FMR-60,-70&nbsp;&nbsp; 5&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Hitachi B32&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 14
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; OKI if800&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;15&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
<BR><BR>Before running<B> DOS/4GW</B> applications, check the switch mode setting by following this procedure:
<LI>Run PMINFO and note the switch setting reported on the last line of the display.&nbsp; (PMINFO, which reports on the protected-mode
resources available to your programs, is described in more detail in the chapter entitled <A HREF="#DOSD4GW__Utilities">DOS/4GW:&nbsp; Utilities</A>)
<BR><BR>If PMINFO runs, the setting is usable on your machine.
<LI>If you changed the switch setting, add the new setting to your AUTOEXEC.BAT file.
</OL>
<BR><B>Note:</B>&nbsp; PMINFO will run successfully on 286 machines.&nbsp; If your<B> DOS/4GW</B> application does not run,
and PMINFO does, check the CPU type reported on the first line of the display.
<BR><BR>You are authorized (and encouraged) to distribute PMINFO to your customers.&nbsp; You may also include a copy of this
section in your documentation.
<H2 ID="DOSD4GW__Fine_Control_of_Memory_Usage"> DOS/4GW:&nbsp; Fine Control of Memory Usage </H2>
<BR>In addition to setting the switch mode as described above, the<B> DOS16M</B> environment variable enables you to specify
which portion of extended memory<B> DOS/4GW</B> will use.&nbsp; The variable also allows you to instruct<B> DOS/4GW</B> to
search for extra memory and use it if it is present.
<H3 ID="DOSD4GW__Specifying_a_Range_of_Extended_Memory"> DOS/4GW:&nbsp; Specifying a Range of Extended Memory </H3>
<BR>Normally, you don't need to specify a range of memory with the<B> DOS16M</B> variable.&nbsp; You must use the variable,
however, in the following cases:
<UL>
<LI>You are running on a Fujitsu FMR-series, NEC 98-series, OKI if800-series or Hitachi B-series machine.
<LI>You have older programs that use extended memory but don't follow one of the standard disciplines.
<LI>You want to shell out of<B> DOS/4GW</B> to use another program that requires extended memory.
</UL>
<BR>If none of these conditions applies to you, you can skip this section.
<BR><BR>The general syntax is:
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; set DOS16M= [switch_mode] [@start_address [- end_address]] [:size]</TT>
<BR><BR>In the syntax shown above,<TT> start_address, end_address</TT> and<TT> size</TT> represent numbers, expressed in decimal
or in hexadecimal (hex requires a<TT> 0x</TT> prefix).&nbsp; The number may end with a K to indicate an address or size in
kilobytes, or an M to indicate megabytes.&nbsp; If no suffix is given, the address or size is assumed to be in kilobytes.
&nbsp;If both a size and a range are specified, the more restrictive interpretation is used.
<BR><BR>The most flexible strategy is to specify only a size.&nbsp; However, if you are running with other software that does
not follow a convention for indicating its use of extended memory, and these other programs start before<B> DOS/4GW</B>, you
will need to calculate the range of memory used by the other programs and specify a range for<B> DOS/4GW</B> programs to use.
<BR><BR><B>DOS/4GW</B> ignores specifications (or parts of specifications) that conflict with other information about extended
memory use.&nbsp; Below are some examples of memory usage control:
<DL>
<DT>set DOS16M= 1 @2m-4m
<DD>Mode 1, for NEC 98-series machines, and use extended memory between 2.0 and 4.0MB.
<DT>set DOS16M= :1M
<DD>Use the last full megabyte of extended memory, or as much as available limited to 1MB.
<DT>set DOS16M= @2m
<DD>Use any extended memory available above 2MB.
<DT>set DOS16M= @ 0 - 5m
<DD>Use any available extended memory from 0.0 (really 1.0) to 5.0MB.
<DT>set DOS16M= :0
<DD>Use no extended memory.
</DL>
<BR>As a default condition<B> DOS/4GW</B> applications take all extended memory that is not otherwise in use.&nbsp; Multiple<B>
DOS/4GW</B> programs that execute simultaneously will share the reserved range of extended memory.&nbsp; Any non-<B>DOS/4GW</B>
programs started while<B> DOS/4GW</B> programs are executing will find that extended memory above the start of the<B> DOS/4GW</B>
range is unavailable, so they may not be able to run.&nbsp; This is very safe.&nbsp; There will be a conflict only if the
other program does not check the BIOS configuration call (Interrupt 15H function 88H, get extended memory size).
<BR><BR>To create a private pool of extended memory for your<B> DOS/4GW</B> application, use the PRIVATXM program, described
in the chapter entitled <A HREF="#DOSD4GW__Utilities">DOS/4GW:&nbsp; Utilities</A>.
<BR><BR>The default memory allocation strategy is to use extended memory if available, and overflow into DOS (low) memory.
<BR><BR>In a VCPI or DPMI environment, the<TT> start_address</TT> and<TT> end_address</TT> arguments are not meaningful.<B>
&nbsp;DOS/4GW</B> memory under these protocols is not allocated according to specific addresses because VCPI and DPMI automatically
prevent address conflicts between extended memory programs.&nbsp; You can specify a<TT> size</TT> for memory managed by VCPI
or DPMI, but<B> DOS/4GW</B> will not necessarily allocate this memory from the highest available extended memory address,
as it does for memory managed under other protocols.
<H3 ID="DOSD4GW__Using_Extra_Memory"> DOS/4GW:&nbsp; Using Extra Memory </H3>
<BR>Some machines contain extra non-extended, non-conventional memory just below 16MB.&nbsp; When<B> DOS/4GW</B> runs on a
Compaq 386, it automatically uses this memory because the memory is allocated according to a certain protocol, which<B> DOS/4GW</B>
follows.&nbsp; Other machines have no protocol for allocating this memory.&nbsp; To use the extra memory that may exist on
these machines, set<B> DOS16M</B> with the + option.
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; set DOS16M=+</TT>
<BR><BR>Setting the + option causes<B> DOS/4GW</B> to search for memory in the range from FA0000 to FFFFFF and determine whether
the memory is usable.<B>&nbsp; DOS/4GW</B> does this by writing into the extra memory and reading what it has written.&nbsp;
In some cases, this memory is mapped for DOS or BIOS usage, or for other system uses.&nbsp; If<B> DOS/4GW</B> finds extra
memory that is mapped this way, and is not marked read-only, it will write into that memory.&nbsp; This will cause a crash,
but won't have any other effect on your system.
<H2 ID="DOSD4GW__Setting_Runtime_Options"> DOS/4GW:&nbsp; Setting Runtime Options </H2>
<BR>The<B> DOS16M</B> environment variable sets certain runtime options for all<B> DOS/4GW</B> programs running on the same
system.
<BR><BR>To set the environment variable, the syntax is:
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; set DOS16M=[switch_mode_setting]^options.</TT>
<BR><BR><B>Note:</B>&nbsp; Some command line editing TSRs, such as CED, use the caret (^) as a delimiter.&nbsp; If you want
to set<B> DOS16M</B> using the syntax above while one of these TSRs is resident, modify the TSR to use a different delimiter.
<BR><BR>These are the options:
<DL>
<DT>0x01
<DD><B> check A20 line --</B> This option forces<B> DOS/4GW</B> to wait until the A20 line is enabled before switching to protected
mode.&nbsp; When<B> DOS/4GW</B> switches to real mode, this option suspends your program's execution until the A20 line is
disabled, unless an XMS manager (such as HIMEM.SYS) is active.&nbsp; If an XMS manager is running, your program's execution
is suspended until the A20 line is restored to the state it had when the CPU was last in real mode.&nbsp; Specify this option
if you have a machine that runs<B> DOS/4GW</B> but is not truly AT-compatible.&nbsp; For more information on the A20 line,
see the section entitled <A HREF="#DOSD4GW__Controlling_Address_Line_20">DOS/4GW:&nbsp; Controlling Address Line 20</A>.
<DT>0x02
<DD><B> prevent initialization of VCPI --</B> By default,<B> DOS/4GW</B> searches for a VCPI server and, if one is present, forces
it on.&nbsp; This option is useful if your application does not use EMS explicitly, is not a resident program, and may be
used with 386-based EMS simulator software.
<DT>0x04
<DD><B> directly pass down keyboard status calls --</B> When this option is set, status requests are passed down immediately and
unconditionally.&nbsp; When disabled, pass-downs are limited so the 8042 auxiliary processor does not become overloaded by
keyboard polling loops.
<DT>0x10
<DD><B> restore only changed interrupts --</B> Normally, when a<B> DOS/4GW</B> program terminates, all interrupts are restored
to the values they had at the time of program startup.&nbsp; When you use this option, only the interrupts changed by the<B>
DOS/4GW</B> program are restored.
<DT>0x20
<DD><B> set new memory to 00 --</B> When<B> DOS/4GW</B> allocates a new segment or increases the size of a segment, the memory
is zeroed.&nbsp; This can help you find bugs having to do with uninitialized memory.&nbsp; You can also use it to provide
a consistent working environment regardless of what programs were run earlier.&nbsp; This option only affects segment allocations
or expansions that are made through the<B> DOS/4GW</B> kernel (with DOS function 48H or 4AH).&nbsp; This option does not affect
memory allocated with a compiler's<TT> malloc</TT> function.
<DT>0x40
<DD><B> set new memory to FF --</B> When<B> DOS/4GW</B> allocates a new segment or increases the size of a segment, the memory
is set to 0xFF bytes.&nbsp; This is helpful in making reproducible cases of bugs caused by using uninitialized memory.&nbsp;
This option only affects segment allocations or expansions that are made through the<B> DOS/4GW</B> kernel (with DOS function
48H or 4AH).&nbsp; This option does not affect memory allocated with a compiler's<TT> malloc</TT> function.
<DT>0x80
<DD><B> new selector rotation --</B> When<B> DOS/4GW</B> allocates a new selector, it usually looks for the first available (unused)
selector in numerical order starting with the highest selector used when the program was loaded.&nbsp; When this option is
set, the new selector search begins after the last selector that was allocated.&nbsp; This causes new selectors to rotate
through the range.&nbsp; Use this option to find references to<B> stale</B> selectors, i.e., segments that have been cancelled
or freed.
</DL>
<H2 ID="DOSD4GW__Controlling_Address_Line_20"> DOS/4GW:&nbsp; Controlling Address Line 20 </H2>
<BR>This section explains how<B> DOS/4GW</B> uses address line 20 (A20) and describes the related<B> DOS16M</B> environment
variable settings.&nbsp; It is unlikely that you will need to use these settings.
<BR><BR>Because the 8086 and 8088 chips have 20-bit address spaces, their highest addressable memory location is one byte
below 1MB.&nbsp; If you specify an address at 1MB or over, which would require a twenty-first bit to set, the address wraps
back to zero.&nbsp; Some parts of DOS depend on this wrap, so on the 286 and 386, the twenty-first address bit is disabled.
&nbsp;To address extended memory,<B> DOS/4GW</B> enables the twenty-first address bit (the A20 line).&nbsp; The A20 line must
be enabled for the CPU to run in protected mode, but it may be either enabled or disabled in real mode.
<BR><BR>By default, when<B> DOS/4GW</B> returns to real mode, it disables the A20 line.&nbsp; Some software depends on the
line being enabled.<B>&nbsp; DOS/4GW</B> recognizes the most common software in this class, the XMS managers (such as HIMEM.SYS),
and enables the A20 line when it returns to real mode if an XMS manager is present.&nbsp; For other software that requires
the A20 line to be enabled, use the<TT> A20</TT> option.&nbsp; The<TT> A20</TT> option makes<B> DOS/4GW</B> restore the A20
line to the setting it had when<B> DOS/4GW</B> switched to protected mode.&nbsp; Set the environment variable as follows:
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; set DOS16M=A20</TT>
<BR><BR>To specify more than one option on the command line, separate the options with spaces.
<BR><BR>The<B> DOS16M</B> variable also lets you to specify the length of the delay between a<B> DOS/4GW</B> instruction to
change the status of the A20 line and the next<B> DOS/4GW</B> operation.&nbsp; By default, this delay is 1 loop instruction
when<B> DOS/4GW</B> is running on a 386 machine.&nbsp; In some cases, you may need to specify a longer delay for a machine
that will run<B> DOS/4GW</B> but is not truly AT-compatible.&nbsp; To change the delay, set<B> DOS16M</B> to the desired number
of loop instructions, preceded by a comma:&nbsp; 
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; set DOS16M=,loops</TT>
<H1 ID="DOSD4GW__VMM"> DOS/4GW:&nbsp; VMM </H1>
<BR>The Virtual Memory Manager (VMM) uses a swap file on disk to augment RAM.&nbsp; With VMM you can use more memory than
your machine actually has.&nbsp; When RAM is not sufficient, part of your program is swapped out to the disk file until it
is needed again.&nbsp; The combination of the swap file and available RAM is the<B> virtual memory.</B>
<BR><BR>Your program can use VMM if you set the DOS environment variable,<B> DOS4GVM</B> , as follows.&nbsp; To set the<B>
DOS4GVM</B> environment variable, use the format shown below.
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; set DOS4GVM= [option[#value]] [option[#value]]</TT>
<BR><BR>A &quot;#&quot; is used with options that take values since the DOS command shell will not accept &quot;=&quot;.
<BR><BR>If you set<B> DOS4GVM</B> equal to 1, the default parameters are used for all options.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; C&gt;set DOS4GVM=1</TT>
<H2 ID="DOSD4GW__VMM_Default_Parameters"> DOS/4GW:&nbsp; VMM Default Parameters </H2>
<BR>VMM parameters control the options listed below.
<DL>
<DT>MINMEM
<DD>The minimum amount of RAM managed by VMM.&nbsp; The default is 512KB.
<DT>MAXMEM
<DD>The maximum amount of RAM managed by VMM.&nbsp; The default is 4MB.
<DT>SWAPMIN
<DD>The minimum or initial size of the swap file.&nbsp; If this option is not used, the size of the swap file is based on<B><I>
VIRTUALSIZE</I></B> (see below).
<DT>SWAPINC
<DD>The size by which the swap file grows.
<DT>SWAPNAME
<DD>The swap file name.&nbsp; The default name is &quot;DOS4GVM.SWP&quot;.&nbsp; By default the file is in the root directory
of the current drive.&nbsp; Specify the complete path name if you want to keep the swap file somewhere else.
<DT>DELETESWAP
<DD>Whether the swap file is deleted when your program exits.&nbsp; By default the file is not deleted.&nbsp; Program startup
is quicker if the file is not deleted.
<DT>VIRTUALSIZE
<DD>The size of the virtual memory space.&nbsp; The default is 16MB.
</DL>
<H2 ID="DOSD4GW__Changing_the_Defaults"> DOS/4GW:&nbsp; Changing the Defaults </H2>
<BR>You can change the defaults in two ways.
<OL>
<LI>Specify different parameter values as arguments to the<B> DOS4GVM</B> environment variable, as shown in the example below.
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; set DOS4GVM=deleteswap maxmem#8192</TT>
<LI>Create a configuration file with the filetype extension &quot;.VMC&quot;, and use that as an argument to the<B> DOS4GVM</B>
environment variable, as shown below.
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; set DOS4GVM=@NEW4G.VMC</TT>
</OL>
<H3 ID="DOSD4GW__The__VMC_File"> DOS/4GW:&nbsp; The .VMC File </H3>
<BR>A &quot;.VMC&quot; file contains VMM parameters and settings as shown in the example below.&nbsp; Comments are permitted.
&nbsp;Comments on lines by themselves are preceded by an exclamation point (!).&nbsp; Comments that follow option settings
are preceded by white space.&nbsp; Do not insert blank lines:&nbsp; processing stops at the first blank line.
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; !Sample .VMC file</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; !This file shows the default parameter values.</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; minmem = 512&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; At least 512K
bytes of RAM is required.</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; maxmem = 4096&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Uses no more than
4MB of RAM</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; virtualsize = 16384&nbsp;&nbsp;&nbsp;&nbsp; Swap file plus allocated memory is 16MB</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; !To delete the swap file automatically when the program exits, add</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; !deleteswap</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; !To store the swap file in a directory called SWAPFILE, add</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; !swapname = c:\swapfile\dos4gvm.swp</TT>
<H1 ID="DOSD4GW__Interrupt_21H_Functions"> DOS/4GW:&nbsp; Interrupt 21H Functions </H1>
<BR>When you call an Interrupt 21H function under<B> DOS/4GW</B>, the 32-bit registers in which you pass values are translated
into the appropriate 16-bit registers, since DOS works only with 16 bits.&nbsp; However, you can use 32-bit values in your
DOS calls.&nbsp; You can allocate blocks of memory larger than 64KB or use an address with a 32-bit offset, and<B> DOS/4GW</B>
will translate the call appropriately, to use 16-bit registers.&nbsp; When the Interrupt 21H function returns, the value is
widened - placed in a 32-bit register, with the high order bits zeroed.
<BR><BR><B>DOS/4GW</B> uses the following rules to manage registers:
<UL>
<LI>When you pass a parameter to an Interrupt 21H function that expects a 16-bit quantity in a general register (for example,
AX), pass a 32-bit quantity in the corresponding extended register (for example, EAX).&nbsp; When a DOS function returns a
16-bit quantity in a general register, expect to receive it (with high-order zero bits) in the corresponding extended register.
<LI>When an Interrupt 21H function expects to receive a 16:16 pointer in a segment:general register pair (for example, ES:BX),
supply a 16:32 pointer using the same segment register and the corresponding extended general register (ES:EBX).<B>&nbsp;
DOS/4GW</B> will copy data and translate pointers so that DOS ultimately receives a 16:16 real-mode pointer in the correct
registers.
<LI>When DOS returns a 16:16 real-mode pointer,<B> DOS/4GW</B> translates the segment value into an appropriate protected-mode
selector and generates a 32-bit offset that results in a 16:32 pointer to the same location in the linear address space.
<LI>Many DOS functions return an error code in AX if the function fails.<B>&nbsp; DOS/4GW</B> checks the status of the carry
flag, and if it is set, indicating an error, zero-extends the code for EAX.&nbsp; It does not change any other registers.
<LI>If the value is passed or returned in an 8-bit register (AL or AH, for example),<B> DOS/4GW</B> puts the value in the
appropriate location and leaves the upper half of the 32-bit register untouched.
</UL>
<BR>The table below lists all the Interrupt 21h functions.&nbsp; For each, it shows the registers that are widened or narrowed.
&nbsp;Footnotes provide additional information about some of the interrupts that require special handling.&nbsp; Following
the table is a section that provides a detailed explanation of interrupt handling under<B> DOS/4GW.</B>
<BR><BR> Function&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Purpose&nbsp; Managed
Registers
<BR><BR> 00H&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Terminate Process&nbsp;&nbsp; None
<BR> 01H&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp; Character Input with Echo&nbsp;&nbsp; None
<BR> 02H&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Character Output&nbsp;&nbsp; None
<BR> 03H&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Auxiliary Input&nbsp;&nbsp; None
<BR> 04H&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Auxiliary Output&nbsp;&nbsp; None
<BR> 05H&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Print Character&nbsp;&nbsp; None
<BR> 06H&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Direct Console I/O&nbsp;&nbsp; None
<BR> 07H&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Unfiltered Character Input Without Echo&nbsp;&nbsp; None
<BR> 08H&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
Character Input Without Echo&nbsp;&nbsp; None
<BR> 09H&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Display String&nbsp;&nbsp; EDX
<BR> 0AH&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp; Buffered Keyboard Input&nbsp;&nbsp; EDX
<BR> 0BH&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Check Keyboard Status&nbsp;&nbsp; None
<BR> 0CH&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;Flush Buffer, Read Keyboard&nbsp;&nbsp; EDX
<BR> 0DH&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Disk Reset&nbsp;&nbsp;
None
<BR> 0EH&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Select Disk&nbsp;&nbsp; None
<BR> 0FH&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Open File with FCB&nbsp;&nbsp; EDX
<BR><BR> 10H&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Close File with FCB&nbsp;&nbsp; EDX
<BR> 11H&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Find First File&nbsp;&nbsp; EDX
<BR> 12H&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Find Next File&nbsp;&nbsp; EDX
<BR> 13H&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Delete File&nbsp;&nbsp; EDX
<BR> 14H&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Sequential Read&nbsp;&nbsp; EDX
<BR> 15H&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Sequential Write&nbsp;&nbsp; EDX
<BR> 16H&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Create File with FCB&nbsp;&nbsp; EDX
<BR> 17H&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Rename File&nbsp;&nbsp; EDX
<BR> 19H&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Get Current Disk&nbsp;&nbsp; None
<BR> 1AH&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Set DTA Address&nbsp;&nbsp; EDX
<BR> 1BH&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Get Default Drive Data&nbsp;&nbsp; Returns in EBX, ECX, and EDX
<BR> 1CH&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Get Drive Data&nbsp;&nbsp; Returns in EBX,
ECX, and EDX
<BR><BR> 21H&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Random Read&nbsp;&nbsp; EDX
<BR> 22H&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Random Write&nbsp;&nbsp; EDX
<BR> 23H&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Get File Size&nbsp;&nbsp; EDX
<BR> 24H&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Set Relative Record&nbsp;&nbsp; EDX
<BR> 25H&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Set Interrupt Vector&nbsp;&nbsp; EDX
<BR> 26H&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Create New Program Segment Prefix
&nbsp; None
<BR> 27H&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Random Block Read&nbsp;&nbsp; EDX, returns in ECX
<BR> 28H&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Random Block Write&nbsp;&nbsp; EDX, returns in ECX
<BR> 29H&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Parse Filename&nbsp;&nbsp; ESI, EDI, returns
in EAX, ESI and EDI (1.)
<BR> 2AH&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Get Date
&nbsp; Returns in ECX
<BR> 2BH&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Set Date
&nbsp; None
<BR> 2CH&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Get Time
&nbsp; None
<BR> 2DH&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Set Time
&nbsp; None
<BR> 2EH&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Set/Reset Verify Flag&nbsp;&nbsp; None
<BR> 2FH&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Get DTA Address&nbsp;&nbsp; Returns in EBX
<BR><BR> 30H&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp; Get MS-DOS Version Number&nbsp;&nbsp; Returns in ECX
<BR> 31H&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;Terminate and Stay Resident&nbsp;&nbsp; None
<BR> 33H&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
Get/Set Control-C Check Flag&nbsp;&nbsp; None
<BR> 34H&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
Return Address of InDOS Flag&nbsp;&nbsp; Returns in EBX
<BR> 35H&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Get Interrupt Vector&nbsp;&nbsp; Returns in EBX
<BR> 36H&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Get Disk Free Space&nbsp;&nbsp; Returns in EAX, EBX, ECX, and EDX
<BR> 38H&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp; Get/Set Current Country&nbsp;&nbsp; EDX, returns in EBX
<BR> 39H&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Create Directory&nbsp;&nbsp; EDX
<BR> 3AH&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Remove Directory&nbsp;&nbsp; EDX
<BR> 3BH&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; Change Current Directory&nbsp;&nbsp; EDX
<BR> 3CH&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp; Create File with Handle&nbsp;&nbsp; EDX, returns in EAX
<BR> 3DH&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Open File with Handle&nbsp;&nbsp; EDX, returns in EAX
<BR> 3EH&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Close File&nbsp;&nbsp;
None
<BR> 3FH&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Read File or Device&nbsp;&nbsp; EBX, ECX, EDX, returns in EAX (2.)
<BR><BR> 40H&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Write File or Device&nbsp;&nbsp; EBX, ECX, EDX, returns in EAX (2.)
<BR> 41H&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Delete File&nbsp;&nbsp; EDX
<BR> 42H&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Move File Pointer&nbsp;&nbsp; Returns in EDX, EAX
<BR> 43H&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Get/Set File Attribute&nbsp;&nbsp; EDX, returns in ECX
<BR> 44H&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;IOCTL&nbsp;&nbsp; (3.)
<BR>&nbsp;&nbsp;&nbsp; 00H Get Device Information&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Returns in EDX
<BR>&nbsp;&nbsp;&nbsp; 01H SetDevice Information&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; None
<BR>&nbsp;&nbsp;&nbsp; 02H Read Control Data from CDD
<BR> EDX, returns in EAX
<BR>&nbsp;&nbsp;&nbsp; 03H Write Control Data to CDD
<BR> EDX, returns in EAX
<BR>&nbsp;&nbsp;&nbsp; 04H Read Control Data from BDD
<BR> EDX, returns in EAX
<BR>&nbsp;&nbsp;&nbsp; 05H Write Control Data to BDD
<BR> EDX, returns in EAX
<BR>&nbsp;&nbsp;&nbsp; 06H Check Input Status&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; None
<BR>&nbsp;&nbsp;&nbsp; 07H Check Output Status&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; None
<BR>&nbsp;&nbsp;&nbsp; 08H Check if Block Device is Removeable
<BR> Returns in EAX
<BR>&nbsp;&nbsp;&nbsp; 09H Check if Block Device is Remote
<BR> Returns in EDX
<BR>&nbsp;&nbsp;&nbsp; 0AH Check if Handle is Remote&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Returns in EDX
<BR>&nbsp;&nbsp;&nbsp; 0BH Change Sharing Retry Count&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp; None
<BR>&nbsp;&nbsp;&nbsp; 0CH Generic I/O Control for Character Devices EDX
<BR>&nbsp;&nbsp;&nbsp; 0DH Generic I/O Control for Block Devices&nbsp;&nbsp;&nbsp;&nbsp; EDX
<BR>&nbsp;&nbsp;&nbsp; 0EH Get Logical Drive Map&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; None
<BR>&nbsp;&nbsp;&nbsp; 0FH Set Logical Drive Map&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; None
<BR> 45H&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Duplicate File Handle&nbsp;&nbsp; Returns in EAX
<BR> 46H&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;Force Duplicate File Handle&nbsp;&nbsp; None
<BR> 47H&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Get Current Directory&nbsp;&nbsp; ESI
<BR> 48H&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Allocate Memory Block&nbsp;&nbsp; Returns in EAX
<BR> 49H&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Free Memory Block&nbsp;&nbsp; None
<BR> 4AH&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Resize Memory Block&nbsp;&nbsp; None
<BR> 4BH&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Load and Execute
Program (EXEC)&nbsp;&nbsp; EBX, EDX (4.)
<BR> 4CH&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Terminate Process with Return Code
&nbsp; None
<BR> 4DH&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Get Return Code of Child
Process&nbsp;&nbsp; None
<BR> 4EH&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Find First File&nbsp;&nbsp; EDX
<BR> 4FH&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Find Next File&nbsp;&nbsp; None
<BR><BR> 52H&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Get List of Lists&nbsp;&nbsp; (not supported)
<BR> 54H&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Get Verify Flag&nbsp;&nbsp; None
<BR> 56H&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Rename File&nbsp;&nbsp; EDX,
EDI
<BR> 57H&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp; Get/Set Date/Time of File&nbsp;&nbsp; Returns in ECX, and EDX
<BR> 58H&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;Get/Set Allocation Strategy&nbsp;&nbsp; Returns in EAX
<BR> 59H&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Get Extended
Error Information&nbsp;&nbsp; Returns in EAX
<BR> 5AH&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Create Temporary File&nbsp;&nbsp; EDX, returns in EAX and EDX
<BR> 5BH&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Create New File&nbsp;&nbsp; EDX, returns in EAX
<BR> 5CH&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp; Lock/Unlock File Region&nbsp;&nbsp; None
<BR> 5EH&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Network Machine Name/Printer
Setup&nbsp; 
<BR>&nbsp;&nbsp;&nbsp; 00H Get Machine Name&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; EDX
<BR>&nbsp;&nbsp;&nbsp; 02H Set Printer Setup String&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp; ESI
<BR>&nbsp;&nbsp;&nbsp; 03H Get Printer Setup String&nbsp; EDI, returns in ECX
<BR> 5FH&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp; Get/Make Assign List Entry&nbsp; 
<BR>&nbsp;&nbsp;&nbsp; 02H Get Redirection List Entry
<BR> ESI, EDI, returns in ECX
<BR>&nbsp;&nbsp;&nbsp; 03H Redirect Device&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ESI, EDI
<BR>&nbsp;&nbsp;&nbsp; 04H Cancel Device Redirection&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; ESI
<BR><BR> 62H&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Get Program Segment Prefix Address
&nbsp; Returns in EBX
<BR> 63H&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Get Lead Byte Table (version 2.25 only)&nbsp;&nbsp; Returns in ESI
<BR> 65H&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Get Extended Country Information
&nbsp; EDI
<BR> 66H&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Get or Set Code Page&nbsp;&nbsp; None
<BR> 67H&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Set Handle Count&nbsp;&nbsp; None
<BR>This list of functions is excerpted from<B> The MS-DOS Encyclopedia</B>, Copyright (c) 1988 by Microsoft Press.&nbsp;
All Rights Reserved.
<OL>
<LI>For Function 29H, DS:ESI and ES:EDI contain pointer values that are not changed by the call.
<LI>You can read and write quantities larger than 64KB with Functions 3FH and 40H.<B>&nbsp; DOS/4GW</B> breaks your request
into chunks smaller than 64KB, and calls the DOS function once for each chunk.
<LI>You can't transfer more than 64KB using Function 44h, subfunctions 02H, 03H, 04H, or 05H.<B>&nbsp; DOS/4GW</B> does not
break larger requests into DOS-sized chunks, as it does for Functions 3FH and 40H.
<LI>When you call Function 4B under<B> DOS/4GW</B>, you pass it a data structure that contains 16:32 bit pointers.<B>&nbsp;
DOS/4GW</B> translates these into 16:16 bit pointers in the structure it passes to DOS.
</OL>
<H2 ID="DOSD4GW__Functions_25H_and_35H__Interrupt_Handling_in_Protected_Mode"> DOS/4GW:&nbsp; Functions 25H and 35H:&nbsp; Interrupt Handling in Protected Mode </H2>
<BR>By default, interrupts that occur in protected mode are passed down:&nbsp; the entry in the IDT points to code in<B> DOS/4GW</B>
that switches the CPU to real mode and resignals the interrupt.&nbsp; If you install an interrupt handler using Interrupt
21H, Function 25H, that handler will get control of any interrupts that occur while the processor is in protected mode.&nbsp;
If the interrupt for which you installed the handler is in the<B> autopassup range,</B> your handler will also get control
of interrupts signalled in real mode.
<BR><BR>The autopassup range runs from 08H to 2EH inclusive, but excluding 21H.&nbsp; If the interrupt is in the autopassup
range, the real-mode vector will be modified when you install the protected-mode handler to point to code in the<B> DOS/4GW</B>
kernel.&nbsp; This code switches the processor to protected mode and resignals the interrupt-where your protected-mode handler
will get control.
<H3 ID="DOSD4GW__32MBit_Gates"> DOS/4GW:&nbsp; 32-Bit Gates </H3>
<BR>The<B> DOS/4GW</B> kernel always assigns a 32-bit gate for the interrupt handlers it installs.&nbsp; It does not distinguish
between 16-bit and 32-bit handlers for consistency with DPMI.
<BR><BR>This 32-bit gate points into the<B> DOS/4GW</B> kernel.&nbsp; When<B> DOS/4GW</B> handles the interrupt, it switches
to its own 16-bit stack, and from there it calls the interrupt handler (yours or the default).&nbsp; This translation is transparent
to the handler, with one exception:&nbsp; since the current stack is not the one on which the interrupt occurred, the handler
cannot look up the stack for the address at which the interrupt occurred.
<H3 ID="DOSD4GW__Chaining_16Mbit_and_32Mbit_Handlers"> DOS/4GW:&nbsp; Chaining 16-bit and 32-bit Handlers </H3>
<BR>If your program hooks an interrupt, write a normal service routine that either handles the interrupt and IRETs or chains
to the previous handler.&nbsp; As part of handling the interrupt, your handler can PUSHF/CALL to the previous handler.&nbsp;
The handler<B> must</B> IRET (or IRETD) or chain.
<BR><BR>For each protected-mode interrupt,<B> DOS/4GW</B> maintains separate chains of 16-bit and 32-bit handlers.&nbsp; If
your 16-bit handler chains, the previous handler is a 16-bit program.&nbsp; If your 32-bit handler chains, the previous handler
is a 32-bit program.
<BR><BR>If a 16-bit program hooks a given interrupt before any 32-bit programs hook it, the 16-bit chain is executed first.
&nbsp;If all the 16-bit handlers unhook later and a new 16-bit program hooks the interrupt while 32-bit handlers are still
outstanding, the 32-bit handlers will be executed first.
<BR><BR>If the first program to hook an interrupt is 32-bit, the 32-bit chain is executed first.
<H3 ID="DOSD4GW__Getting_the_Address_of_the_Interrupt_Handler"> DOS/4GW:&nbsp; Getting the Address of the Interrupt Handler </H3>
<BR>When you signal Interrupt 21H, Function 35, it always returns a non-null address even if no other program of your bitness
(i.e., 16-bit or 32-bit) has hooked the interrupt.&nbsp; The address points to a dummy handler that looks to you as though
it does an IRET to end the chain.&nbsp; This means that you can't find an unused interrupt by looking for a NULL pointer.
&nbsp;Since this technique is most frequently used by programs that are looking for an unclaimed<B> real-mode</B> interrupt
on which to install a TSR, it shouldn't cause you problems.
<H1 ID="DOSD4GW__Interrupt_31H_DPMI_Functions"> DOS/4GW:&nbsp; Interrupt 31H DPMI Functions </H1>
<BR>When a<B> DOS/4GW</B> application runs under a DPMI host, such as Windows 3.1 in enhanced mode, an OS/2 virtual DOS machine,
386Max (with DEBUG=DPMIXCOPY), or QEMM/QDPMI (with EXTCHKOFF), the DPMI host provides the DPMI services, not<B> DOS/4GW</B>.
&nbsp;The DPMI host also provides virtual memory, if any.&nbsp; Performance (speed and memory use) under different DPMI hosts
varies greatly due to the quality of the DPMI implementation.
<BR><BR>DPMI services are accessed using Interrupt 31H.
<BR><BR>The following describes the services provided by<B> DOS/4GW</B> and DOS/4GW Professional in the absence of a DPMI
host.<B>&nbsp; DOS/4GW</B> supports many of the common DPMI system services.&nbsp; Not all of the services described below
are supported by other DPMI hosts.
<BR><BR>Some of the information in this chapter was obtained from the the DOS Protected-Mode Interface (DPMI) specification.
&nbsp;It is no longer in print; however the DPMI 1.0 specification can be obtained from the Intel ftp site.&nbsp; Here is
the URL.
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; ftp://ftp.intel.com/pub/IAL/software_specs/dpmiv1.zip</TT>
<BR><BR>This ZIP file contains a Postscript version of the DPMI 1.0 specification.
<H2 ID="DOSD4GW__Using_Interrupt_31H_Function_Calls"> DOS/4GW:&nbsp; Using Interrupt 31H Function Calls </H2>
<BR>Interrupt 31H DPMI function calls can be used only by protected-mode programs.
<BR><BR>The general ground rules for Interrupt 31H calls are as follows:
<UL>
<LI>All Interrupt 31H calls modify the AX register.&nbsp; Unsupported or unsuccessful calls return an error code in AX.&nbsp;
Other registers are saved unless they contain specified return values.
<LI>All Interrupt 31H calls modify flags:&nbsp; Unsupported or unsuccessful calls return with the carry flag set.&nbsp; Successful
calls clear the carry flag.&nbsp; Only memory management and interrupt flag management calls modify the interrupt flag.
<LI>Memory management calls can enable interrupts.
<LI>All calls are reentrant.
</UL>
<BR>The flag and register information for each call is listed in the following descriptions of supported Interrupt 31H function
calls.
<H2 ID="DOSD4GW__Int31H_Function_Calls"> DOS/4GW:&nbsp; Int31H Function Calls </H2>
<BR>The Interrupt 31H subfunction calls supported by<B> DOS/4GW</B> are listed below by category:
<UL>
<LI>Local Descriptor Table (LDT) management services
<LI>DOS memory management services
<LI>Interrupt services
<LI>Translation services
<LI>DPMI version
<LI>Memory management services
<LI>Page locking services
<LI>Demand paging performance tuning services
<LI>Physical address mapping
<LI>Virtual interrupt state functions
<LI>Vendor specific extensions
<LI>Coprocessor status
</UL>
<BR>Only the most commonly used Interrupt 31H function calls are supported in this version.
<H3 ID="DOSD4GW__Local_Descriptor_Table_LLDTR_Management_Services"> DOS/4GW:&nbsp; Local Descriptor Table (LDT) Management Services </H3>
<DL>
<DT>Function 0000H
<DD>This function allocates a specified number of descriptors from the LDT and returns the base selector.&nbsp; Pass the following
information:
<DL>
<DT>AX = 0000H
<DD>
<DT>CX = number of descriptors to be allocated
<DD>
</DL>
<BR>If the call succeeds, the carry flag is clear and the base selector is returned in AX.&nbsp; If the call fails, the carry
flag is set.
<BR><BR>An allocated descriptor is set to the present data type, with a base and limit of zero.&nbsp; The privilege level
of an allocated descriptor is set to match the code segment privilege level of the application.&nbsp; To find out the privilege
level of a descriptor, use the<TT> lar</TT> instruction.
<BR><BR>Allocated descriptors must be filled in by the application.&nbsp; If more than one descriptor is allocated, the returned
selector is the first of a contiguous array.&nbsp; Use Function 0003H to get the increment for the next selector in the array.
<DT>Function 0001H
<DD>This function frees the descriptor specified.&nbsp; Pass the following information:
<DL>
<DT>AX = 0001H
<DD>
<DT>BX = the selector to free
<DD>
</DL>
<BR>Use the selector returned with function 0000h when the descriptor was allocated.&nbsp; To free an array of descriptors,
call this function for each descriptor.&nbsp; Use Function 0003H to find out the increment for each descriptor in the array.
<BR><BR>If the call succeeds, the carry flag is clear; if it fails, the carry flag is set.
<BR><BR>You can use this function to free the descriptors allocated for the program's initial CS, DS, and SS segments, but
you should not free other segments that were not allocated with Function 0000H or Function 000DH.
<DT>Function 0002H
<DD>This function converts a real-mode segment to a descriptor that a protected-mode program can address.&nbsp; Pass the following
information:
<DL>
<DT>AX = 0002H
<DD>
<DT>BX = real-mode segment address
<DD>
</DL>
<BR>If the call succeeds, it clears the carry flag and returns the selector mapped to the real-mode segment in AX.&nbsp; If
the call fails, the carry flag is set.
<BR><BR>If you call this function more than once with the same real-mode segment address, you get the same selector value
each time.&nbsp; The descriptor limit is set to 64KB.
<BR><BR>The purpose of this function is to give protected-mode programs easy access to commonly used real-mode segments.&nbsp;
However, because you cannot modify or free descriptors created by this function, it should be used infrequently.&nbsp; Do
not use this function to get descriptors for private data areas.
<BR><BR>To examine real-mode addresses using the same selector, first allocate a descriptor, and then use Function 0007H to
change the linear base address.
<DT>Function 0003H
<DD>This function returns the increment value for the next selector.&nbsp; Use this function to get the value you add to the base
address of an allocated array of descriptors to get the next selector address.&nbsp; Pass the following information:
<DL>
<DT>AX = 0003H
<DD>
</DL>
<BR>This call always succeeds.&nbsp; The increment value is returned in AX.&nbsp; This value is always a power of two, but
no other assumptions can be made.
<DT>Function 0006H
<DD>This function gets the linear base address of a selector.&nbsp; Pass the following information:
<DL>
<DT>AX = 0006H
<DD>
<DT>BX = selector
<DD>
</DL>
<BR>If the call succeeds, the carry flag is clear and CX:DX contains the 32-bit linear base address of the segment.&nbsp;
If the call fails, it sets the carry flag.
<BR><BR>If the selector you specify in BX is invalid, the call fails.
<DT>Function 0007H
<DD>This function changes the base address of a specified selector.&nbsp; Only descriptors allocated through Function 0000H should
be modified.&nbsp; Pass the following information:
<DL>
<DT>AX = 0007H
<DD>
<DT>BX = selector
<DD>
<DT>CX:DX = the new 32-bit linear base address for the segment
<DD>
</DL>
<BR>If the call succeeds, the carry flag is clear; if unsuccessful, the carry flag is set.
<BR><BR>If the selector you specify in BX is invalid, the call fails.
<DT>Function 0008H
<DD>This function sets the upper limit of a specified segment.&nbsp; Use this function to modify descriptors allocated with Function
0000H only.&nbsp; Pass the following information:
<DL>
<DT>AX = 0008H
<DD>
<DT>BX = selector
<DD>
<DT>CX:DX = 32-bit segment limit
<DD>
</DL>
<BR>If the call succeeds, the carry flag is clear; if unsuccessful, the carry flag is set.
<BR><BR>The call fails if the specified selector is invalid, or if the specified limit cannot be set.
<BR><BR>Segment limits greater than 1MB must be page-aligned.&nbsp; This means that limits greater than 1MB must have the
low 12 bits set.
<BR><BR>To get the limit of a segment, use the 32-bit form of<TT> lsl</TT> for segment limits greater than 64KB.
<DT>Function 0009H
<DD>This function sets the descriptor access rights.&nbsp; Use this function to modify descriptors allocated with Function 0000H
only.&nbsp; To examine the access rights of a descriptor, use the<TT> lar</TT> instruction.&nbsp; Pass the following information:
<DL>
<DT>AX = 0009H
<DD>
<DT>BX = selector
<DD>
<DT>CL = Access rights/type byte
<DD>
<DT>CH = 386 extended access rights/type byte
<DD>
</DL>
<BR>If the call succeeds, the carry flag is clear; if unsuccessful, the carry flag is set.&nbsp; If the selector you specify
in BX is invalid, the call fails.&nbsp; The call also fails if the access rights/type byte does not match the format and meet
the requirements shown in the figures below.
<BR><BR>The access rights/type byte passed in CL has the format shown in the figure below.
<BR><BR><TT><IMG SRC="mem3.bmp" ALIGN=MIDDLE></TT>
<BR><B><I>Figure 3.</I></B><B><I></I></B><B> Access Rights/Type</B>
<BR><BR>The extended access rights/type byte passed in CH has the following format.
<BR><BR><TT><IMG SRC="mem4.bmp" ALIGN=MIDDLE></TT>
<BR><B><I>Figure 4.</I></B><B><I></I></B><B> Extended Access Rights/Type</B>
<DT>Function 000AH
<DD>This function creates an alias to a code segment.&nbsp; This function creates a data descriptor that has the same base and
limit as the specified code segment descriptor.&nbsp; Pass the following information:
<DL>
<DT>AX = 000AH
<DD>
<DT>BX = code segment selector
<DD>
</DL>
<BR>If the call succeeds, the carry flag is clear and the new data selector is returned in AX.&nbsp; If the call fails, the
carry flag is set.&nbsp; The call fails if the selector passed in BX is not a valid code segment.
<BR><BR>To deallocate an alias to a code segment, use Function 0001H.
<BR><BR>After the alias is created, it does not change if the code segment descriptor changes.&nbsp; For example, if the base
or limit of the code segment change later, the alias descriptor stays the same.
<DT>Function 000BH
<DD>This function copies the descriptor table entry for a specified descriptor.&nbsp; The copy is written into an 8-byte buffer.
&nbsp;Pass the following information:
<DL>
<DT>AX = 000BH
<DD>
<DT>BX = selector
<DD>
<DT>ES:EDI = a pointer to the 8-byte buffer for the descriptor copy
<DD>
</DL>
<BR>If the call succeeds, the carry flag is clear and ES:EDI contains a pointer to the buffer that contains a copy of the
descriptor.&nbsp; If the call fails, the carry flag is set.&nbsp; The call fails if the selector passed in BX is invalid or
unallocated.
<DT>Function 000CH
<DD>This function copies an 8-byte buffer into the LDT for a specified descriptor.&nbsp; The descriptor must first have been allocated
with Function 0000H.&nbsp; Pass the following information:
<DL>
<DT>AX = 000CH
<DD>
<DT>BX = selector
<DD>
<DT>ES:EDI = a pointer to the 8-byte buffer containing the descriptor
<DD>
</DL>
<BR>If the call succeeds, the carry flag is clear; if it fails, the carry flag is set.&nbsp; The call fails if the descriptor
passed in BX is invalid.
<BR>The type byte, byte 5, has the same format and requirements as the access rights/type byte passed to Function 0009H in
CL.&nbsp; The format is shown in the first figure presented with the description of Function 0009H.
<BR><BR>The extended type byte, byte 6, has the same format and requirements as the extended access rights/type byte passed
to Function 0009H in CH, except that the limit field can have any value, and the low order bits marked<B> reserved</B> are
used to set the upper 4 bits of the descriptor limit.&nbsp; The format is shown in the second figure presented with the description
of Function 0009H.
<DT>Function 000DH
<DD>This function allocates a specific LDT descriptor.&nbsp; Pass the following information:
<DL>
<DT>AX = 000DH
<DD>
<DT>BX = selector
<DD>
</DL>
<BR>If the call succeeds, the carry flag is clear and the specified descriptor is allocated.&nbsp; If the call fails, the
carry flag is set.
<BR><BR>The call fails if the specified selector is already in use, or if it is not a valid LDT descriptor.&nbsp; The first
10h (16 decimal) descriptors are reserved for this function, and should not be used by the host.&nbsp; Some of these descriptors
may be in use, however, if another client application is already loaded.
<BR><BR>To free the descriptor, use Function 0001H.
</DL>
<H3 ID="DOSD4GW__DOS_Memory_Management_Services"> DOS/4GW:&nbsp; DOS Memory Management Services </H3>
<DL>
<DT>Function 0100H
<DD>This function allocates memory from the DOS free memory pool.&nbsp; This function returns both the real-mode segment and one
or more descriptors that can be used by protected-mode applications.&nbsp; Pass the following information:
<DL>
<DT>AX = 0100H
<DD>
<DT>BX = the number of paragraphs (16-byte blocks) requested
<DD>
</DL>
<BR>If the call succeeds, the carry flag is clear.&nbsp; AX contains the initial real-mode segment of the allocated block
and DX contains the base selector for the allocated block.
<BR><BR>If the call fails, the carry flag is set.&nbsp; AX contains the DOS error code.&nbsp; If memory is damaged, code 07H
is returned.&nbsp; If there is not enough memory to satisfy the request, code 08H is returned.&nbsp; BX contains the number
of paragraphs in the largest available block of DOS memory.
<BR><BR>If you request a block larger than 64KB, contiguous descriptors are allocated.&nbsp; Use Function 0003H to find the
value of the increment to the next descriptor.&nbsp; The limit of the first descriptor is set to the entire block.&nbsp; Subsequent
descriptors have a limit of 64KB, except for the final descriptor, which has a limit of<TT> blocksize MOD 64KB.</TT>
<BR><BR>You cannot modify or deallocate descriptors allocated with this function.&nbsp; Function 101H deallocates the descriptors
automatically.
<DT>Function 0101H
<DD>This function frees a DOS memory block allocated with function 0100H.&nbsp; Pass the following information:
<DL>
<DT>AX = 0101H
<DD>
<DT>DX = selector of the block to be freed
<DD>
</DL>
<BR>If the call succeeds, the carry flag is clear.
<BR><BR>If the call fails, the carry flag is set and the DOS error code is returned in AX.&nbsp; If the incorrect segment
was specified, code 09H is returned.&nbsp; If memory control blocks are damaged, code 07H is returned.
<BR><BR>All descriptors allocated for the specified memory block are deallocated automatically and cannot be accessed correctly
after the block is freed.
<DT>Function 0102H
<DD>This function resizes a DOS memory block allocated with function 0100H.&nbsp; Pass the following information:
<DL>
<DT>AX = 0102H
<DD>
<DT>BX = the number of paragraphs (16-byte blocks) in the resized block
<DD>
<DT>DX = selector of block to resize
<DD>
</DL>
<BR>If the call succeeds, the carry flag is clear.
<BR><BR>If the call fails, the carry flag is set, the maximum number of paragraphs available is returned in BX, and the DOS
error code is returned in AX.&nbsp; If memory code blocks are damaged, code 07H is returned.&nbsp; If there isn't enough memory
to increase the size as requested, code 08H is returned.&nbsp; If the incorrect segment is specified, code 09h is returned.
<BR><BR>Because of the difficulty of finding additional contiguous memory or descriptors, this function is not often used
to increase the size of a memory block.&nbsp; Increasing the size of a memory block might well fail because other DOS allocations
have used contiguous space.&nbsp; If the next descriptor in the LDT is not free, allocation also fails when the size of a
block grows over the 64KB boundary.
<BR><BR>If you shrink the size of a memory block, you may also free some descriptors allocated to the block.&nbsp; The initial
selector remains unchanged, however; only the limits of subsequent selectors will change.
</DL>
<H3 ID="DOSD4GW__Interrupt_Services"> DOS/4GW:&nbsp; Interrupt Services </H3>
<DL>
<DT>Function 0200H
<DD>This function gets the value of the current task's real-mode interrupt vector for the specified interrupt.&nbsp; Pass the
following information:
<DL>
<DT>AX = 0200H
<DD>
<DT>BL = interrupt number
<DD>
</DL>
<BR>This call always succeeds.&nbsp; All 100H (256 decimal) interrupt vectors are supported by the host.&nbsp; When the call
returns, the carry flag is clear, and the<TT> segment:offset</TT> of the real-mode interrupt handler is returned in CX:DX.
<BR><BR>Because the address returned in CX is a segment, and not a selector, you cannot put it into a protected-mode segment
register.&nbsp; If you do, a general protection fault may occur.
<DT>Function 0201H
<DD>This function sets the value of the current task's real-mode interrupt vector for the specified interrupt.&nbsp; Pass the
following information:
<DL>
<DT>AX = 0201H
<DD>
<DT>BL = interrupt number
<DD>
<DT>CX:DX = segment:offset of the real-mode interrupt handler
<DD>
</DL>
<BR>If the call succeeds, the carry flag is clear; if it fails, the carry flag is set.
<BR><BR>The address passed in CX:DX should be a real-mode<TT> segment:offset,</TT> such as function 0200H returns.&nbsp; For
this reason, the interrupt handler must reside in DOS addressable memory.&nbsp; You can use Function 0100H to allocate DOS
memory.&nbsp; This version does not support the real-mode callback address function.
<BR><BR>If you are hooking a hardware interrupt, you have to lock all segments involved.&nbsp; These segments include the
segment in which the interrupt handler runs, and any segment it may touch at interrupt time.
<DT>Function 0202H
<DD>This function gets the processor exception handler vector.&nbsp; This function returns the CS:EIP of the current protected-mode
exception handler for the specified exception number.&nbsp; Pass the following information:
<DL>
<DT>AX = 0202H
<DD>
<DT>BL = exception/fault number (00h - 1Fh)
<DD>
</DL>
<BR>If the call succeeds, the carry flag is clear and the<TT> selector:offset</TT> of the protected-mode exception handler
is returned in CX:EDX.&nbsp; If it fails, the carry flag is set.
<BR><BR>The value returned in CX is a valid protected-mode selector, not a real-mode segment.
<DT>Function 0203H
<DD>This function sets the processor exception handler vector.&nbsp; This function allows protected-mode applications to intercept
processor exceptions that are not handled by the DPMI environment.&nbsp; Programs may wish to handle exceptions such as &quot;not
present segment faults&quot; which would otherwise generate a fatal error.&nbsp; Pass the following information:
<DL>
<DT>AX = 0203H
<DD>
<DT>BL = exception/fault number (00h - 1Fh)
<DD>
<DT>CX:EDX = selector:offset of the exception handler
<DD>
</DL>
<BR>If the call succeeds, the carry flag is clear.&nbsp; If it fails, the carry flag is set.
<BR><BR>The address passed in CX must be a valid protected-mode selector, such as Function 204H returns, and not a real-mode
segment.&nbsp; A 32-bit implementation must supply a 32-bit offset in the EDX register.&nbsp; If the handler chains to the
next handler, it must use a 32-bit interrupt stack frame to do so.
<BR><BR>The handler should return using a far return instruction.&nbsp; The original SS:ESP, CS:EIP and flags on the stack,
including the interrupt flag, will be restored.
<BR><BR>All fault stack frames have an error code.&nbsp; However the error code is only valid for exceptions 08h, 0Ah, 0Bh,
0Ch, 0Dh, and 0Eh.
<BR><BR>The handler must preserve and restore all registers.
<BR><BR>The exception handler will be called on a locked stack with interrupts disabled.&nbsp; The original SS, ESP, CS, and
EIP will be pushed on the exception handler stack frame.
<BR><BR>The handler must either return from the call by executing a far return or jump to the next handler in the chain (which
will execute a far return or chain to the next handler).
<BR><BR>The procedure can modify any of the values on the stack pertaining to the exception before returning.&nbsp; This can
be used, for example, to jump to a procedure by modifying the CS:EIP on the stack.&nbsp; Note that the procedure must not
modify the far return address on the stack - it must return to the original caller.&nbsp; The caller will then restore the
flags, CS:EIP and SS:ESP from the stack frame.
<BR><BR>If the DPMI client does not handle an exception, or jumps to the default exception handler, the host will reflect
the exception as an interrupt for exceptions 0, 1, 2, 3, 4, 5 and 7.&nbsp; Exceptions 6 and 8 - 1Fh will be treated as fatal
errors and the client will be terminated.
<BR><BR>Exception handlers will only be called for exceptions that occur in protected mode.
<DT>Function 0204H
<DD>This function gets the CS:EIP<TT> selector:offset</TT> of the current protected-mode interrupt handler for a specified interrupt
number.&nbsp; Pass the following information:
<DL>
<DT>AX = 0204H
<DD>
<DT>BL = interrupt number
<DD>
</DL>
<BR>This call always succeeds.&nbsp; All 100H (256 decimal) interrupt vectors are supported by the host.&nbsp; When the call
returns, the carry flag is clear and CX:EDX contains the protected-mode<TT> selector:offset</TT> of the exception handler.
<BR><BR>A 32-bit offset is returned in the EDX register.
<DT>Function 0205H
<DD>This function sets the address of the specified protected-mode interrupt vector.&nbsp; Pass the following information:
<DL>
<DT>AX = 0205H
<DD>
<DT>BL = interrupt number
<DD>
<DT>CX:EDX = selector:offset of the exception handler
<DD>
</DL>
<BR>If the call succeeds, the carry flag is clear; if it fails, the carry flag is set.
<BR><BR>The address passed in CX must be a valid protected-mode selector, such as Function 204H returns, and not a real-mode
segment.&nbsp; A 32-bit implementation must supply a 32-bit offset in the EDX register.&nbsp; If the handler chains to the
next handler, it must use a 32-bit interrupt stack frame to do so.
</DL>
<H3 ID="DOSD4GW__Translation_Services"> DOS/4GW:&nbsp; Translation Services </H3>
<BR>These services are provided so that protected-mode programs can call real-mode software that DPMI does not support directly.
&nbsp;The protected-mode program must set up a data structure with the appropriate register values.&nbsp; This &quot;real-mode
call structure&quot; is shown below.
<BR><BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Offset&nbsp; Register&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;

<BR><BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 00H&nbsp;&nbsp;&nbsp;&nbsp; EDI&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
<BR><BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 04H&nbsp;&nbsp;&nbsp;&nbsp; ESI&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
<BR><BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 08H&nbsp;&nbsp;&nbsp;&nbsp; EBP&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
<BR><BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0CH&nbsp;&nbsp;&nbsp;&nbsp; Reserved by system&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
<BR><BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 10H&nbsp;&nbsp;&nbsp;&nbsp; EBX&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
<BR><BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 14H&nbsp;&nbsp;&nbsp;&nbsp; EDX&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
<BR><BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 18H&nbsp;&nbsp;&nbsp;&nbsp; ECX&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
<BR><BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 1CH&nbsp;&nbsp;&nbsp;&nbsp; EAX&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
<BR><BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 20H&nbsp;&nbsp;&nbsp;&nbsp; Flags&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp; 
<BR><BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 22H&nbsp;&nbsp;&nbsp;&nbsp; ES&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
<BR><BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 24H&nbsp;&nbsp;&nbsp;&nbsp; DS&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
<BR><BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 26H&nbsp;&nbsp;&nbsp;&nbsp; FS&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
<BR><BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 28H&nbsp;&nbsp;&nbsp;&nbsp; GS&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
<BR><BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 2AH&nbsp;&nbsp;&nbsp;&nbsp; IP&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
<BR><BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 2CH&nbsp;&nbsp;&nbsp;&nbsp; CS&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
<BR><BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 2EH&nbsp;&nbsp;&nbsp;&nbsp; SP&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
<BR><BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 30H&nbsp;&nbsp;&nbsp;&nbsp; SS&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
<BR><BR>After the call or interrupt is complete, all real-mode registers and flags except SS, SP, CS, and IP will be copied
back to the real-mode call structure so that the caller can examine the real-mode return values.
<BR><BR>The values in the segment registers should be real-mode segments, not protected-mode selectors.
<BR><BR>The translation services will provide a real-mode stack if the SS:SP fields are zero.&nbsp; However, the stack provided
is relatively small.&nbsp; If the real-mode procedure/interrupt routine uses more than 30 words of stack space then you should
provide your own real-mode stack.
<DL>
<DT>Function 0300H
<DD>This function simulates a real-mode interrupt.&nbsp; This function simulates an interrupt in real mode.&nbsp; It will invoke
the CS:IP specified by the real-mode interrupt vector and the handler must return by executing an<TT> iret.</TT>&nbsp; Pass
the following information:
<DL>
<DT>AX = 0300H
<DD>
<DT>BL = interrupt number
<DD>
<DT>BH = flags
<DD>Bit 0 = 1 resets the interrupt controller and A20 line.&nbsp; Other flags are reserved and must be 0.
<DT>CX = number of words to copy from protected-mode stack to real-mode stack
<DD>
<DT>ES:EDI = the selector:offset of real-mode call structure
<DD>
</DL>
<BR>If the call fails, the carry flag is set.
<BR><BR>If the call succeeds, the carry flag is clear and ES:EDI contains the<TT> selector:offset</TT> of the modified real-mode
call structure.
<BR><BR>The CS:IP in the real-mode call structure is ignored by this service.&nbsp; The appropriate interrupt handler will
be called based on the value passed in BL.
<BR><BR>The flags specified in the real-mode call structure will be pushed on the real-mode stack<TT> iret</TT> frame.&nbsp;
The interrupt handler will be called with the interrupt and trace flags clear.
<BR><BR>It is up to the caller to remove any parameters that were pushed on the protected-mode stack.
<BR><BR>The flag to reset the interrupt controller and the A20 line is ignored by DPMI implementations that run in Virtual
8086 mode.&nbsp; It causes DPMI implementations that return to real mode to set the interrupt controller and A20 address line
hardware to its normal real-mode state.
<DT>Function 0301H
<DD>(DOS/4GW Professional only) This function calls a real-mode procedure with a FAR return frame.&nbsp; The called procedure
must execute a FAR return when it completes.&nbsp; Pass the following information:
<DL>
<DT>AX = 0301H
<DD>
<DT>BH = flags
<DD>Bit 0 = 1 resets the interrupt controller and A20 line.&nbsp; Other flags reserved and must be 0.
<DT>CX = Number of words to copy from protected-mode to real-mode stack
<DD>
<DT>ES:EDI = selector:offset of real-mode call structure
<DD>
</DL>
<BR>If the call succeeds, the carry flag is clear and ES:EDI contains the<TT> selector:offset</TT> of modified real-mode call
structure.
<BR><BR>If the call fails, the carry flag is set.
<BR><BR><B>Notes:</B>
<OL>
<LI>The CS:IP in the real-mode call structure specifies the address of the real-mode procedure to call.
<LI>The real-mode procedure must execute a FAR return when it has completed.
<LI>If the SS:SP fields are zero then a real-mode stack will be provided by the DPMI host.&nbsp; Otherwise, the real-mode
SS:SP will be set to the specified values before the procedure is called.
<LI>When the Int 31h returns, the real-mode call structure will contain the values that were returned by the real-mode procedure.
<LI>It is up to the caller to remove any parameters that were pushed on the protected-mode stack.
<LI>The flag to reset the interrupt controller and A20 line is ignored by DPMI implementations that run in Virtual 8086 mode.
&nbsp;It causes DPMI implementations that return to real mode to set the interrupt controller and A20 address line hardware
to its normal real-mode state.
</OL>
<DT>Function 0302H
<DD>(DOS/4GW Professional only) This function calls a real-mode procedure with an<TT> iret</TT> frame.&nbsp; The called procedure
must execute an<TT> iret</TT> when it completes.&nbsp; Pass the following information:
<DL>
<DT>AX = 0302H
<DD>
<DT>BH = flags
<DD>Bit 0 = 1 resets the interrupt controller and A20 line.&nbsp; Other flags reserved and must be 0.
<DT>CX = Number of words to copy from protected-mode to real-mode stack
<DD>
<DT>ES:EDI = selector:offset of real-mode call structure
<DD>
</DL>
<BR>If the call succeeds, the carry flag is clear and ES:EDI contains the<TT> selector:offset</TT> of modified real-mode call
structure.
<BR><BR>If the call fails, the carry flag is set.
<BR><BR><B>Notes:</B>
<OL>
<LI>The CS:IP in the real-mode call structure specifies the address of the real-mode procedure to call.
<LI>The real-mode procedure must execute an<TT> iret</TT> when it has completed.
<LI>If the SS:SP fields are zero then a real-mode stack will be provided by the DPMI host.&nbsp; Otherwise, the real-mode
SS:SP will be set to the specified values before the procedure is called.
<LI>When the Int 31h returns, the real-mode call structure will contain the values that were returned by the real-mode procedure.
<LI>The flags specified in the real-mode call structure will be pushed the real-mode stack<TT> iret</TT> frame.&nbsp; The
procedure will be called with the interrupt and trace flags clear.
<LI>It is up to the caller to remove any parameters that were pushed on the protected-mode stack.
<LI>The flag to reset the interrupt controller and A20 line is ignored by DPMI implementations that run in Virtual 8086 mode.
&nbsp;It causes DPMI implementations that return to real mode to set the interrupt controller and A20 address line hardware
to its normal real-mode state.
</OL>
<DT>Function 0303H
<DD>(DOS/4GW Professional only) This function allocates a real-mode callback address.&nbsp; This service is used to obtain a unique
real-mode SEG:OFFSET that will transfer control from real mode to a protected-mode procedure.
<BR><BR>At times it is necessary to hook a real-mode interrupt or device callback in a protected-mode driver.&nbsp; For example,
many mouse drivers call an address whenever the mouse is moved.&nbsp; Software running in protected mode can use a real-mode
callback to intercept the mouse driver calls.&nbsp; Pass the following information:
<DL>
<DT>AX = 0303H
<DD>
<DT>DS:ESI = selector:offset of procedure to call
<DD>
<DT>ES:EDI = selector:offset of real-mode call structure
<DD>
</DL>
<BR>If the call succeeds, the carry flag is clear and CX:DX contains the<TT> segment:offset</TT> of real-mode callback address.
<BR><BR>If the call fails, the carry flag is set.
<DL>
<DT>Callback Procedure Parameters
<DD>
<BR><BR>&nbsp;&nbsp;&nbsp;&nbsp; Interrupts disabled
<BR>&nbsp;&nbsp;&nbsp;&nbsp; DS:ESI = selector:offset of real-mode SS:SP
<BR>&nbsp;&nbsp;&nbsp;&nbsp; ES:EDI = selector:offset of real-mode call structure
<BR>&nbsp;&nbsp;&nbsp;&nbsp; SS:ESP = Locked protected-mode API stack
<BR>&nbsp;&nbsp;&nbsp;&nbsp; All other registers undefined
<DT>Return from Callback Procedure
<DD>
<BR><BR>&nbsp;&nbsp;&nbsp;&nbsp; Execute an IRET to return
<BR>&nbsp;&nbsp;&nbsp;&nbsp; ES:EDI =&nbsp; selector:offset of real-mode call structure
<BR>&nbsp;&nbsp;&nbsp;&nbsp; to restore (see note)
</DL>
<BR><B>Notes:</B>
<OL>
<LI>Since the real-mode call structure is static, you must be careful when writing code that may be reentered.&nbsp; The simplest
method of avoiding reentrancy is to leave interrupts disabled throughout the entire call.&nbsp; However, if the amount of
code executed by the callback is large then you will need to copy the real-mode call structure into another buffer.&nbsp;
You can then return with ES:EDI pointing to the buffer you copied the data to - it does not have to point to the original
real mode call structure.
<LI>The called procedure is responsible for modifying the real-mode CS:IP before returning.&nbsp; If the real-mode CS:IP is
left unchanged then the real-mode callback will be executed immediately and your procedure will be called again.&nbsp; Normally
you will want to pop a return address off of the real-mode stack and place it in the real-mode CS:IP.&nbsp; The example code
in the next section demonstrates chaining to another interrupt handler and simulating a real-mode<TT> iret.</TT>
<LI>To return values to the real-mode caller, you must modify the real-mode call structure.
<LI>Remember that all segment values in the real-mode call structure will contain real-mode segments, not selectors.&nbsp;
If you need to examine data pointed to by a real-mode seg:offset pointer, you should not use the segment to selector service
to create a new selector.&nbsp; Instead, allocate a descriptor during initialization and change the descriptor's base to 16
times the real-mode segment's value.&nbsp; This is important since selectors allocated though the segment to selector service
can never be freed.
<LI>DPMI hosts should provide a minimum of 16 callback addresses per task.
</OL>
<BR>The following code is a sample of a real-mode interrupt hook.&nbsp; It hooks the DOS Int 21h and returns an error for
the delete file function (AH=41h).&nbsp; Other calls are passed through to DOS.&nbsp; This example is somewhat silly but it
demonstrates the techniques used to hook a real mode interrupt.&nbsp; Note that since DOS calls are reflected from protected
mode to real mode, the following code will intercept all DOS calls from both real mode and protected mode.
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; ;******************************************************</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; ; This procedure gets the current Int 21h real-mode</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; ; Seg:Offset, allocates a real-mode callback address,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; ; and sets the real-mode Int 21h vector to the call-</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; ; back address.</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; ;******************************************************</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Initialization_Code:</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; ;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; ; Create a code segment alias to save data in</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; ;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mov&nbsp;&nbsp;&nbsp;&nbsp; ax, 000Ah</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mov&nbsp;&nbsp;&nbsp;&nbsp; bx, cs</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int&nbsp;&nbsp;&nbsp;&nbsp; 31h</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; jc&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ERROR</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mov&nbsp;&nbsp;&nbsp;&nbsp; ds, ax</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ASSUMES DS,_TEXT</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; ;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; ; Get current Int 21h real-mode SEG:OFFSET</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; ;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mov&nbsp;&nbsp;&nbsp;&nbsp; ax, 0200h</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mov&nbsp;&nbsp;&nbsp;&nbsp; bl, 21h</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int&nbsp;&nbsp;&nbsp;&nbsp; 31h</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; jc&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ERROR</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mov&nbsp;&nbsp;&nbsp;&nbsp; [Orig_Real_Seg],
cx</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mov&nbsp;&nbsp;&nbsp;&nbsp; [Orig_Real_Offset],
dx</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; ;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; ; Allocate a real-mode callback</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; ;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mov&nbsp;&nbsp;&nbsp;&nbsp; ax, 0303h</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; push&nbsp;&nbsp;&nbsp; ds</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mov&nbsp;&nbsp;&nbsp;&nbsp; bx, cs</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mov&nbsp;&nbsp;&nbsp;&nbsp; ds, bx</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mov&nbsp;&nbsp;&nbsp;&nbsp; si, OFFSET My_Int_21_Hook</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pop&nbsp;&nbsp;&nbsp;&nbsp; es</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mov&nbsp;&nbsp;&nbsp;&nbsp; di, OFFSET My_Real_Mode_Call_Struc</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int&nbsp;&nbsp;&nbsp;&nbsp; 31h</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; jc&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ERROR</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; ;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; ; Hook real-mode int 21h with the callback address</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; ;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mov&nbsp;&nbsp;&nbsp;&nbsp; ax, 0201h</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mov&nbsp;&nbsp;&nbsp;&nbsp; bl, 21h</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int&nbsp;&nbsp;&nbsp;&nbsp; 31h</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; jc&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ERROR</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; ;******************************************************</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; ;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; ; This is the actual Int 21h hook code.&nbsp; It will return</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; ; an &quot;access denied&quot; error for all calls made in real</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; ; mode to delete a file.&nbsp; Other calls will be passed</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; ; through to DOS.</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; ;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; ; ENTRY:</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; ;&nbsp;&nbsp;&nbsp; DS:SI -&gt; Real-mode SS:SP</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; ;&nbsp;&nbsp;&nbsp; ES:DI -&gt; Real-mode call structure</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; ;&nbsp;&nbsp;&nbsp; Interrupts disabled</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; ;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; ; EXIT:</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; ;&nbsp;&nbsp;&nbsp; ES:DI -&gt; Real-mode call structure</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; ;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; ;******************************************************</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; My_Int_21_Hook:</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cmp&nbsp;&nbsp;&nbsp;&nbsp; es:[di.RealMode_AH],
41h</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; jne&nbsp;&nbsp;&nbsp;&nbsp; Chain_To_DOS</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; ;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; ; This is a delete file call (AH=41h).&nbsp; Simulate an</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; ; iret on the real-mode stack, set the real-mode</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; ; carry flag, and set the real-mode AX to 5 to indicate</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; ; an access denied error.</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; ;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cld</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; lodsw&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ; Get real-mode ret IP</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mov&nbsp;&nbsp;&nbsp;&nbsp; es:[di.RealMode_IP],
ax</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; lodsw&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ; Get real-mode ret CS</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mov&nbsp;&nbsp;&nbsp;&nbsp; es:[di.RealMode_CS],
ax</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; lodsw&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ; Get real-mode flags</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; or&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ax, 1&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ; Set carry flag</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mov&nbsp;&nbsp;&nbsp;&nbsp; es:[di.RealMode_Flags],
ax</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; add&nbsp;&nbsp;&nbsp;&nbsp; es:[di.RealMode_SP],
6</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mov&nbsp;&nbsp;&nbsp;&nbsp; es:[di.RealMode_AX],
5</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; jmp&nbsp;&nbsp;&nbsp;&nbsp; My_Hook_Exit</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; ;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; ; Chain to original Int 21h vector by replacing the</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; ; real-mode CS:IP with the original Seg:Offset.</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; ;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Chain_To_DOS:</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mov&nbsp;&nbsp;&nbsp;&nbsp; ax, cs:[Orig_Real_Seg]</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mov&nbsp;&nbsp;&nbsp;&nbsp; es:[di.RealMode_CS],
ax</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mov&nbsp;&nbsp;&nbsp;&nbsp; ax, cs:[Orig_Real_Offset]</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mov&nbsp;&nbsp;&nbsp;&nbsp; es:[di.RealMode_IP],
ax</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; My_Hook_Exit:</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; iret</TT>
<DT>Function 0304H
<DD>(DOS/4GW Professional only) This function frees a real-mode callback address that was allocated through the allocate real-mode
callback address service.&nbsp; Pass the following information:
<DL>
<DT>AX = 0304H
<DD>
<DT>CX:DX = Real-mode callback address to free
<DD>
</DL>
<BR>If the call succeeds, the carry flag is clear; if it fails, the carry flag is set.
<BR><BR><B>Notes:</B>
<OL>
<LI>Real-mode callbacks are a limited resource.&nbsp; Your code should free any break point that it is no longer using.
</OL>
</DL>
<H3 ID="DOSD4GW__DPMI_Version"> DOS/4GW:&nbsp; DPMI Version </H3>
<DL>
<DT>Function 0400H
<DD>This function returns the version of DPMI services supported.&nbsp; Note that this is not necessarily the version of any operating
system that supports DPMI.&nbsp; It should be used by programs to determine what calls are legal in the current environment.
&nbsp;Pass the following information:
<DL>
<DT>AX = 0400H
<DD>
</DL>
<BR>The information returned is:
<DL>
<DT>AH = Major version
<DD>
<DT>AL = Minor version
<DD>
<DT>BX = Flags
<DD>Bit 0 = 1 if running under an 80386 DPMI implementation.&nbsp; Bit 1 = 1 if processor is returned to real mode for reflected
interrupts (as opposed to Virtual 8086 mode).&nbsp; Bit 2 = 1 if virtual memory is supported.&nbsp; Bit 3 is reserved and
undefined.&nbsp; All other bits are zero and reserved for later use.
<DT>CL = Processor type
<DD>
<BR><BR>&nbsp;&nbsp;&nbsp;&nbsp; 02 = 80286
<BR>&nbsp;&nbsp;&nbsp;&nbsp; 03 = 80386
<BR>&nbsp;&nbsp;&nbsp;&nbsp; 04 = 80486
<BR>&nbsp;&nbsp;&nbsp;&nbsp; 05 = Pentium
<DT>DH = Current value of virtual master PIC base interrupt
<DD>
<DT>DL = Current value of virtual slave PIC base interrupt
<DD>
<DT>Carry flag clear (call cannot fail)
<DD>
</DL>
</DL>
<H3 ID="DOSD4GW__Memory_Management_Services"> DOS/4GW:&nbsp; Memory Management Services </H3>
<DL>
<DT>Function 0500H
<DD>This function gets information about free memory.&nbsp; Pass the following information:
<DL>
<DT>AX = 0500H
<DD>
<DT>ES:EDI = the selector:offset of a 30H byte buffer.
<DD>
</DL>
<BR>If the call fails, the carry flag is set.
<BR><BR>If the call succeeds, the carry flag is clear and ES:EDI contains the<TT> selector:offset</TT> of a buffer with the
structure shown in the figure below.
<BR><BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Offset&nbsp; Description&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;

<BR><BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 00H&nbsp;&nbsp;&nbsp;&nbsp; Largest available block,
in bytes&nbsp;&nbsp;&nbsp;&nbsp; 
<BR><BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 04H&nbsp;&nbsp;&nbsp;&nbsp; Maximum unlocked page
allocation&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
<BR><BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 08H&nbsp;&nbsp;&nbsp;&nbsp; Largest block of memory
(in pages) that
<BR>could&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; be
allocated and then locked&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
<BR><BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0CH&nbsp;&nbsp;&nbsp;&nbsp; Total linear address
space size, in pages,
<BR>including&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; already
allocated pages&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
<BR><BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 10H&nbsp;&nbsp;&nbsp;&nbsp; Total number of free
pages and pages&nbsp; 
<BR>currently&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; unlocked
and available for paging out 
<BR><BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 14H&nbsp;&nbsp;&nbsp;&nbsp; Number of physical
pages not in use&nbsp;&nbsp; 
<BR><BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 18H&nbsp;&nbsp;&nbsp;&nbsp; Total number of physical
pages managed by host
<BR><BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 1CH&nbsp;&nbsp;&nbsp;&nbsp; Free linear address
space, in pages&nbsp;&nbsp; 
<BR><BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 20H&nbsp;&nbsp;&nbsp;&nbsp; Size of paging/file
partition, in pages
<BR><BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 24H -&nbsp;&nbsp; Reserved&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp; 
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 2FH&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
<BR><BR>Only the first field of the structure is guaranteed to contain a valid value.&nbsp; Any field that is not returned
by<B> DOS/4GW</B> is set to -1 (0FFFFFFFFH).
<DT>Function 0501H
<DD>This function allocates and commits linear memory.&nbsp; Pass the following information:
<DL>
<DT>AX = 0501H
<DD>
<DT>BX:CX = size of memory to allocate, in bytes.
<DD>
</DL>
<BR>If the call succeeds, the carry flag is clear, BX:CX contains the linear address of the allocated memory, and SI:DI contains
the memory block handle used to free or resize the block.&nbsp; If the call fails, the carry flag is set.
<BR><BR>No selectors are allocated for the memory block.&nbsp; The caller must allocate and initialize selectors needed to
access the memory.
<BR><BR>If VMM is present, the memory is allocated as unlocked, page granular blocks.&nbsp; Because of the page granularity,
memory should be allocated in multiples of 4KB.
<DT>Function 0502H
<DD>This function frees a block of memory allocated through function 0501H.&nbsp; Pass the following information:
<DL>
<DT>AX = 0502H
<DD>
<DT>SI:DI = handle returned with function 0501H when memory was allocated
<DD>
</DL>
<BR>If the call succeeds, the carry flag is clear; if it fails, the carry flag is set.&nbsp; You must also free any selectors
allocated to point to the freed memory block.
<DT>Function 0503H
<DD>This function resizes a block of memory allocated through the 0501H function.&nbsp; If you resize a block of linear memory,
it may have a new linear address and a new handle.&nbsp; Pass the following information:
<DL>
<DT>AX = 0503H
<DD>
<DT>BX:CX = new size of memory block, in bytes
<DD>
<DT>SI:DI = handle returned with function 0501H when memory was allocated
<DD>
</DL>
<BR>If the call succeeds, the carry flag is clear, BX:CX contains the new linear address of the memory block, and SI:DI contains
the new handle of the memory block.&nbsp; If the call fails, the carry flag is set.
<BR><BR>If either the linear address or the handle has changed, update the selectors that point to the memory block.&nbsp;
Use the new handle instead of the old one.
<BR><BR>You cannot resize a memory block to zero bytes.
</DL>
<H3 ID="DOSD4GW__Page_Locking_Services"> DOS/4GW:&nbsp; Page Locking Services </H3>
<BR>These services are only useful under DPMI implementations that support virtual memory.&nbsp; Although memory ranges are
specified in bytes, the actual unit of memory that will be locked will be one or more pages.&nbsp; Page locks are maintained
as a count.&nbsp; When the count is decremented to zero, the page is unlocked and can be swapped to disk.&nbsp; This means
that if a region of memory is locked three times then it must be unlocked three times before the pages will be unlocked.
<DL>
<DT>Function 0600H
<DD>This function locks a specified linear address range.&nbsp; Pass the following information:
<DL>
<DT>AX = 0600H
<DD>
<DT>BX:CX = starting linear address of memory to lock
<DD>
<DT>SI:DI = size of region to lock (in bytes)
<DD>
</DL>
<BR>If the call fails, the carry flag is set and none of the memory will be locked.
<BR><BR>If the call succeeds, the carry flag is clear.&nbsp; If the specified region overlaps part of a page at the beginning
or end of a region, the page(s) will be locked.
<DT>Function 0601H
<DD>This function unlocks a specified linear address range that was previously locked using the &quot;lock linear region&quot;
function (0600h).&nbsp; Pass the following information:
<DL>
<DT>AX = 0601H
<DD>
<DT>BX:CX = starting linear address of memory to unlock
<DD>
<DT>SI:DI = size of region to unlock (in bytes)
<DD>
</DL>
<BR>If the call fails, the carry flag is set and none of the memory will be unlocked.&nbsp; An error will be returned if the
memory was not previously locked or if the specified region is invalid.
<BR><BR>If the call succeeds, the carry flag is clear.&nbsp; If the specified region overlaps part of a page at the beginning
or end of a region, the page(s) will be unlocked.&nbsp; Even if the call succeeds, the memory will remain locked if the lock
count is not decremented to zero.
<DT>Function 0604H
<DD>This function gets the page size for Virtual Memory (VM) only.&nbsp; This function returns the size of a single memory page
in bytes.&nbsp; Pass the following information:
<DL>
<DT>AX = 0604H
<DD>
</DL>
<BR>If the call succeeds, the carry flag is clear and BX:CX = Page size in bytes.
<BR><BR>If the call fails, the carry flag is set.
</DL>
<H3 ID="DOSD4GW__Demand_Paging_Performance_Tuning_Services"> DOS/4GW:&nbsp; Demand Paging Performance Tuning Services </H3>
<BR>Some applications will discard memory objects or will not access objects for long periods of time.&nbsp; These services
can be used to improve the performance of demand paging.
<BR><BR>Although these functions are only relevant for DPMI implementations that support virtual memory, other implementations
will ignore these functions (it will always return carry clear).&nbsp; Therefore your code can always call these functions
regardless of the environment it is running under.
<BR><BR>Since both of these functions are simply advisory functions, the operating system may choose to ignore them.&nbsp;
In any case, your code should function properly even if the functions fail.
<DL>
<DT>Function 0702H
<DD>(DOS/4GW Professional only) This function marks a page as a demand paging candidate.&nbsp; This function is used to inform
the operating system that a range of pages should be placed at the head of the page out candidate list.&nbsp; This will force
these pages to be swapped to disk ahead of other pages even if the memory has been accessed recently.&nbsp; However, all memory
contents will be preserved.
<BR><BR>This is useful, for example, if a program knows that a given piece of data will not be accessed for a long period
of time.&nbsp; That data is ideal for swapping to disk since the physical memory it now occupies can be used for other purposes.
&nbsp;Pass the following information:
<DL>
<DT>AX = 0702H
<DD>
<DT>BX:CX = Starting linear address of pages to mark
<DD>
<DT>SI:DI = Number of bytes to mark as paging candidates
<DD>
</DL>
<BR>If the call succeeds, the carry flag is clear; if it fails, the carry flag is set.
<BR><BR><B>Notes:</B>
<OL>
<LI>This function does not force the pages to be swapped to disk immediately.
<LI>Partial pages will not be discarded.
</OL>
<DT>Function 0703H
<DD>(DOS/4GW Professional only) This function discards page contents.&nbsp; This function discards the entire contents of a given
linear memory range.&nbsp; It is used after a memory object that occupied a given piece of memory has been discarded.
<BR><BR>The contents of the region will be undefined the next time the memory is accessed.&nbsp; All values previously stored
in this memory will be lost.&nbsp; Pass the following information:
<DL>
<DT>AX = 0703H
<DD>
<DT>BX:CX = Starting linear address of pages to discard
<DD>
<DT>SI:DI = Number of bytes to discard
<DD>
</DL>
<BR>If the call succeeds, the carry flag is clear; if it fails, the carry flag is set.
<BR><BR><B>Notes:</B>
<OL>
<LI>Partial pages will not be discarded.
</OL>
</DL>
<H3 ID="DOSD4GW__Physical_Address_Mapping"> DOS/4GW:&nbsp; Physical Address Mapping </H3>
<BR>Memory mapped devices such as network adapters and displays sometimes have memory mapped at physical addresses that lie
outside of the normal 1Mb of memory that is addressable in real mode.&nbsp; Under many implementations of DPMI, all addresses
are linear addresses since they use the paging mechanism of the 80386.&nbsp; This service can be used by device drivers to
convert a physical address into a linear address.&nbsp; The linear address can then be used to access the device memory.
<DL>
<DT>Function 0800H
<DD>This function is used for Physical Address Mapping.
<BR><BR>Some implementations of DPMI may not support this call because it could be used to circumvent system protection.&nbsp;
This call should only be used by programs that absolutely require direct access to a memory mapped device.
<BR><BR>Pass the following information:
<DL>
<DT>AX = 0800H
<DD>
<DT>BX:CX = Physical address of memory
<DD>
<DT>SI:DI = Size of region to map in bytes
<DD>
</DL>
<BR>If the call succeeds, the carry flag is clear and BX:CX = Linear Address that can be used to access the physical memory.
<BR><BR>If the call fails, the carry flag is set.
<BR><BR><B>Notes:</B>
<OL>
<LI>Under DPMI implementations that do not use the 80386 paging mechanism, the call will always succeed and the address returned
will be equal to the physical address parameter passed into this function.
<LI>It is up to the caller to build an appropriate selector to access the memory.
<LI>Do not use this service to access memory that is mapped in the first megabyte of address space (the real-mode addressable
region).
</OL>
<DT>Function 0801H
<DD>This function is used to free Physical Address Mapping.&nbsp; Pass the following information:
<DL>
<DT>AX = 0801H
<DD>
<DT>BX:CX = Linear address returned by Function 0800H.
<DD>
</DL>
<BR>If the call succeeds, the carry flag is clear; if it fails, the carry flag is set.
<BR><BR><B>Notes:</B>
<OL>
<LI>The client should call this function when it is finished using a device previously mapped to linear addresses with the
Physical Address Mapping function (Function 0800H).
</OL>
</DL>
<H3 ID="DOSD4GW__Virtual_Interrupt_State_Functions"> DOS/4GW:&nbsp; Virtual Interrupt State Functions </H3>
<BR>Under many implementations of DPMI, the interrupt flag in protected mode will always be set (interrupts enabled).&nbsp;
This is because the program is running under a protected operating system that cannot allow programs to disable physical hardware
interrupts.&nbsp; However, the operating system will maintain a &quot;virtual&quot; interrupt state for protected-mode programs.
&nbsp;When the program executes a CLI instruction, the program's virtual interrupt state will be disabled, and the program
will not receive any hardware interrupts until it executes an STI to reenable interrupts (or calls service 0901h).
<BR><BR>When a protected-mode program executes a PUSHF instruction, the real processor flags will be pushed onto the stack.
&nbsp;Thus, examining the flags pushed on the stack is not sufficient to determine the state of the program's virtual interrupt
flag.&nbsp; These services enable programs to get and modify the state of their virtual interrupt flag.
<BR><BR>The following sample code enters an interrupt critical section and then restores the virtual interrupt state to it's
previous state.
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; ;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; ; Disable interrupts and get previous interrupt state</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; ;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mov&nbsp;&nbsp;&nbsp;&nbsp; ax, 0900h</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int&nbsp;&nbsp;&nbsp;&nbsp; 31h</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; ;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; ; At this point AX = 0900h or 0901h</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; ;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; ;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; ; Restore previous state (assumes AX unchanged)</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; ;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int&nbsp;&nbsp;&nbsp;&nbsp; 31h</TT>
<DL>
<DT>Function 0900H
<DD>This function gets and disables Virtual Interrupt State.&nbsp; This function will disable the virtual interrupt flag and return
the previous state of the virtual interrupt flag.&nbsp; Pass the following information:
<DL>
<DT>AX = 0900H
<DD>
</DL>
<BR>After the call, the carry flag is clear (this function always succeeds) and virtual interrupts are disabled.
<BR><BR>&nbsp;&nbsp;&nbsp;&nbsp; AL = 0 if virtual interrupts were previously disabled.
<BR>&nbsp;&nbsp;&nbsp;&nbsp; AL = 1 if virtual interrupts were previously enabled.
<BR><BR><B>Notes:</B>
<OL>
<LI>AH will not be changed by this procedure.&nbsp; Therefore, to restore the previous state, simply execute an Int 31h.
</OL>
<DT>Function 0901H
<DD>This function gets and enables the Virtual Interrupt State.&nbsp; This function will enable the virtual interrupt flag and
return the previous state of the virtual interrupt flag.&nbsp; Pass the following information:
<DL>
<DT>AX = 0901H
<DD>
</DL>
<BR>After the call, the carry flag is clear (this function always succeeds) and virtual interrupts are enabled.
<BR><BR>&nbsp;&nbsp;&nbsp;&nbsp; AL = 0 if virtual interrupts were previously disabled.
<BR>&nbsp;&nbsp;&nbsp;&nbsp; AL = 1 if virtual interrupts were previously enabled.
<BR><BR><B>Notes:</B>
<OL>
<LI>AH will not be changed by this procedure.&nbsp; Therefore, to restore the previous state, simply execute an Int 31h.
</OL>
<DT>Function 0902H
<DD>This function gets the Virtual Interrupt State.&nbsp; This function will return the current state of the virtual interrupt
flag.&nbsp; Pass the following information:
<DL>
<DT>AX = 0902H
<DD>
</DL>
<BR>After the call, the carry flag is clear (this function always succeeds).
<BR><BR>&nbsp;&nbsp;&nbsp;&nbsp; AL = 0 if virtual interrupts are disabled.
<BR>&nbsp;&nbsp;&nbsp;&nbsp; AL = 1 if virtual interrupts are enabled.
</DL>
<H3 ID="DOSD4GW__Vendor_Specific_Extensions"> DOS/4GW:&nbsp; Vendor Specific Extensions </H3>
<BR>Some DOS extenders provide extensions to the standard set of DPMI calls.&nbsp; This call is used to obtain an address
which must be called to use the extensions.&nbsp; The caller points DS:ESI to a null terminated string that specifies the
vendor name or some other unique identifier to obtain the specific extension entry point.
<DL>
<DT>Function 0A00H
<DD>This function gets Tenberry Software's API Entry Point.&nbsp; Pass the following information:
<DL>
<DT>AX = 0A00H
<DD>
<DT>DS:ESI = Pointer to null terminated string &quot;RATIONAL DOS/4G&quot;
<DD>
</DL>
<BR>If the call succeeds, the carry flag is clear and ES:EDI = Extended API entry point.&nbsp; DS, FS, GS, EAX, EBX, ECX,
EDX, ESI, and EBP may be modified.
<BR><BR>If the call fails, the carry flag is set.
<BR><BR><B>Notes:</B>
<OL>
<LI>Execute a far call to call the API entry point.
<LI>All extended API parameters are specified by the vendor.
<LI>The string comparison used to return the API entry point is case sensitive.
</OL>
</DL>
<H3 ID="DOSD4GW__Coprocessor_Status"> DOS/4GW:&nbsp; Coprocessor Status </H3>
<DL>
<DT>Function 0E00H
<DD>This function gets the coprocessor status.&nbsp; Pass the following information:
<DL>
<DT>AX = 0E00H
<DD>
</DL>
<BR>If the call succeeds, the carry flag is clear and AX contains the coprocessor status.
<DL>
<DT><B><I>Bit</I></B>
<DD><B><I>Significance</I></B>
<DT>0
<DD>MPv (MP bit in the virtual MSW/CR0).
<BR><BR>0 = Numeric coprocessor is disabled for this client.
<BR>1 = Numeric coprocessor is disabled for this client.
<DT>1
<DD>EMv (EM bit in the virtual MSW/CR0).
<BR><BR>0 = Client is not emulating coprocessor instructions.
<BR>1 = Client is emulating coprocessor instructions.
<DT>2
<DD>MPr (MP bit from the actual MSW/CR0).
<BR><BR>0 = Numeric coprocessor is not present.
<BR>1 = Numeric coprocessor is present.
<DT>1
<DD>EMr (EM bit from the actual MSW/CR0).
<BR><BR>0 = Host is not emulating coprocessor instructions.
<BR>1 = Host is emulating coprocessor instructions.
<DT>4-7
<DD>Coprocessor type.
<BR><BR>&nbsp;&nbsp;&nbsp;&nbsp; 00H = no coprocessor.
<BR>&nbsp;&nbsp;&nbsp;&nbsp; 02H = 80287
<BR>&nbsp;&nbsp;&nbsp;&nbsp; 03H = 80387
<BR>&nbsp;&nbsp;&nbsp;&nbsp; 04H = 80486 with numeric coprocessor
<BR>&nbsp;&nbsp;&nbsp;&nbsp; 05H = Pentium
<DT>8-15
<DD>Not applicable.
</DL>
<BR>If the call fails, the carry flag is set.
<BR><BR><B>Notes:</B>
<OL>
<LI>If the real EM (EMr) bit is set, the host is supplying or is capable of supplying floating-point emulation.
<LI>If the MPv bit is not set, the host may not need to save the coprocessor state for this virtual machine to improve system
performance.
<LI>The MPr bit setting should be consistent with the setting of the coprocessor type information.&nbsp; Ignore MPr bit information
if it is in conflict with the coprocessor type information.
<LI>If the virtual EM (EMv) bit is set, the host delivers all coprocessor exceptions to the client, and the client is performing
its own floating-point emulation (wether or not a coprocessor is present or the host also has a floating-point emulator).
&nbsp;In other words, if the EMv bit is set, the host sets the EM bit in the real CR0 while the virtual machine is active,
and reflects coprocessor not present faults (int 7) to the virtual machine.
<LI>A client can determine the CPU type with int 31H Function 0400H, but a client should not draw any conclusions about the
presence or absence of a coprocessor based on the CPU type alone.
</OL>
<DT>Function 0E01H
<DD>This function sets coprocessor emulation.&nbsp; Pass the following information:
<DL>
<DT>AX = 0E01H
<DD>
<DT>BX = coprocessor bits
<DD>
<DL>
<DT><B><I>Bit</I></B>
<DD><B><I>Significance</I></B>
<DT>0
<DD>New value of MPv bit for client's virtual CR0.
<BR><BR>0 = Disable numeric coprocessor for this client.
<BR>1 = Enable numeric coprocessor for this client.
<DT>1
<DD>New value of EMv bit for client's virtual CR0.
<BR><BR>0 = client will not supply coprocessor emulation.
<BR>1 = client will supply coprocessor emulation.
<DT>2-15
<DD>Not applicable.
</DL>
</DL>
<BR>If the call succeeds, the carry flag is clear; if it fails, the carry flag is set.
</DL>
<H1 ID="DOSD4GW__Utilities"> DOS/4GW:&nbsp; Utilities </H1>
<BR>This chapter describes the Tenberry Software<B> DOS/4GW</B> utility programs provided with the Open Watcom F77 package.
&nbsp;Each program is described using the following format:
<DL>
<DT>Purpose:
<DD>This is a brief statement of what the utility program does.&nbsp; More specific information is provided under &quot;Notes&quot;.
<DT>Syntax:
<DD>This shows the syntax of the program.&nbsp; The fixed portion of each command is in a<TT> typewriter font,</TT> while variable
parts of the command are in<B> italics.</B>&nbsp; Optional parts are enclosed in [brackets].
<DT>Notes:
<DD>These are explanatory remarks noting major features and possible pitfalls.&nbsp; We explain anything special that you might
need to know about the program.
<DT>See Also:
<DD>This is a cross-reference to any information that is related to the program.
<DT>Example:
<DD>You'll find one or more sample uses of the utility program with an explanation of what the program is doing.
</DL>
<BR>Some of the utilities are<B> DOS/4GW</B>-based, protected-mode programs.&nbsp; To determine which programs run in protected
mode and which in real, run the program.&nbsp; If you see the<B> DOS/4GW</B> banner, the program runs in protected mode.
<H2 ID="DOSD4GW__DOS4GW"> DOS/4GW:&nbsp; DOS4GW </H2>
<DL>
<DT>Purpose:
<DD>Loads and executes linear executables.
<DT>Syntax:
<DD><B> linear_executable</B>
<DT>Notes:
<DD>The stub program at the beginning of the linear executable invokes this program, which loads the linear executable and starts
up the DOS extender.&nbsp; The stub program must be able to find DOS4GW:&nbsp; make sure it is in the path.
</DL>
<H2 ID="DOSD4GW__PMINFO"> DOS/4GW:&nbsp; PMINFO </H2>
<DL>
<DT>Purpose:
<DD>Measures the performance of protected/real-mode switching and extended memory.
<DT>Syntax:
<DD><TT> PMINFO.EXE</TT>
<DT>Notes:
<DD>We encourage you to distribute this program to your users.
<BR><BR>The time-based measurements made by PMINFO may vary slightly from run to run.
<DT>Example:
<DD>The following example shows the output of the PMINFO program on a 386 AT-compatible machine.
<HR>
<BR><TT>&nbsp;&nbsp; C&gt;pminfo</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Protected Mode and Extended Memory Performance Measurement -- 5.00</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Copyright (c) Tenberry
Software, Inc. 1987 - 1993</TT>
<BR><BR><TT>&nbsp;&nbsp; DOS memory&nbsp;&nbsp; Extended memory&nbsp;&nbsp; CPU performance equivalent to 67.0 MHz 80486</TT>
<BR><TT>&nbsp;&nbsp; ----------&nbsp;&nbsp; ---------------</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 736&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp; 8012&nbsp;&nbsp; K bytes configured (according to BIOS).</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 640&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp; 15360&nbsp;&nbsp; K bytes physically present (SETUP).</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 651&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp; 7887&nbsp;&nbsp; K bytes available for DOS/16M programs.</TT>
<BR><TT>&nbsp;&nbsp; 22.0 (3.0)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 18.9 (4.0)&nbsp;&nbsp; MB/sec word transfer rate
(wait states).</TT>
<BR><TT>&nbsp;&nbsp; 42.9 (3.0)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 37.0 (4.0)&nbsp;&nbsp; MB/sec 32-bit transfer rate
(wait states).</TT>
<BR><BR><TT>&nbsp;&nbsp; Overall cpu and memory performance (non-floating point) for typical</TT>
<BR><TT>&nbsp;&nbsp; DOS programs is 10.36  1.04 times an 8MHz IBM PC/AT.</TT>
<BR><BR><TT>&nbsp;&nbsp; Protected/Real switch rate = 36156/sec (27 usec/switch, 15 up + 11 down),</TT>
<BR><TT>&nbsp;&nbsp; DOS/16M switch mode 11 (VCPI).</TT>
<HR>
<BR>The top information line shows that the CPU performance is equivalent to a 67.0 MHz 80486.&nbsp; Below are the configuration
and timings for both the DOS memory and extended memory.&nbsp; If the computer is not equipped with extended memory, or none
is available for<B> DOS/4GW</B>, the extended memory measurements may be omitted (&quot;--&quot;).
<BR><BR>The line &quot;according to BIOS&quot; shows the information provided by the BIOS (interrupts 12h and 15h function
88h).&nbsp; The line &quot;SETUP&quot;, if displayed, is the configuration obtained directly from the CMOS RAM as set by the
computer's setup program.&nbsp; It is displayed only if the numbers are different from those in the BIOS line.&nbsp; They
will be different for computers where the BIOS has reserved memory for itself or if another program has allocated some memory
and is intercepting the BIOS configuration requests to report less memory available than is physically configured.&nbsp; The
&quot;DOS/16M memory range&quot;, if displayed, shows the low and high addresses available to<B> DOS/4GW</B> in extended memory.
<BR><BR>Below the configuration information is information on the memory speed<B> (transfer rate).</B>&nbsp; PMINFO tries
to determine the memory architecture.&nbsp; Some architectures will perform well under some circumstances and poorly under
others; PMINFO will show both the best and worst cases.&nbsp; The architectures detected are cache, interleaved, page-mode
(or static column), and direct.&nbsp; Measurements are made using 32-bit accesses and reported as the number of megabytes
per second that can be transferred.&nbsp; The number of wait states is reported in parentheses.&nbsp; The wait states can
be a fractional number, like 0.5, if there is a wait state on writes but not on reads.&nbsp; Memory bandwidth (i.e., how fast
the CPU can access memory) accounts for 60% to 70% of the performance for typical programs (that are not heavily dependent
on floating-point math).
<BR><BR>A performance metric developed by Tenberry Software is displayed, showing the expected throughput for the computer
relative to a standard 8MHz IBM PC/AT (disk accesses and floating point are excluded).&nbsp; Finally, the speed with which
the computer can switch between real and protected mode is displayed, both as the maximum number of round-trip switches that
can occur per second, and the time for a single round-trip switch, broken out into the real-to-protected (up) and protected-to-real
(down) components.
</DL>
<H2 ID="DOSD4GW__PRIVATXM"> DOS/4GW:&nbsp; PRIVATXM </H2>
<DL>
<DT>Purpose:
<DD>Creates a private pool of memory for<B> DOS/4GW</B> programs.
<DT>Syntax:
<DD><TT> PRIVATXM [-r]</TT>
<DT>Notes:
<DD>This program may be distributed to your users.
<BR><BR>Without PRIVATXM, a<B> DOS/4GW</B> program that starts up while another<B> DOS/4GW</B> program is active uses the
pool of memory built by the first program.&nbsp; The new program cannot change the parameters of this memory pool, so setting<B>
DOS16M</B> to increase the size of the pool has no effect.&nbsp; To specify that the two programs use different pools of memory,
use PRIVATXM.
<BR><BR>PRIVATXM marks the active<B> DOS/4GW</B> programs as private, preventing subsequent<B> DOS/4GW</B> programs from using
the same memory pool.&nbsp; The first<B> DOS/4GW</B> program to start after PRIVATXM sets up a new pool of memory for itself
and any subsequent<B> DOS/4GW</B> programs.&nbsp; To release the memory used by the private programs, use the PRIVATXM<TT>
-r</TT> option.
<BR><BR>PRIVATXM is a TSR that requires less than 500 bytes of memory.&nbsp; It is not supported under DPMI.
<DT>Example:
<DD>The following example creates a 512KB memory pool that is shared by two<B> DOS/4GW</B> TSRs.&nbsp; Subsequent<B> DOS/4GW</B>
programs use a different memory pool.
<DL>
<DT>C&gt;set DOS16M= :512
<DD>Specifies the size of the memory pool.
<DT>C&gt;TSR1
<DD>Sets up the memory pool at startup.
<DT>C&gt;TSR2
<DD>This TSR shares the pool built by TSR1.
<DT>C&gt;PRIVATXM
<DD>Makes subsequent<B> DOS/4GW</B> programs use a new memory pool.
<DT>C&gt;set DOS16M=
<DD>Specifies an unlimited size for the new pool.
<DT>C&gt;PROGRAM3
<DD>This program uses the new memory pool.
<DT>C&gt;PRIVATXM -R
<DD>Releases the 512KB memory pool used by the TSRs.&nbsp; (If the TSRs shut down, their memory is not released unless PRIVATXM
is released.)
</DL>
</DL>
<H2 ID="DOSD4GW__RMINFO"> DOS/4GW:&nbsp; RMINFO </H2>
<DL>
<DT>Purpose:
<DD>Supplies configuration information and the basis for real/protected-mode switching in your machine.
<DT>Syntax:
<DD><TT> RMINFO.EXE</TT>
<DT>Notes:
<DD>This program may be distributed to your users.
<BR><BR>RMINFO starts up<B> DOS/4GW</B>, but stops your machine just short of switching from real mode to protected mode and
displays configuration information about your computer.&nbsp; The information shown by RMINFO can help determine why<B> DOS/4GW</B>
applications won't run on a particular machine.&nbsp; Run RMINFO if PMINFO does not run to completion.
<DT>Example:
<DD>The following example shows the output of the RMINFO program on an 386 AT-compatible machine.
<HR>
<BR><TT>&nbsp;&nbsp; C&gt;rminfo</TT>
<BR><BR><TT>&nbsp;&nbsp; DOS/16M Real Mode Information Program 5.00</TT>
<BR><TT>&nbsp;&nbsp; Copyright (C) Tenberry Software, Inc. 1987 - 1993</TT>
<BR><BR><TT>&nbsp;&nbsp; Machine and Environment:</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Processor:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; i386, coprocessor present</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Machine type:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp; 10 (AT-compatible)</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; A20 now:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; enabled</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; A20 switch rigor:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
disabled</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DPMI host found</TT>
<BR><TT>&nbsp;&nbsp; Switching Functions:</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; To PM switch:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp; DPMI</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; To RM switch:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp; DPMI</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Nominal switch mode:&nbsp;&nbsp;&nbsp; 0</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Switch control flags:&nbsp;&nbsp; 0000</TT>
<BR><TT>&nbsp;&nbsp; Memory Interfaces:</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DPMI may provide:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
16384K returnable</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Contiguous DOS memory:&nbsp; 463K</TT>
<HR>
<BR>The information provided by RMINFO includes:
<DL>
<DT>Machine and Environment:
<DD>
<DT>Processor:
<DD>processor type, coprocessor present/not present
<DT>Machine type:
<DD>
<BR><BR>&nbsp;&nbsp;&nbsp;&nbsp; (NEC 9801)
<BR>&nbsp;&nbsp;&nbsp;&nbsp; (PS/2-compatible)
<BR>&nbsp;&nbsp;&nbsp;&nbsp; (AT-compatible)
<BR>&nbsp;&nbsp;&nbsp;&nbsp; (FM R)
<BR>&nbsp;&nbsp;&nbsp;&nbsp; (AT&amp;T 6300+)
<BR>&nbsp;&nbsp;&nbsp;&nbsp; (AT-compatible)
<BR>&nbsp;&nbsp;&nbsp;&nbsp; (C&amp;T 230 chipset)
<BR>&nbsp;&nbsp;&nbsp;&nbsp; (AT-compatible)
<BR>&nbsp;&nbsp;&nbsp;&nbsp; (AT-compatible)
<BR>&nbsp;&nbsp;&nbsp;&nbsp; (Acer)
<BR>&nbsp;&nbsp;&nbsp;&nbsp; (Zenith)
<BR>&nbsp;&nbsp;&nbsp;&nbsp; (Hitachi)
<BR>&nbsp;&nbsp;&nbsp;&nbsp; (Okidata)
<BR>&nbsp;&nbsp;&nbsp;&nbsp; (PS/55)
<DT>A20 now:
<DD>Current state of Address line 20.
<DT>A20 switch rigor:
<DD>Whether DOS4GW rigorously controls enabling and disabling of Address line 20 when switching modes.
<DT>PS feature flag
<DD>
<DT>XMS host found
<DD>Whether your system has any software using extended memory under the XMS discipline.
<DT>VCPI host found
<DD>Whether your system has any software using extended memory under the VCPI discipline.
<DT>page table 0 at:&nbsp; x000h
<DD>
<DT>DPMI host found
<DD>
<DT>DOS/16M resident with private/public memory
<DD>
</DL>
<DL>
<DT>Switching Functions:
<DD>
<DT>A20 switching:
<DD>
<DT>To PM switch:
<DD>reset catch:
<BR><BR>pre-PM prep:
<BR>post-PM-switch:
<DT>To RM switch:
<DD>
<BR><BR>pre-RM prep:
<BR>reset method:
<BR>post-reset:
<BR>reset uncatch:
<DT>Nominal switch mode:&nbsp; x
<DD>
<DT>Switch control flags:&nbsp; xxxxh
<DD>
</DL>
<DL>
<DT>Memory Interfaces:
<DD>
<DT>(VCPI remapping in effect)
<DD>
<DT>DPMI may provide:&nbsp; xxxxxK returnable
<DD>
<DT>VCPI may provide:&nbsp; xxxxxK returnable
<DD>
<DT>Top-down
<DD>
<DT>Other16M
<DD>
<DT>Forced
<DD>
<DT>Contiguous DOS memory:
<DD>
</DL>
</DL>
<H1 ID="DOSD4GW__Error_Messages"> DOS/4GW:&nbsp; Error Messages </H1>
<BR>The following lists DOS/4G error messages, with descriptions of the circumstances in which the error is most likely to
occur, and suggestions for remedying the problem.&nbsp; Some error messages pertaining to features - like DLLs - that are
not supported in<B> DOS/4GW</B> will not arise with that product.&nbsp; In the following descriptions, references to DOS/4G,
DOS4G, or DOS4G.EXE may be replaced by DOS/4GW, DOS4GW, or DOS4GW.EXE should the error message arise when using<B> DOS/4GW</B>.
<H2 ID="DOSD4GW__Kernel_Error_Messages"> DOS/4GW:&nbsp; Kernel Error Messages </H2>
<BR>This section describes error messages from the DOS/16M kernel embedded in DOS/4G.&nbsp; Kernel error messages may occur
because of severe resource shortages, corruption of DOS4GW.EXE, corruption of memory, operating system incompatibilities,
or internal errors in DOS/4GW.&nbsp; All of these messages are quite rare.
<DL>
<DT>0.&nbsp; involuntary switch to real mode
<DD>
<BR><BR>The computer was in protected mode but switched to real mode without going through DOS/16M.&nbsp; This error most
often occurs because of an unrecoverable stack segment exception (stack overflow), but can also occur if the Global Descriptor
Table or Interrupt Descriptor Table is corrupted.&nbsp; Increase the stack size, recompile your program with stack overflow
checking, or look into ways that the descriptor tables may have been overwritten.
<DT>1.&nbsp; not enough extended memory
<DD>
<DT>2.&nbsp; not a DOS/16M executable &lt;filename&gt;
<DD>
<BR><BR>DOS4G.EXE, or a bound DOS/4G application, has probably been corrupted in some way.&nbsp; Rebuild or recopy the file.
<DT>3.&nbsp; no DOS memory for transparent segment
<DD>
<DT>4.&nbsp; cannot make transparent segment
<DD>
<DT>5.&nbsp; too many transparent segments
<DD>
<DT>6.&nbsp; not enough memory to load program
<DD>
<BR><BR>There is not enough memory to load DOS/4G.&nbsp; Make more memory available and try again.
<DT>7.&nbsp; no relocation segment
<DD>
<DT>8.&nbsp; cannot open file &lt;filename&gt;
<DD>
<BR><BR>The DOS/16M loader cannot load DOS/4G, probably because DOS has run out of file units.&nbsp; Set a larger FILES= entry
in CONFIG.SYS, reboot, and try again.
<DT>9.&nbsp; cannot allocate tstack
<DD>
<BR><BR>There is not enough memory to load DOS/4G.&nbsp; Make more memory available and try again.
<DT>10.&nbsp; cannot allocate memory for GDT
<DD>
<BR><BR>There is not enough memory to load DOS/4G.&nbsp; Make more memory available and try again.
<DT>11.&nbsp; no passup stack selectors -- GDT too small
<DD>
<BR><BR>This error indicates an internal error in DOS/4G or an incompatibility with other software.
<DT>12.&nbsp; no control program selectors -- GDT too small
<DD>
<BR><BR>This error indicates an internal error in DOS/4G or an incompatibility with other software.
<DT>13.&nbsp; cannot allocate transfer buffer
<DD>
<BR><BR>There is not enough memory to load DOS/4G.&nbsp; Make more memory available and try again.
<DT>14.&nbsp; premature EOF
<DD>
<BR><BR>DOS4G.EXE, or a bound DOS/4G application, has probably been corrupted in some way.&nbsp; Rebuild or recopy the file.
<DT>15.&nbsp; protected mode available only with 386 or 486
<DD>
<BR><BR>DOS/4G requires an 80386 (or later) CPU.&nbsp; It cannot run on an 80286 or earlier CPU.
<DT>16.&nbsp; cannot run under OS/2
<DD>
<DT>17.&nbsp; system software does not follow VCPI or DPMI specifications
<DD>
<BR><BR>Some memory resident program has put your 386 or 486 CPU into Virtual 8086 mode.&nbsp; This is done to provide special
memory services to DOS programs, such as EMS simulation (EMS interface without EMS hardware) or high memory.&nbsp; In this
mode, it is not possible to switch into protected mode unless the resident software follows a standard that DOS/16M supports
(DPMI, VCPI, and XMS are the most common).&nbsp; Contact the vendor of your memory management software.
<DT>18.&nbsp; you must specify an extended memory range (SET DOS16M= )
<DD>
<BR><BR>On some Japanese machines that are not IBM AT-compatible, and have no protocol for managing extended memory, you must
set the DOS16M environment variable to specify the range of available extended memory.
<DT>19.&nbsp; computer must be AT- or PS/2- compatible
<DD>
<DT>20.&nbsp; unsupported DOS16M switchmode choice
<DD>
<DT>21.&nbsp; requires DOS 3.0 or later
<DD>
<DT>22.&nbsp; cannot free memory
<DD>
<BR><BR>This error probably indicates that memory was corrupted during execution of your program.
<DT>23.&nbsp; no memory for VCPI page table
<DD>
<BR><BR>There is not enough memory to load DOS/4G.&nbsp; Make more memory available and try again.
<DT>24.&nbsp; VCPI page table address incorrect
<DD>
<BR><BR>This is an internal error.
<DT>25.&nbsp; cannot initialize VCPI
<DD>
<BR><BR>This error indicates an incompatibility with other software.&nbsp; DOS/16M has detected that VCPI is present, but
VCPI returns an error when DOS/16M tries to initialize the interface.
<DT>26.&nbsp; 8042 timeout
<DD>
<DT>27.&nbsp; extended memory is configured but it cannot be allocated
<DD>
<DT>28.&nbsp; memory error, avail loop
<DD>
<BR><BR>This error probably indicates that memory was corrupted during execution of your program.&nbsp; Using an invalid or
stale alias selector may cause this error.&nbsp; Incorrect manipulation of segment descriptors may also cause it.
<DT>29.&nbsp; memory error, out of range
<DD>
<BR><BR>This error probably indicates that memory was corrupted during execution of your program.&nbsp; Writing through an
invalid or stale alias selector may cause this error.
<DT>30.&nbsp; program must be built -AUTO for DPMI
<DD>
<DT>31.&nbsp; protected mode already in use in this DPMI virtual machine
<DD>
<DT>32.&nbsp; DPMI host error (possibly insufficient memory)
<DD>
<DT>33.&nbsp; DPMI host error (need 64K XMS)
<DD>
<DT>34.&nbsp; DPMI host error (cannot lock stack)
<DD>
<BR><BR>Any of these errors (32, 33, 34) probably indicate insufficient memory under DPMI.&nbsp; Under Windows, you might
try making more physical memory available by eliminating or reducing any RAM drives or disk caches.&nbsp; You might also try
editing DEFAULT.PIF so that at least 64KB of XMS memory is available to non-Windows programs.&nbsp; Under OS/2, you want to
increase the DPMI_MEMORY_LIMIT in the DOS box settings.
<DT>35.&nbsp; General Protection Fault
<DD>
<BR><BR>This message probably indicates an internal error in DOS/4G.&nbsp; Faults generated by your program should cause error
2001 instead.
<DT>36.&nbsp; The DOS16M.386 virtual device driver was never loaded
<DD>
<DT>37.&nbsp; Unable to reserve selectors for DOS16M.386 Windows driver
<DD>
<DT>38.&nbsp; Cannot use extended memory:&nbsp; HIMEM.SYS not version 2
<DD>
<BR><BR>This error indicates an incompatibility with an old version of HIMEM.SYS.
<DT>39.&nbsp; An obsolete version of DOS16M.386 was loaded
<DD>
<DT>40.&nbsp; not enough available extended memory (XMIN)
<DD>
<BR><BR>This message probably indicates an incompatibility with your memory manager or its configuration.&nbsp; Try configuring
the memory manager to provide more extended memory, or change memory managers.
</DL>
<H2 ID="DOSD4GW__DOSD4G_Errors"> DOS/4GW:&nbsp; DOS/4G Errors </H2>
<DL>
<DT>1000 &quot;can't hook interrupts&quot;
<DD>
<BR><BR>A DPMI host has prevented DOS/4G from loading.&nbsp; Please contact Tenberry Technical Support.
<DT>1001 &quot;error in interrupt chain&quot;
<DD>
<BR><BR>DOS/4G internal error.&nbsp; Please contact Tenberry Technical Support.
<DT>1003 &quot;can't lock extender kernel in memory&quot;
<DD>
<BR><BR>DOS/4G couldn't lock the kernel in physical memory, probably because of a memory shortage.
<DT>1004 &quot;syntax is DOS4G &lt;executable.xxx&gt;&quot;
<DD>
<BR><BR>You must specify a program name.
<DT>1005 &quot;not enough memory for dispatcher data&quot;
<DD>
<BR><BR>There is not enough memory for DOS/4G to manage user-installed interrupt handlers properly.&nbsp; Free some memory
for the DOS/4G application.
<DT>1007 &quot;can't find file &lt;program&gt; to load&quot;
<DD>
<BR><BR>DOS/4G could not open the specified program.&nbsp; Probably the file didn't exist.&nbsp; It is possible that DOS ran
out of file handles, or that a network or similar utility has prohibited read access to the program.&nbsp; Make sure that
the file name was spelled correctly.
<DT>1008 &quot;can't load executable format for file &lt;filename&gt; [&lt;error code&gt;]&quot;
<DD>
<BR><BR>DOS/4G did not recognize the specified file as a valid executable file.&nbsp; DOS/4G can load linear executables (LE
and LX) and EXPs (BW).&nbsp; The error code is for Tenberry Software's use.
<DT>1009 &quot;program &lt;filename&gt; is not bound&quot;
<DD>
<BR><BR>This message does not occur in DOS/4G, only DOS/4GW Professional; the latter requires that the DOS extender be bound
to the program file.&nbsp; The error signals an attempt to load
<DT>1010 &quot;can't initialize loader &lt;loader&gt; [&lt;error code&gt;]&quot;
<DD>
<BR><BR>DOS/4G could not initialize the named loader, probably because of a resource shortage.&nbsp; Try making more memory
available.&nbsp; If that doesn't work, please contact Tenberry Technical Support.&nbsp; The error code is for Tenberry Software'
use.
<DT>1011 &quot;VMM initialization error [&lt;error code&gt;]&quot;
<DD>
<BR><BR>DOS/4G could not initialize the Virtual Memory Manager, probably because of a resource shortage.&nbsp; Try making
more memory available.&nbsp; If that doesn't work, please contact Tenberry Technical Support.&nbsp; The error code is for
Tenberry Software' use.
<DT>1012 &quot;&lt;filename&gt; is not a WATCOM program&quot;
<DD>
<BR><BR>This message does not occur in DOS/4G, only DOS/4GW and DOS/4GW Professional.&nbsp; Those extenders only support WATCOM
32-bit compilers.
<DT>1013 &quot;int 31h initialization error&quot;
<DD>
<BR><BR>DOS/4G was unable to initialize the code that handles Interrupt 31h, probably because of an internal error.&nbsp;
Please call Tenberry Technical Support.
<DT>1100 &quot;assertion \&quot;&lt;statement&gt;\&quot; failed (&lt;file&gt;:&lt;line&gt;)&quot;
<DD>
<BR><BR>DOS/4G internal error.&nbsp; Please contact Tenberry Technical Support.
<DT>1200 &quot;invalid EXP executable format&quot;
<DD>
<BR><BR>DOS/4G tried to load an EXP, but couldn't.&nbsp; The executable file is probably corrupted.
<DT>1201 &quot;program must be built -AUTO for DPMI&quot;
<DD>
<BR><BR>Under DPMI, DOS/4G can only load EXPs that have been linked with the GLU -AUTO or -DPMI switch.
<DT>1202 &quot;can't allocate memory for GDT&quot;
<DD>
<BR><BR>There is not enough memory available for DOS/4G to build a Global Descriptor Table.&nbsp; Make more memory available.
<DT>1203 &quot;premature EOF&quot;
<DD>
<BR><BR>DOS/4G tried to load an EXP but couldn't.&nbsp; The file is probably corrupted.
<DT>1204 &quot;not enough memory to load program&quot;
<DD>
<BR><BR>There is not enough memory available for DOS/4G to load your program.&nbsp; Make more memory available.
<DT>1301 &quot;invalid linear executable format&quot;
<DD>
<BR><BR>DOS/4G cannot recognize the program file as a LINEXE format.&nbsp; Make sure that you specified the correct file name.
<DT>1304 &quot;file I/O seek error&quot;
<DD>
<BR><BR>DOS/4G was unable to seek to a file location that should exist.&nbsp; This usually indicates truncated program files
or problems with the storage device from which your program loads.&nbsp; Run CHKDSK or a similar utility to begin determining
possible causes.
<DT>1305 &quot;file I/O read error&quot;
<DD>
<BR><BR>DOS/4G was unable to read a file location that should contain program data.&nbsp; This usually indicates truncated
program files or problems with the storage device from which your program loads.&nbsp; Run CHKDSK or a similar utility to
begin determining possible causes.
<DT>1307 &quot;not enough memory&quot;
<DD>
<BR><BR>As it attempted to load your program, DOS/4G ran out of memory.&nbsp; Make more memory available, or enable VMM.
<DT>1308 &quot;can't load requested program&quot;
<DD>
<DT>1309 &quot;can't load requested program&quot;
<DD>
<DT>1311 &quot;can't load requested program&quot;
<DD>
<DT>1312 &quot;can't load requested program&quot;
<DD>
<BR><BR>DOS/4G cannot load your program for some reason.&nbsp; Contact Tenberry Technical Support.
<DT>1313 &quot;can't resolve external references&quot;
<DD>
<BR><BR>DOS/4G was unable to resolve all references to DLLs for the requested program, or the program contained unsupported
fixup types.&nbsp; Use EXEHDR or a similar LINEXE dump utility to see what references your program makes and what special
fixup records might be present.
<DT>1314 &quot;not enough lockable memory&quot;
<DD>
<BR><BR>As it attempted to load your program, DOS/4G encountered a refusal to lock a virtual memory region.&nbsp; Some memory
must be locked in order to handle demand-load page faults.&nbsp; Make more physical memory available.
<DT>1315 &quot;can't load requested program&quot;
<DD>
<DT>1316 &quot;can't load requested program&quot;
<DD>
<BR><BR>DOS/4G cannot load your program for some reason.&nbsp; Contact Tenberry Technical Support.
<DT>1317 &quot;program has no stack&quot;
<DD>
<BR><BR>DOS/4G reports this error when you try to run a program with no stack.&nbsp; Rebuild your program, building in a stack.
<DT>2000 &quot;deinitializing twice&quot;
<DD>
<BR><BR>DOS/4G internal error.&nbsp; Please contact Tenberry Technical Support.
<DT>2001 &quot;exception &lt;exception_number&gt; (&lt;exception_description&gt;) at
<DD>&lt;selector:offset&gt;&quot;
<BR><BR>Your program has generated an exception.&nbsp; For information about interpreting this message, see the file COMMON.DOC.
<DT>2002 &quot;transfer stack overflow at &lt;selector:offset&gt;&quot;
<DD>
<BR><BR>Your program has overflowed the DOS/4G transfer stack.&nbsp; For information about interpreting this message, see
the file COMMON.DOC.
<DT>2300 &quot; can't find &lt;DLL&gt;.&lt;ordinal&gt; - referenced from &lt;module&gt;&quot;
<DD>
<BR><BR>DOS/4G could not find the ordinal listed in the specified DLL, or it could not find the DLL at all.&nbsp; Correct
or remove the reference, and make sure that DOS/4G can find the DLL.
<BR><BR>DOS/4G looks for DLLs in the following directories:
<UL>
<LI>The directory specified by the Libpath32 configuration option (which defaults to the directory of the main application
file).
<LI>The directory or directories specified by the LIBPATH32 environment variable.
<LI>Directories specified in the PATH.
</UL>
<DT>2301 &quot;can't find &lt;DLL&gt;.&lt;name&gt; - referenced from &lt;module&gt;&quot;
<DD>
<BR><BR>DOS/4G could not find the entry point named in the specified module.&nbsp; Correct or remove the reference, and make
sure that DOS/4G can find the DLL.
<DT>2302 &quot;DLL modules not supported&quot;
<DD>
<BR><BR>This DOS/4GW Professional error message arises when an application references or tries to explicitly load a DLL.&nbsp;
DOS/4GW Professional does not support DLLs.
<DT>2303 &quot;internal LINEXE object limit reached&quot;
<DD>
<BR><BR>DOS/4G currently handles a maximum of 128 LINEXE objects, including all .DLL and .EXE files.&nbsp; Most .EXE or .DLL
files use only three or four objects.&nbsp; If possible, reduce the number of objects, or contact Tenberry Technical Support.
<DT>2500 &quot;can't connect to extender kernel&quot;
<DD>
<BR><BR>DOS/4G internal error.&nbsp; Please contact Tenberry Technical Support.
<DT>2503 &quot;not enough disk space for swapping - &lt;count&gt; byes required&quot;
<DD>
<BR><BR>VMM was unable to create a swap file of the required size.&nbsp; Increase the amount of disk space available.
<DT>2504 &quot;can't create swap file \&lt;filename&gt;\&quot;&quot;
<DD>
<BR><BR>VMM was unable to create the swap file.&nbsp; This could be because the swap file is specified for a nonexistent drive
or on a drive that is read-only.&nbsp; Set the SWAPNAME parameter to change the location of the swap file.
<DT>2505 &quot;not enough memory for &lt;table&gt;&quot;
<DD>
<BR><BR>VMM was unable to get sufficient extended memory for internal tables.&nbsp; Make more memory available.&nbsp; If &lt;table&gt;
is page buffer, make more DOS memory available.
<DT>2506 &quot;not enough physical memory (minmem)&quot;
<DD>
<BR><BR>There is less physical memory available than the amount specified by the MINMEM parameter.&nbsp; Make more memory
available.
<DT>2511 &quot;swap out error [&lt;error code&gt;]&quot;
<DD>
<BR><BR>Unknown disk error.&nbsp; The error code is for Tenberry Software' use.
<DT>2512 &quot;swap in error [&lt;error code&gt;]&quot;
<DD>
<BR><BR>Unknown disk error.&nbsp; The error code is for Tenberry Software' use.
<DT>2514 &quot;can't open trace file&quot;
<DD>
<BR><BR>VMM could not open the VMM.TRC file in the current directory for writing.&nbsp; If the directory already has a VMM.TRC
file, delete it.&nbsp; If not, there may not be enough memory on the drive for the trace file, or DOS may not have any more
file handles.
<DT>2520 &quot;can't hook int 31h&quot;
<DD>
<BR><BR>DOS/4G internal error.&nbsp; Please contact Tenberry Technical Support.
<DT>2523 &quot;page fault on non-present mapped page&quot;
<DD>
<BR><BR>Your program references memory that has been mapped to a nonexistent physical device, using DPMI function 508h.&nbsp;
Make sure the device is present, or remove the reference.
<DT>2524 &quot;page fault on uncommitted page&quot;
<DD>
<BR><BR>Your program references memory reserved with a call to DPMI function
<DT>504h, but never committed (using a DPMI 507h or 508h call).&nbsp; Commit
<DD>the memory before you reference it.
<DT>3301 &quot;unhandled EMPTYFWD, GATE16, or unknown relocation&quot;
<DD>
<DT>3302 &quot;unhandled ALIAS16 reference to unaliased object&quot;
<DD>
<DT>3304 &quot;unhandled or unknown relocation&quot;
<DD>
<BR><BR>If your program was built for another platform that supports the LINEXE format, it may contain a construct that DOS/4G
does not currently support, such as a call gate.&nbsp; This message may also occur if your program has a problem mixing 16-
and 32-bit code.&nbsp; A linker error is another likely cause.
</DL>
<H1 ID="DOSD4GW__DOSD4GW_Commonly_Asked_Questions"> DOS/4GW:&nbsp; DOS/4GW Commonly Asked Questions </H1>
<BR>The following information has been provided by Tenberry Software, Inc.&nbsp; for their DOS/4GW and DOS/4GW Professional
product.&nbsp; The content of this chapter has been edited by Open Watcom.&nbsp; In most cases, the information is applicable
to both products.
<BR><BR>This chapter covers the following topics:
<UL>
<LI>Access to technical support
<LI>Differences within the DOS/4G product line
<LI>Addressing
<LI>Interrupt and exception handling
<LI>Memory management
<LI>DOS, BIOS, and mouse services
<LI>Virtual memory
<LI>Debugging
<LI>Compatibility
</UL>
<H2 ID="DOSD4GW__Access_to_Technical_Support"> DOS/4GW:&nbsp; Access to Technical Support </H2>
<DL>
<DT>1a.&nbsp; How to reach technical support.
<DD>
<BR><BR>Here are the various ways you may contact Tenberry Software for technical support.
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; WWW:&nbsp;&nbsp;&nbsp; http://www.tenberry.com/dos4g/</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Email:&nbsp; 4gwhelp@tenberry.com</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Phone:&nbsp; 1.480.767.8868</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Fax:&nbsp;&nbsp;&nbsp; 1.480.767.8709</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Mail:&nbsp;&nbsp; Tenberry Software, Inc.</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; PO Box 20050</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Fountain Hills, Arizona</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; U.S.A&nbsp; 85269-0050</TT>
<BR><BR><B><I>PLEASE GIVE YOUR SERIAL NUMBER WHEN YOU CONTACT TENBERRY.</I></B>
<DT>1b.&nbsp; When to contact Open Watcom, when to contact Tenberry.
<DD>
<BR><BR>Since DOS/4GW Professional is intended to be completely compatible with DOS/4GW, you may wish to ascertain whether
your program works properly under DOS/4GW before contacting Tenberry Software for technical support.&nbsp; (This is likely
to be the second question we ask you, after your serial number.)
<BR><BR>If your program fails under both DOS/4GW and DOS/4GW Professional, and you suspect your own code or a problem compiling
or linking, you may wish to contact Open Watcom first.&nbsp; Tenberry Software support personnel are not able to help you
with most programming questions, or questions about using the Open Watcom tools.
<BR><BR>If your program only fails with DOS/4GW Professional, you have probably found a bug in DOS/4GW Professional, so please
contact us right away.
<DT>1c.&nbsp; Telephone support.
<DD>
<BR><BR>Tenberry Software's hours for telephone support are 9am-6pm EST.&nbsp; Please note that telephone support is free
for the first 30 days only.&nbsp; A one-year contract for continuing telephone support on DOS/4GW Professional is US$500 per
developer, including an update subscription for one year, to customers in the United States and Canada; for overseas customers,
the price is $600.&nbsp; Site licenses may be negotiated.
<BR><BR>There is no time limit on free support by fax, mail, or electronic means.
<DT>1d.&nbsp; References.
<DD>
<BR><BR>The DOS/4GW documentation from Open Watcom is the primary reference for DOS/4GW Professional as well.&nbsp; Another
useful reference is the DPMI specification.&nbsp; In the past, the DPMI specification could be obtained free of charge by
contacting Intel Literature.&nbsp; We have been advised that the DPMI specification is no longer available in printed form.
<BR><BR>However, the DPMI 1.0 specification can be obtained at:
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; http://www.delorie.com/djgpp/doc/dpmi/</TT>
<BR><BR>Online HTML as well as a downloadable archive are provided.
</DL>
<H2 ID="DOSD4GW__Differences_Within_the_DOSD4G_Product_Line"> DOS/4GW:&nbsp; Differences Within the DOS/4G Product Line </H2>
<DL>
<DT>2a.&nbsp; DOS/4GW Professional versus DOS/4GW
<DD>
<BR><BR>DOS/4GW Professional was designed to be a higher-performance version of DOS/4GW suitable for commercial applications.
&nbsp;Here is a summary of the advantages of DOS/4GW Professional with respect to DOS/4GW:
<UL>
<LI>Extender binds to the application program file
<LI>Extender startup time has been reduced
<LI>Support for Open Watcom floating-point emulator has been optimized
<LI>Virtual memory manager performance has been greatly improved
<LI>Under VMM, programs are demand loaded
<LI>Virtual address space is 4 GB instead of 32 MB
<LI>Extender memory requirements have been reduced by more than 50K
<LI>Extender disk space requirements have been reduced by 40K
<LI>Can omit virtual memory manager to save 50K more disk space
<LI>Support for INT 31h functions 301h-304h and 702h-703h
</UL>
<BR>DOS/4GW Professional is intended to be fully compatible with programs written for DOS/4GW 1.9 and up.&nbsp; The only functional
difference is that the extender is bound to your program instead of residing in a separate file.&nbsp; Not only does this
help reduce startup time, but it eliminates version-control problems when someone has both DOS/4GW and DOS/4GW Professional
applications present on one machine.
<DT>2b.&nbsp; DOS/4GW Professional versus DOS/4G.
<DD>
<BR><BR>DOS/4GW Professional is not intended to provide any other new DOS extender functionality.&nbsp; Tenberry Software's
top-of-the-line 32-bit extender, DOS/4G, is not sold on a retail basis but is of special interest to developers who require
more flexibility (such as OEMs).&nbsp; DOS/4G offers these additional features beyond DOS/4GW and DOS/4GW Professional:
<UL>
<LI>Complete documentation
<LI>DLL support
<LI>TSR support
<LI>Support for INT 31h functions 301h-306h, 504h-50Ah, 702h-703h
<LI>A C language API that offers more control over interrupt handling and program loading, as well as making it easier to
use the extender
<LI>An optional (more protected) nonzero-based flat memory model
<LI>Remappable error messages
<LI>More configuration options
<LI>The D32 debugger, GLU linker, and other tools
<LI>Support for other compilers besides Open Watcom
<LI>A higher level of technical support
<LI>Custom work is available (e.g., support for additional executable formats, operating system API emulations, mixed 16-bit
and 32-bit code)
</UL>
<BR>Please contact Tenberry Software if you have questions about other products (present or future) in the DOS/4G line.
<DT>2c.&nbsp; DPMI functions supported by DOS/4GW.
<DD>
<BR><BR>Note that when a DOS/4GW application runs under a DPMI host, such as Windows 3.1 in enhanced mode, an OS/2 virtual
DOS machine, 386Max (with DEBUG=DPMIXCOPY), or QDPMI (with EXTCHKOFF), the DPMI host provides the DPMI services, not DOS/4GW.
&nbsp;The DPMI host also provides virtual memory, if any.&nbsp; Performance (speed and memory use) under different DPMI hosts
varies greatly due to the quality of the DPMI implementation.
<BR><BR>These are the services provided by DOS/4GW and DOS/4GW Professional in the absence of a DPMI host.
<DL>
<DT>0000
<DD>Allocate LDT Descriptors
<DT>0001
<DD>Free LDT Descriptor
<DT>0002
<DD>Map Real-Mode Segment to Descriptor
<DT>0003
<DD>Get Selector Increment Value
<DT>0006
<DD>Get Segment Base Address
<DT>0007
<DD>Set Segment Base Address
<DT>0008
<DD>Set Segment Limit
<DT>0009
<DD>Set Descriptor Access Rights
<DT>000A
<DD>Create Alias Descriptor
<DT>000B
<DD>Get Descriptor
<DT>000C
<DD>Set Descriptor
<DT>000D
<DD>Allocate Specific LDT Descriptor
<DT>0100
<DD>Allocate DOS Memory Block
<DT>0101
<DD>Free DOS Memory Block
<DT>0102
<DD>Resize DOS Memory Block
<DT>0200
<DD>Get Real-Mode Interrupt Vector
<DT>0201
<DD>Set Real-Mode Interrupt Vector
<DT>0202
<DD>Get Processor Exception Handler
<DT>0203
<DD>Set Processor Exception Handler
<DT>0204
<DD>Get Protected-Mode Interrupt Vector
<DT>0205
<DD>Set Protected-Mode Interrupt Vector
<DT>0300
<DD>Simulate Real-Mode Interrupt
<DT>0301
<DD>Call Real-Mode Procedure with Far Return Frame (DOS/4GW Professional only)
<DT>0302
<DD>Call Real-Mode Procedure with IRET Frame (DOS/4GW Professional only)
<DT>0303
<DD>Allocate Real-Mode Callback Address (DOS/4GW Professional only)
<DT>0304
<DD>Free Real-Mode Callback Address (DOS/4GW Professional only)
<DT>0400
<DD>Get DPMI Version
<DT>0500
<DD>Get Free Memory Information
<DT>0501
<DD>Allocate Memory Block
<DT>0502
<DD>Free Memory Block
<DT>0503
<DD>Resize Memory Block
<DT>0600
<DD>Lock Linear Region
<DT>0601
<DD>Unlock Linear Region
<DT>0604
<DD>Get Page Size (VM only)
<DT>0702
<DD>Mark Page as Demand Paging Candidate (DOS/4GW Professional only)
<DT>0703
<DD>Discard Page Contents (DOS/4GW Professional only)
<DT>0800
<DD>Physical Address Mapping
<DT>0801
<DD>Free Physical Address Mapping
<DT>0900
<DD>Get and Disable Virtual Interrupt State
<DT>0901
<DD>Get and Enable Virtual Interrupt State
<DT>0902
<DD>Get Virtual Interrupt State
<DT>0A00
<DD>Get Tenberry Software API Entry Point
<DT>0E00
<DD>Get Coprocessor Status
<DT>0E01
<DD>Set Coprocessor Emulation
</DL>
</DL>
<H2 ID="DOSD4GW__Addressing"> DOS/4GW:&nbsp; Addressing </H2>
<DL>
<DT>3a.&nbsp; Converting between pointers and linear addresses.
<DD>
<BR><BR>Because DOS/4GW uses a zero-based flat memory model, converting between pointers and linear addresses is trivial.
&nbsp;A pointer value is always relative to the current segment (the value in CS for a code pointer, or in DS or SS for a
data pointer).&nbsp; The segment bases for the default DS, SS, and CS are all zero.&nbsp; Hence a near pointer is exactly
the same thing as a linear address:&nbsp; a null pointer points to linear address 0, and a pointer with value 0x10000 points
to linear address 0x10000.
<DT>3b.&nbsp; Converting between code and data pointers.
<DD>
<BR><BR>Because DS and CS have the same base address, they are natural aliases for each other.&nbsp; To create a data alias
for a code pointer, merely create a data pointer and set it equal to the code pointer.&nbsp; It's not necessary for you to
create your own alias descriptor.&nbsp; Similarly, to create a code alias for a data pointer, merely create a code pointer
and set it equal to the data pointer.
<DT>3c.&nbsp; Converting between pointers and low memory addresses.
<DD>
<BR><BR>Linear addresses under 1 MB map directly to physical memory.&nbsp; Hence the real-mode interrupt vector table is at
address 0, the BIOS data segment is at address 0x400, the monochrome video memory is at address 0xB0000, and the color video
memory is at address 0xB8000.&nbsp; To read and write any of these, you can just use a pointer set to the proper address.
&nbsp;You don't need to create a far pointer, using some magic segment value.
<DT>3d.&nbsp; Converting between linear and physical addresses.
<DD>
<BR><BR>Linear addresses at or above 1 MB do not map directly to physical memory, so you can not in general read or write
extended memory directly, nor can you tell how a particular block of extended memory has been used.
<BR><BR>DOS/4GW supports the DPMI call INT 31h/800h, which maps physical addresses to linear addresses.&nbsp; In other words,
if you have a peripheral device in your machine that has memory at a physical address of 256 MB, you can issue this call to
create a linear address that points to that physical memory.&nbsp; The linear address is the same thing as a near pointer
to the memory and can be manipulated as such.
<BR><BR>There is no way in a DPMI environment to determine the physical address corresponding to a given linear address.&nbsp;
This is part of the design of DPMI.&nbsp; You must design your application accordingly.
<DT>3e.&nbsp; Null pointer checking.
<DD>
<BR><BR>DOS/4GW will trap references to the first sixteen bytes of physical memory if you set the environment variable DOS4G=NULLP.
&nbsp;This is currently the only null-pointer check facility provided by DOS/4GW.
<BR><BR>As of release 1.95, DOS/4GW traps both reads and writes.&nbsp; Prior to this, it only trapped writes.
<BR><BR>You may experience problems if you set DOS4G=NULLP and use some versions of the Open Watcom Debugger with a 1.95 or
later extender.&nbsp; These problems have been corrected in later versions of the Open Watcom Debugger.
</DL>
<H2 ID="DOSD4GW__Interrupt_and_Exception_Handling"> DOS/4GW:&nbsp; Interrupt and Exception Handling </H2>
<DL>
<DT>4a.&nbsp; Handling asynchronous interrupts.
<DD>
<BR><BR>Under DOS/4GW, there is a convenient way to handle asynchronous interrupts and an efficient way to handle them.
<BR><BR>Because your CPU may be in either protected mode (when 32-bit code is executing) or real mode (a DOS or BIOS call)
when a hardware interrupt comes in, you have to be prepared to handle interrupts in either mode.&nbsp; Otherwise, you may
miss interrupts.
<BR><BR>You can handle both real-mode and protected-mode interrupts with a single handler, if 1) the interrupt is in the auto-passup
range, 8 to 2Eh; and 2) you install a handler with INT 21h/25h or _dos_setvect(); 3) you do not install a handler for the
same interrupt using any other mechanism.&nbsp; DOS/4GW will route both protected-mode interrupts and real-mode interrupts
to your protected-mode handler.&nbsp; This is the convenient way.
<BR><BR>The efficient way is to install separate real-mode and protected-mode handlers for your interrupt, so your CPU won't
need to do unnecessary mode switches.&nbsp; Writing a real-mode handler is tricky; all you can reasonably expect to do is
save data in a buffer and IRET.&nbsp; Your protected-mode code can periodically check the buffer and process any queued data.
&nbsp;(Remember, protected-mode code can access data and execute code in low memory, but real-mode code can't access data
or execute code in extended memory.)
<BR><BR>For performance, it doesn't matter how you install the real-mode handler, but we recommend the DPMI function INT 31h/201h
for portability.
<BR><BR>It does matter how you install the protected-mode handler.&nbsp; You can't install it directly into the IDT, because
a DPMI provider must distinguish between interrupts and exceptions and maintain separate handler chains.&nbsp; Installing
with INT 31h/205h is the recommended way to install your protected-mode handler for both performance and portability.
<BR><BR>If you install a protected-mode handler with INT 21h/25h, both interrupts and exceptions will be funneled to your
handler, to mimic DOS.&nbsp; Since DPMI exception handlers and interrupt handlers are called with different stack frames,
DOS/4GW executes a layer of code to cover these differences up; the same layer is used to support the DOS/4G API (not part
of DOS/4GW).&nbsp; This layer is the reason that hooking with INT 21h/25h is less efficient than hooking with INT 31h/205h.
<DT>4b.&nbsp; Handling asynchronous interrupts in the second IRQ range.
<DD>
<BR><BR>Because the second IRQ range (normally INTs 70h-77h) is outside the DOS/4GW auto-passup range (8-2Eh, excluding 21h)
you may not handle these interrupts with a single handler, as described above (the &quot;convenient&quot; method).&nbsp; You
must install separate real-mode and protected-mode handlers (the &quot;efficient&quot; method).
<BR><BR>DOS/4G does allow you to specify additional passup interrupts, however.
<DT>4c.&nbsp; Asynchronous interrupt handlers and DPMI.
<DD>
<BR><BR>The DPMI specification requires that all code and data referenced by a hardware interrupt handler MUST be locked at
interrupt time.&nbsp; A DPMI virtual memory manager can use the DOS file system to swap pages of memory to and from the disk;
because DOS is not reentrant, a DPMI host is not required to be able to handle page faults during asynchronous interrupts.
&nbsp;Use INT 31h/600h (Lock Linear Region) to lock an address range in memory.
<BR><BR>If you fail to lock all of your code and data, your program may run under DOS/4GW, but fail under the DOS/4GW Virtual
Memory Manager or under another DPMI host such as Windows or OS/2.
<BR><BR>You should also lock the code and data of a mouse callback function.
<DT>4d.&nbsp; Open Watcom signal() function and Ctrl-Break.
<DD>
<BR><BR>In earlier versions of the Open Watcom C/C++ library, there was a bug that caused signal(SIGBREAK) not to work.&nbsp;
Calling signal(SIGBREAK) did not actually install an interrupt handler for Ctrl-Break (INT 1Bh), so Ctrl-Break would terminate
the application rather than invoking the signal handler.
<BR><BR>With these earlier versions of the library, you could work around this problem by hooking INT 1Bh directly.&nbsp;
With release 10.0, this problem has been fixed.
<DT>4e.&nbsp; More tips on writing hardware interrupt handlers.
<DD>
<UL>
<LI>It's more like handling interrupts in real mode than not.
<BR><BR>The same problems arise when writing hardware interrupt handlers for protected mode as arise for real mode.&nbsp;
We assume you know how to write real-mode handlers; if our suggestions don't seem clear, you might want to brush up on real-mode
interrupt programming.
<LI>Minimize the amount of time spent in your interrupt handlers.
<BR><BR>When your interrupt handlers are called, interrupts are disabled.&nbsp; This means that no other system tasks can
be performed until you enable interrupts (an STI instruction) or until your handler returns.&nbsp; In general, it's a good
idea to handle interrupts as quickly as possible.
<LI>Minimize the amount of time spent in the DOS extender by installing separate real-mode and protected-mode handlers.
<BR><BR>If you use a passup interrupt handler, so that interrupts received in real mode are resignalled in protected mode
by the extender, your application has to switch from real mode to protected mode to real mode once per interrupt.&nbsp; Mode
switching is a time-consuming process, and interrupts are disabled during a mode switch.&nbsp; Therefore, if you're concerned
about performance, you should install separate handlers for real-mode and protected-mode interrupts, eliminating the mode
switch.
<LI>If you can't just set a flag and return, enable interrupts (STI).
<BR><BR>Handlers that do more than just set a flag or store data in a buffer should re-enable interrupts as soon as it's safe
to do so.&nbsp; In other words, save your registers on the stack, establish your addressing conventions, switch stacks if
you're going to - and then enable interrupts (STI), to give priority to other hardware interrupts.
<LI>If you enable interrupts (STI), you should disable interrupts (CLI).
<BR><BR>Because some DPMI hosts virtualize the interrupt flag, if you do an STI in your handler, you should be sure to do
a CLI before you return.&nbsp; (CLI, then switch back to the original stack if you switched away, then restore registers,
then IRET.) If you don't do this, the IRET will not necessarily restore the previous interrupt flag state, and your program
may crash.&nbsp; This is a difference from real-mode programming, and it tends to show up as a problem when you try running
your program in a Windows or OS/2 DOS box for the first time (but not before).
<LI>Add a reentrancy check.
<BR><BR>If your handler doesn't complete its work by the time the next interrupt is signalled, then interrupts can quickly
nest to the point of overflowing the transfer stack.&nbsp; This is a design flaw in your program, not in the DOS extender;
a real-mode DOS program can have exactly the same behavior.&nbsp; If you can conceive of a situation where your interrupt
handler can be called again before the first instance returns, you need to code in a reentrancy check of some sort (before
you switch stacks and enable interrupts (STI), obviously).
<BR><BR>Remember that interrupts can take different amounts of time to execute on different machines; the CPU manufacturer,
CPU speed, speed of memory accesses, and CMOS settings (e.g.&nbsp; &quot;system BIOS shadowing&quot;) can all affect performance
in subtle ways.&nbsp; We recommend you program defensively and always check for unexpected reentry, to avoid transfer stack
overflows.
<LI>Switch to your own stack.
<BR><BR>Interrupt handlers are called on a stack that typically has only a small amount of stack available (512 bytes or less).
&nbsp;If you need to use more stack than this, you have to switch to your own stack on entry into the handler, and switch
back before returning.
<BR><BR>If you want to use C run-time library functions, which are compiled for flat memory model (SS == DS, and the base
of CS == the base of DS), you need to switch back to a stack in the flat data segment first.
<BR><BR>Note that switching stacks by itself won't prevent transfer stack overflows of the kind described above.
</UL>
</DL>
<H2 ID="DOSD4GW__Memory_Management"> DOS/4GW:&nbsp; Memory Management </H2>
<DL>
<DT>5a.&nbsp; Using the realloc() function.
<DD>
<BR><BR>In versions of Open Watcom C/C++ prior to 9.5b, there was a bug in the library implementation of realloc() under DOS/4GW
and DOS/4GW Professional.&nbsp; This bug was corrected by Open Watcom in the 9.5b release.
<DT>5b.&nbsp; Using all of physical memory.
<DD>
<BR><BR>DOS/4GW Professional is currently limited to 64 MB of physical memory.&nbsp; We do not expect to be able to fix this
problem for at least six months.&nbsp; If you need more than 64 MB of memory, you must use virtual memory.
</DL>
<H2 ID="DOSD4GW__DOS__BIOS__and_Mouse_Services"> DOS/4GW:&nbsp; DOS, BIOS, and Mouse Services </H2>
<DL>
<DT>6a.&nbsp; Speeding up file I/O.
<DD>
<BR><BR>The best way to speed up DOS file I/O in DOS/4GW is to write large blocks (up to 65535 bytes, or the largest number
that will fit in a 16-bit int) at a time from a buffer in low memory.&nbsp; In this case, DOS/4GW has to copy the least amount
of data and make the fewest number of DOS calls in order to process the I/O request.
<BR><BR>Low memory is allocated through INT 31h/0100h, Allocate DOS Memory Block.&nbsp; You can convert the real-mode segment
address returned by INT 31h/0100h to a pointer (suitable for passing to setvbuf()) by shifting it left four bits.
<DT>6b.&nbsp; Spawning.
<DD>
<BR><BR>It is possible to spawn one DOS/4GW application from another.&nbsp; However, two copies of the DOS extender will be
loaded into memory.&nbsp; DOS/4G supports loading of multiple programs atop a single extender, as well as DLLs.
<DT>6c.&nbsp; Mouse callbacks.
<DD>
<BR><BR>DOS/4GW Professional now supports the INT 31h interface for managing real-mode callbacks.&nbsp; However, you don't
need to bother with them for their single most important application:&nbsp; mouse callback functions.&nbsp; Just register
your protected-mode mouse callback function as you would in real mode, by issuing INT 33h/0Ch with the event mask in CX and
the function address in ES:EDX, and your function will work as expected.
<BR><BR>Because a mouse callback function is called asynchronously, the same locking requirement exists for a mouse callback
function as for a hardware interrupt handler.&nbsp; See (4c) above.
<DT>6d.&nbsp; VESA support.
<DD>
<BR><BR>While DOS/4GW automatically handles most INT 10h functions so that you can you can issue them from protected mode,
it does not translate the INT 10h VESA extensions.&nbsp; The workaround is to use INT 31h/300h (Simulate Real-Mode Interrupt).
</DL>
<H2 ID="DOSD4GW__Virtual_Memory"> DOS/4GW:&nbsp; Virtual Memory </H2>
<DL>
<DT>7a.&nbsp; Testing for the presence of VMM.
<DD>
<BR><BR>INT 31h/400h returns a value (BX, bit 2) that tells if virtual memory is available.&nbsp; Under a DPMI host such as
Windows 3.1, this will be the host's virtual memory manager, not DOS/4GW's.
<BR><BR>You can test for the presence of a DOS/4G-family DOS extender with INT 31h/0A00h, with a pointer to the null-terminated
string &quot;RATIONAL DOS/4G&quot; in DS:ESI.&nbsp; If the function returns with carry clear, a DOS/4G-family extender is
running.
<DT>7b.&nbsp; Reserving memory for a spawned application.
<DD>
<BR><BR>If you spawn one DOS/4GW application from another, you should set the DELETESWAP configuration option (i.e., SET DOS4GVM=deleteswap)
so that the two applications don't try to use the same swap file.&nbsp; You should also set the MAXMEM option low enough so
that the parent application doesn't take all available physical memory; memory that's been reserved by the parent application
is not available to the child application.
<DT>7c.&nbsp; Instability under VMM.
<DD>
<BR><BR>A program that hooks hardware interrupts, and works fine without VMM but crashes sporadically with it, probably needs
to lock the code and data for its hardware interrupt handlers down in memory.&nbsp; DOS/4GW does not support page faults during
hardware interrupts, because DOS services may not be available at that time.&nbsp; See (4c) and (6c) above.
<BR><BR>Memory can be locked down with INT 31h/600h (Lock Linear Region).
<DT>7d.&nbsp; Running out of memory with a huge virtual address space.
<DD>
<BR><BR>Because DOS/4GW has to create page tables to describe your virtual address space, we recommend that you set your VIRTUALSIZE
parameter just large enough to accommodate your program.&nbsp; If you set your VIRTUALSIZE to 4 GB, the physical memory occupied
by the page tables will be 4 MB, and that memory will not be available to DOS/4GW.
<DT>7e.&nbsp; Reducing the size of the swap file.
<DD>
<BR><BR>DOS/4GW will normally create a swap file equal to your VIRTUALSIZE setting, for efficiency.&nbsp; However, if you
set the SWAPMIN parameter to a size (in KB), DOS/4GW will start with a swap file of that size, and will grow the swap file
when it has to.&nbsp; The SWAPINC value (default 64 KB) controls the incremental size by which the swap file will grow.
<DT>7f.&nbsp; Deleting the swap file.
<DD>
<BR><BR>The DELETESWAP option has two effects:&nbsp; telling DOS/4GW to delete the swap file when it exits, and causing DOS/4GW
to provide a unique swap file name if an explicit SWAPNAME setting was not given.
<BR><BR>DELETESWAP is required if one DOS/4GW application is to spawn another; see (7b) above.
<DT>7g.&nbsp; Improving demand-load performance of large static arrays.
<DD>
<BR><BR>DOS/4GW demand-loading feature normally cuts the load time of a large program drastically.&nbsp; However, if your
program has large amounts of global, zero-initialized data (storage class BSS), the Open Watcom startup code will explicitly
zero it (version 9.5a or earlier).&nbsp; Because the zeroing operation touches every page of the data, the benefits of demand-loading
are lost.
<BR><BR>Demand loading can be made fast again by taking advantage of the fact that DOS/4GW automatically zeroes pages of BSS
data as they are loaded.&nbsp; You can make this change yourself by inserting a few lines into the startup routine, assembling
it (MASM 6.0 will work), and listing the modified object module first when you link your program.
<BR><BR>Here are the changes for<TT> \watcom\src\startup\386\cstart3r.asm</TT> (startup module from the C/C++ 9.5 compiler,
library using register calling conventions).&nbsp; You can modify the workaround easily for other Open Watcom compilers:
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ...&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ; cstart3r.asm, circa line 332</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ; end of _BSS segment (start
of STACK)</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mov&nbsp;&nbsp;&nbsp;&nbsp; ecx,offset DGROUP:_end</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ; start of _BSS segment</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mov&nbsp;&nbsp;&nbsp;&nbsp; edi,offset DGROUP:_edata</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; ;-------------------------------; RSI OPTIMIZATION</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mov&nbsp;&nbsp;&nbsp;&nbsp; eax, edi&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ; minimize _BSS initialization loop</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; or&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; eax, 0FFFh
&nbsp;&nbsp;&nbsp;&nbsp; ; compute address of first page after</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; inc&nbsp;&nbsp;&nbsp;&nbsp; eax&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ;&nbsp;&nbsp; start of _BSS</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cmp&nbsp;&nbsp;&nbsp;&nbsp; eax, ecx&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ; if _BSS extends onto that page,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; jae&nbsp;&nbsp;&nbsp;&nbsp; allzero&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ;&nbsp;&nbsp; then we can rely on the loader</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mov&nbsp;&nbsp;&nbsp;&nbsp; ecx, eax&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ;&nbsp;&nbsp; zeroing the remaining pages</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; allzero:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; ;-------------------------------; END RSI OPTIMIZATION</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; sub&nbsp;&nbsp;&nbsp;&nbsp; ecx,edi&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ; calc # of bytes in _BSS segment</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mov&nbsp;&nbsp;&nbsp;&nbsp; dl,cl&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ; save bottom 2 bits of count in edx</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; shr&nbsp;&nbsp;&nbsp;&nbsp; ecx,2&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ; calc # of dwords</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; sub&nbsp;&nbsp;&nbsp;&nbsp; eax,eax&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ; zero the _BSS segment</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rep&nbsp;&nbsp;&nbsp;&nbsp; stosd&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ; ...</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mov&nbsp;&nbsp;&nbsp;&nbsp; cl,dl&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ; get bottom 2 bits of count</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; and&nbsp;&nbsp;&nbsp;&nbsp; cl,3&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ; ...</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rep&nbsp;&nbsp;&nbsp;&nbsp; stosb&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ; ...</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ...</TT>
<BR><BR>Note that the 9.5b and later versions of the Open Watcom C library already contain this enhancement.
<DT>7h.&nbsp; How should I configure VM for best performance?
<DD>
<BR><BR>Here are some recommendations for setting up the DOS/4GW virtual memory manager.
<DL>
<DT>VIRTUALSIZE
<DD>Set to no more than twice the total amount of memory (virtual and otherwise) your program requires.&nbsp; If your program
has 16 MB of code and data, set to 32 MB.&nbsp; (There is only a small penalty for setting this value larger than you will
need, but your program won't run if you set it too low.) See (7d) above.
<DT>MINMEM
<DD>Set to the minimum hardware requirement for running your application.&nbsp; (If you require a 2 MB machine, set to 2048).
<DT>MAXMEM
<DD>Set to the maximum amount of memory you want your application to use.&nbsp; If you don't spawn any other applications, set
this large (e.g., 32000) to make sure you can use all available physical memory.&nbsp; If you do spawn, see (7b) above.
<DT>SWAPMIN
<DD>Don't use this if you want the best possible VM performance.&nbsp; The trade-off is that DOS/4GW will create a swap file as
big as your VIRTUALSIZE.
<DT>SWAPINC
<DD>Don't use this if you want the best possible VM performance.
<DT>DELETESWAP
<DD>DOS/4GW's VM will start up slightly slower if it has to create the swap file afresh each time.&nbsp; However, unless your
swap file is very large, DELETESWAP is a reasonable choice; it may be required if you spawn another DOS/4GW program at the
same time.&nbsp; See (7b) above.
</DL>
</DL>
<H2 ID="DOSD4GW__Debugging"> DOS/4GW:&nbsp; Debugging </H2>
<DL>
<DT>8a.&nbsp; Attempting to debug a bound application.
<DD>
<BR><BR>You can't debug a bound application.&nbsp; The 4GWBIND utility (included with DOS/4GW Professional) will allow you
to take apart a bound application so that you can debug it:
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; 4GWBIND -U &lt;boundapp.exe&gt; &lt;yourapp.exe&gt;</TT>
<DT>8b.&nbsp; Debugging with an old version of the Open Watcom debugger.
<DD>
<BR><BR>DOS/4GW supports versions 8.5 and up of the Open Watcom C, C++ and FORTRAN compilers.&nbsp; However, in order to debug
your unbound application with a Open Watcom debugger, you must have version 9.5a or later of the debugger.
<BR><BR>If you have an older version of the debugger, we strongly recommend that you contact Open Watcom to upgrade your compiler
and tools.&nbsp; The only way to debug a DOS/4GW Professional application with an old version of the debugger is to rename
4GWPRO.EXE to DOS4GW.EXE and make sure that it's either in the current directory or the first DOS4GW.EXE on the DOS PATH.
<BR><BR>Tenberry will not provide technical support for this configuration; it's up to you to keep track of which DOS extender
is which.
<DT>8c.&nbsp; Meaning of &quot;unexpected interrupt&quot; message/error 2001.
<DD>
<BR><BR>In version 1.95 of DOS/4GW, we revised the &quot;unexpected interrupt&quot; message to make it easier to understand.
<BR><BR>For example, the message:
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Unexpected interrupt 0E (code 0) at 168:10421034</TT>
<BR><BR>is now printed:
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; error (2001): exception 0Eh (page fault) at 168:10421034</TT>
<BR><BR>followed by a register dump, as before.
<BR><BR>This message indicates that the processor detected some form of programming error and signaled an exception, which
DOS/4GW trapped and reported.&nbsp; Exceptions which can be trapped include:
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; 00h&nbsp;&nbsp;&nbsp;&nbsp; divide by zero</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; 01h&nbsp;&nbsp;&nbsp;&nbsp; debug exception OR null pointer used</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; 03h&nbsp;&nbsp;&nbsp;&nbsp; breakpoint</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; 04h&nbsp;&nbsp;&nbsp;&nbsp; overflow</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; 05h&nbsp;&nbsp;&nbsp;&nbsp; bounds</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; 06h&nbsp;&nbsp;&nbsp;&nbsp; invalid opcode</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; 07h&nbsp;&nbsp;&nbsp;&nbsp; device not available</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; 08h&nbsp;&nbsp;&nbsp;&nbsp; double fault</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; 09h&nbsp;&nbsp;&nbsp;&nbsp; overrun</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; 0Ah&nbsp;&nbsp;&nbsp;&nbsp; invalid TSS</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; 0Bh&nbsp;&nbsp;&nbsp;&nbsp; segment not present</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; 0Ch&nbsp;&nbsp;&nbsp;&nbsp; stack fault</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; 0Dh&nbsp;&nbsp;&nbsp;&nbsp; general protection fault</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; 0Eh&nbsp;&nbsp;&nbsp;&nbsp; page fault</TT>
<BR><BR>When you receive this message, this is the recommended course of action:
<OL>
<LI>Record all of the information from the register dump.
<LI>Determine the circumstances under which your program fails.
<LI>Consult your debugger manual, or an Intel 386, 486 or Pentium Programmer's Reference Manual, to determine the circumstances
under which the processor will generate the reported exception.
<LI>Get the program to fail under your debugger, which should stop the program as soon as the exception occurs.
<LI>Determine from the exception context why the processor generated an exception in this particular instance.
</OL>
<DT>8d.&nbsp; Meaning of &quot;transfer stack overflow&quot; message/error 2002.
<DD>
<BR><BR>In version 1.95 of DOS/4GW, we added more information to the &quot;transfer stack overflow&quot; message.&nbsp; The
message (which is now followed by a register dump) is printed:
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; error (2002): transfer stack overflow</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; on interrupt &lt;number&gt; at &lt;address&gt;</TT>
<BR><BR>This message means DOS/4GW detected an overflow on its interrupt handling stack.&nbsp; It usually indicates either
a recursive fault, or a hardware interrupt handler that can't keep up with the rate at which interrupts are occurring.&nbsp;
The best way to understand the problem is to use the VERBOSE option in DOS/4GW to dump the interrupt history on the transfer
stack; see (8e) below.
<DT>8e.&nbsp; Making the most of a DOS/4GW register dump.
<DD>
<BR><BR>If you can't understand your problem by running it under a debugger, the DOS/4GW register dump is your best debugging
tool.&nbsp; To maximize the information available for postmortem debugging, set the environment variable DOS4G to VERBOSE,
then reproduce the crash and record the output.
<BR><BR>Here's a typical register dump with VERBOSE turned on, with annotations.
<BR><BR><TT>&nbsp;&nbsp; </TT>
<BR><TT>&nbsp; 1 DOS/4GW error (2001): exception 0Eh (page fault)</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; at 170:0042C1B2</TT>
<BR><TT>&nbsp; 2 TSF32: prev_tsf32 67D8</TT>
<BR><TT>&nbsp; 3 SS&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 178 DS&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 178 ES&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp; 178 FS&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0 GS&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 20</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; EAX 1F000000 EBX&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0 ECX&nbsp;&nbsp; 43201C EDX&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp; E</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; ESI&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; E EDI&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0
EBP&nbsp;&nbsp; 431410 ESP&nbsp;&nbsp; 4313FC</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; CS:IP&nbsp; 170:0042C1B2 ID 0E COD&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0 FLG&nbsp;&nbsp;
&nbsp;10246</TT>
<BR><TT>&nbsp; 4 CS=&nbsp; 170, USE32, page granular, limit FFFFFFFF, base&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0, acc
CF9B</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; SS=&nbsp; 178, USE32, page granular, limit FFFFFFFF, base&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
0, acc CF93</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; DS=&nbsp; 178, USE32, page granular, limit FFFFFFFF, base&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
0, acc CF93</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; ES=&nbsp; 178, USE32, page granular, limit FFFFFFFF, base&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
0, acc CF93</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; FS=&nbsp;&nbsp;&nbsp; 0, USE16, byte granular, limit&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
0, base&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 15, acc&nbsp; 0</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; GS=&nbsp;&nbsp; 20, USE16, byte granular, limit&nbsp;&nbsp;&nbsp;&nbsp; FFFF, base&nbsp;&nbsp;
&nbsp; 6AA0, acc 93</TT>
<BR><TT>&nbsp; 5 CR0: PG:1 ET:1 TS:0 EM:0 MP:0 PE:1&nbsp;&nbsp; CR2: 1F000000 CR3: 9067</TT>
<BR><TT>&nbsp; 6 Crash address (unrelocated) = 1:000001B2</TT>
<BR><TT>&nbsp; 7 Opcode stream: 8A 18 31 D2 88 DA EB 0E 50 68 39 00 43 00 E8 1D</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; Stack:</TT>
<BR><TT>&nbsp; 8 0178:004313FC 000E 0000 0000 0000 C2D5 0042 C057 0042 0170 0000 0000 0000</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; 0178:00431414 0450 0043 0452 0043 0000 0000 1430 0043 CBEF 0042 011C 0000</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; 0178:0043142C C568 0042 0000 0000 0000 0000 0000 0000 F248 0042 F5F8 0042</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; 0178:00431444 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; 0178:0043145C 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; 0178:00431474 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000</TT>
<BR><TT>&nbsp; 9 Last 4 ints: 21 @ 170:42CF48/21 @ 170:42CF48/21 @ 170:42CF48/E @ 170:42C1B2/</TT>
<OL>
<LI>The error message includes a synopsis of the problem.&nbsp; In this case, the processor signaled a page fault exception
while executing at address 170:0042C1B2.
<LI>The prev_tsf32 field is not usually of interest.
<LI>These are the register values at the time of the exception.&nbsp; The interrupt number and error code (pushed on the stack
by the processor for certain exceptions) are also printed.
<LI>The descriptors referenced by each segment register are described for your convenience.&nbsp; USE32 segments in general
belong to your program; USE16 segments generally belong to the DOS extender.&nbsp; Here, CS points to your program's code
segment, and SS, DS, and ES point to your data segment.&nbsp; FS is NULL and GS points to a DOS extender segment.
<LI>The control register information is not of any general interest, except on a page fault, when CR2 contains the address
value that caused the fault.&nbsp; Since EAX in this case contains the same value, an attempt to dereference EAX could have
caused this particular fault.
<LI>If the crash address (unrelocated) appears, it tells you where the crash occurred relative to your program's link map.
&nbsp;You can therefore tell where a crash occurred even if you can't reproduce the crash in a debugger.
<LI>The opcode stream, if it appears, shows the next 16 bytes from the code segment at the point of the exception.&nbsp; If
you disassemble these instructions, you can tell what instructions caused the crash, even without using a debugger.&nbsp;
In this case, 8A 18 is the instruction<TT> mov bl,[eax].</TT>
<LI>72 words from the top of the stack, at the point of the exception, may be listed next.&nbsp; You may be able to recognize
function calls or data from your program on the stack.
<LI>The four interrupts least to most recently handled by DOS/4GW in protected mode are listed next.&nbsp; In this example,
the last interrupt issued before the page fault occurred was an INT 21h (DOS call) at address 170:42CF48.&nbsp; Sometimes,
this information provides helpful context.
</OL>
<BR>Here's an abridged register dump from a stack overflow.
<BR><BR><TT>&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp; DOS/4GW error (2002): transfer stack overflow</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; on interrupt 70h at 170:0042C002</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; TSF32: prev_tsf32 48C8</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; SS&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; C8 DS&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 170 ES&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 28 FS&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0 GS&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;20</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; EAX AAAAAAAA EBX BBBBBBBB ECX CCCCCCCC EDX DDDDDDDD</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; ESI 51515151 EDI D1D1D1D1 EBP B1B1B1B1 ESP&nbsp;&nbsp;&nbsp;&nbsp; 4884</TT>
<BR><TT>&nbsp; 1 CS:IP&nbsp; 170:0042C002 ID 70 COD&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0 FLG&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp; 2</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; ...</TT>
<BR><TT>&nbsp; 2 Previous TSF:</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; TSF32: prev_tsf32 498C</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; SS&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; C8 DS&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 170 ES&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 28 FS&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0 GS&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;20</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; EAX AAAAAAAA EBX BBBBBBBB ECX CCCCCCCC EDX DDDDDDDD</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; ESI 51515151 EDI D1D1D1D1 EBP B1B1B1B1 ESP&nbsp;&nbsp;&nbsp;&nbsp; 4960</TT>
<BR><TT>&nbsp; 3 CS:IP&nbsp; 170:0042C002 ID 70 COD&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0 FLG&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp; 2</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; ...</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; Previous TSF:</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; TSF32: prev_tsf32 67E4</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; SS&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 178 DS&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 170 ES&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 28 FS&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0 GS&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;20</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; EAX AAAAAAAA EBX BBBBBBBB ECX CCCCCCCC EDX DDDDDDDD</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; ESI 51515151 EDI D1D1D1D1 EBP B1B1B1B1 ESP&nbsp;&nbsp; 42FFE0</TT>
<BR><TT>&nbsp; 4 CS:IP&nbsp; 170:0042C039 ID 70 COD&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0 FLG&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;202</TT>
<BR><TT>&nbsp; 5 Opcode stream: CF 66 B8 62 25 66 8C CB 66 8E DB BA 00 C0 42 00</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; Last 4 ints: 70 @ 170:42C002/70 @ 170:42C002/70 @ 170:42C002/70 @ 170:42C002/</TT>
<OL>
<LI>We overflowed the transfer stack while trying to process an interrupt 70h at 170:0042C002.
<LI>The entire interrupt history from the transfer stack is printed next.&nbsp; The prev_tsf32 numbers increase as we progress
from most recent to least recent interrupt.&nbsp; All of these interrupts are still pending, which is why we ran out of stack
space.
<LI>Before we overflowed the stack, we got the same interrupt at the same address.&nbsp; For a recursive interrupt situation,
this is typical.
<LI>The oldest frame on the transfer stack shows the recursion was touched off at a slightly different address.&nbsp; Looking
at this address may help you understand the recursion.
<LI>The opcode stream and last four interrupt information comes from the newest transfer stack frame, not the oldest.
</OL>
</DL>
<H2 ID="DOSD4GW__Compatibility"> DOS/4GW:&nbsp; Compatibility </H2>
<DL>
<DT>9a.&nbsp; Running DOS/4GW applications from inside Lotus 1-2-3.
<DD>
<BR><BR>In order to run DOS/4GW applications while &quot;shelled out&quot; from Lotus 1-2-3, you must use the PRIVATXM program
included with your Open Watcom compiler.&nbsp; Otherwise, 1-2-3 will take all of the memory on your machine and prevent DOS/4GW
from using it.
<BR><BR>Before starting 1-2-3, you must set the DOS16M environment variable to limit Lotus' memory use (see your Open Watcom
manual).&nbsp; After shelling out, you must run PRIVATXM, then clear the DOS16M environment variable before running your application.
<DT>9b.&nbsp; EMM386.EXE provided with DOS 6.0.
<DD>
<BR><BR>We know of at least three serious bugs in the EMM386.EXE distributed with MS-DOS 6.0, one involving mis-counting the
amount of available memory, one involving mapping too little of the High Memory Area (HMA) into its page tables, and one involving
allocation of EMS memory.&nbsp; Version 1.95 of DOS/4GW contains workarounds for some of these problems.
<BR><BR>If you are having problems with DOS/4GW and you are using an EMM386.EXE dated 3-10-93 at 6:00:00, or later, you may
wish to try the following workarounds, in sequence, until the problem goes away.
<UL>
<LI>Configure EMM386 with both the NOEMS and NOVCPI options.
<LI>Convert the DEVICEHIGH statements in your CONFIG.SYS to DEVICE statements, and remove the LH (Load High) commands from
your AUTOEXEC.BAT.
<LI>Run in a Windows DOS box.
<LI>Replace EMM386 with another memory manager, such as QEMM-386, 386Max, or an older version of EMM386.
<LI>Run with HIMEM.SYS alone.
</UL>
<BR>You may also wish to contact Microsoft Corporation to inquire about the availability of a fix.
<DT>9c.&nbsp; Spawning under OS/2 2.1.
<DD>
<BR><BR>We know of a bug in OS/2 2.1 that prevents one DOS/4GW application from spawning another over and over again.&nbsp;
The actual number of repeated spawns that are possible under OS/2 varies from machine to machine, but is generally about 30.
<BR><BR>This bug also affects programs running under other DOS extenders, and we have not yet found a workaround, other than
linking your two programs together as a single program.
<DT>9d.&nbsp; &quot;DPMI host error:&nbsp; cannot lock stack&quot;.
<DD>
<BR><BR>This error message almost always indicates insufficient memory, rather than a real incompatibility.&nbsp; If you see
it under an OS/2 DOS box, you probably need to edit your DOS Session settings and make DPMI_MEMORY_LIMIT larger.
<DT>9e.&nbsp; Bug in Novell TCPIP driver.
<DD>
<BR><BR>Some versions of a program from Novell called TCPIP.EXE, a real-mode program, will cause the high words of EAX and
EDX to be altered during a hardware interrupt.&nbsp; This bug breaks protected-mode software (and other real-mode software
that uses the 80386 registers).&nbsp; Novell has released a newer version of TCPIP that fixes the problem; contact Novell
to obtain the fix.
<DT>9f.&nbsp; Bugs in Windows NT.
<DD>
<BR><BR>The initial release of Windows NT includes a DPMI host, DOSX.EXE, with several serious bugs, some of which apparently
cannot be worked around.&nbsp; We cannot warranty operation of DOS/4GW under Windows NT at this time, but we are continuing
to exercise our best efforts to work around these problems.
<BR><BR>You may wish to contact Microsoft Corporation to inquire about the availability of a new version of DOSX.EXE.
</DL>
<H1 ID="16Mbit_Windows__Creating_16Mbit_Windows_3_x_Applications"> 16-bit Windows:&nbsp; Creating 16-bit Windows 3.x Applications </H1>
<BR>This chapter describes how to compile and link 16-bit Windows 3.x applications simply and quickly.&nbsp; In this chapter,
we look at applications written to exploit the Windows 3.x Application Programming Interface (API).
<BR><BR>We will illustrate the steps to creating 16-bit Windows 3.x applications by taking a small sample application and
showing you how to compile, link, run and debug it.
<H2 ID="16Mbit_Windows__The_Sample_GUI_Application"> 16-bit Windows:&nbsp; The Sample GUI Application </H2>
<BR>To demonstrate the creation of 16-bit Windows 3.x applications, we introduce a simple sample program.&nbsp; For our example,
we are going to use the &quot;sieve&quot; program.
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; *$include winapi.fi</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; *$noreference</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; INTEGER*2 FUNCTION FWINMAIN( hInstance, hPrevInstance,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &amp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; lpszCmdLine,
nCmdShow )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; *$reference</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; IMPLICIT NONE</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; INTEGER*2 hInstance, hPrevInstance, nCmdShow</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; INTEGER*4 lpszCmdLine</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; include 'windows.fi'</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; * This program computes the prime numbers between 1 and 10,000</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; * using the Sieve of Eratosthenes algorithm.</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; INTEGER UPBOUND</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; PARAMETER (UPBOUND=10000)</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; INTEGER I, K, PRIMES</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; LOGICAL*1 NUMBERS(2:UPBOUND)</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CHARACTER*11 FORM</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CHARACTER*60 BUFFER</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; PARAMETER (FORM='(A,I5,A,I5)')</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DO I = 2, UPBOUND</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; NUMBERS(I) = .TRUE.</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ENDDO</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; PRIMES = 0</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DO I = 2, UPBOUND</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; IF( NUMBERS(I) )THEN</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; PRIMES
= PRIMES + 1</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DO K
= I + I, UPBOUND, I</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp; NUMBERS(K) = .FALSE.</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ENDDO</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ENDIF</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ENDDO</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; WRITE(BUFFER, FORM) 'The Number of Primes between
1 and ',</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &amp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; UPBOUND, ' are: ', PRIMES</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CALL MessageBox( 0, BUFFER,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &amp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;'Sieve of Eratosthenes'c,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &amp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;MB_OK .OR. MB_TASKMODAL )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; END</TT>
<BR><BR>The goal of this program is to count the prime numbers between 1 and 10,000.&nbsp; It uses the famous<B> Sieve of
Eratosthenes</B> algorithm to accomplish this task.&nbsp; We will take you through the steps necessary to produce this result.
<H2 ID="16Mbit_Windows__Building_and_Running_the_GUI_Application"> 16-bit Windows:&nbsp; Building and Running the GUI Application </H2>
<BR>To compile and link our example program which is stored in the file<TT> sieve.for</TT>, enter the following command:
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; C&gt;wfl -l=windows -win sieve.for</TT>
<BR><BR>The typical messages that appear on the screen are shown in the following illustration.
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; C&gt;wfl -l=windows -win sieve.for</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Open Watcom F77/16 Compile and Link Utility</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Copyright (c) 2002-2019 the Open Watcom Contributors. All Rights Reserved.</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Portions Copyright (c) 1990-2002 Sybase, Inc. All Rights Reserved.</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Source code is available under the Sybase Open Watcom Public License.</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; See http://www.openwatcom.org/ for details.</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; wfc sieve.for -win</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Open Watcom FORTRAN 77/16 Optimizing Compiler</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Copyright (c) 2002-2019 the Open Watcom Contributors. All Rights Reserved.</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Portions Copyright (c) 1984-2002 Sybase, Inc. All Rights Reserved.</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Source code is available under the Sybase Open Watcom Public License.</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; See http://www.openwatcom.org/ for details.</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; sieve.for: 4305 statements, 356 bytes, 1524 extensions, 0 warnings, 0 errors</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Open Watcom Linker</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Copyright (c) 2002-2019 the Open Watcom Contributors. All Rights Reserved.</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Portions Copyright (c) 1985-2002 Sybase, Inc. All Rights Reserved.</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Source code is available under the Sybase Open Watcom Public License.</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; See http://www.openwatcom.org/ for details.</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; loading object files</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; searching libraries</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; creating a Windows 16-bit executable</TT>
<BR><BR>If you examine the current directory, you will find that two files have been created.&nbsp; These are<TT> sieve.obj</TT>
(the result of compiling<TT> sieve.for</TT>) and<TT> sieve.exe</TT> (the result of linking<TT> sieve.obj</TT> with the appropriate
Open Watcom FORTRAN 77 libraries).
<BR><BR>The resultant 16-bit Windows 3.x application<TT> SIEVE.EXE</TT> can now be run under Windows 3.x.
<H2 ID="16Mbit_Windows__Debugging_the_GUI_Application"> 16-bit Windows:&nbsp; Debugging the GUI Application </H2>
<BR>Let us assume that you wish to debug your application in order to locate an error in programming.&nbsp; In the previous
section, the &quot;sieve&quot; program was compiled with default compile and link options.&nbsp; When debugging an application,
it is useful to refer to the symbolic names of routines and variables.&nbsp; It is also convenient to debug at the source
line level rather than the machine language level.&nbsp; To do this, we must direct both the compiler and linker to include
additional debugging information in the object and executable files.&nbsp; Using the<B><I> WFL</I></B> command, this is fairly
straightforward.<B><I>&nbsp; WFL</I></B> recognizes the Open Watcom F77 compiler &quot;debug&quot; options and will create
the appropriate debug directives for the Open Watcom Linker.
<BR><BR>For example, to compile and link the &quot;sieve&quot; program with debugging information, the following command may
be issued.
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; C&gt;wfl -l=windows -win -d2 sieve.for</TT>
<BR><BR>The typical messages that appear on the screen are shown in the following illustration.
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; C&gt;wfl -l=windows -win -d2 sieve.for</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Open Watcom F77/16 Compile and Link Utility</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Copyright (c) 2002-2019 the Open Watcom Contributors. All Rights Reserved.</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Portions Copyright (c) 1990-2002 Sybase, Inc. All Rights Reserved.</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Source code is available under the Sybase Open Watcom Public License.</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; See http://www.openwatcom.org/ for details.</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; wfc sieve.for -win -d2</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Open Watcom FORTRAN 77/16 Optimizing Compiler</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Copyright (c) 2002-2019 the Open Watcom Contributors. All Rights Reserved.</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Portions Copyright (c) 1984-2002 Sybase, Inc. All Rights Reserved.</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Source code is available under the Sybase Open Watcom Public License.</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; See http://www.openwatcom.org/ for details.</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; sieve.for: 4305 statements, 467 bytes, 1524 extensions, 0 warnings, 0 errors</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Open Watcom Linker</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Copyright (c) 2002-2019 the Open Watcom Contributors. All Rights Reserved.</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Portions Copyright (c) 1985-2002 Sybase, Inc. All Rights Reserved.</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Source code is available under the Sybase Open Watcom Public License.</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; See http://www.openwatcom.org/ for details.</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; loading object files</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; searching libraries</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; creating a Windows 16-bit executable</TT>
<BR><BR>The &quot;d2&quot; option requests the maximum amount of debugging information that can be provided by the Open Watcom
F77 compiler.<B><I>&nbsp; WFL</I></B> will make sure that this debugging information is included in the executable file that
is produced by the linker.
<BR><BR>The &quot;bytes&quot; value is larger than in the previous example since selection of the &quot;d2&quot; option results
in fewer code optimizations by default.&nbsp; You can request more optimization by specifying the appropriate options.&nbsp;
However, you do so at the risk of making it more difficult for yourself to determine the relationship between the object code
and the original source language code.
<BR><BR>To request the Open Watcom Debugger to assist in debugging the application, select the Open Watcom Debugger icon.
&nbsp;It would be too ambitious to describe the debugger in this introductory chapter so we refer you to the book entitled<B><I>
Open Watcom Debugger User's Guide.</I></B>
<BR><BR>There are more extensive examples of Windows applications written in FORTRAN 77 in the<TT> \WATCOM\SAMPLES\FORTRAN\WIN</TT>
directory.&nbsp; The example programs are<TT> ELLIPSE.FOR</TT> and<TT> FWCOPY.FOR.</TT>
<H1 ID="16Mbit_Windows__Porting_NonMGUI_Applications_to_16Mbit_Windows_3_x"> 16-bit Windows:&nbsp; Porting Non-GUI Applications to 16-bit Windows 3.x </H1>
<BR>Generally, an application that is to run in a windowed environment must be written in such a way as to exploit the Windows
Application Programming Interface (API).&nbsp; To take an existing character-based (i.e., non-graphical) application that
ran under a system such as DOS and adapt it to run under Windows can require some considerable effort.&nbsp; There is a steep
learning curve associated with the API function libraries.
<BR><BR>This chapter describes how to create a Windows application quickly and simply from an application that does not use
the Windows API.&nbsp; The application will make use of Open Watcom's default windowing support.
<BR><BR>Suppose you have a set of FORTRAN 77 applications that previously ran under a system like DOS and you now wish to
run them under Windows 3.x.&nbsp; To achieve this, you can simply recompile your application with the appropriate options
and link with the appropriate libraries.&nbsp; We provide a default windowing system that turns your character-mode application
into a simple Windows 3.x Graphical User Interface (GUI) application.
<BR><BR>Normally, a Windows 3.x GUI application makes use of user-interface tools such as menus, icons, scroll bars, etc.
&nbsp;However, an application that was not designed as a windowed application (such as a DOS application) can run as a GUI
application.&nbsp; This is achieved by our default windowing system.&nbsp; The following sections describe the default windowing
system.
<H2 ID="16Mbit_Windows__Console_Device_in_a_Windowed_Environment"> 16-bit Windows:&nbsp; Console Device in a Windowed Environment </H2>
<BR>In a FORTRAN 77 application that runs under DOS,<B> unit 5</B> and<B> unit 6</B> are connected to the standard input and
standard output devices respectively.&nbsp; It is not a recommended practice to read directly from the standard input device
or write to the standard output device when running in a windowed environment.&nbsp; For this reason, a default windowing
environment is created for FORTRAN 77 applications that read from<B> unit 5</B> or write to<B> unit 6.</B>&nbsp; When your
application is started, a window is created in which output to<B> unit 6</B> is displayed and input from<B> unit 5</B> is
requested.
<BR><BR>In addition to the standard I/O device, it is also possible to perform I/O to the console by explicitly opening a
file whose name is &quot;CON&quot;.&nbsp; When this occurs, another window is created and displayed.&nbsp; This window is
different from the one created for standard input and standard output.&nbsp; In fact, every time you open the console device
a different window is created.&nbsp; This provides a simple multi-windowing system for multiple streams of data to and from
the console device.
<H2 ID="16Mbit_Windows__The_Sample_NonMGUI_Application"> 16-bit Windows:&nbsp; The Sample Non-GUI Application </H2>
<BR>To demonstrate the creation of 16-bit Windows 3.x applications, we introduce a simple sample program.&nbsp; For our example,
we are going to use the &quot;sieve&quot; program.
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; * This program computes the prime numbers between 1 and 10,000</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; * using the Sieve of Eratosthenes algorithm.</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; IMPLICIT NONE</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; INTEGER UPBOUND</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; PARAMETER (UPBOUND=10000)</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; INTEGER I, K, PRIMES</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; LOGICAL*1 NUMBERS(2:UPBOUND)</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CHARACTER*11 FORM</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; PARAMETER (FORM='(A,I5,A,I5)')</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DO I = 2, UPBOUND</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; NUMBERS(I) = .TRUE.</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ENDDO</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; PRIMES = 0</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DO I = 2, UPBOUND</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; IF( NUMBERS(I) )THEN</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; PRIMES
= PRIMES + 1</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DO K
= I + I, UPBOUND, I</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp; NUMBERS(K) = .FALSE.</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ENDDO</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ENDIF</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ENDDO</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; PRINT FORM, 'The Number of Primes between 1 and ', UPBOUND,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;' are: ', PRIMES</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; END</TT>
<BR><BR>The goal of this program is to count the prime numbers between 1 and 10,000.&nbsp; It uses the famous<B> Sieve of
Eratosthenes</B> algorithm to accomplish this task.&nbsp; We will take you through the steps necessary to produce this result.
<H2 ID="16Mbit_Windows__Building_and_Running_the_NonMGUI_Application"> 16-bit Windows:&nbsp; Building and Running the Non-GUI Application </H2>
<BR>Very little effort is required to port an existing FORTRAN 77 application to Windows 3.x.
<BR><BR>You must compile and link the file<TT> sieve.for</TT> specifying the &quot;bw&quot; option.
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; C&gt;wfl -l=windows -bw -win sieve.for</TT>
<BR><BR>The typical messages that appear on the screen are shown in the following illustration.
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; C&gt;wfl -l=windows -bw -win sieve.for</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Open Watcom F77/16 Compile and Link Utility</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Copyright (c) 2002-2019 the Open Watcom Contributors. All Rights Reserved.</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Portions Copyright (c) 1990-2002 Sybase, Inc. All Rights Reserved.</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Source code is available under the Sybase Open Watcom Public License.</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; See http://www.openwatcom.org/ for details.</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; wfc sieve.for -bw -win</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Open Watcom FORTRAN 77/16 Optimizing Compiler</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Copyright (c) 2002-2019 the Open Watcom Contributors. All Rights Reserved.</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Portions Copyright (c) 1984-2002 Sybase, Inc. All Rights Reserved.</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Source code is available under the Sybase Open Watcom Public License.</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; See http://www.openwatcom.org/ for details.</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; sieve.for: 21 statements, 311 bytes, 6 extensions, 0 warnings, 0 errors</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Open Watcom Linker</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Copyright (c) 2002-2019 the Open Watcom Contributors. All Rights Reserved.</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Portions Copyright (c) 1985-2002 Sybase, Inc. All Rights Reserved.</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Source code is available under the Sybase Open Watcom Public License.</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; See http://www.openwatcom.org/ for details.</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; loading object files</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; searching libraries</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; creating a Windows 16-bit executable</TT>
<BR><BR>If you examine the current directory, you will find that two files have been created.&nbsp; These are<TT> sieve.obj</TT>
(the result of compiling<TT> sieve.for</TT>) and<TT> sieve.exe</TT> (the result of linking<TT> sieve.obj</TT> with the appropriate
Open Watcom FORTRAN 77 libraries).
<BR><BR>The resultant 16-bit Windows 3.x application<TT> SIEVE.EXE</TT> can now be run under Windows 3.x as a Windows GUI
application.
<H2 ID="16Mbit_Windows__Debugging_the_NonMGUI_Application"> 16-bit Windows:&nbsp; Debugging the Non-GUI Application </H2>
<BR>Let us assume that you wish to debug your application in order to locate an error in programming.&nbsp; In the previous
section, the &quot;sieve&quot; program was compiled with default compile and link options.&nbsp; When debugging an application,
it is useful to refer to the symbolic names of routines and variables.&nbsp; It is also convenient to debug at the source
line level rather than the machine language level.&nbsp; To do this, we must direct both the compiler and linker to include
additional debugging information in the object and executable files.&nbsp; Using the<B><I> WFL</I></B> command, this is fairly
straightforward.<B><I>&nbsp; WFL</I></B> recognizes the Open Watcom F77 compiler &quot;debug&quot; options and will create
the appropriate debug directives for the Open Watcom Linker.
<BR><BR>For example, to compile and link the &quot;sieve&quot; program with debugging information, the following command may
be issued.
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; C&gt;wfl -l=windows -bw -win -d2 sieve.for</TT>
<BR><BR>The typical messages that appear on the screen are shown in the following illustration.
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; C&gt;wfl -l=windows -bw -win -d2 sieve.for</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Open Watcom F77/16 Compile and Link Utility</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Copyright (c) 2002-2019 the Open Watcom Contributors. All Rights Reserved.</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Portions Copyright (c) 1990-2002 Sybase, Inc. All Rights Reserved.</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Source code is available under the Sybase Open Watcom Public License.</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; See http://www.openwatcom.org/ for details.</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; wfc sieve.for -bw -win -d2</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Open Watcom FORTRAN 77/16 Optimizing Compiler</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Copyright (c) 2002-2019 the Open Watcom Contributors. All Rights Reserved.</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Portions Copyright (c) 1984-2002 Sybase, Inc. All Rights Reserved.</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Source code is available under the Sybase Open Watcom Public License.</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; See http://www.openwatcom.org/ for details.</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; sieve.for: 21 statements, 392 bytes, 6 extensions, 0 warnings, 0 errors</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Open Watcom Linker</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Copyright (c) 2002-2019 the Open Watcom Contributors. All Rights Reserved.</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Portions Copyright (c) 1985-2002 Sybase, Inc. All Rights Reserved.</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Source code is available under the Sybase Open Watcom Public License.</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; See http://www.openwatcom.org/ for details.</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; loading object files</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; searching libraries</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; creating a Windows 16-bit executable</TT>
<BR><BR>The &quot;d2&quot; option requests the maximum amount of debugging information that can be provided by the Open Watcom
F77 compiler.<B><I>&nbsp; WFL</I></B> will make sure that this debugging information is included in the executable file that
is produced by the linker.
<BR><BR>The &quot;bytes&quot; value is larger than in the previous example since selection of the &quot;d2&quot; option results
in fewer code optimizations by default.&nbsp; You can request more optimization by specifying the appropriate options.&nbsp;
However, you do so at the risk of making it more difficult for yourself to determine the relationship between the object code
and the original source language code.
<BR><BR>To request the Open Watcom Debugger to assist in debugging the application, select the Open Watcom Debugger icon.
&nbsp;It would be too ambitious to describe the debugger in this introductory chapter so we refer you to the book entitled<B><I>
Open Watcom Debugger User's Guide.</I></B>
<H2 ID="16Mbit_Windows__Default_Windowing_Library_Functions"> 16-bit Windows:&nbsp; Default Windowing Library Functions </H2>
<BR>A few library functions have been written to enable some simple customization of the default windowing system's behaviour.
&nbsp;The following functions are supplied:
<DL>
<DT>dwfDeleteOnClose
<DD>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; integer function dwfDeleteOnClose( unit )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; integer unit</TT>
<BR><BR>This function tells the console window that it should close itself when the file is closed.&nbsp; You must pass to
it the unit number associated with the opened console.
<DT>dwfSetAboutDlg
<DD>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; integer function dwfSetAboutDlg( title, text )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; character*(*) title</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; character*(*) text</TT>
<BR><BR>This function sets the about dialog box of the default windowing system.&nbsp; The &quot;title&quot; points to the
string that will replace the current title.&nbsp; If title is CHAR(0) then the title will not be replaced.&nbsp; The &quot;text&quot;
points to a string which will be placed in the about box.&nbsp; To get multiple lines, embed a new line after each logical
line in the string.&nbsp; If &quot;text&quot; is CHAR(0), then the current text in the about box will not be replaced.
<DT>dwfSetAppTitle
<DD>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; integer function dwfSetAppTitle( title )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; character*(*) title</TT>
<BR><BR>This function sets the main window's title.
<DT>dwfSetConTitle
<DD>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; integer function dwfSetConTitle( unit, title )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; integer unit</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; character*(*) title</TT>
<BR><BR>This function sets the console window's title which corresponds to the unit number passed to it.
<DT>dwfShutDown
<DD>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; integer function dwfShutDown()</TT>
<BR><BR>This function shuts down the default windowing I/O system.&nbsp; The application will continue to execute but no windows
will be available for output.
<DT>dwfYield
<DD>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; integer function dwfYield()</TT>
<BR><BR>This function yields control back to the operating system, thereby giving other processes a chance to run.
</DL>
<BR>These functions are described more fully in the<B><I> Open Watcom FORTRAN 77 User's Guide.</I></B>
<H1 ID="32Mbit_Windows__Creating_32Mbit_Windows_3_x_Applications"> 32-bit Windows:&nbsp; Creating 32-bit Windows 3.x Applications </H1>
<BR>This chapter describes how to compile and link 32-bit Windows 3.x applications simply and quickly.&nbsp; In this chapter,
we look at applications written to exploit the Windows 3.x Application Programming Interface (API).
<BR><BR>We will illustrate the steps to creating 32-bit Windows 3.x applications by taking a small sample application and
showing you how to compile, link, run and debug it.
<H2 ID="32Mbit_Windows__The_Sample_GUI_Application"> 32-bit Windows:&nbsp; The Sample GUI Application </H2>
<BR>To demonstrate the creation of 32-bit Windows 3.x applications, we introduce a simple sample program.&nbsp; For our example,
we are going to use the &quot;sieve&quot; program.
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; *$include winapi.fi</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; *$noreference</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; INTEGER*2 FUNCTION FWINMAIN( hInstance, hPrevInstance,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &amp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; lpszCmdLine,
nCmdShow )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; *$reference</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; IMPLICIT NONE</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; INTEGER*2 hInstance, hPrevInstance, nCmdShow</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; INTEGER*4 lpszCmdLine</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; include 'windows.fi'</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; * This program computes the prime numbers between 1 and 10,000</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; * using the Sieve of Eratosthenes algorithm.</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; INTEGER UPBOUND</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; PARAMETER (UPBOUND=10000)</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; INTEGER I, K, PRIMES</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; LOGICAL*1 NUMBERS(2:UPBOUND)</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CHARACTER*11 FORM</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CHARACTER*60 BUFFER</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; PARAMETER (FORM='(A,I5,A,I5)')</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DO I = 2, UPBOUND</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; NUMBERS(I) = .TRUE.</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ENDDO</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; PRIMES = 0</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DO I = 2, UPBOUND</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; IF( NUMBERS(I) )THEN</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; PRIMES
= PRIMES + 1</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DO K
= I + I, UPBOUND, I</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp; NUMBERS(K) = .FALSE.</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ENDDO</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ENDIF</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ENDDO</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; WRITE(BUFFER, FORM) 'The Number of Primes between
1 and ',</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &amp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; UPBOUND, ' are: ', PRIMES</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CALL MessageBox( 0, BUFFER,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &amp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;'Sieve of Eratosthenes'c,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &amp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;MB_OK .OR. MB_TASKMODAL )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; END</TT>
<BR><BR>The goal of this program is to count the prime numbers between 1 and 10,000.&nbsp; It uses the famous<B> Sieve of
Eratosthenes</B> algorithm to accomplish this task.&nbsp; We will take you through the steps necessary to produce this result.
<H2 ID="32Mbit_Windows__Building_and_Running_the_GUI_Application"> 32-bit Windows:&nbsp; Building and Running the GUI Application </H2>
<BR>To compile and link our example program which is stored in the file<TT> sieve.for</TT>, enter the following command:
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; C&gt;wfl386 -l=win386&nbsp; sieve.for</TT>
<BR><BR>The typical messages that appear on the screen are shown in the following illustration.
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; C&gt;wfl386 -l=win386&nbsp; sieve.for</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Open Watcom F77/32 Compile and Link Utility</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Copyright (c) 2002-2019 the Open Watcom Contributors. All Rights Reserved.</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Portions Copyright (c) 1990-2002 Sybase, Inc. All Rights Reserved.</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Source code is available under the Sybase Open Watcom Public License.</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; See http://www.openwatcom.org/ for details.</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; wfc386 sieve.for </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Open Watcom FORTRAN 77/32 Optimizing Compiler</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Copyright (c) 2002-2019 the Open Watcom Contributors. All Rights Reserved.</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Portions Copyright (c) 1984-2002 Sybase, Inc. All Rights Reserved.</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Source code is available under the Sybase Open Watcom Public License.</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; See http://www.openwatcom.org/ for details.</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; sieve.for: 4390 statements, 207 bytes, 1585 extensions, 0 warnings, 0 errors</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Open Watcom Linker</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Copyright (c) 2002-2019 the Open Watcom Contributors. All Rights Reserved.</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Portions Copyright (c) 1985-2002 Sybase, Inc. All Rights Reserved.</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Source code is available under the Sybase Open Watcom Public License.</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; See http://www.openwatcom.org/ for details.</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; loading object files</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; searching libraries</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; creating a Windows 32-bit executable</TT>
<BR><BR>If you examine the current directory, you will find that two files have been created.&nbsp; These are<TT> sieve.obj</TT>
(the result of compiling<TT> sieve.for</TT>) and<TT> sieve.rex</TT> (the result of linking<TT> sieve.obj</TT> with the appropriate
Open Watcom FORTRAN 77 libraries).&nbsp; The &quot;.rex&quot; file must now be combined with Open Watcom's 32-bit Windows
supervisor<TT> WIN386.EXT</TT> using the Open Watcom Bind utility.<TT>&nbsp; WBIND.EXE</TT> combines your 32-bit application
code and data (&quot;.rex&quot; file) with the 32-bit Windows supervisor.&nbsp; The process involves the following steps:
<OL>
<LI><TT> WBIND</TT> copies<TT> WIN386.EXT</TT> into the current directory.
<LI><TT> WBIND.EXE</TT> optionally runs the resource compiler on the 32-bit Windows supervisor so that the 32-bit executable
can have access to the applications resources.
<LI><TT> WBIND.EXE</TT> concatenates<TT> WIN386.EXT</TT> and the &quot;.rex&quot; file, and creates a &quot;.exe&quot; file
with the same name as the &quot;.rex&quot; file.
</OL>
<BR>The following describes the syntax of the<TT> WBIND</TT> command.
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; WBIND file_spec [-d] [-n] [-q] [-s supervisor] [-R rc_options]</TT>
<BR><BR>The square brackets [ ] denote items which are optional.
<DL>
<DT>WBIND
<DD>is the name of the Open Watcom Bind utility.
<DT>file_spec
<DD>is the name of the 32-bit Windows EXE to bind.
<DT>-d
<DD>requests that a 32-bit DLL be built.
<DT>-n
<DD>indicates that the resource compiler is NOT to be invoked.
<DT>-q
<DD>requests that WBIND run in quiet mode (no informational messages are displayed).
<DT>-s supervisor
<DD>specifies the path and name of the Windows supervisor to be bound with the application.&nbsp; If not specified, a search of
the paths listed in the<B> PATH</B> environment variable is performed.&nbsp; If this search is not successful and the<B> WATCOM</B>
environment variable is defined, the<TT> %WATCOM%\BINW</TT> directory is searched.
<DT>-R rc_options
<DD>all options after -R are passed to the resource compiler.
</DL>
<BR>To bind our example program, the following command may be issued:
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; C&gt;wbind sieve -n</TT>
<BR><BR>If the &quot;s&quot; option is specified, it must identify the location of the<TT> WIN386.EXT</TT> file or the<TT>
W386DLL.EXT</TT> file (if you are building a DLL).
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; C&gt;wbind sieve -n -s c:\watcom\binw\win386.ext</TT>
<BR><BR>If the &quot;s&quot; option is not specified, then the<B> WATCOM</B> environment variable must be defined or the &quot;BINW&quot;
directory must be listed in your<B> PATH</B> environment variable.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; C&gt;set watcom=c:\watcom</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; or</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; C&gt;path c:\watcom\binw;c:\dos;c:\windows</TT>
<BR><BR>The resultant 32-bit Windows 3.x application<TT> SIEVE.EXE</TT> can now be run under Windows 3.x.
<H2 ID="32Mbit_Windows__Debugging_the_GUI_Application"> 32-bit Windows:&nbsp; Debugging the GUI Application </H2>
<BR>Let us assume that you wish to debug your application in order to locate an error in programming.&nbsp; In the previous
section, the &quot;sieve&quot; program was compiled with default compile and link options.&nbsp; When debugging an application,
it is useful to refer to the symbolic names of routines and variables.&nbsp; It is also convenient to debug at the source
line level rather than the machine language level.&nbsp; To do this, we must direct both the compiler and linker to include
additional debugging information in the object and executable files.&nbsp; Using the<B><I> WFL386</I></B> command, this is
fairly straightforward.<B><I>&nbsp; WFL386</I></B> recognizes the Open Watcom F77 compiler &quot;debug&quot; options and will
create the appropriate debug directives for the Open Watcom Linker.
<BR><BR>For example, to compile and link the &quot;sieve&quot; program with debugging information, the following command may
be issued.
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; C&gt;wfl386 -l=win386&nbsp; -d2 sieve.for</TT>
<BR><BR>The typical messages that appear on the screen are shown in the following illustration.
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; C&gt;wfl386 -l=win386&nbsp; -d2 sieve.for</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Open Watcom F77/32 Compile and Link Utility</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Copyright (c) 2002-2019 the Open Watcom Contributors. All Rights Reserved.</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Portions Copyright (c) 1990-2002 Sybase, Inc. All Rights Reserved.</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Source code is available under the Sybase Open Watcom Public License.</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; See http://www.openwatcom.org/ for details.</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; wfc386 sieve.for&nbsp; -d2</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Open Watcom FORTRAN 77/32 Optimizing Compiler</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Copyright (c) 2002-2019 the Open Watcom Contributors. All Rights Reserved.</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Portions Copyright (c) 1984-2002 Sybase, Inc. All Rights Reserved.</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Source code is available under the Sybase Open Watcom Public License.</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; See http://www.openwatcom.org/ for details.</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; sieve.for: 4390 statements, 293 bytes, 1585 extensions, 0 warnings, 0 errors</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Open Watcom Linker</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Copyright (c) 2002-2019 the Open Watcom Contributors. All Rights Reserved.</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Portions Copyright (c) 1985-2002 Sybase, Inc. All Rights Reserved.</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Source code is available under the Sybase Open Watcom Public License.</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; See http://www.openwatcom.org/ for details.</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; loading object files</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; searching libraries</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; creating a Windows 32-bit executable</TT>
<BR><BR>The &quot;d2&quot; option requests the maximum amount of debugging information that can be provided by the Open Watcom
F77 compiler.<B><I>&nbsp; WFL386</I></B> will make sure that this debugging information is included in the executable file
that is produced by the linker.
<BR><BR>The &quot;bytes&quot; value is larger than in the previous example since selection of the &quot;d2&quot; option results
in fewer code optimizations by default.&nbsp; You can request more optimization by specifying the appropriate options.&nbsp;
However, you do so at the risk of making it more difficult for yourself to determine the relationship between the object code
and the original source language code.
<BR><BR>Once again, the &quot;.rex&quot; file must be combined with Open Watcom's 32-bit Windows supervisor<TT> WIN386.EXT</TT>
using the Open Watcom Bind utility.&nbsp; This step is described in the previous section.
<BR><BR>To request the Open Watcom Debugger to assist in debugging the application, select the Open Watcom Debugger icon.
&nbsp;It would be too ambitious to describe the debugger in this introductory chapter so we refer you to the book entitled<B><I>
Open Watcom Debugger User's Guide.</I></B>
<BR><BR>There are more extensive examples of Windows applications written in FORTRAN 77 in the<TT> \WATCOM\SAMPLES\FORTRAN\WIN</TT>
directory.&nbsp; The example programs are<TT> ELLIPSE.FOR</TT> and<TT> FWCOPY.FOR.</TT>
<H1 ID="32Mbit_Windows__Porting_NonMGUI_Applications_to_32Mbit_Windows_3_x"> 32-bit Windows:&nbsp; Porting Non-GUI Applications to 32-bit Windows 3.x </H1>
<BR>Generally, an application that is to run in a windowed environment must be written in such a way as to exploit the Windows
Application Programming Interface (API).&nbsp; To take an existing character-based (i.e., non-graphical) application that
ran under a system such as DOS and adapt it to run under Windows can require some considerable effort.&nbsp; There is a steep
learning curve associated with the API function libraries.
<BR><BR>This chapter describes how to create a Windows application quickly and simply from an application that does not use
the Windows API.&nbsp; The application will make use of Open Watcom's default windowing support.
<BR><BR>Suppose you have a set of FORTRAN 77 applications that previously ran under a system like DOS and you now wish to
run them under Windows 3.x.&nbsp; To achieve this, you can simply recompile your application with the appropriate options
and link with the appropriate libraries.&nbsp; We provide a default windowing system that turns your character-mode application
into a simple Windows 3.x Graphical User Interface (GUI) application.
<BR><BR>Normally, a Windows 3.x GUI application makes use of user-interface tools such as menus, icons, scroll bars, etc.
&nbsp;However, an application that was not designed as a windowed application (such as a DOS application) can run as a GUI
application.&nbsp; This is achieved by our default windowing system.&nbsp; The following sections describe the default windowing
system.
<H2 ID="32Mbit_Windows__Console_Device_in_a_Windowed_Environment"> 32-bit Windows:&nbsp; Console Device in a Windowed Environment </H2>
<BR>In a FORTRAN 77 application that runs under DOS,<B> unit 5</B> and<B> unit 6</B> are connected to the standard input and
standard output devices respectively.&nbsp; It is not a recommended practice to read directly from the standard input device
or write to the standard output device when running in a windowed environment.&nbsp; For this reason, a default windowing
environment is created for FORTRAN 77 applications that read from<B> unit 5</B> or write to<B> unit 6.</B>&nbsp; When your
application is started, a window is created in which output to<B> unit 6</B> is displayed and input from<B> unit 5</B> is
requested.
<BR><BR>In addition to the standard I/O device, it is also possible to perform I/O to the console by explicitly opening a
file whose name is &quot;CON&quot;.&nbsp; When this occurs, another window is created and displayed.&nbsp; This window is
different from the one created for standard input and standard output.&nbsp; In fact, every time you open the console device
a different window is created.&nbsp; This provides a simple multi-windowing system for multiple streams of data to and from
the console device.
<H2 ID="32Mbit_Windows__The_Sample_NonMGUI_Application"> 32-bit Windows:&nbsp; The Sample Non-GUI Application </H2>
<BR>To demonstrate the creation of 32-bit Windows 3.x applications, we introduce a simple sample program.&nbsp; For our example,
we are going to use the &quot;sieve&quot; program.
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; * This program computes the prime numbers between 1 and 10,000</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; * using the Sieve of Eratosthenes algorithm.</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; IMPLICIT NONE</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; INTEGER UPBOUND</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; PARAMETER (UPBOUND=10000)</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; INTEGER I, K, PRIMES</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; LOGICAL*1 NUMBERS(2:UPBOUND)</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CHARACTER*11 FORM</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; PARAMETER (FORM='(A,I5,A,I5)')</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DO I = 2, UPBOUND</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; NUMBERS(I) = .TRUE.</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ENDDO</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; PRIMES = 0</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DO I = 2, UPBOUND</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; IF( NUMBERS(I) )THEN</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; PRIMES
= PRIMES + 1</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DO K
= I + I, UPBOUND, I</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp; NUMBERS(K) = .FALSE.</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ENDDO</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ENDIF</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ENDDO</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; PRINT FORM, 'The Number of Primes between 1 and ', UPBOUND,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;' are: ', PRIMES</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; END</TT>
<BR><BR>The goal of this program is to count the prime numbers between 1 and 10,000.&nbsp; It uses the famous<B> Sieve of
Eratosthenes</B> algorithm to accomplish this task.&nbsp; We will take you through the steps necessary to produce this result.
<H2 ID="32Mbit_Windows__Building_and_Running_the_NonMGUI_Application"> 32-bit Windows:&nbsp; Building and Running the Non-GUI Application </H2>
<BR>Very little effort is required to port an existing FORTRAN 77 application to Windows 3.x.
<BR><BR>You must compile and link the file<TT> sieve.for</TT> specifying the &quot;bw&quot; option.
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; C&gt;wfl386 -l=win386 -bw sieve.for</TT>
<BR><BR>The typical messages that appear on the screen are shown in the following illustration.
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; C&gt;wfl386 -l=win386 sieve.for</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Open Watcom F77/32 Compile and Link Utility</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Copyright (c) 2002-2019 the Open Watcom Contributors. All Rights Reserved.</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Portions Copyright (c) 1990-2002 Sybase, Inc. All Rights Reserved.</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Source code is available under the Sybase Open Watcom Public License.</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; See http://www.openwatcom.org/ for details.</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; wfc386 sieve.for -bw</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Open Watcom FORTRAN 77/32 Optimizing Compiler</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Copyright (c) 2002-2019 the Open Watcom Contributors. All Rights Reserved.</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Portions Copyright (c) 1984-2002 Sybase, Inc. All Rights Reserved.</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Source code is available under the Sybase Open Watcom Public License.</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; See http://www.openwatcom.org/ for details.</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; sieve.for: 21 statements, 172 bytes, 6 extensions, 0 warnings, 0 errors</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Open Watcom Linker</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Copyright (c) 2002-2019 the Open Watcom Contributors. All Rights Reserved.</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Portions Copyright (c) 1985-2002 Sybase, Inc. All Rights Reserved.</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Source code is available under the Sybase Open Watcom Public License.</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; See http://www.openwatcom.org/ for details.</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; loading object files</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; searching libraries</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; creating a Windows 32-bit executable</TT>
<BR><BR>If you examine the current directory, you will find that two files have been created.&nbsp; These are<TT> sieve.obj</TT>
(the result of compiling<TT> sieve.for</TT>) and<TT> sieve.rex</TT> (the result of linking<TT> sieve.obj</TT> with the appropriate
Open Watcom FORTRAN 77 libraries).&nbsp; The &quot;.rex&quot; file must now be combined with Open Watcom's 32-bit Windows
supervisor<TT> WIN386.EXT</TT> using the Open Watcom Bind utility.<TT>&nbsp; WBIND.EXE</TT> combines your 32-bit application
code and data (&quot;.rex&quot; file) with the 32-bit Windows supervisor.&nbsp; The process involves the following steps:
<OL>
<LI><TT> WBIND</TT> copies<TT> WIN386.EXT</TT> into the current directory.
<LI><TT> WBIND.EXE</TT> optionally runs the resource compiler on the 32-bit Windows supervisor so that the 32-bit executable
can have access to the applications resources.
<LI><TT> WBIND.EXE</TT> concatenates<TT> WIN386.EXT</TT> and the &quot;.rex&quot; file, and creates a &quot;.exe&quot; file
with the same name as the &quot;.rex&quot; file.
</OL>
<BR>The following describes the syntax of the<TT> WBIND</TT> command.
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; WBIND file_spec [-d] [-n] [-q] [-s supervisor] [-R rc_options]</TT>
<BR><BR>The square brackets [ ] denote items which are optional.
<DL>
<DT>WBIND
<DD>is the name of the Open Watcom Bind utility.
<DT>file_spec
<DD>is the name of the 32-bit Windows EXE to bind.
<DT>-d
<DD>requests that a 32-bit DLL be built.
<DT>-n
<DD>indicates that the resource compiler is NOT to be invoked.
<DT>-q
<DD>requests that WBIND run in quiet mode (no informational messages are displayed).
<DT>-s supervisor
<DD>specifies the path and name of the Windows supervisor to be bound with the application.&nbsp; If not specified, a search of
the paths listed in the<B> PATH</B> environment variable is performed.&nbsp; If this search is not successful and the<B> WATCOM</B>
environment variable is defined, the<TT> %WATCOM%\BINW</TT> directory is searched.
<DT>-R rc_options
<DD>all options after -R are passed to the resource compiler.
</DL>
<BR>To bind our example program, the following command may be issued:
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; C&gt;wbind sieve -n</TT>
<BR><BR>If the &quot;s&quot; option is specified, it must identify the location of the<TT> WIN386.EXT</TT> file or the<TT>
W386DLL.EXT</TT> file (if you are building a DLL).
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; C&gt;wbind sieve -n -s c:\watcom\binw\win386.ext</TT>
<BR><BR>If the &quot;s&quot; option is not specified, then the<B> WATCOM</B> environment variable must be defined or the &quot;BINW&quot;
directory must be listed in your<B> PATH</B> environment variable.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; C&gt;set watcom=c:\watcom</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; or</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; C&gt;path c:\watcom\binw;c:\dos;c:\windows</TT>
<BR><BR>The resultant 32-bit Windows 3.x application<TT> SIEVE.EXE</TT> can now be run under Windows 3.x as a Windows GUI
application.
<H2 ID="32Mbit_Windows__Debugging_the_NonMGUI_Application"> 32-bit Windows:&nbsp; Debugging the Non-GUI Application </H2>
<BR>Let us assume that you wish to debug your application in order to locate an error in programming.&nbsp; In the previous
section, the &quot;sieve&quot; program was compiled with default compile and link options.&nbsp; When debugging an application,
it is useful to refer to the symbolic names of routines and variables.&nbsp; It is also convenient to debug at the source
line level rather than the machine language level.&nbsp; To do this, we must direct both the compiler and linker to include
additional debugging information in the object and executable files.&nbsp; Using the<B><I> WFL386</I></B> command, this is
fairly straightforward.<B><I>&nbsp; WFL386</I></B> recognizes the Open Watcom F77 compiler &quot;debug&quot; options and will
create the appropriate debug directives for the Open Watcom Linker.
<BR><BR>For example, to compile and link the &quot;sieve&quot; program with debugging information, the following command may
be issued.
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; C&gt;wfl386 -l=win386 -bw -d2 sieve.for</TT>
<BR><BR>The typical messages that appear on the screen are shown in the following illustration.
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; C&gt;wfl386 -l=win386 -d2 sieve.for</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Open Watcom F77/32 Compile and Link Utility</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Copyright (c) 2002-2019 the Open Watcom Contributors. All Rights Reserved.</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Portions Copyright (c) 1990-2002 Sybase, Inc. All Rights Reserved.</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Source code is available under the Sybase Open Watcom Public License.</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; See http://www.openwatcom.org/ for details.</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; wfc386 sieve.for -bw -d2</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Open Watcom FORTRAN 77/32 Optimizing Compiler</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Copyright (c) 2002-2019 the Open Watcom Contributors. All Rights Reserved.</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Portions Copyright (c) 1984-2002 Sybase, Inc. All Rights Reserved.</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Source code is available under the Sybase Open Watcom Public License.</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; See http://www.openwatcom.org/ for details.</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; sieve.for: 21 statements, 237 bytes, 6 extensions, 0 warnings, 0 errors</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Open Watcom Linker</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Copyright (c) 2002-2019 the Open Watcom Contributors. All Rights Reserved.</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Portions Copyright (c) 1985-2002 Sybase, Inc. All Rights Reserved.</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Source code is available under the Sybase Open Watcom Public License.</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; See http://www.openwatcom.org/ for details.</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; loading object files</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; searching libraries</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; creating a Windows 32-bit executable</TT>
<BR><BR>The &quot;d2&quot; option requests the maximum amount of debugging information that can be provided by the Open Watcom
F77 compiler.<B><I>&nbsp; WFL386</I></B> will make sure that this debugging information is included in the executable file
that is produced by the linker.
<BR><BR>The &quot;bytes&quot; value is larger than in the previous example since selection of the &quot;d2&quot; option results
in fewer code optimizations by default.&nbsp; You can request more optimization by specifying the appropriate options.&nbsp;
However, you do so at the risk of making it more difficult for yourself to determine the relationship between the object code
and the original source language code.
<BR><BR>Once again, the &quot;.rex&quot; file must be combined with Open Watcom's 32-bit Windows supervisor<TT> WIN386.EXT</TT>
using the Open Watcom Bind utility.&nbsp; This step is described in the previous section.
<BR><BR>To request the Open Watcom Debugger to assist in debugging the application, select the Open Watcom Debugger icon.
&nbsp;It would be too ambitious to describe the debugger in this introductory chapter so we refer you to the book entitled<B><I>
Open Watcom Debugger User's Guide.</I></B>
<H2 ID="32Mbit_Windows__Default_Windowing_Library_Functions"> 32-bit Windows:&nbsp; Default Windowing Library Functions </H2>
<BR>A few library functions have been written to enable some simple customization of the default windowing system's behaviour.
&nbsp;The following functions are supplied:
<DL>
<DT>dwfDeleteOnClose
<DD>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; integer function dwfDeleteOnClose( unit )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; integer unit</TT>
<BR><BR>This function tells the console window that it should close itself when the file is closed.&nbsp; You must pass to
it the unit number associated with the opened console.
<DT>dwfSetAboutDlg
<DD>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; integer function dwfSetAboutDlg( title, text )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; character*(*) title</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; character*(*) text</TT>
<BR><BR>This function sets the about dialog box of the default windowing system.&nbsp; The &quot;title&quot; points to the
string that will replace the current title.&nbsp; If title is CHAR(0) then the title will not be replaced.&nbsp; The &quot;text&quot;
points to a string which will be placed in the about box.&nbsp; To get multiple lines, embed a new line after each logical
line in the string.&nbsp; If &quot;text&quot; is CHAR(0), then the current text in the about box will not be replaced.
<DT>dwfSetAppTitle
<DD>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; integer function dwfSetAppTitle( title )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; character*(*) title</TT>
<BR><BR>This function sets the main window's title.
<DT>dwfSetConTitle
<DD>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; integer function dwfSetConTitle( unit, title )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; integer unit</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; character*(*) title</TT>
<BR><BR>This function sets the console window's title which corresponds to the unit number passed to it.
<DT>dwfShutDown
<DD>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; integer function dwfShutDown()</TT>
<BR><BR>This function shuts down the default windowing I/O system.&nbsp; The application will continue to execute but no windows
will be available for output.
<DT>dwfYield
<DD>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; integer function dwfYield()</TT>
<BR><BR>This function yields control back to the operating system, thereby giving other processes a chance to run.
</DL>
<BR>These functions are described more fully in the<B><I> Open Watcom FORTRAN 77 User's Guide.</I></B>
<H1 ID="Windows__The_Open_Watcom_32Mbit_Windows_3_x_Extender"> Windows:&nbsp; The Open Watcom 32-bit Windows 3.x Extender </H1>
<BR>Open Watcom FORTRAN 77 contains the necessary tools and libraries to create 32-bit applications for Windows 3.x.&nbsp;
Using Open Watcom FORTRAN 77 gives the programmer the benefits of a 32-bit flat memory model and access to the full Windows
API (along with the usual FORTRAN 77 and C library functions).
<BR><BR>The general model of the environment is as follows:&nbsp; The 32-bit flat memory model program is linked against a
special 32-bit Windows library.&nbsp; This library contains the necessary information to invoke special 16-bit functions,
which lie in the supervisor<TT> (WIN386.EXT).</TT>&nbsp; The 32-bit program is then bound (using<TT> WBIND.EXE)</TT> with
the supervisor to create a Windows executable.&nbsp; At the same time as the 32-bit program is being bound, the resource compiler
is run on the supervisor, and all the resources for the application are placed there.&nbsp; When the application is started,
the supervisor obtains the 32-bit memory, relocates the 32-bit application into the memory, and invokes the 32-bit application.
<BR><BR>All Windows functions are invoked from the supervisor, and all callback routines lie within the supervisor.&nbsp;
The local heap resides within the supervisor as well.
<BR><BR>If you are starting from a 16-bit Windows application, most of the code will not change when you port it to the 32-bit
Windows environment.&nbsp; However, because of the nature of the Windows API and its implicit dependencies on a 16-bit environment,
some source changes are necessary.&nbsp; These source changes are minimal, and are backwards compatible with the 16-bit environment.
<H2 ID="Windows__Pointers"> Windows:&nbsp; Pointers </H2>
<BR>Throughout this document, there will be references to both<B><I> near</I></B> and<B><I> far</I></B> , and<B><I> 16-bit</I></B>
and<B><I> 32-bit</I></B> pointers.&nbsp; Since this can rapidly become confusing, some initial explanations will be given
here.
<BR><BR>A<B><I> far pointer</I></B> is a pointer that is composed of both a selector and an offset.&nbsp; A selector determines
a specific region of memory, and the offset is relative to the start of this region.&nbsp; A<B><I> near pointer</I></B> is
a pointer that has an offset only, the selector is automatically assumed by the CPU.
<BR><BR>The problem with far pointers is the selector overhead.&nbsp; Using a far pointer is much more expensive than using
a near pointer.&nbsp; This is the advantage of the 32-bit flat memory model - all pointers within the program are near, and
yet you can address up to 4 gigabytes of memory.
<BR><BR>A<B><I> 16-bit near pointer</I></B> occupies 2 bytes of memory (i.e., the offset is 16 bits long).&nbsp; This pointer
can reference up to 64K of data.
<BR><BR>A<B><I> 16-bit far pointer</I></B> occupies 4 bytes of memory.&nbsp; There is a 16-bit selector and a 16-bit offset.
&nbsp;This pointer can reference up to 64K of data.
<BR><BR>A<B><I> 32-bit near pointer</I></B> occupies 4 bytes of memory (i.e., the offset is 32 bits long).&nbsp; This pointer
can reference up to 4 gigabytes of data.
<BR><BR>A<B><I> 32-bit far pointer</I></B> occupies 6 bytes of memory.&nbsp; There is a 16-bit selector and a 32-bit offset.
&nbsp;This pointer can reference up to 4 gigabytes of data.
<BR><BR>Windows, in general, uses 16-bit far pointers to pass information around.&nbsp; These 16-bit far pointers can also
be used by a 32-bit Windows application.&nbsp; The conversion from a 16-bit pointer to a 32-bit pointer will occur automatically
when you map a dynamically allocatable array to the memory pointed to by the 16-bit pointer using the<B><I> LOCATION=</I></B>
specifier of the<B><I> ALLOCATE</I></B> statement.&nbsp; You must also declare the allocatable array as<B><I> far</I></B>
using the<B><I> array</I></B> pragma.&nbsp; The syntax for the<B><I> array</I></B> pragma is:
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; $*pragma array ARRAY_NAME far</TT>
<BR><BR>where<TT> ARRAY_NAME</TT> is the array name.
<H2 ID="Windows__Implementation_Overview"> Windows:&nbsp; Implementation Overview </H2>
<BR>This section provides an overview of the issues that require consideration when creating a 32-bit Windows application
for a 16-bit Windows environment.
<BR><BR>First, all modules have to be recompiled for the 32-bit flat memory model with a compiler capable of generating 32-bit
instructions.
<BR><BR>Pointers to data passed to Windows are all far pointers.&nbsp; We will be passing pointers to data in our 32-bit flat
address space, and these pointers are near pointers.&nbsp; As well, notice that these 32-bit near pointers are the same size
as as their 16-bit far pointer counterparts (4 bytes).&nbsp; This is good, since all data structures containing pointers will
remain the same size.
<BR><BR>Windows cannot be called from 32-bit code on a 32-bit stack.&nbsp; This means that in order to call the API functions,
it is necessary to write a set of cover functions that will accept the parameters, switch into a 16-bit environment, and then
call Windows.&nbsp; There is another issue, though.&nbsp; Windows only understands 16-bit pointers, so before calling Windows,
all pointers being passed to Windows must be converted to 16-bit far pointers.
<BR><BR>It turns out that Windows can also call back to your application.&nbsp; Windows can only call 16-bit code, though,
so there is a need for a bridge from the 16-bit side to the 32-bit side.&nbsp; It is necessary to allocate 16-bit call back
routines that can be passed to Windows.&nbsp; These call back routines will then switch into the 32-bit environment and call
whatever 32-bit function is required.&nbsp; The 32-bit call back has to be declared as a far function, since it is necessary
to issue a far call to enter it from the 16-bit side.&nbsp; If it is a far function, then the compiler will generate the appropriate
code for it to return from the far call.
<BR><BR>Once Windows calls you back, it can hand you 16-bit far pointers in a long (4 byte) parameter.&nbsp; This pointer
can only be used in the 32-bit environment if it is a 32-bit far pointer, not a 16-bit far pointer.&nbsp; The conversion is
simple:&nbsp; the 16-bit offset is extended to a 32-bit offset (the high word is zeroed out).&nbsp; Any far pointer that Windows
hands to you must be converted in this way.&nbsp; This conversion is performed automatically when a dynamically allocatable
array is mapped to a 16-bit far pointer using the<B><I> LOCATION</I></B> specifier of the Open Watcom FORTRAN 77<B><I> ALLOCATE</I></B>
statement and the<B><I> array</I></B> pragma.&nbsp; The syntax for the<B><I> array</I></B> pragma is:
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; $*pragma array ARRAY_NAME far</TT>
<BR><BR>where<TT> ARRAY_NAME</TT> is the array name.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; subroutine DLLSUB( arg_list )</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; structure /argtypes/</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; integer&nbsp;&nbsp;
&nbsp; w1</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; integer&nbsp;&nbsp;
&nbsp; w2</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; integer&nbsp;&nbsp;
&nbsp; w3</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; integer&nbsp;&nbsp;
&nbsp; sum</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; end structure</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; record /argtypes/ args(:)</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; *$pragma array args far</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; integer*4 arg_list</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; allocate( args(1), location=arg_list
)</TT>
<BR><BR>In the preceding example,<TT> arg_list</TT> is a 16-bit far pointer to a structure with the elements described by
the<TT> argtypes</TT> structure.&nbsp; The allocatable array<TT> args</TT> is described as<B><I> far</I></B> using the<B><I>
array</I></B> pragma.
<BR><BR>Sometimes, a Windows application wants to call a procedure in a DLL.&nbsp; The procedure address is a 16-bit far pointer.
&nbsp;It is not possible to issue an indirect call to this address from the 32-bit environment, so some sort of interface
is needed.&nbsp; This interface would switch into the 16-bit environment, and then call the 16-bit function.
<BR><BR>These issues, along with other minor items, are handled by Open Watcom FORTRAN 77, and are discussed in more technical
detail in later sections.
<H2 ID="Windows__System_Structure"> Windows:&nbsp; System Structure </H2>
<BR><TT><IMG SRC="fstruct.bmp" ALIGN=MIDDLE></TT>
<BR><B><I>Figure 5.</I></B><B><I></I></B><B> WIN386 Structure</B>
<BR><BR><TT><IMG SRC="struct2.bmp" ALIGN=MIDDLE></TT>
<BR><B><I>Figure 6.</I></B><B><I></I></B><B> 32-bit Application Structure</B>
<H2 ID="Windows__System_Overview"> Windows:&nbsp; System Overview </H2>
<UL>
<LI><TT> WIN386.EXT</TT> is the key component of a 32-bit Windows application.&nbsp; It is a 16-bit Windows application which
contains:
<UL>
<LI>All application resources.
<LI>A 16-bit local heap.
<LI>A 16-bit stack.
</UL>
<LI><TT> W386DLL.EXT</TT> is similar to<TT> WIN386.EXT,</TT> only it provides a DLL interface.
<BR><BR><TT>WIN386.EXT</TT> is bound to your 32-bit application to create a 32-bit application that will run under Windows
3.x.<TT>&nbsp; WIN386.EXT</TT> provides the following functionality:
<UL>
<LI>supervisor to bring the 32-bit application into memory and start it running.
<LI>&quot;glue&quot; functions to connect to Windows for both API and DOS functionality.&nbsp; This interface is designed
to transparently set up the calling functions' pointers and parameters to their 16-bit counterparts.
<LI>&quot;glue-back&quot; functions to allow Windows to call back 32-bit routines.
<LI>special code to allow debugging of 32-bit applications.
</UL>
<LI>A number of files with file extension<TT> .fi</TT> are located in the<TT> \WATCOM\SRC\FORTRAN\WIN</TT> directory.&nbsp;
The file<TT> WINAPI.FI</TT> describes the calling convention of each Windows API function.&nbsp; Other files define Windows
constants and data structures.
<LI><TT> WIN386.LIB</TT> contains all the necessary library functions to connect to the 32-bit supervisor<TT> WIN386.EXT.</TT>
&nbsp;All Windows API calls and Open Watcom FORTRAN 77 library DOS calls are found here.
<LI>The standard FORTRAN 77 and C library functions, specially modified to run in the 32-bit environment, are located in the<TT>
\WATCOM\LIB386\WIN</TT> directory.
<LI><TT> WBIND.EXE</TT> merges your 32-bit executable and the appropriate Supervisor into a single executable.
</UL>
<H2 ID="Windows__Steps_to_Obtaining_a_32Mbit_Application"> Windows:&nbsp; Steps to Obtaining a 32-bit Application </H2>
<BR>The following is an overview of the procedure for creating a 32-bit Windows Application:
<OL>
<LI>If you are starting with a 16-bit Windows application, you must adapt your source code to the 32-bit environment.
<LI>You must compile the application using a 32-bit compiler.
<LI>You must link the application with the 32-bit libraries.
<LI>You must bind the 32-bit application with the 32-bit supervisor.
<LI>You can then run and/or debug the application.
</OL>
<H1 ID="Windows__Windows_3_x_32Mbit_Programming_Overview"> Windows:&nbsp; Windows 3.x 32-bit Programming Overview </H1>
<BR>This chapter includes the following topics:
<UL>
<LI>WINAPI.FI and WINDOWS.FI
<LI>Environment Notes
<LI>Floating-point Emulation
<LI>Multiple Instances
<LI>Pointer Handling
<LI>When To Convert Incoming Pointers
<LI>When To Convert Outgoing Pointers
<LI>SendMessage and SendDlgItemMessage
<LI>GlobalAlloc and LocalAlloc
<LI>Callback Function Pointers
<LI>Window Sub-classing
<LI>Calling 16-bit DLLs
<LI>_16 Functions
</UL>
<H2 ID="Windows__WINAPI_FI"> Windows:&nbsp; WINAPI.FI </H2>
<BR>When developing programs, make sure<TT> WINAPI.FI</TT> is included at the start of all source files and the necessary
include files (particularly<TT> WINDOWS.FI</TT>) are included in each function or subroutine.
<BR><BR>It is especially important to get the correct function and argument typing information for Windows API functions.
&nbsp;Due to the default typing rules of FORTRAN, many Windows API functions have a default result type of REAL when they
may in fact return an INTEGER or INTEGER*2 result.&nbsp; By including the appropriate include files, you ensure that this
never happens.&nbsp; For example, the function<TT> CreateDialog</TT> is described in<TT> WINDLG.FI.</TT>&nbsp; as a function
returning an INTEGER*2 result.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; external CreateDialog</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; integer*2 CreateDialog</TT>
<BR><BR>Failure to specify the correct type of a function will result in code that looks correct but does not execute correctly.
&nbsp;Similarly, you should make sure that all symbolic constants are properly defined by including the appropriate include
files.&nbsp; For example, the constant<TT> DEFAULT_QUALITY</TT> is described in<TT> WINFONT.FI</TT> as an INTEGER constant
whose value is 0.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; integer DEFAULT_QUALITY</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; parameter ( DEFAULT_QUALITY = 0 )</TT>
<BR><BR>Without this information,<TT> DEFAULT_QUALITY</TT> would be assumed to be a REAL variable and would not have any assigned
value.
<BR><BR>The &quot;EXPLICIT&quot; compiler option is useful in this regard.&nbsp; It requires that all symbols be explicitly
typed.
<H2 ID="Windows__Environment_Notes"> Windows:&nbsp; Environment Notes </H2>
<UL>
<LI>The 32-bit Windows Supervisor uses the first 256 bytes of the 32-bit application's stack to save state information.&nbsp;
If this is corrupted, your application will abnormally terminate.
<LI>The 32-bit Windows Supervisor provides resources for up to 512 callback routines.&nbsp; Note that this restriction is
only on the maximum number of active callbacks.
</UL>
<H2 ID="Windows__FloatingMpoint_Emulation"> Windows:&nbsp; Floating-point Emulation </H2>
<BR>The file<TT> WEMU387.386</TT> is included to support floating-point emulation for 32-bit applications running under Windows.
&nbsp;This file is installed in the<TT> [386Enh]</TT> section of your<TT> SYSTEM.INI</TT> file.&nbsp; By using the floating-point
emulator, your application can be compiled with the &quot;fpi87&quot; option to use inline floating-point instructions, and
it will run on a machine without a numeric coprocessor.
<BR><BR>Only one of<TT> WEMU387.386</TT> and<TT> WDEBUG.386</TT> may be installed in your<TT> [386Enh]</TT> section.&nbsp;
<TT> WEMU387.386</TT> may be distributed with your application.
<H2 ID="Windows__Multiple_Instances"> Windows:&nbsp; Multiple Instances </H2>
<BR>Since the 32-bit application resides in a flat memory space, it is NOT possible to share code with other instances.&nbsp;
This means that you must register new window classes with callbacks into the new instance's code space.&nbsp; A simple way
of accomplishing this is as follows:
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; integer*2 function FWINMAIN( hInstance,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &amp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; hPrevInstance,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &amp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; lpszCmdLine,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &amp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; nCmdShow )</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; integer*2 hInstance</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; integer*2 hPrevInstance</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; integer*2 nCmdShow</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; integer*4 lpszCmdLine</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; include 'win386.fi'</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; include 'wincreat.fi'</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; include 'wincurs.fi'</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; include 'windefn.fi'</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; include 'windisp.fi'</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; include 'winmsg.fi'</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; include 'winmsgs.fi'</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; include 'windtool.fi'</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; include 'winutil.fi'</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; external WndProc</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; integer*2&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; hWnd</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; record /MSG/&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; msg</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; record /WNDCLASS/&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
wndclass</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; character*14&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; class</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; wndclass.style = CS_HREDRAW .or. CS_VREDRAW</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; wndclass.lpfnWndProc = loc( WndProc )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; wndclass.cbClsExtra = 0</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; wndclass.cbWndExtra = 0</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; wndclass.hInstance = hInstance</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; wndclass.hIcon = NULL_HANDLE</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; wndclass.hCursor = LoadCursor( NULL_HANDLE, IDC_ARROW
)</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; wndclass.hbrBackground = GetStockObject( WHITE_BRUSH
)</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; wndclass.lpszMenuName = NULL</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; write( class, '(''Ellipses'',i5.5,a)' ) hInstance, char(0)</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; wndclass.lpszClassName = Loc( class )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call RegisterClass( wndclass )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; hWnd = CreateWindow( class,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &amp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 'Application'c,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &amp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; WS_OVERLAPPEDWINDOW,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &amp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CW_USEDEFAULT,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &amp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &amp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CW_USEDEFAULT,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &amp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &amp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; NULL_HANDLE,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &amp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; NULL_HANDLE,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &amp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; hInstance,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &amp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; NULL )</TT>
<BR><BR>The variable<B><I> class</I></B> contains a unique name based on the instance of the application.
<H2 ID="Windows__Pointer_Handling"> Windows:&nbsp; Pointer Handling </H2>
<BR>Windows 3.x is a 16-bit operating system.&nbsp; Function pointers that Windows deals with are 16-bit far pointers, and
any data you communicate to Windows with are 16-bit far pointers.&nbsp; 16-bit far pointers occupy 4 bytes of data, and are
capable of addressing up to 64K.&nbsp; For data objects larger than 64K, huge pointers are used (a sequence of far pointers
that map out consecutive 64K segments for the data object).&nbsp; 16-bit far pointers are expensive to use due to the overhead
of selector loads (each time you use the pointer, a segment register must have a value put in it).&nbsp; 16-bit huge pointers
are even more expensive:&nbsp; not only is there the overhead of selector loads, but a run-time call is necessary to perform
any pointer arithmetic.
<BR><BR>In a 32-bit flat memory model, such as that of the Open Watcom F77 for Windows environment, all pointers are 32-bit
near pointers (occupying 4 bytes of data as well).&nbsp; However, these pointers may access objects of up to 4 gigabytes in
size, and there is no selector load overhead.
<BR><BR>For a 32-bit environment to communicate with Windows 3.x, there are some considerations.&nbsp; All pointers sent to
Windows must be converted from 32-bit near pointers to 16-bit far pointers.&nbsp; These conversions are handled by the Supervisor.
<BR><BR>It is important to remember that all API functions which accept pointers (with the exception of functions that accept
function pointers) accept 32-bit near pointers in this 32-bit model.&nbsp; If you attempt to pass a 32-bit far pointer, the
conversion will not take place correctly.
<BR><BR>16-bit far pointers to data may be passed into the API functions, and the Supervisor will not do any conversion.
<BR><BR>Incoming pointers must be converted from 16-bit far pointers to 32-bit far pointers.&nbsp; This conversion is a trivial
one:&nbsp; the offset portion of the 16-bit far pointer is extended to 32-bits.&nbsp; The pointer conversion will occur automatically
when you map a dynamically allocatable array to the memory pointed to by the 16-bit pointer using the<B><I> LOCATION=</I></B>
specifier of the<B><I> ALLOCATE</I></B> statement.&nbsp; You must also declare the array as<B><I> far</I></B> using the<B><I>
array</I></B> pragma.&nbsp; The syntax for the<B><I> array</I></B> pragma is:
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; $*pragma array ARRAY_NAME far</TT>
<BR><BR>where<TT> ARRAY_NAME</TT> is the array name.&nbsp; Pointers from Windows are by their nature far (that is, the data
is pointed to by its own selector), and must be used as far in the 32-bit environment.&nbsp; Of course, conversions are only
required if you actually need to reference the pointer.
<BR><BR>Function pointers (i.e., pointers to callback routines) used by Windows are not converted from 32-bit to 16-bit.&nbsp;
Rather, a 16-bit thunking layer that transfers control from the 16-bit environment to the 32-bit environment must be used.
&nbsp;This thunking layer is provided by the Supervisor.
<H3 ID="Windows__When_To_Convert_Incoming_Pointers"> Windows:&nbsp; When To Convert Incoming Pointers </H3>
<BR>Whenever you wish to use a pointer passed to you by Windows, you must map a dynamically allocatable array to the memory
pointed to by the pointer using the<B><I> LOCATION</I></B> specifier of the<B><I> ALLOCATE</I></B> statement.&nbsp; You must
also declare the array as<B><I> far</I></B> using the<B><I> array</I></B> pragma.&nbsp; The pointer conversion will occur
automatically.
<BR><BR>Some places where pointer conversion may be required are:
<UL>
<LI>LocalLock
<LI>GlobalLock
<LI>the lParam in a window callback routine (if it is a pointer)
</UL>
<H3 ID="Windows__When_To_Convert_Outgoing_Pointers"> Windows:&nbsp; When To Convert Outgoing Pointers </H3>
<BR>Typically, there is no need to do any kind of conversions on your pointers when passing them to Windows.&nbsp; The Supervisor
handles all 32-bit to 16-bit translations for you, in the case of the regular Windows API functions.&nbsp; However, if you
are passing a 32-bit pointer to some other 16-bit application in the Windows environment, then pointer conversions must by
done.&nbsp; There are two types of &quot;outgoing&quot; pointers:&nbsp; data pointers and function pointers.
<BR><BR>Function pointers (to callback routines) must have a thunking layer provided, using the<B><I> GetProc16</I></B> function
(this is explained in detail in a later section).
<BR><BR>Data pointers can be translated from 32-bit to 16-bit using the<B><I> AllocAlias16</I></B> and<B><I> AllocHugeAlias16</I></B>
functions.&nbsp; These functions create 16-bit far pointers that have the same linear address as the 32-bit near pointer that
was converted.
<BR><BR>It is important to remember that when passing a pointer to a data structure in this fashion, any pointers in the data
structure must also be converted.
<BR><BR>The Supervisor will convert any pointers that it knows about; but there are some complications created by the fact
that Windows allows you to pass pointers in functions that are prototyped to take a long integer.
<BR><BR>The Windows API functions<B><I> SendMessage</I></B> and<B><I> SendDlgItemMessage</I></B> rely on other fields determining
the nature of the long data item that they accept; this is discussed in detail in the next section.
<H4 ID="Windows__SendMessage_and_SendDlgItemMessage"> Windows:&nbsp; SendMessage and SendDlgItemMessage </H4>
<BR><B><I>SendMessage</I></B> and<B><I> SendDlgItemMessage</I></B> have special cover functions that determine when the 32-bit
integer is really a pointer and needs to be converted.&nbsp; These cover functions are used automatically, unless the macro<B><I>
NOCOVERSENDS</I></B> is defined before including <TT> WINAPI.FI</TT> as in the following example.
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; *$define NOCOVERSENDS</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; *$include winapi.fi</TT>
<BR><BR><B><I>SendMessage</I></B> and<B><I> SendDlgItemMessage</I></B> will do pointer conversions automatically using<B><I>
AllocAlias16</I></B> and<B><I> FreeAlias16</I></B> (unless<B><I> NOCOVERSENDS</I></B> is defined) for the following message
types:
<UL>
<LI>combo boxes (CB_ messages)
<LI>edit controls (EM_ messages)
<LI>list boxes (LB_ messages)
<LI>certain windows messages (WM_ messages);
</UL>
<BR>The messages that are intercepted by the cover functions for<B><I> SendMessage</I></B> and<B><I> SendDlgItemMessage</I></B>
are:
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; CB_ADDSTRING&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CB_DIR&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CB_FINDSTRING</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; CB_FINDSTRINGEXACT CB_GETLBTEXT&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CB_INSERTSTRING</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; CB_SELECTSTRING</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; EM_GETLINE&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; EM_GETRECT&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp; EM_REPLACESEL</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; EM_SETRECT&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; EM_SETRECTNP&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp; EM_SETTABSTOPS</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; LB_ADDSTRING&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; LB_DIR&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; LB_FINDSTRING</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; LB_FINDSTRINGEXACT LB_GETITEMRECT&nbsp;&nbsp;&nbsp;&nbsp; LB_GETSELITEMS</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; LB_GETTEXT&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; LB_INSERTSTRING&nbsp;&nbsp;&nbsp;
LB_SELECTSTRING</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; LB_SETTABSTOPS</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; WM_MDICREATE&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; WM_NCCALCSIZE</TT>
<BR><BR>Note that for<B><I> SendMessage</I></B> and<B><I> SendDlgItemMessage</I></B> , some of the messages may NOT require
pointer conversion:
<UL>
<LI>CB_ADDSTRING, CB_FINDSTRING, CB_FINDSTRINGEXACT, CB_INSERTSTRING will not need a conversion if the combo box was created
as owner-draw style without CBS_HASSTRINGS style.
<LI>LB_ADDSTRING, LB_FINDSTRING, LB_FINDSTRINGEXACT, LB_INSERTSTRING will not need a conversion if the list box was created
as owner-draw style without LBS_HASSTRINGS style.
</UL>
<BR>The macro<B><I> NOCOVERSENDS</I></B> should be defined in modules where messages like these are being sent.&nbsp; With
these messages, the lParam data item does not contain a pointer, and the automatic pointer conversion would be incorrect.
&nbsp;By doing
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; *$define NOCOVERSENDS</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; *$include winapi.fi</TT>
<BR><BR>modules that send messages like the above will not have the pointer conversion performed.
<H3 ID="Windows__GlobalAlloc_and_LocalAlloc"> Windows:&nbsp; GlobalAlloc and LocalAlloc </H3>
<BR>The functions<B><I> GlobalAlloc</I></B> and<B><I> LocalAlloc</I></B> are the typical way of allocating memory in the 16-bit
Windows environment.&nbsp; In the 32-bit environment, there is no need to use these functions.&nbsp; The only time<B><I> GlobalAlloc</I></B>
is needed is when allocating shared memory, i.e.,<B><I> GMEM_DDESHARE</I></B> .
<BR><BR>The<B><I> ALLOCATE</I></B> and<B><I> DEALLOCATE</I></B> statements can be used to allocate memory from your 32-bit
near heap.&nbsp; By allocating memory in this way, you may create data objects as large as the enhanced mode Windows memory
manager will permit.
<H3 ID="Windows__Callback_Function_Pointers"> Windows:&nbsp; Callback Function Pointers </H3>
<BR>To access a callback function, an instance of it must be created using<B><I> MakeProcInstance</I></B> .&nbsp; This creates
a &quot;thunk&quot; (a special piece of code) that automatically puts the application's data segment into the AX register,
and then calls the specified callback function.
<BR><BR>In Windows 3.x, it is not possible to do a<B><I> MakeProcInstance</I></B> directly on a 32-bit callback routine, since
Windows 3.x does not understand 32-bit applications.&nbsp; Therefore, it is necessary to use a 16-bit callback routine that
passes control to the 32-bit callback routine.&nbsp; This 16-bit callback routine is automatically created by the Supervisor
when using any of the standard Windows API functions that accept a callback routine.
<BR><BR>The 16-bit callback routine for a 32-bit application is a special layer that transfers the parameters from a 16-bit
stack to the 32-bit stack, and then passes control to 32-bit code.&nbsp; These 16-bit callback routines are found in the Supervisor.
&nbsp;The function<B><I> GetProc16</I></B> provides pointers to these 16-bit callback routines.
<BR><BR>However, it is not often necessary to use the<B><I> GetProc16</I></B> function to obtain a 16-bit/32-bit callback
interface function.
<BR><BR>In the general case, one would have to write code as follows:
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; integer*4 pCb, fpProc</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pCb = GetProc16( A_Function, GETPROC_callbacktype
)</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; fpProc = MakeProcInstance( pCb, hInstance )</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; *&nbsp;&nbsp;&nbsp;&nbsp; do stuff</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call Do_it( ..., fpProc, ... )</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; *&nbsp;&nbsp;&nbsp;&nbsp; do more stuff</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call FreeProcInstance( fpProc )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call ReleaseProc16( pCb )</TT>
<BR><BR>It is not necessary to use this general code in the case of the regular Windows API functions.&nbsp; The following
functions will automatically allocate the correct 16-bit/32-bit callback interface functions:
<UL>
<LI>ChooseColor
<LI>ChooseFont
<LI>CreateDialog
<LI>CreateDialogIndirect
<LI>CreateDialogIndirectParam
<LI>CreateDialogParam
<LI>DialogBox
<LI>DialogBoxIndirect
<LI>DialogBoxIndirectParam
<LI>DialogBoxParam
<LI>EnumChildWindows
<LI>EnumFonts
<LI>EnumMetaFile
<LI>EnumObjects
<LI>EnumProps
<LI>EnumTaskWindows
<LI>EnumWindows
<LI>Escape (SETABORTPROC option)
<LI>FindText
<LI>GetOpenFileName
<LI>GetSaveFileName
<LI>GlobalNotify
<LI>GrayString
<LI>LineDDA
<LI>PrintDlg
<LI>RegisterClass
<LI>ReplaceText
<LI>SetClassLong (GCL_WNDPROC option)
<LI>SetResourceHandler
<LI>SetTimer
<LI>SetWindowLong (GWL_WNDPROC option)
<LI>SetWindowsHook
</UL>
<BR>As well, the following functions are covered to provide support for automatic creation of 16-bit callback routines:
<UL>
<LI>FreeProcInstance
<LI>MakeProcInstance
<LI>UnhookWindowsHook
</UL>
<BR>If you need to get a callback that is not used by one of the above functions, then you must code the general case.&nbsp;
Typically, this is required when a DLL needs a callback routine.&nbsp; In modules where this is necessary, you define the
macro<B><I> NOAUTOPROCS</I></B> before you include<TT> WINAPI.FI</TT> as in the following example.
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; *$define NOAUTOPROCS</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; *$include winapi.fi</TT>
<BR><BR>Be careful of the following when using<B><I> NOAUTOPROCS</I></B> .
<OL>
<LI>The call to<B><I> MakeProcInstance</I></B> and<B><I> FreeProcInstance</I></B> for the callback function occurs in a module
with<B><I> NOAUTOPROCS</I></B> defined.
<LI>No Windows API functions (listed above) are used in the module with<B><I> NOAUTOPROCS</I></B> defined.&nbsp; If they are,
you must code the general case to use them.
</OL>
<BR>Note that<B><I> NOAUTOPROCS</I></B> is in effect on a module-to-module basis only.
<BR><BR>RegisterClass automatically does a GetProc16 for the callback function, unless the macro NOCOVERRC is specified before
including<TT> WINAPI.FI</TT> as in the following example.
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; *$define NOCOVERRC</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; *$include winapi.fi</TT>
<H4 ID="Windows__Window_SubMclassing"> Windows:&nbsp; Window Sub-classing </H4>
<BR>Sub-classing a Windows control in the 32-bit environment is straightforward.&nbsp; In fact, the code is identical to the
code used in the 16-bit environment.&nbsp; A simple example is:
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; *$include winapi.fi</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; *$pragma aux (callback) SubClassProc parm( value, value, value, value )</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; integer*4 function SubClassProc( hWnd, msg, wp, lp
)</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; integer*2 hWnd</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; integer*2 msg</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; integer*2 wp</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; integer*4 lp</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; include 'windows.fi'</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; common fpOldProc</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; integer*4 fpOldProc</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ! code for sub-classing here</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; SubClassProc = CallWindowProc( fpOldProc, hWnd, msg,
wp, lp )</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; end</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; program SubClassDemo</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; integer*2 hControl</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; common fpOldProc</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; integer*4 fpOldProc</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; integer*4 fp;</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; include 'windows.fi'</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; integer*4 SubClassProc</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; external SubClassProc</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; integer*4 ProgramInstance</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; external ProgramInstance</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ! assume hControl gets created in here</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; fpOldProc = GetWindowLong( hControl, GWL_WNDPROC
)</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; fp = MakeProcInstance( SubClassProc, ProgramInstance
)</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call SetWindowLong( hControl, GWL_WNDPROC, fp )</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ! set it back</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call SetWindowLong( hControl, GWL_WNDPROC, fpOldProc
)</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call FreeProcInstance( fp )</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; end</TT>
<BR><BR>Note that<B><I> SetWindowLong</I></B> is covered to recognize<B><I> GWL_WNDPROC</I></B> and automatically creates
a 16-bit callback for the 32-bit callback.&nbsp; When replacing the callback routine with the original 16-bit routine, the
covered version of<B><I> SetWindowLong</I></B> recognizes that the function is not a 32-bit callback, and so passes the pointer
right through to Windows unchanged.
<H2 ID="Windows__Calling_16Mbit_DLLs"> Windows:&nbsp; Calling 16-bit DLLs </H2>
<BR>A 16-bit function in a DLL can be called using the<B><I> _Call16</I></B> function.&nbsp; The first argument to<B><I> _Call16</I></B>
is the address of the 16-bit function.&nbsp; This address is usually obtained by calling<B><I> GetProcAddress</I></B> with
the name of the desired function.&nbsp; The second argument to<B><I> _Call16</I></B> is a string identifying the types of
the parameters to be passed to the 16-bit function.
<DL>
<DT><B><I>Character</I></B>
<DD><B><I>Parameter Type</I></B>
<DT>c
<DD>call a 'cdecl' function as opposed to a 'pascal' function (if specified, it must be listed first)
<DT>b
<DD>unsigned BYTE
<DT>w
<DD>16-bit WORD
<DT>d
<DD>32-bit DWORD
<DT>f
<DD>double precision floating-point
<DT>p
<DD>32-bit flat pointer (converted to 16:16 far pointer)
</DL>
<BR>The 16-bit function must use either the<B><I> PASCAL</I></B> or<B><I> CDECL</I></B> calling convention.<B><I>&nbsp; PASCAL</I></B>
calling convention is the default.&nbsp; If the function uses the<B><I> CDECL</I></B> calling convention, then you must specify
the letter &quot;c&quot; as the first character of the argument type string.
<BR><BR>Pointer types will automatically be converted from 32-bit near pointers to 16-bit far pointers before the function
is invoked.&nbsp; Note that this pointer is only valid over the period of the call; after control returns to the 32-bit application,
the 16-bit pointer created by the Supervisor is no longer valid.
<BR><BR>The return value from<B><I> _Call16</I></B> is a<B><I> DWORD</I></B> .
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; *$include winapi.fi</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; integer*2 function FWinMain( hInstance,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &amp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; hPrevInstance,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &amp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; lpszCmdLine,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &amp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; nCmdShow )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; integer*2 hInstance</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; integer*2 hPrevInstance</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; integer*4 lpszCmdLine</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; integer*2 nCmdShow</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; include 'windows.fi'</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; integer*2 hDrv, hWnd</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; integer*4 lpfn, cb</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; hDrv = LoadLibrary( 'your.dll'c )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if( hDrv .lt. 32 )then</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; end if</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; lpfn = GetProcAddress( hDrv, 'ExtDeviceMode'c )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if( lpfn .eq. 0 )then</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; end if</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ! Invoke the function.</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cb = _Call16( lpfn, 'wwdppddw'c,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &amp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; hWnd, hDrv, NULL,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &amp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; 'POSTSCRIPT PRINTER'c,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &amp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; 'LPT1'c,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &amp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; NULL, NULL, 0 )</TT>
<H2 ID="Windows___16_Functions"> Windows:&nbsp; _16 Functions </H2>
<BR>Every Windows API function that accepts a pointer has a corresponding _16 function.&nbsp; The _16 version of the function
will not convert any of the pointers that it accepts; it will assume that all pointers are 16-bit far pointers already.&nbsp;
This applies to both data and function pointers.
<H1 ID="Windows__Windows_32MBit_Dynamic_Link_Libraries"> Windows:&nbsp; Windows 32-Bit Dynamic Link Libraries </H1>
<BR>Open Watcom FORTRAN 77 allows the creation of 32-bit Dynamic Link Libraries (DLL).&nbsp; In fact, 32-bit DLLs are simpler
to write than 16-bit DLLs.&nbsp; A 16-bit DLL runs on the caller's stack, and thus DS != SS.&nbsp; This creates difficulties
in the small and medium memory models because near pointers to local variables are different from near pointers to global
variables.&nbsp; The 32-bit DLL runs on its own stack, in the usual flat memory space, which eliminates these concerns.
<BR><BR>There is a special version of the supervisor,<TT> W386DLL.EXT</TT> that performs a similar job to<TT> WIN386.EXT.</TT>
&nbsp;However, the 32-bit DLL supervisor is a 16-bit Windows DLL, rather than a 16-bit Windows application.&nbsp; On the first
use of the 32-bit DLL, the DLL supervisor loads the 32-bit DLL and invokes the 32-bit initialization routine (the DLL's<TT>
FWinMain</TT> routine).&nbsp; The initialization routine declares all entry points (via<TT> DefineDLLEntry</TT>) and performs
any other necessary initialization.&nbsp; An index number in the range 1 to 128 is used to identify all external 32-bit DLL
routines.<TT>&nbsp; DefineDLLEntry</TT> is used to assign an index number to each routine, as well as to identify the arguments.
<BR><BR>The DLL supervisor contains a general entry point for Windows applications to call into called<TT> Win386LibEntry.</TT>
&nbsp;It also contains 128 specific entry points called<TT> DLL1</TT> to<TT> DLL128</TT> which correspond to the entry points
established via<TT> DefineDLLEntry</TT> (the first argument to<TT> DefineDLLEntry</TT> is an index number in the range 1 to
128).&nbsp; All applications call into the 32-bit DLL via these entry points.&nbsp; They build the necessary stack frame and
switch to the 32-bit DLL's data space.
<BR><BR>If you call via<TT> Win386LibEntry</TT> then you pass the DLL entry point number or index (1 to 128) as the last argument.<TT>
&nbsp;Win386LibEntry</TT> uses this index number to call the appropriate 32-bit DLL routine.&nbsp; From a pseudo-code point
of view, the 16-bit supervisor might look like the following:
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; DLL1::&nbsp; set index=1</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; invoke 32bitDLLindirect</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; DLL2::&nbsp; set index=2</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; invoke 32bitDLLindirect</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; DLL128:: set index=128</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; invoke 32bitDLLindirect</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Win386LibEntry::</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; set index from index_argument</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; invoke 32bitDLLindirect</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; 32bitDLLindirect:</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; set up stack frame</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; switch to 32-bit data space</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call indirect registration_list[ index ]</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .</TT>
<BR><BR>When you are creating a 32-bit DLL, keep in mind that the entry points you define may be invoked by a 16-bit application
as well as a 32-bit application.&nbsp; It is for this reason that all far pointers passed to a 32-bit DLL are 16-bit far pointers.
&nbsp;Hence, whenever a pointer is passed as an argument to a 32-bit DLL entry point and you wish to access the data it points
to, you must convert the pointer appropriately.&nbsp; To do this, you must map a dynamically allocatable array to the memory
pointed to by the 16-bit far pointer.
<H2 ID="Windows__A_Sample_32Mbit_DLL"> Windows:&nbsp; A Sample 32-bit DLL </H2>
<BR>Let us begin our discussion of DLLs by showing the code for a simple DLL.&nbsp; The source code for these examples is
provided in the<TT> \WATCOM\SAMPLES\FORTRAN\WIN\DLL</TT> directory.&nbsp; We describe how to compile and link the examples
in the section entitled <A HREF="#Windows__Creating_and_Debugging_Dynamic_Link_Libraries">Windows:&nbsp; Creating and Debugging Dynamic Link Libraries</A>.
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; *$include winapi.fi</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; * WINDLLV.FOR</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; * Setup:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; set finclude=\WATCOM\src\fortran\win</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; * Compile and Link: wfl386 windllv -explicit -d2 -bd -l=win386</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; * Bind:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; wbind windllv
-d -n</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; *$pragma aux (dll_function) Add3</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; integer function Add3( w1, w2, w3 )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; integer*4 w1, w2, w3</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; include 'windows.fi'</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; character*128 str</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; write( str, '(16hDLL 1 arguments:, 3i10, a)' ) w1,
w2, w3,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &amp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; char(0)</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call MessageBox( NULL, str, 'DLL Function 1'c, MB_OK
)</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Add3 = w1 + w2 + w3</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; end</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; *$pragma aux (dll_function) Add2</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; integer function Add2( w1, w2 )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; integer*4 w1, w2</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; include 'windows.fi'</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; character*128 str</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; write( str, '(16hDLL 2 arguments:, 2i10, a)' ) w1,
w2, char(0)</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call MessageBox( NULL, str, 'DLL Function 2'c, MB_OK
)</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Add2 = w1 + w2</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; end</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; integer*2 function FWinMain( hInstance,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &amp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; hPrevInstance,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &amp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; lpszCmdLine,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &amp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; nCmdShow )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; integer*2 hInstance</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; integer*2 hPrevInstance</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; integer*4 lpszCmdLine</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; integer*2 nCmdShow</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; include 'windows.fi'</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; external Add3, Add2</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; integer rc</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call BreakPoint</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rc = DefineDLLEntry( 1, Add3, DLL_DWORD, DLL_DWORD, DLL_DWORD,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &amp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DLL_ENDLIST )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if( rc .ne. 0 )then</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; FWinMain = 0</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; end if</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rc = DefineDLLEntry( 2, Add2, DLL_DWORD, DLL_DWORD,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &amp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DLL_ENDLIST )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if( rc .ne. 0 )then</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; FWinMain = 0</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; end if</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call MessageBox( NULL, '32-bit DLL started'c,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &amp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 'WINDLLV'c, MB_OK )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; FWinMain = 1</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; end</TT>
<BR><BR>There are two entry points defined,<TT> Add3</TT> (index number 1) and<TT> Add2</TT> (index number 2).<TT>&nbsp; Add3</TT>
has three INTEGER*4 arguments and<TT> Add2</TT> has two INTEGER*4 arguments.&nbsp; The argument lists are described by calling<TT>
DefineDLLEntry.</TT>&nbsp; All arguments are passed by value.&nbsp; As previously mentioned, all pointers passed to 32-bit
DLLs are 16-bit far pointers.&nbsp; Since, by default, FORTRAN 77 passes arguments by reference (a pointer to the data is
passed instead of the actual data), a level of complexity is introduced since some pointer conversions must take place when
accessing the data pointed to by a 16-bit far pointer in a 32-bit environment.&nbsp; We will deal with this problem in a following
example.&nbsp; First, let us deal with passing arguments by value to 32-bit DLLs from 16 and 32-bit Windows applications.
<BR><BR>Note that each entry name must be given the<TT> dll_function</TT> attribute using an auxiliary pragma.&nbsp; This
alias name is defined in the file<TT> WINAPI.FI.</TT>
<BR><BR><TT>FWinMain</TT> returns zero to notify Windows that the DLL initialization failed, and returns a one if initialization
succeeds.
<BR><BR><TT>FWinMain</TT> accepts the same arguments as the<TT> FWinMain</TT> procedure of a regular Windows program, however,
only two arguments are used.<TT>&nbsp; hInstance</TT> is the DLL handle and<TT> lpszCmdLine</TT> is the command line passed
to the DLL.
<H2 ID="Windows__Calling_Functions_in_a_32Mbit_DLL_from_a_16Mbit_Application"> Windows:&nbsp; Calling Functions in a 32-bit DLL from a 16-bit Application </H2>
<BR>The following is a 16-bit Windows program that demonstrates how to call the two routines defined in our DLL example.
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; *$include winapi.fi</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; * GEN16V.FOR</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; * Setup:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; set finclude=\WATCOM\src\fortran\win</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; * Compile and Link: wfl gen16v -explicit -d2 -windows -l=windows</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; *&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -&quot;op desc '16-bit DLL Test'&quot;</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; *$pragma aux (dll32_call) indirect_1 \</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; *&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; parm( value*4, value*4,
value*4 )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; *$pragma aux (dll32_call) indirect_2 \</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; *&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; parm( value*4, value*4
)</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; integer*2 function FWinMain( hInstance,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &amp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; hPrevInstance,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &amp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; lpszCmdLine,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &amp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; nCmdShow )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; integer*2 hInstance</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; integer*2 hPrevInstance</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; integer*4 lpszCmdLine</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; integer*2 nCmdShow</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; include 'windows.fi'</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; integer*2 hlib</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; integer*4 indirect_1, indirect_2</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; integer*4 dll_1, dll_2, cb</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; character*128 str</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; hlib = LoadLibrary( 'windllv.dll'c )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if( hlib .lt. 32 ) then</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call MessageBox( NULL, 'Can''t
load WINDLLV'c,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &amp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 'Gen16V'c, MB_OK )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; stop</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; endif</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; dll_1 = GetProcAddress( hlib, 'DLL1'c )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; dll_2 = GetProcAddress( hlib, 'DLL2'c )</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cb = indirect_1( 111, 22222, 3333, dll_1 )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; write( str, '(15hDLL 1 returned , i10, a)' ) cb, char(0)</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call MessageBox( NULL, str, 'Gen16V Test 1'c, MB_OK )</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cb = indirect_2( 4444, 55, dll_2 )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; write( str, '(15hDLL 2 returned , i10, a)' ) cb, char(0)</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call MessageBox( NULL, str, 'Gen16V Test 2'c, MB_OK )</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; FWinMain = 0</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; end</TT>
<BR><BR>The addresses of the routines<TT> DLL1</TT> and<TT> DLL2</TT> in the 32-bit DLL are obtained and stored in the variables<TT>
dll_1</TT> and<TT> dll_2.</TT>&nbsp; Since the FORTRAN 77 language does not support indirect function calls, we need a mechanism
to call these functions indirectly.&nbsp; We do this using the two indirect functions called<TT> indirect_1</TT> and<TT> indirect_2.</TT>
&nbsp;These two functions are given the<TT> dll32_call</TT> attribute using an auxiliary pragma which is defined in the file<TT>
WINAPI.FI.</TT>&nbsp; Note that the last argument of the calls to<TT> indirect_1</TT> or<TT> indirect_2</TT> is the actual
address of the DLL routine.
<BR><BR>What you should realize is that the<TT> indirect_1</TT> and<TT> indirect_2</TT> functions do not really exist.&nbsp;
The code that is generated for statements like the following is really an indirect call to the function whose address is represented
in the last argument.
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; cb = indirect_1( 111, 22222, 3333, dll_1 )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; cb = indirect_2( 4444, 55, dll_2 )</TT>
<BR><BR>This is a result of using the<TT> dll32_call</TT> auxiliary pragma attribute to describe both<TT> indirect_1</TT>
and<TT> indirect_2.</TT>&nbsp; You can verify this by disassembling the object file that is generated when this code is compiled.
<H2 ID="Windows__Calling_Functions_in_a_32Mbit_DLL_from_a_32Mbit_Application"> Windows:&nbsp; Calling Functions in a 32-bit DLL from a 32-bit Application </H2>
<BR>The following is a 32-bit Windows program that demonstrates how to call the two routines defined in our 32-bit DLL example.
&nbsp;Since this is a 32-bit Windows program, we will use the<TT> _Call16</TT> function to call functions in our 32-bit DLL.
&nbsp;Note that we get to the 32-bit DLL functions by going indirectly through the 16-bit supervisor that forms the &quot;front
end&quot; for our 32-bit DLL.
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; *$include winapi.fi</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; * GEN32V.FOR</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; * Setup:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; set finclude=\WATCOM\src\fortran\win</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; * Compile and Link: wfl386 gen32v -explicit -d2 -l=win386</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; * Bind:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; wbind gen32v
-n -D &quot;32-bit DLL Test&quot;</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; integer*2 function FWinMain( hInstance,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &amp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; hPrevInstance,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &amp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; lpszCmdLine,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &amp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; nCmdShow
)</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; integer*2 hInstance</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; integer*2 hPrevInstance</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; integer*4 lpszCmdLine</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; integer*2 nCmdShow</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; include 'windows.fi'</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; integer*2 hlib</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; integer*4 dll_1, dll_2, cb</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; character*128 str</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; hlib = LoadLibrary( 'windllv.dll'c )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if( hlib .lt. 32 ) then</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call MessageBox( NULL, 'Can''t
load WINDLLV'c,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &amp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 'Gen32V'c, MB_OK )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; stop</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; endif</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; dll_1 = GetProcAddress( hlib, 'DLL1'c )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; dll_2 = GetProcAddress( hlib, 'DLL2'c )</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cb = _Call16( dll_1, 'ddd'c, 111, 22222, 3333 )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; write( str, '(15hDLL 1 returned , i10, a)' ) cb, char(0)</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call MessageBox( NULL, str, 'Gen32V Test 1'c, MB_OK )</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cb = _Call16( dll_2, 'dd'c, 4444, 55 )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; write( str, '(15hDLL 2 returned , i10, a)' ) cb, char(0)</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call MessageBox( NULL, str, 'Gen32V Test 2'c, MB_OK )</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; FWinMain = 0</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; end</TT>
<BR><BR>Note that the first argument of a call to<TT> _Call16</TT> is the DLL function address returned by<TT> GetProcAddress</TT>
and must be a 32-bit argument.&nbsp; The second argument of a call to<TT> _Call16</TT> is a string describing the types of
arguments that will be passed to the DLL function.
<H2 ID="Windows__A_Sample_32Mbit_DLL_Using_a_Structure"> Windows:&nbsp; A Sample 32-bit DLL Using a Structure </H2>
<BR>As previously mentioned, passing pointers from a 16 or 32-bit Windows application to a 32-bit DLL poses a problem since
all pointers are passed as 16-bit far pointers.&nbsp; The pointer must be converted from a 16-bit far pointer to a 32-bit
far pointer.&nbsp; This is achieved by mapping a dynamically allocatable array to each argument that is passed by reference
using the<TT> LOCATION</TT> specifier of the<TT> ALLOCATE</TT> statement.&nbsp; Furthermore, you must specify the<TT> far</TT>
attribute for each such array using the<TT> array</TT> pragma.&nbsp; Since this is cumbersome if you wish to pass many arguments,
it is recommended that a single argument be passed that is actually a pointer to a structure that contains the actual arguments.
&nbsp;Furthermore, since each call to a DLL routine is made indirectly through one of<TT> Win386LibEntry</TT> or<TT> DLL1</TT>
through<TT> DLL128,</TT> you should also return any values in the same structure since the return value from any of these
functions is only 32-bits wide.
<BR><BR>The following example is a 32-bit DLL that receives its arguments and returns values using a structure.&nbsp; The
source code for these examples is provided in the<TT> \WATCOM\SAMPLES\FORTRAN\WIN\DLL</TT> directory.&nbsp; We describe how
to compile and link the examples in the section entitled <A HREF="#Windows__Creating_and_Debugging_Dynamic_Link_Libraries">Windows:&nbsp; Creating and Debugging Dynamic Link Libraries</A>.
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; *$include winapi.fi</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; * WINDLL.FOR</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; * Setup:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; set finclude=\WATCOM\src\fortran\win</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; * Compile and Link: wfl386 windll -explicit -d2 -bd -l=win386</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; * Bind:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; wbind windll
-d -n</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; *$pragma aux (dll_function) Add3</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; subroutine Add3( arg_list )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; integer*4 arg_list</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; structure /argtypes/</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; integer&nbsp;&nbsp;&nbsp;&nbsp;
w1</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; integer&nbsp;&nbsp;&nbsp;&nbsp;
w2</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; integer&nbsp;&nbsp;&nbsp;&nbsp;
w3</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; integer&nbsp;&nbsp;&nbsp;&nbsp;
sum</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; end structure</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; record /argtypes/ args(:)</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; *$pragma array args far</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; include 'windows.fi'</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; character*128 str</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; allocate( args(1), location=arg_list )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; write( str, '(16hDLL 1 arguments:, 3i10, a)' ) args(1).w1,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &amp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; args(1).w2,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &amp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; args(1).w3,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &amp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; char(0)</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call MessageBox( NULL, str, 'DLL Function 1'c, MB_OK
)</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; args(1).sum = args(1).w1 + args(1).w2 + args(1).w3</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; deallocate( args )</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; end</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; *$pragma aux (dll_function) Add2</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; subroutine Add2( arg_list )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; integer*4 arg_list</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; structure /argtypes/</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; real&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp; w1</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; real&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp; w2</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; real&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp; sum</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; end structure</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; record /argtypes/ args(:)</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; *$pragma array args far</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; include 'windows.fi'</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; character*128 str</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; allocate( args(1), location=arg_list )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; write( str, '(16hDLL 2 arguments:, 2f10.2, a)' ) args(1).w1,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &amp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; args(1).w2,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &amp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; char(0)</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call MessageBox( NULL, str, 'DLL Function 2'c, MB_OK
)</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; args(1).sum = args(1).w1 + args(1).w2</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; deallocate( args )</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; end</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; integer*2 function FWinMain( hInstance,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &amp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; hPrevInstance,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &amp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; lpszCmdLine,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &amp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; nCmdShow )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; integer*2 hInstance</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; integer*2 hPrevInstance</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; integer*4 lpszCmdLine</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; integer*2 nCmdShow</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; include 'windows.fi'</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; external Add3, Add2</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; integer rc</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call BreakPoint</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rc = DefineDLLEntry( 1, Add3, DLL_PTR, DLL_ENDLIST )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if( rc .ne. 0 )then</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; FWinMain = 0</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; end if</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rc = DefineDLLEntry( 2, Add2, DLL_PTR, DLL_ENDLIST
)</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if( rc .ne. 0 )then</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; FWinMain = 0</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; end if</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call MessageBox( NULL, '32-bit DLL started'c,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &amp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 'WINDLL'c, MB_OK )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; FWinMain = 1</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; end</TT>
<BR><BR>The following example is a 16-bit Windows application that passes arguments to a 32-bit DLL using a structure.
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; *$include winapi.fi</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; * GEN16.FOR</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; * Setup:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; set finclude=\WATCOM\src\fortran\win</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; * Compile and Link: wfl gen16 -explicit -d2 -windows -l=windows</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; *&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -&quot;op desc '16-bit DLL Test'&quot;</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; *$pragma aux (dll32_call) indirect_1 parm( reference, value*4 )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; *$pragma aux (dll32_call) indirect_2 parm( reference, value*4 )</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; integer*2 function FWinMain( hInstance,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &amp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; hPrevInstance,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &amp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; lpszCmdLine,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &amp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; nCmdShow )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; integer*2 hInstance</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; integer*2 hPrevInstance</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; integer*4 lpszCmdLine</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; integer*2 nCmdShow</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; include 'windows.fi'</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; integer*2 hlib</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; integer*4 dll_1, dll_2</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; character*128 str</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; structure /args_1/</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; integer&nbsp;&nbsp;&nbsp;&nbsp;
w1</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; integer&nbsp;&nbsp;&nbsp;&nbsp;
w2</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; integer&nbsp;&nbsp;&nbsp;&nbsp;
w3</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; integer&nbsp;&nbsp;&nbsp;&nbsp;
sum</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; end structure</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; structure /args_2/</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; real&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp; w1</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; real&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp; w2</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; real&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp; sum</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; end structure</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; record /args_1/ args_1/111, 22222, 3333, 0/</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; record /args_2/ args_2/714.3, 35.7, 0.0/</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; hlib = LoadLibrary( 'windll.dll'c )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if( hlib .lt. 32 ) then</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call MessageBox( NULL, 'Can''t
load WINDLL'c,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &amp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 'Gen16'c, MB_OK )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; stop</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; endif</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; dll_1 = GetProcAddress( hlib, 'DLL1'c )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; dll_2 = GetProcAddress( hlib, 'DLL2'c )</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call indirect_1( args_1, dll_1 )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; write( str, '(15hDLL 1 returned , i10, a)' ) args_1.sum,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &amp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; char(0)</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call MessageBox( NULL, str, 'Gen16 Test 1'c, MB_OK )</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call indirect_2( args_2, dll_2 )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; write( str, '(15hDLL 2 returned , f10.2, a)' ) args_2.sum,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &amp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; char(0)</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call MessageBox( NULL, str, 'Gen16 Test 2'c, MB_OK )</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; FWinMain = 0</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; end</TT>
<BR><BR>The following example is a 32-bit Windows application that passes arguments to a 32-bit DLL using a structure.
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; *$include winapi.fi</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; * GEN32.FOR</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; * Setup:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; set finclude=\WATCOM\src\fortran\win</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; * Compile and Link: wfl386 gen32 -explicit -d2 -l=win386</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; * Bind:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; wbind gen32
-n -D &quot;32-bit DLL Test&quot;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; integer*2 function FWinMain( hInstance,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &amp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; hPrevInstance,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &amp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; lpszCmdLine,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &amp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; nCmdShow )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; integer*2 hInstance</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; integer*2 hPrevInstance</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; integer*4 lpszCmdLine</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; integer*2 nCmdShow</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; include 'windows.fi'</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; integer*2 hlib</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; integer*4 dll_1, dll_2, cb</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; character*128 str</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; structure /args_1/</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; integer&nbsp;&nbsp;&nbsp;&nbsp;
w1</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; integer&nbsp;&nbsp;&nbsp;&nbsp;
w2</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; integer&nbsp;&nbsp;&nbsp;&nbsp;
w3</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; integer&nbsp;&nbsp;&nbsp;&nbsp;
sum</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; end structure</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; structure /args_2/</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; real&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp; w1</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; real&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp; w2</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; real&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp; sum</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; end structure</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; record /args_1/ args_1/111, 22222, 3333, 0/</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; record /args_2/ args_2/714.3, 35.7, 0.0/</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; hlib = LoadLibrary( 'windll.dll'c )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if( hlib .lt. 32 ) then</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call MessageBox( NULL, 'Can''t
load WINDLL'c,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &amp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 'Gen32'c, MB_OK )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; stop</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; endif</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; dll_1 = GetProcAddress( hlib, 'DLL1'c )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; dll_2 = GetProcAddress( hlib, 'DLL2'c )</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cb = _Call16( dll_1, 'p'c, loc(args_1) )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; write( str, '(15hDLL 1 returned , i10, a)' ) args_1.sum,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &amp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; char(0)</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call MessageBox( NULL, str, 'Gen32 Test 1'c, MB_OK )</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cb = _Call16( dll_2, 'p'c, loc(args_2) )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; write( str, '(15hDLL 2 returned , f10.2, a)' ) args_2.sum,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &amp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; char(0)</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call MessageBox( NULL, str, 'Gen32 Test 2'c, MB_OK )</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; FWinMain = 0</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; end</TT>
<H2 ID="Windows__Creating_and_Debugging_Dynamic_Link_Libraries"> Windows:&nbsp; Creating and Debugging Dynamic Link Libraries </H2>
<BR>In the following sections, we will take you through the steps of compiling, linking, and debugging 32-bit Dynamic Link
Libraries (DLLs).
<BR><BR>We will use example programs that are provided in source-code form in the Open Watcom F77 package.&nbsp; The files
described in this chapter are located in the directory<TT> \WATCOM\SAMPLES\FORTRAN\WIN\DLL.</TT>&nbsp; The following files
are provided:
<DL>
<DT>WINDLLV.FOR
<DD>is the source code for a simple 32-bit DLL containing two library routines that use integer arguments to pass information.
<DT>GEN16V.FOR
<DD>is the source code for a generic 16-bit Windows application that calls functions in the &quot;WINDLLV&quot; 32-bit Windows
DLL.
<DT>GEN32V.FOR
<DD>is the source code for a generic 32-bit Windows application that calls functions in the &quot;WINDLLV&quot; 32-bit Windows
DLL.
<DT>WINDLL.FOR
<DD>is the source code for a simple 32-bit DLL containing two library routines that use structures to pass information.
<DT>GEN16.FOR
<DD>is the source code for a generic 16-bit Windows application that calls functions in the &quot;WINDLL&quot; 32-bit Windows
DLL.
<DT>GEN32.FOR
<DD>is the source code for a generic 32-bit Windows application that calls functions in the &quot;WINDLL&quot; 32-bit Windows
DLL.
<DT>MAKEFILE
<DD>is a makefile for compiling and linking the programs described above.
</DL>
<H3 ID="Windows__Building_the_Applications"> Windows:&nbsp; Building the Applications </H3>
<BR>To create the DLLs and test applications, we will use the WATCOM Open Watcom Make utility and the supplied makefile.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; C&gt;wmake -f makefile</TT>
<H3 ID="Windows__Installing_the_Examples_under_Windows"> Windows:&nbsp; Installing the Examples under Windows </H3>
<BR>Start up Microsoft Windows 3.x if you have not already done so.&nbsp; Add the<TT> GEN16V.EXE</TT> and<TT> GEN32V.EXE</TT>
files to one of your Window groups using the Microsoft Program Manager.
<OL>
<LI>Select the &quot;New...&quot; entry from the &quot;File&quot; menu of the Microsoft Windows Program Manager.
<LI>Select &quot;Program Item&quot; from the &quot;New Program Object&quot; window and press the &quot;OK&quot; button.
<LI>Enter &quot;16-bit DLL Test&quot; as a description for the GEN16V program.&nbsp; Enter the full path to the GEN16V program
as a command line.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Description:&nbsp;&nbsp;&nbsp; 16-bit DLL Test</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Command Line:&nbsp;&nbsp; c:\work\dll\gen16v.exe</TT>
<LI>Enter &quot;32-bit DLL Test&quot; as a description for the GEN32V program.&nbsp; Enter the full path to the GEN32V program
as a command line.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Description:&nbsp;&nbsp;&nbsp; 32-bit DLL Test</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Command Line:&nbsp;&nbsp; c:\work\dll\gen32v.exe</TT>
</OL>
<BR>Use a similar procedure to install the<TT> GEN16.EXE</TT> and<TT> GEN32.EXE</TT> programs.
<H3 ID="Windows__Running_the_Examples"> Windows:&nbsp; Running the Examples </H3>
<BR>Start the 16-bit application by double clicking on its icon.&nbsp; A number of message boxes are presented.&nbsp; You
may wish to compare the output in each message box with the source code of the program to determine if the correct results
are being obtained.&nbsp; Click on the &quot;OK&quot; button as each of them are displayed.
<BR><BR>Similarly, start the 32-bit application by double-clicking on its icon and observe the results.
<H3 ID="Windows__Debugging_a_32Mbit_DLL"> Windows:&nbsp; Debugging a 32-bit DLL </H3>
<BR>The Open Watcom Debugger can be used to debug a DLL.&nbsp; To debug a 32-bit DLL, a &quot;breakpoint&quot; instruction
must be inserted into the source code for the DLL at the &quot;FWinMain&quot; entry point.&nbsp; This is done using the &quot;pragma&quot;
compiler directive.&nbsp; We have already added the breakpoint to the source code for the 32-bit DLL.
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;.</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;.</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;.</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; integer*2 function FWinMain( hInstance,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &amp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; hPrevInstance,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &amp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; lpszCmdLine,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &amp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; nCmdShow
)</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; integer*2 hInstance</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; integer*2 hPrevInstance</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; integer*4 lpszCmdLine</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; integer*2 nCmdShow</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; include 'windows.fi'</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; external Add3, Add2</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; integer rc</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call BreakPoint</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rc = DefineDLLEntry( 1, Add3, DLL_DWORD,
DLL_DWORD, DLL_DWORD,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &amp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DLL_ENDLIST )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if( rc .ne. 0 )then</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; FWinMain = 0</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; end if</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;.</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;.</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;.</TT>
<BR><BR>The pragma for &quot;BreakPoint&quot; is defined in the &quot;WINAPI.FI&quot; file.
<BR><BR>Start up Microsoft Windows 3.x if you have not already done so.&nbsp; Start the debugger by double-clicking on the
Open Watcom Debugger icon.&nbsp; At the prompt, enter the path specification for the application.&nbsp; When the debugger
has successfully loaded GEN32v, start execution of the program.&nbsp; When the breakpoint is encountered in the 32-bit DLL,
the debugger is re-entered.&nbsp; The debugger will automatically skip past the breakpoint.
<BR><BR>From this point on, you can symbolically debug the 32-bit DLL.&nbsp; You might, for example, set breakpoints at the
start of each DLL routine to debug each of them as they are called.
<H3 ID="Windows__Summary"> Windows:&nbsp; Summary </H3>
<BR>Note that the &quot;FWinMain&quot; entry point is only called once, at the start of any application requesting it.&nbsp;
After this, the &quot;FWinMain&quot; entry point is no longer called.&nbsp; You may have to restart Windows to debug this
section of code a second or third time.
<H1 ID="Windows__Interfacing_Visual_Basic_and_Open_Watcom_FORTRAN_77_DLLs"> Windows:&nbsp; Interfacing Visual Basic and Open Watcom FORTRAN 77 DLLs </H1>
<BR>This chapter describes how to interface Microsoft Visual Basic 3.0 applications and 32-bit Dynamic Link Libraries (DLLs)
created by Open Watcom FORTRAN 77.&nbsp; It describes how to write functions for a 32-bit DLL, how to compile and link them,
and how to call these functions from Visual Basic.&nbsp; One of the proposed techniques involves the use of a set of cover
functions in a 16-bit DLL so, indirectly, this chapter also describes interfacing to 16-bit DLLs.
<BR><BR>It is possible to invoke the<TT> Win386LibEntry</TT> function (Open Watcom's 32-bit function entry point, described
below) directly from Visual Basic.&nbsp; However, this technique limits the arguments that can be passed to a 32-bit DLL.
&nbsp;The procedure and problems are explained below.
<BR><BR>To work around the problem, a 16-bit DLL can be created, that covers the 32-bit DLL.&nbsp; Within the 16-bit DLL,
we will place cover functions that will call the corresponding 32-bit function in the 32-bit DLL.&nbsp; We illustrate the
creation of the 16-bit DLL using the 16-bit C compiler in Open Watcom C/C++.
<BR><BR>Before we begin our example, there are some important technical issues to consider.
<BR><BR>The discussion in this chapter assumes that you, the developer, have a working knowledge of Visual Basic, including
how to bring up the general declarations screen, how to create command buttons, and how to associate code with command buttons.
&nbsp;You must use Visual Basic 3.0 or later.&nbsp; Visual Basic Version 2.x will not work because of a deficiency in this
product regarding the calling of functions in DLLs.
<BR><BR>For the purposes of the following discussion, you should have installed the 32-bit version of Open Watcom FORTRAN
77, as well as version 3.0 or later of Visual Basic.&nbsp; If you also have the 16-bit Open Watcom C compiler, you can use
this to create a 16-bit DLL containing the 16-bit cover functions.&nbsp; Ensure that the<B> PATH</B> amd<B> FINCLUDE</B> environment
variables are defined to include at least the directories indicated.&nbsp; We have assumed that Open Watcom FORTRAN 77 is
installed in the<TT> c:\watcom</TT> directory, and Visual Basic is in the<TT> c:\vb</TT> directory:
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; set path=c:\watcom\binw;c:\vb;c:\dos;c:\windows</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; set finclude=c:\watcom\src\fortran\win</TT>
<BR><BR>Open Watcom's 32-bit DLL supervisor contains a general entry point for Windows applications to call into called<TT>
Win386LibEntry.</TT>&nbsp; It also contains 128 specific entry points called<TT> DLL1</TT> to<TT> DLL128</TT> which correspond
to the entry points established via<TT> DefineDLLEntry</TT> (the first argument to<TT> DefineDLLEntry</TT> is an index number
in the range 1 to 128).&nbsp; All applications call into the 32-bit DLL via these entry points.&nbsp; They build the necessary
stack frame and switch to the 32-bit DLL's data space.
<BR><BR>If you call via<TT> Win386LibEntry</TT> then you pass the DLL entry point number or index (1 to 128) as the last argument.<TT>
&nbsp;Win386LibEntry</TT> uses this index number to call the appropriate 32-bit DLL routine.
<BR><BR>In many languages and programs (such as C and Microsoft Excel), function calls are very flexible.&nbsp; In other words,
a function can be called with different argument types each time.&nbsp; This is generally necessary for calling<TT> Win386LibEntry</TT>
in a 32-bit extended DLL function.&nbsp; The reason is that this function takes the same arguments as the function being called,
as well as the index number of the called function.&nbsp; After the 32-bit flat model has been set up,<TT> Win386LibEntry</TT>
then calls this function.&nbsp; In Visual Basic, once a function is declared as having certain arguments, it cannot be redeclared.
&nbsp;For example, suppose we have a declaration as follows:
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Declare Function Win386LibEntry Lib &quot;c:\path\vbdll32.dll&quot;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; =&gt; (ByVal v1 As Long, ByVal v2 As Long, ByVal</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; =&gt; v3 As Long, ByVal I As Integer) As Long</TT>
<BR><BR>(Note:&nbsp; the =&gt; means to continue the statement on the same line.) In this example, we could only call a function
in any 32-bit extended DLL with three 32-bit integers as arguments.&nbsp; There are three ways to work around this deficiency
in Visual Basic:
<OL>
<LI>Use the Visual Basic &quot;Alias&quot; attribute to declare<TT> Win386LibEntry</TT> differently for each DLL routine.
&nbsp;Reference the different DLL routines using these aliases.
<LI>Use the specific entry point, one of<TT> DLL1</TT> through<TT> DLL128,</TT> corresponding to the DLL routine that you
want to call.&nbsp; Each entry point can be described to take different arguments.&nbsp; We can still use the &quot;Alias&quot;
attribute to make the link between the name we use in the Visual Basic function and the name in the 32-bit extended DLL.&nbsp;
This is the method that we will use in the &quot;Direct Call&quot; technique discussed below.&nbsp; It is simpler to use since
it requires one less argument (you don't require the index number).
<LI>Use a method which involves calling functions in a 16-bit &quot;cover&quot; DLL written in a flexible-argument language,
which then calls the functions in the 32-bit DLL.&nbsp; This is the &quot;Indirect Call&quot; method discussed below.
</OL>
<H2 ID="Windows__A_Working_Example"> Windows:&nbsp; A Working Example </H2>
<BR>The best way to demonstrate these techniques is through an example.&nbsp; This example consists of a Visual Basic application
with 3 push buttons.&nbsp; The first push button invokes a direct call to a 32-bit DLL which will display a message window
with its arguments, the second push button invokes an indirect call to the same function through a 16-bit DLL, and the third
button exits the Visual Basic application.
<DL>
<DT>To create a Visual Basic application:
<DD>
<DT>(1)
<DD><B> Start up a new project folder</B> from the &quot;File&quot; menu.
<DT>(2)
<DD><B> Select &quot;View Form&quot;</B> from the &quot;Project&quot; window.
<DT>(3)
<DD><B> Draw three command buttons</B> on the form by selecting command buttons from the &quot;Toolbox&quot; window.
<DT>(4)
<DD><B> Change the caption on each button.</B>&nbsp; To do this, highlight the first button.&nbsp; Then, open the &quot;Properties&quot;
window.&nbsp; Double click on the &quot;Caption window&quot;, and change the caption to &quot;Direct call&quot;.&nbsp; Highlight
the second button, and change its caption to &quot;Indirect call&quot;.&nbsp; Highlight the third, changing the caption to
&quot;Exit&quot;.
<BR><BR>Now, your Visual Basic application should have three push buttons, &quot;Direct call&quot;, &quot;Indirect call&quot;,
and &quot;Exit&quot;.
<DT>(5)
<DD><B> Double click on the &quot;Direct Call&quot; button.</B>
<BR><BR>An edit window will pop up.&nbsp; Enter the following code:
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Sub Command1_Click ()</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Dim var1, var2, var3, worked As Long</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; var1 = 230</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; var2 = 215</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; var3 = 32</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; worked = Add3(var1, var2, var3)</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Print worked</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; worked = Add2(var2, var3)</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Print worked</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; End Sub</TT>
<DT>(6)
<DD><B> Double click on the &quot;Indirect Call&quot; button.</B>
<BR><BR>Another edit window will pop up.&nbsp; Enter the following code:
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Sub Command2_Click ()</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Dim var1, var2, var3, worked As Long</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; var1 = 230</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; var2 = 215</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; var3 = 32</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; worked = Function1(var1, var2, var3)</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Print worked</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; worked = Function2(var2, var3)</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Print worked</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; End Sub</TT>
<DT>(7)
<DD><B> Double click on the &quot;Exit&quot; command button</B> and enter the following code in the pop-up window:
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Sub Command3_Click ()</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; End</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; End Sub</TT>
<DT>(8)
<DD><B> Select &quot;View Code&quot;</B> from the &quot;Project&quot; window.&nbsp; To interface these Visual Basic functions
to the DLLs, the following code is needed in the
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Object: [general] Proc: [declarations]</TT>
<BR><BR>section of the code.&nbsp; This code assumes that<TT> VBDLL32.DLL</TT> and<TT> COVER16.DLL</TT> are in the<TT> c:\path</TT>
directory.&nbsp; Modify the pathnames appropriately if this is not the case.&nbsp; (Note:&nbsp; the =&gt; means to continue
the statement on the same line.)
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Declare Function Function1 Lib &quot;c:\path\cover16.dll&quot;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; =&gt; (ByVal v1 As Long, ByVal v2 As Long, ByVal v3 As Long)</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; =&gt; As Long</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Declare Function Function2 Lib &quot;c:\path\cover16.dll&quot;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; =&gt; (ByVal v1 As Long, ByVal v2 As Long) As Long</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Declare Function Add3 Lib &quot;c:\path\vbdll32.dll&quot;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; =&gt; Alias &quot;DLL1&quot;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; =&gt; (ByVal v1 As Long, ByVal v2 As Long, ByVal v3 As Long)</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; =&gt; As Long</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Declare Function Add2 Lib &quot;c:\path\vbdll32.dll&quot;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; =&gt; Alias &quot;DLL2&quot;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; =&gt; (ByVal v1 As Long, ByVal v2 As Long) As Long</TT>
</DL>
<BR>Now, when all of the code below is compiled correctly, and the Visual Basic program is run, the &quot;Direct call&quot;
button will call the<TT> DLL1</TT> and<TT> DLL2</TT> functions directly, aliased as the functions<TT> Add3</TT> and<TT> Add2</TT>
respectively.&nbsp; The &quot;Indirect call&quot; button will call the 16-bit DLL, which will then call the 32-bit DLL, for
both<TT> Function1</TT> and<TT> Function2.</TT>&nbsp; To run the Visual Basic program, select &quot;Start&quot; from the &quot;Run&quot;
menu.
<H2 ID="Windows__Sample_Visual_Basic_DLL_Programs"> Windows:&nbsp; Sample Visual Basic DLL Programs </H2>
<BR>The sample programs provided below are for a 32-bit DLL, and a 16-bit cover DLL, which will call the two functions contained
in the 32-bit DLL.
<H3 ID="Windows__Source_Code_for_VBDLL32_DLL"> Windows:&nbsp; Source Code for VBDLL32.DLL </H3>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; *$include winapi.fi</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; * VBDLL32.FOR</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; * Setup:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; set finclude=\WATCOM\src\fortran\win</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; * Compile and Link: wfl386 vbdll32 -explicit -d2 -bd -l=win386</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; * Bind:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; wbind vbdll32
-d -n</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; *$pragma aux (dll_function) Add3</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; integer function Add3( w1, w2, w3 )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; integer w1, w2, w3</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; include 'windows.fi'</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; character*128 str</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; write( str, '(16hDLL 1 arguments:, 3i10,
a)' ) w1, w2, w3,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &amp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; char(0)</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call MessageBox( NULL, str, 'F77 VBDLL32'c,
MB_OK )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Add3 = w1 + w2 + w3</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; end</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; *$pragma aux (dll_function) Add2</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; integer function Add2( w1, w2 )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; integer w1, w2</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; include 'windows.fi'</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; character*128 str</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; write( str, '(16hDLL 2 arguments:, 2i10,
a)' ) w1, w2, char(0)</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call MessageBox( NULL, str, 'F77 VBDLL32'c,
MB_OK )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Add2 = w1 + w2</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; end</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; integer*2 function FWinMain( hInstance,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &amp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; hPrevInstance,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &amp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; lpszCmdLine,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &amp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; nCmdShow
)</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; integer*2 hInstance</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; integer*2 hPrevInstance</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; integer*4 lpszCmdLine</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; integer*2 nCmdShow</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; include 'windows.fi'</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; external Add3, Add2</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; integer rc</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rc = DefineDLLEntry( 1, Add3, DLL_DWORD,
DLL_DWORD, DLL_DWORD,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &amp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DLL_ENDLIST )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if( rc .ne. 0 )then</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; FWinMain = 0</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; end if</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rc = DefineDLLEntry( 2, Add2, DLL_DWORD,
DLL_DWORD,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &amp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DLL_ENDLIST )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if( rc .ne. 0 )then</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; FWinMain = 0</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; end if</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call MessageBox( NULL, '32-bit DLL started'c,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &amp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 'F77 VBDLL32'c, MB_OK )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; FWinMain = 1</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; end</TT>
<H3 ID="Windows__Source_code_for_COVER16_DLL"> Windows:&nbsp; Source code for COVER16.DLL </H3>
<BR>The functions in this 16-bit DLL will call the functions in the 32-bit DLL,<TT> VBDLL32.DLL,</TT> shown above, with the
appropriate<TT> Win386LibEntry</TT> call for each function.
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; /*</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; *&nbsp; COVER16.C</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; */</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; #include &lt;stdio.h&gt;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; #include &lt;windows.h&gt;&nbsp;&nbsp;&nbsp; /* required for all Windows applications */</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; typedef long (FAR PASCAL *FPROC)();</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; FPROC DLL_1;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; FPROC DLL_2;</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; long FAR PASCAL __export Function1( long var1,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; long
var2,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; long
var3 )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return( (long) DLL_1( var1, var2, var3 ) );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; }</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; long FAR PASCAL __export Function2( long var1, long var2 )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return( (long) DLL_2( var1, var2 ) );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; }</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; #pragma off (unreferenced);</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; BOOL FAR PASCAL LibMain( HANDLE hInstance, WORD wDataSegment,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; WORD wHeapSize, LPSTR lpszCmdLine )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; #pragma on (unreferenced);</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; HANDLE hlib;</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* Do our DLL initialization */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; hlib = LoadLibrary( &quot;vbdll32.dll&quot; );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if( hlib &lt; 32 ) {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; MessageBox( NULL,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp; &quot;Make sure your PATH contains VBDLL32.DLL&quot;,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp; &quot;COVER16&quot;, MB_OK | MB_ICONEXCLAMATION );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return( FALSE );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DLL_1 = (FPROC) GetProcAddress( hlib, &quot;DLL1&quot; );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DLL_2 = (FPROC) GetProcAddress( hlib, &quot;DLL2&quot; );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return( TRUE );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; }</TT>
<H2 ID="Windows__Compiling_and_Linking_the_Examples"> Windows:&nbsp; Compiling and Linking the Examples </H2>
<BR>To create the 32-bit DLL<TT> VBDLL32.DLL,</TT> type the following at the command line (make sure that<TT> VBDLL32.for</TT>
is in your current directory):
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; set finclude=c:\watcom\src\fortran\win</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; wfl386 vbdll32 -explicit -bd -d2 -l=win386</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; wbind vbdll32 -d -n</TT>
<BR><BR>To create the 16-bit DLL<TT> COVER16.DLL,</TT> type the following at the command line (make sure that<TT> COVER16.C</TT>
are in your current directory):
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; wcl cover16 -mc -bt=windows -bd -zu -d2 -l=windows_dll</TT>
<BR><BR><B>Notes:</B>
<OL>
<LI>An object file is provided for<TT> COVER16.C</TT> if you do not have access to the 16-bit Open Watcom C compiler.&nbsp;
In this case, the DLL can be generated from the object file using the following command:
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; wfl cover16.obj -d2 -l=windows_dll</TT>
<LI>The &quot;mc&quot; option selects the compact memory model (small code, big data).&nbsp; The code for 16-bit DLLs must
be compiled with one of the big data models.
<LI>The &quot;bd&quot; option indicates that a DLL will be created from the object files.
<LI>The &quot;bt&quot; option selects the &quot;windows&quot; target.&nbsp; This option causes the C or C++ compiler to generate
Windows prologue/epilogue code sequences which are required for Microsoft Windows applications.&nbsp; It also causes the compiler
to use the<B> WINDOWS_INCLUDE</B> environment variable for header file searches.&nbsp; It also causes the compiler to define
the macro<TT> __WINDOWS__</TT> and, for the 32-bit C or C++ compiler only, the macro<TT> __WINDOWS_386__</TT> .
<LI>The &quot;zu&quot; option is used when compiling 16-bit code that is to be placed in a Dynamic Link Library (DLL) since
the SS register points to the stack segment of the calling application upon entry to the function.
<LI>The &quot;d2&quot; option is used to disable optimizations and include debugging information in the object file and DLL.
&nbsp;The techniques for debugging DLLs are described in the chapter entitled <A HREF="#Windows__Windows_32MBit_Dynamic_Link_Libraries">Windows:&nbsp; Windows 32-Bit Dynamic Link Libraries</A>.
</OL>
<BR>You are now ready to run the Visual Basic application.
<H1 ID="Windows__WIN386_Library_Subprograms"> Windows:&nbsp; WIN386 Library Subprograms </H1>
<BR>Each special Windows subprogram in the Open Watcom F77 library is described in this chapter.&nbsp; Each description consists
of a number of subsections:
<DL>
<DT>Synopsis:
<DD>This subsection gives the include files that should be included within a source file that references the subprogram.&nbsp;
It also shows an appropriate declaration for the function or for a function that could be substituted for a macro.&nbsp; This
declaration is not included in your program; only the include file(s) should be included.
<DT>Description:
<DD>This subsection is a description of the subprogram.
<DT>Returns:
<DD>This subsection describes the return value (if any) for the subprogram.
<DT>See Also:
<DD>This optional subsection provides a list of related subprograms.
<DT>Example:
<DD>This optional subsection consists of one or more examples of the use of the subprogram.&nbsp; The examples are often just
fragments of code (not complete programs) for illustration purposes.
<DT>Classification:
<DD>This subsection provides an indication of where the subprogram is commonly found.&nbsp; The subprograms in this section are
all classified as &quot;WIN386&quot; (i.e., they pertain to 32-bit Windows programming).
</DL>
<H2 ID="AllocAlias16"> Windows:&nbsp; AllocAlias16 </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>c$include 'winapi.fi'</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; integer*4 function AllocAlias16( ptr )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; integer*4 ptr</TT>
</DL>
<DL>
<DT>Description:
<DD>The AllocAlias16 function obtains a 16-bit far pointer equivalent of a 32-bit near pointer.&nbsp; These pointers are used
when passing data pointers to Windows through functions that have INTEGER*4 arguments, and for any pointers within data structures
passed this way.
</DL>
<DL>
<DT>Returns:
<DD>The AllocAlias16 function returns a 16-bit far pointer (as an INTEGER*4) usable by Windows, or returns 0 if the alias cannot
be allocated.
</DL>
<DL>
<DT>See Also:
<DD><A HREF="#FreeAlias16">FreeAlias16</A>
</DL>
<DL>
<DT>Example:
<DD>
<BR><TT>integer*4 mcs_16</TT>
<BR><TT>record /MDICREATESTRUCT/ mcs</TT>
<BR><TT>mcs.szTitle = AllocAlias16( loc( 'Title'c ) )</TT>
<BR><TT>mcs.szClass = AllocAlias16( loc( 'mdichild'c ) )</TT>
<BR><TT>mcs.hOwner = hInst</TT>
<BR><TT>mcs.x = mcs.cx = CW_USEDEFAULT</TT>
<BR><TT>mcs.y = mcs.cy = CW_USEDEFAULT</TT>
<BR><TT>mcs.style = 0</TT>
<BR><TT>! Send a message to an MDI client to create a window.</TT>
<BR><TT>! Since the pointer to the structure is passed in an</TT>
<BR><TT>! argument that may not be a pointer (depending on the</TT>
<BR><TT>! type of message), there is no implicit 32 to 16-bit</TT>
<BR><TT>! conversion done so the conversion must be done by the</TT>
<BR><TT>! programmer.</TT>
<BR><TT>mcs_16 = AllocAlias16( loc( mcs ) )</TT>
<BR><TT>hwnd = SendMessage( hwndMDI, WM_MDICREATE, 0, mcs_16 )</TT>
<BR><TT>FreeAlias16( mcs_16 )</TT>
<BR><TT>FreeAlias16( mcs.szClass )</TT>
<BR><TT>FreeAlias16( mcs.szTitle )</TT>
</DL>
<DL>
<DT>Classification:
<DD>WIN386
</DL>
<H2 ID="AllocHugeAlias16"> Windows:&nbsp; AllocHugeAlias16 </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>c$include 'winapi.fi'</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; integer*4 function AllocHugeAlias16( ptr, size )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; integer*4 ptr, size</TT>
</DL>
<DL>
<DT>Description:
<DD>The AllocHugeAlias16 function obtains a 16-bit far pointer to a 32-bit memory object that is<B> size</B> bytes in size.&nbsp;
This is similar to the function <TT> AllocAlias16</TT>, except that <TT> AllocAlias16</TT> will only give 16-bit far pointers
to 32-bit memory objects of up to 64K in size.&nbsp; To get 16-bit far pointers to 32-bit memory objects larger than 64K,
<TT> AllocHugeAlias16</TT> should be used.
</DL>
<DL>
<DT>Returns:
<DD>The AllocHugeAlias16 function returns a 16-bit far pointer (as an INTEGER*4) usable by Windows, or returns 0 if the alias
cannot be allocated.
</DL>
<DL>
<DT>See Also:
<DD><A HREF="#AllocAlias16">AllocAlias16</A>, <A HREF="#FreeAlias16">FreeAlias16</A>, <A HREF="#FreeHugeAlias16">FreeHugeAlias16</A>
</DL>
<DL>
<DT>Example:
<DD>
<BR><TT>integer ierr, SIZE</TT>
<BR><TT>integer*4 alias</TT>
<BR><TT>parameter (SIZE=300000)</TT>
<BR><TT>integer*1 tmp(SIZE)</TT>
<BR><BR><TT>allocate( tmp(SIZE), stat=ierr )</TT>
<BR><TT>if( ierr .ne. 0 )then</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; alias = AllocHugeAlias16( loc( tmp ), SIZE )</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp; ! Windows calls using the alias ...</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp; call FreeHugeAlias16( alias, SIZE )</TT>
<BR><TT>endif</TT>
</DL>
<DL>
<DT>Classification:
<DD>WIN386
</DL>
<H2 ID="_Call16"> Windows:&nbsp; _Call16 </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>c$include 'winapi.fi'</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; integer*4 function _Call16( lpFunc, fmt, ... )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; integer*4 lpFunc</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; character*(*) fmt</TT>
</DL>
<DL>
<DT>Description:
<DD>The _Call16 function performs the same function as <TT> GetIndirectFunctionHandle</TT>, <TT> InvokeIndirectFunctionHandle</TT>
and <TT> FreeIndirectFunctionHandle</TT> but is much easier to use.&nbsp; The first argument<B> lpFunc</B> is the address
of the 16-bit function to be called.&nbsp; This address is usually obtained by calling <TT> GetProcAddress</TT> with the name
of the desired function.&nbsp; The second argument<TT> fmt</TT> is a string identifying the types of the parameters to be
passed to the 16-bit function.
<DL>
<DT><B><I>Character</I></B>
<DD><B><I>Parameter Type</I></B>
<DT>c
<DD>call a 'cdecl' function as opposed to a 'pascal' function (if specified, it must be listed first)
<DT>b
<DD>unsigned BYTE
<DT>w
<DD>16-bit WORD (INTEGER*2)
<DT>d
<DD>32-bit DWORD (INTEGER*4, REAL*4)
<DT>f
<DD>double precision floating-point (DOUBLE PRECISION, REAL*8)
<DT>p
<DD>32-bit flat pointer (converted to 16:16 far pointer) (LOC(x))
</DL>
<BR>The 16-bit function must use either the <TT> PASCAL</TT> or <TT> CDECL</TT> calling convention.&nbsp; <TT> PASCAL</TT>
calling convention is the default.&nbsp; If the function uses the <TT> CDECL</TT> calling convention, then you must specify
the letter &quot;c&quot; as the first character of the argument type string.
<BR><BR>Pointer types will automatically be converted from 32-bit near pointers to 16-bit far pointers before the function
is invoked.&nbsp; Note that this pointer is only valid over the period of the call; after control returns to the 32-bit application,
the 16-bit pointer created by the Supervisor is no longer valid.
</DL>
<DL>
<DT>Returns:
<DD>The _Call16 function returns a 32-bit DWORD (as an INTEGER*4) which represents the return value from the 16-bit function that
was called.
</DL>
<DL>
<DT>See Also:
<DD><A HREF="#GetIndirectFunctionHandle">GetIndirectFunctionHandle</A>, <A HREF="#FreeIndirectFunctionHandle">FreeIndirectFunctionHandle</A>
</DL>
<DL>
<DT>Example:
<DD>
<BR><TT>c$include winapi.fi</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; include 'windows.fi'</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; integer*2 hlib</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; integer*4 dll_1, cb</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; character*128 str</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; hlib = LoadLibrary( 'windllv.dll'c )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; dll_1 = GetProcAddress( hlib, 'DLL1'c )</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cb = _Call16( dll_1, 'ddd'c, 111, 22222, 3333 )</TT>
</DL>
<DL>
<DT>Classification:
<DD>WIN386
</DL>
<H2 ID="DefineDLLEntry"> Windows:&nbsp; DefineDLLEntry </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>c$include 'winapi.fi'</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; integer*4 function DefineDLLEntry(index, routine, ...)</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; integer*4 index</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; external routine</TT>
</DL>
<DL>
<DT>Description:
<DD>The DefineDLLEntry function defines an<B> index</B> number for the 32-bit DLL procedure<B> routine</B>.&nbsp; The parameter<B>
index</B> defines the index number that must be used in order to invoke the 32-bit FAR procedure<B> routine</B>.&nbsp; The
variable argument list defines the types of parameters that will be received by the 32-bit DLL<B> routine</B>.&nbsp; Valid
parameter types are:
<DL>
<DT>DLL_PTR
<DD>16-bit far pointer
<DT>DLL_DWORD
<DD>32-bits
<DT>DLL_WORD
<DD>16-bits
<DT>DLL_CHAR
<DD>8-bits
<DT>DLL_ENDLIST
<DD>Marks the end of the variable argument list.
</DL>
<BR>In the above synopsis, &quot;...&quot; in the argument list is not valid FORTRAN 77 syntax; it is used only to indicate
a variable number of arguments.
<BR><BR>Note that all pointers are received as 16-bit far pointers.&nbsp; To access the data from the 32-bit DLL, a dynamically
allocatable array must be mapped to the memory pointed to by the 16-bit far pointer using the <TT> LOCATION</TT> specifier
of the <TT> ALLOCATE</TT> statement and assigning the <TT> FAR</TT> attribute to the array using the array pragma.
</DL>
<DL>
<DT>Returns:
<DD>The DefineDLLEntry function returns zero if successful, and a non-zero value otherwise.
</DL>
<DL>
<DT>Example:
<DD>
<BR><TT>c$include winapi.fi</TT>
<BR><BR><TT>c$pragma aux (dll_function) DLL_1</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; integer function DLL_1( w1, w2, w3 )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; integer*4 w1, w2, w3</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; include 'win386.fi'</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; include 'windefn.fi'</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; include 'winerror.fi'</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; character*128 str</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; write( str, '(16hDLL 1 arguments:, 3i10, a)' ) w1,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; &amp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
w2, w3, char(0)</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call MessageBox( NULL, str,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; &amp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp; 'DLL Function 1'c, MB_OK )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DLL_1 = w1 + w2 + w3</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; end</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; integer*2 function FWINMAIN( hInstance,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; &amp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; hPrevInstance,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; &amp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; lpszCmdLine,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; &amp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; nCmdShow )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; integer*2 hInstance, hPrevInstance, nCmdShow</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; integer*4 lpszCmdLine</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; include 'win386.fi'</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; include 'windefn.fi'</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; include 'winerror.fi'</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; external DLL_1</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; integer rc</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rc = DefineDLLEntry( 1, DLL_1, DLL_DWORD,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; &amp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DLL_DWORD, DLL_DWORD,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; &amp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DLL_ENDLIST )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if( rc .ne. 0 )then</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; FWinMain = 0</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; end if</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call MessageBox( NULL,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; &amp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; '32-bit DLL started'c,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; &amp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; '32-bit DLL'c, MB_OK )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; FWinMain = 1</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; end</TT>
</DL>
<DL>
<DT>Classification:
<DD>WIN386
</DL>
<H2 ID="DefineUserProc16"> Windows:&nbsp; DefineUserProc16 </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>*$include 'winapi.fi'</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; integer*4 function DefineUserProc16(typ, routine, ...)</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; integer*4 typ</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; external routine</TT>
</DL>
<DL>
<DT>Description:
<DD>The DefineUserProc16 function defines the arguments accepted by the user defined callback procedure<B> routine</B>.&nbsp;
There may be up to 32 user defined callbacks.&nbsp; The parameter<B> typ</B> indicates which one of <TT> GETPROC_USERDEFINED_1</TT>
through <TT> GETPROC_USERDEFINED_32</TT> is being defined (see <TT> GetProc16</TT>).&nbsp; The callback routine must be declared
as FAR PASCAL, or as FAR cdecl.&nbsp; The variable argument list defines the types of parameters that will be received by
the user defined callback procedure<B> routine</B>.&nbsp; Valid parameter types are:
<DL>
<DT>UDP16_PTR
<DD>16-bit far pointer
<DT>UDP16_DWORD
<DD>32-bits
<DT>UDP16_WORD
<DD>16-bits
<DT>UDP16_CHAR
<DD>8-bits
<DT>UDP16_CDECL
<DD>callback routine will be declared as type <TT> cdecl</TT> rather than as type <TT> PASCAL</TT>.&nbsp; This keyword may be
placed anywhere before the <TT> UDP16_ENDLIST</TT> keyword.
<DT>UDP16_ENDLIST
<DD>Marks the end of the variable argument list.
</DL>
<BR>Once the DefineUserProc16 function has been used to declare the user callback routine, then <TT> GetProc16</TT> may be
used to get a 16-bit function pointer that may be used by Windows.
<BR><BR>In the above synopsis, &quot;...&quot; in the argument list is not valid FORTRAN 77 syntax; it is used only to indicate
a variable number of arguments.
</DL>
<DL>
<DT>Returns:
<DD>The DefineUserProc16 function returns zero if it succeeds; and non-zero if it fails.
</DL>
<DL>
<DT>See Also:
<DD><A HREF="#GetProc16">GetProc16</A>
</DL>
<DL>
<DT>Example:
<DD>
<BR><TT>c$include winapi.fi</TT>
<BR><BR><TT>c$pragma aux TestProc parm( value )</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; subroutine TestProc( i )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; integer i</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; character*128 str</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; write( str, '(2hi=, i10, a)' ) i, char(0)</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call MessageBox( NULL, str, 'TEST'c, MB_OK )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; end</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; integer function DefineTest()</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; integer*4 cb</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; external TestProc</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call DefineUserProc16( GETPROC_USERDEFINED_1,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; &amp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; TestProc,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; &amp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; UDP16_DWORD,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; &amp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; UDP16_ENDLIST )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cb = GetProc16( TestProc, GETPROC_USERDEFINED_1 )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ! cb may then be used whenever a pointer to the</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ! callback is required by 16-bit Windows</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; end</TT>
</DL>
<DL>
<DT>Classification:
<DD>WIN386
</DL>
<H2 ID="FreeAlias16"> Windows:&nbsp; FreeAlias16 </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>c$include 'winapi.fi'</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; subroutine FreeAlias16( fp16 )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; integer*4 fp16</TT>
</DL>
<DL>
<DT>Description:
<DD>FreeAlias16 frees a 16-bit far pointer alias for a 32-bit near pointer that was allocated with <TT> AllocAlias16</TT>.&nbsp;
This is important to do when there is no further use for the pointer since there are a limited number of 16-bit aliases available
(due to limited space in the local descriptor table).
</DL>
<DL>
<DT>Returns:
<DD>FreeAlias16 is a subroutine.
</DL>
<DL>
<DT>See Also:
<DD><A HREF="#AllocAlias16">AllocAlias16</A>
</DL>
<DL>
<DT>Example:
<DD>
<BR><TT>integer*4 mcs_16</TT>
<BR><TT>record /MDICREATESTRUCT/ mcs</TT>
<BR><TT>mcs.szTitle = AllocAlias16( loc( 'Title'c ) )</TT>
<BR><TT>mcs.szClass = AllocAlias16( loc( 'mdichild'c ) )</TT>
<BR><TT>mcs.hOwner = hInst</TT>
<BR><TT>mcs.x = mcs.cx = CW_USEDEFAULT</TT>
<BR><TT>mcs.y = mcs.cy = CW_USEDEFAULT</TT>
<BR><TT>mcs.style = 0</TT>
<BR><TT>! Send a message to an MDI client to create a window.</TT>
<BR><TT>! Since the pointer to the structure is passed in an</TT>
<BR><TT>! argument that may not be a pointer (depending on the</TT>
<BR><TT>! type of message), there is no implicit 32 to 16-bit</TT>
<BR><TT>! conversion done so the conversion must be done by the</TT>
<BR><TT>! programmer.</TT>
<BR><TT>mcs_16 = AllocAlias16( loc( mcs ) )</TT>
<BR><TT>hwnd = SendMessage( hwndMDI, WM_MDICREATE, 0, mcs_16 )</TT>
<BR><TT>FreeAlias16( mcs_16 )</TT>
<BR><TT>FreeAlias16( mcs.szClass )</TT>
<BR><TT>FreeAlias16( mcs.szTitle )</TT>
</DL>
<DL>
<DT>Classification:
<DD>WIN386
</DL>
<H2 ID="FreeHugeAlias16"> Windows:&nbsp; FreeHugeAlias16 </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>c$include 'winapi.fi'</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; subroutine FreeHugeAlias16( fp16, size )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; integer*4 fp16, size</TT>
</DL>
<DL>
<DT>Description:
<DD>FreeHugeAlias16 frees a 16-bit far pointer alias that was allocated with <TT> AllocHugeAlias16</TT>.&nbsp; The size of the
original 32-bit memory object must be specified.&nbsp; It is important to use <TT> FreeHugeAlias16</TT> when there is no further
use for the pointer, since there are a limited number of 16-bit aliases available (due to limited space in the local descriptor
table).
</DL>
<DL>
<DT>Returns:
<DD>FreeHugeAlias16 is a subroutine.
</DL>
<DL>
<DT>See Also:
<DD><A HREF="#AllocHugeAlias16">AllocHugeAlias16</A>, <A HREF="#AllocAlias16">AllocAlias16</A>, <A HREF="#FreeAlias16">FreeAlias16</A>
</DL>
<DL>
<DT>Example:
<DD>
<BR><TT>integer ierr, SIZE</TT>
<BR><TT>integer*4 alias</TT>
<BR><TT>parameter (SIZE=300000)</TT>
<BR><TT>integer*1 tmp(SIZE)</TT>
<BR><BR><TT>allocate( tmp(SIZE), stat=ierr )</TT>
<BR><TT>if( ierr .ne. 0 )then</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; alias = AllocHugeAlias16( loc( tmp ), SIZE )</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp; ! Windows calls using the alias ...</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp; call FreeHugeAlias16( alias, SIZE )</TT>
<BR><TT>endif</TT>
</DL>
<DL>
<DT>Classification:
<DD>WIN386
</DL>
<H2 ID="FreeIndirectFunctionHandle"> Windows:&nbsp; FreeIndirectFunctionHandle </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>c$include 'winapi.fi'</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; subroutine FreeIndirectFunctionHandle( handle )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; integer*4 handle</TT>
</DL>
<DL>
<DT>Description:
<DD>FreeIndirectFunctionHandle frees a handle that was obtained using <TT> GetIndirectFunctionHandle</TT>.&nbsp; This is important
to do when there is no further use for the pointer since there are a limited number of 16-bit aliases available (due to limited
space in the local descriptor table).
</DL>
<DL>
<DT>Returns:
<DD>FreeIndirectFunctionHandle is a subroutine.
</DL>
<DL>
<DT>See Also:
<DD><A HREF="#_Call16">_Call16</A>, <A HREF="#GetIndirectFunctionHandle">GetIndirectFunctionHandle</A>, <A HREF="#InvokeIndirectFunction">InvokeIndirectFunction</A>
</DL>
<DL>
<DT>Example:
<DD>
<BR><TT>c$include winapi.fi</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; integer*2 hDrv</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; integer*4 lpfn</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; hDrv = LoadLibrary( 'your.lib'c )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if( hDrv .lt. 32 ) return</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; lpfn = GetProcAddress( hDrv,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; &amp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 'ExtDeviceMode'c )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if( lpfn .eq 0 ) return</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; hIndir = GetIndirectFunctionHandle(</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; &amp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; lpfn,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; &amp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; INDIR_WORD,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; &amp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; INDIR_WORD,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; &amp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; INDIR_DWORD,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; &amp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; INDIR_PTR,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; &amp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; INDIR_PTR,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; &amp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; INDIR_DWORD,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; &amp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; INDIR_DWORD,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; &amp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; INDIR_WORD,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; &amp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; INDIR_ENDLIST
)</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cb = InvokeIndirectFunction(</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; &amp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; hIndir,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; &amp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; hwnd,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; &amp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; hDrv,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; &amp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; NULL,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; &amp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 'POSTSCRIPT
PRINTER'c,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; &amp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 'LPT1'c,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; &amp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; NULL,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; &amp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; NULL,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; &amp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0 )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call FreeIndirectFunctionHandle( hIndir )</TT>
</DL>
<DL>
<DT>Classification:
<DD>WIN386
</DL>
<H2 ID="GetIndirectFunctionHandle"> Windows:&nbsp; GetIndirectFunctionHandle </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>c$include 'winapi.fi'</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; integer*4 function GetIndirectFunctionHandle( prc, ... )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; integer*4 prc</TT>
</DL>
<DL>
<DT>Description:
<DD>The GetIndirectFunctionHandle function gets a handle for a 16-bit procedure that is to be invoked indirectly.&nbsp; The procedure
is assumed to have PASCAL calling convention, unless the <TT> INDIR_CDECL</TT> parameter is used, to indicate that Microsoft
C calling convention is to be used.&nbsp; The 16-bit far pointer<B> prc</B> is supplied to GetIndirectFunctionHandle, and
a list of the type of each parameter (in the order that they will be passed to the 16-bit function).&nbsp; The parameter types
are:
<DL>
<DT>INDIR_DWORD
<DD>A INTEGER*4 will be passed.
<DT>INDIR_WORD
<DD>A INTEGER*2 will be passed.
<DT>INDIR_CHAR
<DD>A INTEGER*1 will be passed.
<DT>INDIR_PTR
<DD>A pointer will be passed.&nbsp; This is only used if pointer conversion from 32-bit to 16-bit is required, otherwise; INDIR_DWORD
is specified.
<DT>INDIR_CDECL
<DD>This option may be included anywhere in the list before the <TT> INDIR_ENDLIST</TT> keyword.&nbsp; When this is used, the
calling convention used to invoke the 16-bit function will be the Microsoft C calling convention.
<DT>INDIR_ENDLIST
<DD>Marks the end of the parameter list.
</DL>
<BR>In the above synopsis, &quot;...&quot; in the argument list is not valid FORTRAN 77 syntax; it is used only to indicate
a variable number of arguments.
<BR><BR>This handle is a data structure that was created using the <TT> malloc</TT> function.&nbsp; To free the handle, just
use one of the <TT> FreeIndirectFunctionHandle</TT> or <TT> free</TT> functions.
<BR><BR>You may find it easier to use <TT> _Call16</TT> rather than GetIndirectFunctionHandle followed by a call to <TT> InvokeIndirectFunction</TT>.
</DL>
<DL>
<DT>Returns:
<DD>The GetIndirectFunctionHandle function returns a handle to the indirect function, or NULL if a handle could not be allocated.
&nbsp;This handle is used in conjunction with <TT> InvokeIndirectFunction</TT> to call the 16-bit procedure.
</DL>
<DL>
<DT>See Also:
<DD><A HREF="#_Call16">_Call16</A>, <A HREF="#FreeIndirectFunctionHandle">FreeIndirectFunctionHandle</A>, <A HREF="#InvokeIndirectFunction">InvokeIndirectFunction</A>
</DL>
<DL>
<DT>Example:
<DD>
<BR><TT>c$include winapi.fi</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; integer*2 hDrv</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; integer*4 lpfn</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; hDrv = LoadLibrary( 'your.lib'c )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if( hDrv .lt. 32 ) return</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; lpfn = GetProcAddress( hDrv,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; &amp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 'ExtDeviceMode'c )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if( lpfn .eq 0 ) return</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; hIndir = GetIndirectFunctionHandle(</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; &amp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; lpfn,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; &amp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; INDIR_WORD,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; &amp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; INDIR_WORD,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; &amp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; INDIR_DWORD,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; &amp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; INDIR_PTR,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; &amp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; INDIR_PTR,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; &amp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; INDIR_DWORD,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; &amp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; INDIR_DWORD,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; &amp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; INDIR_WORD,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; &amp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; INDIR_ENDLIST
)</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cb = InvokeIndirectFunction(</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; &amp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; hIndir,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; &amp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; hwnd,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; &amp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; hDrv,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; &amp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; NULL,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; &amp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 'POSTSCRIPT
PRINTER'c,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; &amp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 'LPT1'c,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; &amp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; NULL,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; &amp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; NULL,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; &amp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0 )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call FreeIndirectFunctionHandle( hIndir )</TT>
</DL>
<DL>
<DT>Classification:
<DD>WIN386
</DL>
<H2 ID="GetProc16"> Windows:&nbsp; GetProc16 </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>c$include 'winapi.fi'</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; integer*4 function GetProc16( fcn, type )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; integer*4 fcn, type</TT>
</DL>
<DL>
<DT>Description:
<DD>The GetProc16 function returns a 16-bit far function pointer suitable for use as a Windows callback function.&nbsp; This callback
function will invoke the 32-bit far procedure specified by<B> fcn</B>.&nbsp; The types of callback functions that may be allocated
are:
<DL>
<DT>GETPROC_CALLBACK
<DD>This is the most common form of callback; suitable as the callback routine for a window.
<DT>GETPROC_ABORTPROC
<DD>This is the callback type used for trapping abort requests when printing.
<DT>GETPROC_ENUMCHILDWINDOWS
<DD>This callback is used with the <TT> EnumChildWindows</TT> Windows function.
<DT>GETPROC_ENUMFONTS
<DD>This callback type is used with the <TT> EnumFonts</TT> Windows function.
<DT>GETPROC_ENUMMETAFILE
<DD>This callback is used with the <TT> EnumMetaFile</TT> Windows function.
<DT>GETPROC_ENUMOBJECTS
<DD>This callback is used with the <TT> EnumObjects</TT> Windows function.
<DT>GETPROC_ENUMPROPS_FIXED_DS
<DD>This callback is used with the <TT> EnumProps</TT> Windows function, when the fixed data segments callback is needed.
<DT>GETPROC_ENUMPROPS_MOVEABLE_DS
<DD>This callback is used with the <TT> EnumProps</TT> Windows function, when the moveable data segments callback is needed.
<DT>GETPROC_ENUMTASKWINDOWS
<DD>This callback is used with the <TT> EnumTaskWindows</TT> Windows function.
<DT>GETPROC_ENUMWINDOWS
<DD>This callback is used with the <TT> EnumWindows</TT> Windows function.
<DT>GETPROC_GLOBALNOTIFY
<DD>This callback is used with the <TT> GlobalNotify</TT> Windows function.
<DT>GETPROC_GRAYSTRING
<DD>This callback is used with the <TT> GrayString</TT> Windows function.
<DT>GETPROC_LINEDDA
<DD>This callback is used with the <TT> LineDDA</TT> Windows function.
<DT>GETPROC_SETRESOURCEHANDLER
<DD>This callback is used with the <TT> SetResourceHandler</TT> Windows function.
<DT>GETPROC_SETTIMER
<DD>This callback is used with the <TT> SetTimer</TT> Windows function.
<DT>GETPROC_SETWINDOWSHOOK
<DD>This callback is used with the <TT> SetWindowsHook</TT> Windows function.
<DT>GETPROC_USERDEFINED_x
<DD>This callback is used in conjunction with <TT> DefineUserProc16</TT> function to create a callback routine with an arbitrary
set of parameters.&nbsp; Up to 32 user defined callbacks are allowed, they are identified by using GETPROC_USERDEFINED_1 through
GETPROC_USERDEFINED_32.&nbsp; The user defined callback must be declared as a FAR PASCAL function, or as a FAR cdecl function.
</DL>
</DL>
<DL>
<DT>Returns:
<DD>The GetProc16 function returns a 16-bit far pointer to a callback procedure.&nbsp; This pointer may then be fed to any Windows
function that requires a pointer to a function within the 32-bit program.&nbsp; Note that the callback function within the
32-bit program must be declared as <TT> FAR</TT>.
</DL>
<DL>
<DT>See Also:
<DD><A HREF="#ReleaseProc16">ReleaseProc16</A>
</DL>
<DL>
<DT>Example:
<DD>
<BR><TT>c$include winapi.fi</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; integer*4 cbp</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; integer*4 lpProcAbout</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ! get a 16-bit callback routine to point at</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ! our About dialogue procedure, then create</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ! the dialogue.</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cbp = GetProc16( About, GETPROC_CALLBACK )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; lpProcAbout = MakeProcInstance( cbp, hInst )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call DialogBox( hInst,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; &amp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp; 'AboutBox'c,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp; hWnd,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp; lpProcAbout )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call FreeProcInstance( lpProcAbout )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call ReleaseProc16( cbp )</TT>
</DL>
<DL>
<DT>Classification:
<DD>WIN386
</DL>
<H2 ID="InvokeIndirectFunction"> Windows:&nbsp; InvokeIndirectFunction </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>c$include 'winapi.fi'</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; integer*4 function InvokeIndirectFunction(handle, ...)</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; integer*4 handle</TT>
</DL>
<DL>
<DT>Description:
<DD>The InvokeIndirectFunction function invokes the 16-bit function pointed to by the specified handle.&nbsp; The handle must
have been previously allocated using the <TT> GetIndirectFunctionHandle</TT> function.&nbsp; The handle is followed by the
list of parameters to be passed to the 16-bit function.
<BR><BR>If you specified <TT> INDIR_PTR</TT> as a parameter when allocating the handle, then a 16-bit pointer is allocated
for a 32-bit pointer that you pass.&nbsp; However, this pointer is freed when the 16-bit function being invoked returns.
<BR><BR>In the above synopsis, &quot;...&quot; in the argument list is not valid FORTRAN 77 syntax; it is used only to indicate
a variable number of arguments.
</DL>
<DL>
<DT>Returns:
<DD>The InvokeIndirectFunction function returns the value which the 16-bit function returned.
</DL>
<DL>
<DT>See Also:
<DD><A HREF="#_Call16">_Call16</A>, <A HREF="#FreeIndirectFunctionHandle">FreeIndirectFunctionHandle</A>, <A HREF="#GetIndirectFunctionHandle">GetIndirectFunctionHandle</A>
</DL>
<DL>
<DT>Example:
<DD>
<BR><TT>c$include winapi.fi</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; integer*2 hDrv</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; integer*4 lpfn</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; hDrv = LoadLibrary( 'your.lib'c )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if( hDrv .lt. 32 ) return</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; lpfn = GetProcAddress( hDrv,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; &amp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 'ExtDeviceMode'c )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if( lpfn .eq 0 ) return</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; hIndir = GetIndirectFunctionHandle(</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; &amp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; lpfn,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; &amp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; INDIR_WORD,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; &amp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; INDIR_WORD,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; &amp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; INDIR_DWORD,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; &amp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; INDIR_PTR,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; &amp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; INDIR_PTR,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; &amp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; INDIR_DWORD,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; &amp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; INDIR_DWORD,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; &amp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; INDIR_WORD,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; &amp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; INDIR_ENDLIST
)</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cb = InvokeIndirectFunction(</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; &amp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; hIndir,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; &amp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; hwnd,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; &amp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; hDrv,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; &amp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; NULL,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; &amp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 'POSTSCRIPT
PRINTER'c,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; &amp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 'LPT1'c,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; &amp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; NULL,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; &amp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; NULL,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; &amp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0 )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call FreeIndirectFunctionHandle( hIndir )</TT>
</DL>
<DL>
<DT>Classification:
<DD>WIN386
</DL>
<H2 ID="MapAliasToFlat"> Windows:&nbsp; MapAliasToFlat </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>c$include 'winapi.fi'</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; integer*4 function MapAliasToFlat( alias )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; integer*4 alias</TT>
</DL>
<DL>
<DT>Description:
<DD>The MapAliasToFlat function returns a 32-bit near pointer equivalent of a pointer allocated previously with <TT> AllocAlias16</TT>
or <TT> AllocHugeAlias16</TT>.&nbsp; This is useful if you are communicating with a 16-bit application that is returning pointers
that you previously gave it.
</DL>
<DL>
<DT>Returns:
<DD>The MapAliasToFlat function returns a 32-bit near pointer (as an INTEGER*4) usable by the 32-bit application.
</DL>
<DL>
<DT>See Also:
<DD><A HREF="#AllocAlias16">AllocAlias16</A>, <A HREF="#AllocHugeAlias16">AllocHugeAlias16</A>
</DL>
<DL>
<DT>Example:
<DD>
<BR><TT>c$include winapi.fi</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; integer alias</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; integer ptr</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; alias = AllocAlias16( loc( alias ) )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; alias += 5</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ptr = MapAliasToFlat( alias )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if( ptr .eq. loc( alias ) + 5 )then</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call MessageBox( NULL, 'It Worked'c, ''c, MB_OK )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call MessageBox( NULL, 'It Failed'c, ''c, MB_OK )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; end if</TT>
</DL>
<DL>
<DT>Classification:
<DD>WIN386
</DL>
<H2 ID="PASS_WORD_AS_POINTER"> Windows:&nbsp; PASS_WORD_AS_POINTER </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>c$include 'winapi.fi'</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; integer*4 function PASS_WORD_AS_POINTER( dw )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; integer*4 dw</TT>
</DL>
<DL>
<DT>Description:
<DD>Some Windows API functions have pointer parameters that do not always take pointers.&nbsp; Sometimes these parameters are
pure data.&nbsp; In order to stop the supervisor from trying to convert the data into a 16-bit far pointer, the PASS_WORD_AS_POINTER
function is used.
</DL>
<DL>
<DT>Returns:
<DD>The PASS_WORD_AS_POINTER returns a 32-bit &quot;near&quot; pointer, that is really the parameter<B> dw</B>.
</DL>
<DL>
<DT>Example:
<DD>
<BR><TT>c$include winapi.fi</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call Func( PASS_WORD_AS_POINTER(1) )</TT>
</DL>
<DL>
<DT>Classification:
<DD>WIN386
</DL>
<H2 ID="ReleaseProc16"> Windows:&nbsp; ReleaseProc16 </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>c$include 'winapi.fi'</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; subroutine ReleaseProc16( cbp )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; integer*4 cbp</TT>
</DL>
<DL>
<DT>Description:
<DD>ReleaseProc16 releases the callback function allocated by <TT> GetProc16</TT>.&nbsp; Since the callback routines are a limited
resource, it is important to release the routines when they are no longer required.
</DL>
<DL>
<DT>Returns:
<DD>ReleaseProc16 is a subroutine.
</DL>
<DL>
<DT>See Also:
<DD><A HREF="#GetProc16">GetProc16</A>
</DL>
<DL>
<DT>Example:
<DD>
<BR><TT>c$include winapi.fi</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; integer*4 cbp</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; integer*4 lpProcAbout</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ! get a 16-bit callback routine to point at</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ! our About dialogue procedure, then create</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ! the dialogue.</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cbp = GetProc16( About, GETPROC_CALLBACK )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; lpProcAbout = MakeProcInstance( cbp, hInst )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call DialogBox( hInst, 'AboutBox'c,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; &amp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp; hWnd, lpProcAbout )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call FreeProcInstance( lpProcAbout )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call ReleaseProc16( cbp )</TT>
</DL>
<DL>
<DT>Classification:
<DD>WIN386
</DL>
<H1 ID="Windows__32Mbit_Extended_Windows_Application_Development"> Windows:&nbsp; 32-bit Extended Windows Application Development </H1>
<BR>The purpose of this chapter is to anticipate some common questions about 32-bit Windows application development.
<BR><BR>The following topics are discussed in this chapter:
<UL>
<LI>Can you call 16-bit code from a 32-bit code?
<LI>How do I add my Windows resources?
<LI>What size of function pointers passed to Windows?
<LI>Why are 32-bit callback routines FAR?
<LI>Why use the _16 API functions?
</UL>
<H2 ID="Windows__Can_you_call_16Mbit_code_from_a_32Mbit_code_"> Windows:&nbsp; Can you call 16-bit code from a 32-bit code? </H2>
<BR>A 32-bit Windows application can make a call to 16-bit code through the use of the Open Watcom <TT> _Call16</TT> or <TT>
InvokeIndirectFunction</TT> procedures.&nbsp; These functions ensure that the Open Watcom Windows Supervisor prepares the
stack for the 16-bit call and return to the 32-bit code.&nbsp; The 32-bit application uses <TT> LoadLibrary</TT> function
to bring the 16-bit DLL into memory and then calls the 16-bit procedures.&nbsp; To invoke 16-bit procedures, use <TT> GetProcAddress</TT>
to get the 16-bit far pointer to the function.&nbsp; Use the <TT> _Call16</TT> procedure to call the 16-bit function since
it is simpler to use than the <TT> GetIndirectFunctionHandle</TT>, <TT> InvokeIndirectFunction</TT>, and <TT> FreeIndirectFunctionHandle</TT>
sequence.&nbsp; An example of this process is provided under the <TT> _Call16</TT> Windows library function description.
<BR><BR>This method can be used to call any 16-bit Dynamic Link Library (DLL) procedure or any 32-bit extended DLL procedure
from within a 32-bit application, including DLLs that are available as products through Independent Software Vendors (ISVs).
<H2 ID="Windows__How_do_I_add_my_Windows_resources_"> Windows:&nbsp; How do I add my Windows resources? </H2>
<BR>The <TT> WBIND</TT> utility automatically runs the resource compiler to add the resources to the 32-bit Windows supervisor
(since the supervisor is a 16-bit Windows application).&nbsp; Note that resource compiler options may be specified by using
the &quot;R&quot; option of <TT> WBIND</TT>.
<H2 ID="Windows__What_size_of_function_pointers_passed_to_Windows_"> Windows:&nbsp; What size of function pointers passed to Windows? </H2>
<BR>All function pointers passed to Windows must be 16-bit far pointers since no translation is applied to any function pointers
passed to Windows.&nbsp; Translation is often not possible, since any functions that Windows is to call back must be exported,
and only 16-bit functions can be exported.
<BR><BR>A 16-bit far pointer to a function is obtained in one of two ways:&nbsp; either Windows gives it to you (via <TT>
GetProcAddr</TT>, for example), or you obtain a pointer from the supervisor, via <TT> GetProc16</TT>.
<BR><BR>Function pointers obtained from Windows may either be fed into other Windows functions requiring function pointers,
or called indirectly by using <TT> _Call16</TT> or by using the <TT> GetIndirectFunctionHandle</TT>, <TT> InvokeIndirectFunction</TT>,
and <TT> FreeIndirectFunctionHandle</TT> sequence.
<BR><BR>The function <TT> GetProc16</TT> returns a 16-bit far pointer to a callback function that Windows can use.&nbsp; This
callback function will direct control into the desired 32-bit routine.
<H2 ID="Windows__Why_are_32Mbit_callback_routines_FAR_"> Windows:&nbsp; Why are 32-bit callback routines FAR? </H2>
<BR>The callback routines are declared as FAR so that the compiler will generate a far return from the procedure.&nbsp; This
is necessary since the 32-bit callback routine is &quot;far&quot; called from the supervisor.
<BR><BR>The callback routine is still &quot;near&quot; in the sense that it lies within the 32-bit flat address space of the
application.&nbsp; This means that <TT> GetProc16</TT> only needs the offset of the 32-bit callback function in order to set
up the 16-bit procedure to call back correctly.&nbsp; Thus, <TT> GetProc16</TT> accepts type <TT> PROCPTR</TT> which is in
fact only 4 bytes long.&nbsp; The compiler will provide the offset only, which is, as already stated, all that is needed.
<H2 ID="Windows__Why_use_the__16_API_functions_"> Windows:&nbsp; Why use the _16 API functions? </H2>
<BR>The regular Windows API functions used in Open Watcom F77 automatically convert any pointers to 16-bit far pointers for
use by Windows.&nbsp; Sometimes, you may have a set of pointers that are 16-bit far pointers already (e.g., obtained from
<TT> GlobalLock</TT>), and do not need any conversion.&nbsp; The &quot;_16...&quot; API functions do not convert pointers,
they simply pass them on directly to Windows.&nbsp; See the appendix entitled <A HREF="#Special_Windows_API_Functions">Special Windows API Functions</A>
for a list of the &quot;_16...&quot; API functions.
<H1 ID="Special_Windows_API_Functions"> Special Windows API Functions </H1>
<BR>On rare occasions, you want to use 16-bit far pointers directly in a Windows function.&nbsp; Since all Windows functions
in the 32-bit environment are expecting 32-bit near pointers, you cannot simply use the 16-bit far pointer directly in the
function.
<BR><BR>The following functions are special versions of Windows API functions that do NOT convert any of the pointers from
32-bit to 16-bit.&nbsp; There are _16 versions of all Windows API functions that accept data pointers.
<UL>
<LI>_16AddAtom
<LI>_16AddFontResource
<LI>_16AdjustWindowRect
<LI>_16AdjustWindowRectEx
<LI>_16AnimatePalette
<LI>_16AnsiLower
<LI>_16AnsiLowerBuff
<LI>_16AnsiToOem
<LI>_16AnsiToOemBuff
<LI>_16AnsiUpper
<LI>_16AnsiUpperBuff
<LI>_16BuildCommDCB
<LI>_16CallMsgFilter
<LI>_16ChangeMenu
<LI>_16ClientToScreen
<LI>_16ClipCursor
<LI>_16CopyMetaFile
<LI>_16CopyRect
<LI>_16CreateBitmap
<LI>_16CreateBitmapIndirect
<LI>_16CreateBrushIndirect
<LI>_16CreateCursor
<LI>_16CreateDC
<LI>_16CreateDialog
<LI>_16CreateDialogIndirect
<LI>_16CreateDialogIndirectParam
<LI>_16CreateDialogParam
<LI>_16CreateDIBitmap
<LI>_16CreateEllipticRgnIndirect
<LI>_16CreateFont
<LI>_16CreateFontIndirect
<LI>_16CreateIC
<LI>_16CreateIcon
<LI>_16CreateMetaFile
<LI>_16CreatePalette
<LI>_16CreatePenIndirect
<LI>_16CreatePolygonRgn
<LI>_16CreatePolyPolygonRgn
<LI>_16CreateRectRgnIndirect
<LI>_16CreateWindow
<LI>_16CreateWindowEx
<LI>_16DialogBox
<LI>_16DialogBoxIndirect
<LI>_16DialogBoxIndirectParam
<LI>_16DialogBoxParam
<LI>_16DispatchMessage
<LI>_16DlgDirList
<LI>_16DlgDirListComboBox
<LI>_16DlgDirSelect
<LI>_16DlgDirSelectComboBox
<LI>_16DPtoLP
<LI>_16DrawFocusRect
<LI>_16DrawText
<LI>_16EndPaint
<LI>_16EnumChildWindows
<LI>_16EnumFonts
<LI>_16EnumMetaFile
<LI>_16EnumObjects
<LI>_16EnumProps
<LI>_16EnumTaskWindows
<LI>_16EnumWindows
<LI>_16EqualRect
<LI>_16Escape
<LI>_16ExtTextOut
<LI>_16FillRect
<LI>_16FindAtom
<LI>_16FindResource
<LI>_16FindWindow
<LI>_16FrameRect
<LI>_16FreeProcInstance
<LI>_16GetAtomName
<LI>_16GetBitmapBits
<LI>_16GetCaretPos
<LI>_16GetCharWidth
<LI>_16GetClassInfo
<LI>_16GetClassName
<LI>_16GetClientRect
<LI>_16GetClipboardFormatName
<LI>_16GetClipBox
<LI>_16GetCodeInfo
<LI>_16GetCommError
<LI>_16GetCommState
<LI>_16GetCursorPos
<LI>_16GetDIBits
<LI>_16GetDlgItemInt
<LI>_16GetDlgItemText
<LI>_16GetEnvironment
<LI>_16GetKeyboardState
<LI>_16GetKeyNameText
<LI>_16GetMenuString
<LI>_16GetMetaFile
<LI>_16GetModuleFileName
<LI>_16GetModuleHandle
<LI>_16GetObject
<LI>_16GetPaletteEntries
<LI>_16GetPriorityClipboardFormat
<LI>_16GetPrivateProfileInt
<LI>_16GetPrivateProfileString
<LI>_16GetProcAddress
<LI>_16GetProfileInt
<LI>_16GetProfileString
<LI>_16GetProp
<LI>_16GetRgnBox
<LI>_16GetScrollRange
<LI>_16GetSystemDirectory
<LI>_16GetSystemPaletteEntries
<LI>_16GetTabbedTextExtent
<LI>_16GetTempFileName
<LI>_16GetTextExtent
<LI>_16GetTextFace
<LI>_16GetTextMetrics
<LI>_16GetUpdateRect
<LI>_16GetWindowRect
<LI>_16GetWindowsDirectory
<LI>_16GetWindowText
<LI>_16GlobalAddAtom
<LI>_16GlobalFindAtom
<LI>_16GlobalGetAtomName
<LI>_16GlobalNotify
<LI>_16GrayString
<LI>_16InflateRect
<LI>_16IntersectRect
<LI>_16InvalidateRect
<LI>_16InvertRect
<LI>_16IsDialogMessage
<LI>_16IsRectEmpty
<LI>_16LineDDA
<LI>_16LoadAccelerators
<LI>_16LoadBitmap
<LI>_16LoadCursor
<LI>_16LoadIcon
<LI>_16LoadLibrary
<LI>_16LoadMenu
<LI>_16LoadMenuIndirect
<LI>_16LoadModule
<LI>_16LoadString
<LI>_16LPtoDP
<LI>_16MakeProcInstance
<LI>_16MapDialogRect
<LI>_16MessageBox
<LI>_16OemToAnsi
<LI>_16OemToAnsiBuff
<LI>_16OffsetRect
<LI>_16OpenComm
<LI>_16OpenFile
<LI>_16OutputDebugString
<LI>_16PlayMetaFileRecord
<LI>_16Polygon
<LI>_16Polyline
<LI>_16PolyPolygon
<LI>_16PtInRect
<LI>_16ReadComm
<LI>_16RectInRegion
<LI>_16RectVisible
<LI>_16RegisterClipboardFormat
<LI>_16RegisterWindowMessage
<LI>_16RemoveFontResource
<LI>_16RemoveProp
<LI>_16ScreenToClient
<LI>_16ScrollDC
<LI>_16ScrollWindow
<LI>_16SetBitmapBits
<LI>_16SetCommState
<LI>_16SetDIBits
<LI>_16SetDIBitsToDevice
<LI>_16SetDlgItemText
<LI>_16SetEnvironment
<LI>_16SetKeyboardState
<LI>_16SetPaletteEntries
<LI>_16SetProp
<LI>_16SetRect
<LI>_16SetRectEmpty
<LI>_16SetResourceHandler
<LI>_16SetSysColors
<LI>_16SetTimer
<LI>_16SetWindowsHook
<LI>_16SetWindowText
<LI>_16StretchDIBits
<LI>_16TabbedTextOut
<LI>_16TextOut
<LI>_16ToAscii
<LI>_16TrackPopupMenu
<LI>_16TranslateAccelerator
<LI>_16TranslateMDISysAccel
<LI>_16TranslateMessage
<LI>_16UnhookWindowsHook
<LI>_16UnionRect
<LI>_16UnregisterClass
<LI>_16ValidateRect
<LI>_16WinExec
<LI>_16WinHelp
<LI>_16WriteComm
<LI>_16WritePrivateProfileString
<LI>_16WriteProfileString
<LI>_16_lread
<LI>_16_lwrite
</UL>
<H1 ID="NT__Windows_NT_Programming_Overview"> NT:&nbsp; Windows NT Programming Overview </H1>
<BR>Windows NT supports both non-windowed character-mode applications and windowed Graphical User Interface (GUI) applications.
&nbsp;In addition, Windows NT supports Dynamic Link Libraries and applications with multiple threads of execution.
<BR><BR>We have supplied all the necessary tools for native development on Windows NT.&nbsp; You can also cross develop for
Windows NT using either the DOS-hosted compilers and tools, the Windows 95-hosted compilers and tools, or the OS/2-hosted
compilers and tools.&nbsp; Testing and debugging of your Windows NT application must be done on Windows NT or Windows 95.
<BR><BR>If you are creating a character-mode application, you may also be interested in a special DOS extender from Phar Lap
(TNT) that can run your Windows NT character-mode application under DOS.
<H2 ID="NT__Windows_NT_CharacterMmode_Versus_GUI"> NT:&nbsp; Windows NT Character-mode Versus GUI </H2>
<BR>Basically, there are two classes of FORTRAN 77 applications that can run in a windowed environment like Windows NT.
<BR><BR>The first are those FORTRAN 77 applications that do not use any of the Win32 API functions; they are strictly FORTRAN
77 applications that do not rely on the features of a particular operating system.
<UL>
<LI>This Application must be created as Windows NT Character-mode Application.
</UL>
<BR>The second class of FORTRAN 77 applications are those that actually call Win32 API functions directly.&nbsp; These are
applications that have been tailored for the Win32 operating environment.
<UL>
<LI>Open Watcom FORTRAN 77 does not provide direct support for these types of applications.&nbsp; While we do provide include
files that map out 16-bit Windows structures and the interface to 16-bit Windows API calls, we do not provide this for Win32
API.&nbsp; The Win32 application developer must create these as required.
<LI>An alternate solution, for those so-inclined, is to develop the GUI part of the interface in C and call these functions
from FORTRAN code.
</UL>
<BR>A subsequent chapters deal with the creation of different application types for Windows NT target.
<H1 ID="NT__Creating_Windows_NT_CharacterMmode_Applications"> NT:&nbsp; Creating Windows NT Character-mode Applications </H1>
<BR>This chapter describes how to compile and link Windows NT Character-mode applications simply and quickly.&nbsp; In this
chapter, we look at applications written to exploit the Windows NT Application Programming Interface (API).
<BR><BR>We will illustrate the steps to creating Windows NT Character-mode applications by taking a small sample application
and showing you how to compile, link, run and debug it.
<H2 ID="NT__The_Sample_CharacterMmode_Application"> NT:&nbsp; The Sample Character-mode Application </H2>
<BR>To demonstrate the creation of Windows NT Character-mode applications, we introduce a simple sample program.&nbsp; For
our example, we are going to use the &quot;sieve&quot; program.
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; * This program computes the prime numbers between 1 and 10,000</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; * using the Sieve of Eratosthenes algorithm.</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; IMPLICIT NONE</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; INTEGER UPBOUND</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; PARAMETER (UPBOUND=10000)</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; INTEGER I, K, PRIMES</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; LOGICAL*1 NUMBERS(2:UPBOUND)</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CHARACTER*11 FORM</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CHARACTER*60 BUFFER</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; PARAMETER (FORM='(A,I5,A,I5)')</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DO I = 2, UPBOUND</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; NUMBERS(I) = .TRUE.</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ENDDO</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; PRIMES = 0</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DO I = 2, UPBOUND</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; IF( NUMBERS(I) )THEN</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; PRIMES
= PRIMES + 1</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DO K
= I + I, UPBOUND, I</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp; NUMBERS(K) = .FALSE.</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ENDDO</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ENDIF</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ENDDO</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; PRINT FORM, 'The Number of Primes between 1 and ',
UPBOUND,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;' are: ', PRIMES</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; END</TT>
<BR><BR>The goal of this program is to count the prime numbers between 1 and 10,000.&nbsp; It uses the famous<B> Sieve of
Eratosthenes</B> algorithm to accomplish this task.&nbsp; We will take you through the steps necessary to produce this result.
<H2 ID="NT__Building_and_Running_the_CharacterMmode_Application"> NT:&nbsp; Building and Running the Character-mode Application </H2>
<BR>To compile and link our example program which is stored in the file<TT> sieve.for</TT>, enter the following command:
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; C&gt;wfl386 -l=nt&nbsp; sieve.for</TT>
<BR><BR>The typical messages that appear on the screen are shown in the following illustration.
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; C&gt;wfl386 -l=nt&nbsp; sieve.for</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Open Watcom F77/32 Compile and Link Utility</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Copyright (c) 2002-2019 the Open Watcom Contributors. All Rights Reserved.</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Portions Copyright (c) 1990-2002 Sybase, Inc. All Rights Reserved.</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Source code is available under the Sybase Open Watcom Public License.</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; See http://www.openwatcom.org/ for details.</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; wfc386 sieve.for </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Open Watcom FORTRAN 77/32 Optimizing Compiler</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Copyright (c) 2002-2019 the Open Watcom Contributors. All Rights Reserved.</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Portions Copyright (c) 1984-2002 Sybase, Inc. All Rights Reserved.</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Source code is available under the Sybase Open Watcom Public License.</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; See http://www.openwatcom.org/ for details.</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; sieve.for: 4390 statements, 207 bytes, 1585 extensions, 0 warnings, 0 errors</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Open Watcom Linker</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Copyright (c) 2002-2019 the Open Watcom Contributors. All Rights Reserved.</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Portions Copyright (c) 1985-2002 Sybase, Inc. All Rights Reserved.</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Source code is available under the Sybase Open Watcom Public License.</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; See http://www.openwatcom.org/ for details.</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; loading object files</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; searching libraries</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; creating a Windows NT Character-mode executable</TT>
<BR><BR>If you examine the current directory, you will find that two files have been created.&nbsp; These are<TT> sieve.obj</TT>
(the result of compiling<TT> sieve.for</TT>) and<TT> sieve.exe</TT> (the result of linking<TT> sieve.obj</TT> with the appropriate
Open Watcom FORTRAN 77 libraries).
<BR><BR>The resultant Windows NT Character-mode application<TT> SIEVE.EXE</TT> can now be run under Windows NT.
<H2 ID="NT__Debugging_the_CharacterMmode_Application"> NT:&nbsp; Debugging the Character-mode Application </H2>
<BR>Let us assume that you wish to debug your application in order to locate an error in programming.&nbsp; In the previous
section, the &quot;sieve&quot; program was compiled with default compile and link options.&nbsp; When debugging an application,
it is useful to refer to the symbolic names of routines and variables.&nbsp; It is also convenient to debug at the source
line level rather than the machine language level.&nbsp; To do this, we must direct both the compiler and linker to include
additional debugging information in the object and executable files.&nbsp; Using the <TT> WFL386</TT> command, this is fairly
straightforward.&nbsp; <TT> WFL386</TT> recognizes the Open Watcom F77 compiler &quot;debug&quot; options and will create
the appropriate debug directives for the Open Watcom Linker.
<BR><BR>For example, to compile and link the &quot;sieve&quot; program with debugging information, the following command may
be issued.
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; C&gt;wfl386 -l=nt&nbsp; -d2 sieve.for</TT>
<BR><BR>The typical messages that appear on the screen are shown in the following illustration.
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; C&gt;wfl386 -l=nt&nbsp; -d2 sieve.for</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Open Watcom F77/32 Compile and Link Utility</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Copyright (c) 2002-2019 the Open Watcom Contributors. All Rights Reserved.</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Portions Copyright (c) 1990-2002 Sybase, Inc. All Rights Reserved.</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Source code is available under the Sybase Open Watcom Public License.</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; See http://www.openwatcom.org/ for details.</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; wfc386 sieve.for&nbsp; -d2</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Open Watcom FORTRAN 77/32 Optimizing Compiler</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Copyright (c) 2002-2019 the Open Watcom Contributors. All Rights Reserved.</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Portions Copyright (c) 1984-2002 Sybase, Inc. All Rights Reserved.</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Source code is available under the Sybase Open Watcom Public License.</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; See http://www.openwatcom.org/ for details.</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; sieve.for: 4390 statements, 293 bytes, 1585 extensions, 0 warnings, 0 errors</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Open Watcom Linker</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Copyright (c) 2002-2019 the Open Watcom Contributors. All Rights Reserved.</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Portions Copyright (c) 1985-2002 Sybase, Inc. All Rights Reserved.</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Source code is available under the Sybase Open Watcom Public License.</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; See http://www.openwatcom.org/ for details.</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; loading object files</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; searching libraries</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; creating a Windows NT Character-mode executable</TT>
<BR><BR>The &quot;d2&quot; option requests the maximum amount of debugging information that can be provided by the Open Watcom
F77 compiler.&nbsp; <TT> WFL386</TT> will make sure that this debugging information is included in the executable file that
is produced by the linker.
<BR><BR>The &quot;bytes&quot; value is larger than in the previous example since selection of the &quot;d2&quot; option results
in fewer code optimizations by default.&nbsp; You can request more optimization by specifying the appropriate options.&nbsp;
However, you do so at the risk of making it more difficult for yourself to determine the relationship between the object code
and the original source language code.
<BR><BR>To request the Open Watcom Debugger to assist in debugging the application, select the Open Watcom Debugger icon.
&nbsp;It would be too ambitious to describe the debugger in this introductory chapter so we refer you to the book entitled<B><I>
Open Watcom Debugger User's Guide.</I></B>
<BR><BR>There are more extensive examples of Windows applications written in FORTRAN 77 in the<TT> \WATCOM\SAMPLES\FORTRAN\WIN</TT>
directory.&nbsp; The example programs are<TT> ELLIPSE.FOR</TT> and<TT> FWCOPY.FOR.</TT>
<H1 ID="NT__Windows_NT_MultiMthreaded_Applications"> NT:&nbsp; Windows NT Multi-threaded Applications </H1>
<BR>This chapter describes how to create multi-threaded applications.&nbsp; A multi-threaded application is one whose tasks
are divided among several threads of execution.&nbsp; A process is an executing application and the resources it uses.&nbsp;
A thread is the smallest unit of execution within a process.&nbsp; Each thread has its own stack and a set of machine registers
and shares all resources with its parent process.&nbsp; The path of execution of one thread does not affect that of another;
each thread is an independent entity.
<BR><BR>Typically, an application has a single thread of execution.&nbsp; In this type of application, all tasks, once initiated,
are completed before the next task begins.&nbsp; In contrast, tasks in a multi-threaded application can be performed concurrently
since more than one thread is executing at once.&nbsp; For example, each thread may be designed to perform a separate task.
<H2 ID="NT__Programming_Considerations"> NT:&nbsp; Programming Considerations </H2>
<BR>Since a multi-threaded application consists of many threads of execution, there are a number of issues that you must consider.
<BR><BR>Since threads share the resources of its parent, it may be necessary to serialize access to these resources.&nbsp;
For example, if your application contains more than one thread of execution and each thread uses the <TT> PRINT</TT> statement
to display output to the console, it would be necessary for the I/O support routines to allow only one thread to use the <TT>
PRINT</TT> facility at any time.&nbsp; That is, once a thread issues a <TT> PRINT</TT> request, the I/O support routines should
ensure that no other thread displays information until all information for the initial thread has been displayed.
<H2 ID="NT__Creating_Threads"> NT:&nbsp; Creating Threads </H2>
<BR>Each application initially contains a single thread.&nbsp; The run-time libraries contain two functions that create and
terminate threads of execution.&nbsp; The function<TT> beginthread</TT> creates a thread of execution and the function<TT>
endthread</TT> ends a thread of execution.&nbsp; The function<TT> threadid</TT> can be used to determine the current thread
identifier.
<HR>
<BR><B><I>&nbsp; WARNING!</I></B>&nbsp; If any thread uses an I/O statement or calls an intrinsic function, you must use the<TT>
beginthread</TT> function to create the thread.&nbsp; Do not use the<TT> CreateThread</TT> API function.
<HR>
<H3 ID="NT__Creating_a_New_Thread"> NT:&nbsp; Creating a New Thread </H3>
<BR>The<TT> beginthread</TT> function creates a new thread.&nbsp; It is defined as follows.
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; integer function beginthread( start_address,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; stack_size )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; integer stack_size</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; end</TT>
<DL>
<DT>where
<DD><B>description</B>
<DT>start_address
<DD>is the address of the subroutine that will be called when the newly created thread is executed.&nbsp; When the thread returns
from that subroutine, the thread will be terminated.&nbsp; Note that a call to the<TT> endthread</TT> subroutine will also
terminate the thread.
<DT>stack_size
<DD>specifies the size of the stack to be allocated by the operating system for the new thread.&nbsp; The stack size should be
a multiple of 4K.
</DL>
<BR>If a new thread is successfully created, the thread identifier of the new thread is returned.&nbsp; Otherwise, a value
of -1 is returned.
<BR><BR>The include file<TT> thread.fi</TT> contains the definition of the<TT> beginthread</TT> function.
<BR><BR>Another thread related function for Windows NT is<TT> _beginthreadex.</TT>&nbsp; See the<B><I> Open Watcom C Library
Reference</I></B> for more information.
<H3 ID="NT__Terminating_the_Current_Thread"> NT:&nbsp; Terminating the Current Thread </H3>
<BR>The<TT> endthread</TT> subroutine terminates the current thread.&nbsp; It is defined as follows.
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; subroutine endthread()</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; end</TT>
<BR><BR>The include file<TT> thread.fi</TT> contains the definition of the<TT> endthread</TT> function.
<H3 ID="NT__Getting_the_Current_Thread_Identifier"> NT:&nbsp; Getting the Current Thread Identifier </H3>
<BR>The<TT> threadid</TT> function can be used to determine the current thread identifier.&nbsp; It is defined as follows.
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; integer function threadid()</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; end</TT>
<BR><BR>The include file<TT> thread.fi</TT> contains the definition of the<TT> threadid</TT> function.
<H2 ID="NT__A_MultiMthreaded_Example"> NT:&nbsp; A Multi-threaded Example </H2>
<BR>Let us create a simple multi-threaded application.&nbsp; The source code for this example can be found in<TT> \watcom\samples\fortran\win32.</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; * MTHREAD.FOR</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; *$pragma aux (__stdcall) Sleep parm( value )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; *$pragma aux (__stdcall) InitializeCriticalSection parm( reference )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; *$pragma aux (__stdcall) DeleteCriticalSection parm( reference )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; *$pragma aux (__stdcall) EnterCriticalSection parm( reference )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; *$pragma aux (__stdcall) LeaveCriticalSection parm( reference )</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; structure /RTL_CRITICAL_SECTION/</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; integer*4 DebugInfo</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; integer*4 LockCount</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; integer*4 RecursionCount</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; integer*4 OwningThread</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; integer*4 LockSemaphore</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; integer*4 Reserved</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; end structure</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; integer NumThreads</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; logical HoldThreads</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; volatile HoldThreads, NumThreads</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; record /RTL_CRITICAL_SECTION/ CriticalSection</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; common NumThreads, HoldThreads, CriticalSection</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; integer STACK_SIZE</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; parameter (STACK_SIZE=8192)</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; integer NUM_THREADS</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; parameter (NUM_THREADS=5)</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; integer i, threadid, beginthread</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; external a_thread</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; print '(''main thread id = '',i4)', threadid()</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; NumThreads = 0</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; HoldThreads = .true.</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ! main thread counts as 1</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call InitializeCriticalSection( CriticalSection
)</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; do i = 2, NUM_THREADS</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if( beginthread(
a_thread, STACK_SIZE ) .eq. -1 )then</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;print '(''creation of thread'',i4,''failed'')', i</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;NumThreads = NumThreads + 1</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; end if</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; end do</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; HoldThreads = .false.</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; while( NumThreads .ne. 0 ) do</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call Sleep( 1 )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; end while</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call DeleteCriticalSection( CriticalSection
)</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; end</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; subroutine a_thread()</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; structure /RTL_CRITICAL_SECTION/</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; integer*4 DebugInfo</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; integer*4 LockCount</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; integer*4 RecursionCount</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; integer*4 OwningThread</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; integer*4 LockSemaphore</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; integer*4 Reserved</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; end structure</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; integer NumThreads</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; logical HoldThreads</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; volatile HoldThreads</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; record /RTL_CRITICAL_SECTION/ CriticalSection</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; common NumThreads, HoldThreads, CriticalSection</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; integer threadid</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; while( HoldThreads ) do</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call Sleep( 1 )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; end while</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; print '(''Hi from thread '', i4)', threadid()</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call EnterCriticalSection( CriticalSection
)</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; NumThreads = NumThreads - 1</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call LeaveCriticalSection( CriticalSection
)</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call endthread()</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; end</TT>
<BR><BR><B>Note:</B>
<OL>
<LI>In the subroutine<TT> a_thread, EnterCriticalSection</TT> and<TT> LeaveCriticalSection</TT> are called when we modify
the variable<TT> NumThreads.</TT>&nbsp; This ensures that the action of extracting the value of<TT> NumThreads</TT> from memory,
incrementing the value, and storing the new result into memory, occurs without interruption.&nbsp; If these functions were
not called, it would be possible for two threads to extract the value of<TT> NumThreads</TT> from memory before an update
occurred.
</OL>
<BR>Let us assume that the file<TT> mthread.for</TT> contains the above example.&nbsp; Before compiling the file, make sure
that the<B> WATCOM</B> environment variable is set to the directory in which you installed Open Watcom FORTRAN 77.&nbsp; Also,
the<B> FINCLUDE</B> environment variable must contain the<TT> \watcom\src\fortran</TT> directory where &quot;\WATCOM&quot;
is the name of the directory in which you installed Open Watcom FORTRAN 77.
<BR><BR>We can now compile and link the application by issuing the following command.
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; C:\&gt;wfl386 -bm -l=nt mthread</TT>
<BR><BR>The &quot;bm&quot; option must be specified since we are creating a multi-threaded application.&nbsp; If your multi-threaded
application contains more than one module, each module must be compiled using the &quot;bm&quot; switch.
<BR><BR>The &quot;l&quot; option specifies the target system for which the application is to be linked.&nbsp; The system name<TT>
nt</TT> is defined in the file<TT> wlsystem.lnk</TT> which is located in the &quot;BINW&quot; subdirectory of the directory
in which you installed Open Watcom FORTRAN 77.
<BR><BR>The multi-threaded application is now ready to be run.
<H1 ID="NT__Windows_NT_Dynamic_Link_Libraries"> NT:&nbsp; Windows NT Dynamic Link Libraries </H1>
<BR>A dynamic link library, like a standard library, is a library of functions.&nbsp; When an application uses functions from
a standard library, the library functions referenced by the application become part of the executable module.&nbsp; This form
of linking is called static linking.&nbsp; When an application uses functions from a dynamic link library, the library functions
referenced by the application are not included in the executable module.&nbsp; Instead, the executable module contains references
to these functions which are resolved when the application is loaded.&nbsp; This form of linking is called dynamic linking.
<BR><BR>Let us consider some of the advantages of using dynamic link libraries over standard libraries.
<OL>
<LI>Functions in dynamic link libraries are not linked into your program.&nbsp; Only references to the functions in dynamic
link libraries are placed in the program module.&nbsp; These references are called import definitions.&nbsp; As a result,
the linking time is reduced and disk space is saved.&nbsp; If many applications reference the same dynamic link library, the
saving in disk space can be significant.
<LI>Since program modules only reference dynamic link libraries and do not contain the actual executable code, a dynamic link
library can be updated without re-linking your application.&nbsp; When your application is executed, it will use the updated
version of the dynamic link library.
<LI>Dynamic link libraries also allow sharing of code and data between the applications that use them.&nbsp; If many applications
that use the same dynamic link library are executing concurrently, the sharing of code and data segments improves memory utilization.
</OL>
<H2 ID="NT__Creating_Dynamic_Link_Libraries"> NT:&nbsp; Creating Dynamic Link Libraries </H2>
<BR>Once you have developed the source for a library of functions, a number of steps are required to create a dynamic link
library containing those functions.
<BR><BR>First, you must compile your source using the &quot;bd&quot; compiler option.&nbsp; This option tells the compiler
that the module you are compiling is part of a dynamic link library.&nbsp; Once you have successfully compiled your source,
you must create a linker directive file that describes the attributes of your dynamic link library.&nbsp; The following lists
the most common linker directives required to create a dynamic link library.
<OL>
<LI>The &quot;SYSTEM&quot; directive is used to specify that a dynamic link library is to be created.
<LI>The &quot;EXPORT&quot; directive is used to to specify which functions in the dynamic link library are to be exported.
<LI>The &quot;OPTION&quot; directive is used to specify attributes such as the name of the dynamic link library and how to
allocate the automatic data segment when the dynamic link library is referenced.
<LI>The &quot;SEGMENT&quot; directive is used to specify attributes of segments.&nbsp; For example, a segment may be read-only
or read-write.
</OL>
<BR>Once the dynamic link library is created, you must allow access to the dynamic link library to client applications that
wish to use it.&nbsp; This can be done by creating an import library for the dynamic link library or creating a linker directive
file that contains &quot;IMPORT&quot; directives for each of the entry points in the dynamic link library.
<H2 ID="NT__Creating_a_Sample_Dynamic_Link_Library"> NT:&nbsp; Creating a Sample Dynamic Link Library </H2>
<BR>Let us now create a dynamic link library using the following example.&nbsp; The source code for this example can be found
in<TT> \watcom\samples\fortran\win\dll.</TT>&nbsp; Unlike applications developed in the C or C++ language, the FORTRAN 77
developer must not provide a <TT> LibMain</TT> entry point.&nbsp; This entry point is already defined in the Open Watcom FORTRAN
77 run-time libraries.&nbsp; The run-time system's <TT> LibMain</TT> provides for the proper initialization of the FORTRAN
77 run-time system and includes hooks to call developer-written process attach/detach and thread attach/detach routines.&nbsp;
These routines are optional but we show skeleton versions in the following example so that you can develop your own if required.
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; * DLLSAMP.FOR</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; integer function __fdll_initialize_()</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; *&nbsp;&nbsp;&nbsp;&nbsp; Called from LibMain during &quot;DLL PROCESS ATTACH&quot;</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; *&nbsp;&nbsp;&nbsp;&nbsp; do process initialization</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; print *, 'Hi from process attach'</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; *&nbsp;&nbsp;&nbsp;&nbsp; returning 0 indicates failure</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; __fdll_initialize_ = 1</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; end</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; integer function __fthrd_initialize_()</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; *&nbsp;&nbsp;&nbsp;&nbsp; Called from LibMain during &quot;DLL THREAD ATTACH&quot;</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; *&nbsp;&nbsp;&nbsp;&nbsp; do thread initialization</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; print *, 'Hi from thread attach'</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; *&nbsp;&nbsp;&nbsp;&nbsp; returning 0 indicates failure</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; __fthrd_initialize_ = 1</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; end</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; integer function __fthrd_terminate_()</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; *&nbsp;&nbsp;&nbsp;&nbsp; Called from LibMain during &quot;DLL THREAD DETACH&quot;</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; *&nbsp;&nbsp;&nbsp;&nbsp; do thread cleanup</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; print *, 'Hi from thread detach'</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; *&nbsp;&nbsp;&nbsp;&nbsp; returning 0 indicates failure</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; __fthrd_terminate_ = 1</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; end</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; integer function __fdll_terminate_()</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; *&nbsp;&nbsp;&nbsp;&nbsp; Called from LibMain during &quot;DLL PROCESS DETACH&quot;</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; *&nbsp;&nbsp;&nbsp;&nbsp; do process cleanup</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; print *, 'Hi from process detach'</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; *&nbsp;&nbsp;&nbsp;&nbsp; returning 0 indicates failure</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; __fdll_terminate_ = 1</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; end</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; subroutine dll_entry_1()</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; print *, 'Hi from dll entry #1'</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; end</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; subroutine dll_entry_2()</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; print *, 'Hi from dll entry #2'</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; end</TT>
<BR><BR>Here are some explanatory notes on this example.
<DL>
<DT>Function
<DD>Description
<DT>__FDLL_INITIALIZE_
<DD>This function is called when the DLL is attaching to the address space of the current process as a result of the process starting
up or as a result of a call to <TT> LoadLibrary</TT>.&nbsp; A DLL can use this opportunity to initialize any instance data.
<BR><BR>During initial process startup or after a call to <TT> LoadLibrary</TT>, the operating system scans the list of loaded
DLLs for the process.&nbsp; For each DLL that has not already been called with the<TT> DLL_PROCESS_ATTACH</TT> value, the
system calls the DLL's <TT> LibMain</TT> entry-point (in the Open Watcom FORTRAN 77 run-time system).&nbsp; This call is made
in the context of the thread that caused the process address space to change, such as the primary thread of the process or
the thread that called <TT> LoadLibrary</TT>.
<DT>__FTHRD_INITIALIZE_
<DD>This function is called when the current process is creating a new thread.&nbsp; When this occurs, the system calls the <TT>
LibMain</TT> entry-point (in the Open Watcom FORTRAN 77 run-time system) of all DLLs currently attached to the process.&nbsp;
The call is made in the context of the new thread.&nbsp; DLLs can use this opportunity to initialize thread specific data.
&nbsp;A thread calling the DLL's<TT> LibMain</TT> with the<TT> DLL_PROCESS_ATTACH</TT> value does not call <TT> LibMain</TT>
with the<TT> DLL_THREAD_ATTACH</TT> value.&nbsp; Note that <TT> LibMain</TT> is called with this value only by threads created
after the DLL is attached to the process.&nbsp; When a DLL is attached by <TT> LoadLibrary</TT>, existing threads do not call
the <TT> LibMain</TT> entry-point of the newly loaded DLL.
<DT>__FTHRD_TERMINATE_
<DD>This function is called when a thread is exiting normally.&nbsp; The DLL uses this opportunity to do thread specific termination
such as closing files that were opened by the thread.&nbsp; The operating system calls the <TT> LibMain</TT> entry-point (in
the Open Watcom FORTRAN 77 run-time system) of all currently loaded DLLs with this value.&nbsp; The call is made in the context
of the exiting thread.&nbsp; There are cases in which <TT> LibMain</TT> is called for a terminating thread even if the DLL
never attached to the thread.&nbsp; For example, <TT> LibMain</TT> is never called with the<TT> DLL_THREAD_ATTACH</TT> value
in the context of the thread in either of these two situations:
<UL>
<LI>The thread was the initial thread in the process, so the system called <TT> LibMain</TT> with the<TT> DLL_PROCESS_ATTACH</TT>
value.
<LI>The thread was already running when a call to the <TT> LoadLibrary</TT> function was made, so the system never called
<TT> LibMain</TT> for it.
</UL>
<DT>__FDLL_TERMINATE_
<DD>This function is called when the DLL is detaching from the address space of the calling process as a result of either a normal
termination or of a call to <TT> FreeLibrary</TT>.&nbsp; When a DLL detaches from a process as a result of process termination
or as a result of a call to <TT> FreeLibrary</TT>, the operating system does not call the DLL's <TT> LibMain</TT> with the<TT>
DLL_THREAD_DETACH</TT> value for the individual threads of the process.&nbsp; The DLL is only given<TT> DLL_PROCESS_DETACH</TT>
notification.&nbsp; DLLs can take this opportunity to clean up all resources for all threads attached and known to the DLL.
<DT>Note:
<DD>These functions return 1 if initialization succeeds or 0 if initialization fails.&nbsp; Subsequently, this value will be returned
by the run-time system's<TT> LibMain</TT> function.
<BR><BR>If the return value is 0 when <TT> LibMain</TT> is called because the process uses the <TT> LoadLibrary</TT> function,
<TT> LoadLibrary</TT> returns NULL.
<BR><BR>If the return value is 0 when <TT> LibMain</TT> is called during process initialization, the process terminates with
an error.
<DT>DLL_ENTRY_1, DLL_ENTRY_2
<DD>These are sample DLL entry points that we will call from our simple test program.
</DL>
<BR>Some further explanation and an example are provided in a later section.
<BR><BR>Assume the above example is contained in the file<TT> dllsamp.for.</TT>&nbsp; We can compile the file using the following
command.&nbsp; Note that we must specify the &quot;bd&quot; compiler option.
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; C:\&gt;wfc386 -bd dllsamp</TT>
<BR><BR>Before we can link our example, we must create a linker directive file that describes the attributes and entry points
of our dynamic link library.&nbsp; The following is a linker directive file, called<TT> dllsamp.lnk,</TT> that can be used
to create the dynamic link library.
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; system nt_dll initinstance terminstance</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; export DLL_ENTRY_1</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; export DLL_ENTRY_2</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; file dllsamp</TT>
<BR><BR><B>Notes:</B>
<OL>
<LI>The &quot;SYSTEM&quot; directive specifies that we are creating a Windows NT dynamic link library.
<LI>When a dynamic link library uses the Open Watcom FORTRAN 77 run-time libraries, an automatic data segment is created each
time a new process accesses the dynamic link library.&nbsp; For this reason, initialization code must be executed when a process
accesses the dynamic link library for the first time.&nbsp; To achieve this, &quot;INITINSTANCE&quot; must be specified in
the &quot;SYSTEM&quot; directive.&nbsp; Similarly, &quot;TERMINSTANCE&quot; must be specified so that the termination code
is executed when a process has completed its access to the dynamic link library.&nbsp; If the Open Watcom FORTRAN 77 run-time
libraries are not used, these options are not required.
<LI>The &quot;EXPORT&quot; directive specifies the entry points into the dynamic link library.&nbsp; Note that in Open Watcom
FORTRAN 77, names of all symbols are uppercased.&nbsp; Regardless of the case used in source files, linker directives must
use uppercased symbol names.&nbsp; The linker is case sensitive by default, although the &quot;OP NOCASEEXACT&quot; directive
may be used to override this.
</OL>
<BR>We can now create our dynamic link library by issuing the following command.
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; C:\&gt;wlink @dllsamp</TT>
<BR><BR>A file called<TT> dllsamp.dll</TT> will be created.
<H2 ID="NT__Using_Dynamic_Link_Libraries"> NT:&nbsp; Using Dynamic Link Libraries </H2>
<BR>Once we have created a dynamic link library, we must allow other applications to access the functions available in the
dynamic link library.&nbsp; There are two ways to achieve this.
<BR><BR>The first method is to create a linker directive file which contains an &quot;IMPORT&quot; directive for all entry
points in the dynamic link library.&nbsp; The &quot;IMPORT&quot; directive provides the name of the entry point and the name
of the dynamic link library.&nbsp; When creating an application that references a function in the dynamic link library, this
linker directive file would be included as part of the linking process that created the application.
<BR><BR>The second method is to use import libraries.&nbsp; An import library is a standard library that is created from a
dynamic link library by using the Open Watcom Library Manager.&nbsp; It contains object modules that describe the entry points
in a dynamic link library.&nbsp; The resulting import library can then be specified in a &quot;LIBRARY&quot; directive in
the same way one would specify a standard library.
<BR><BR>Using an import library is the preferred method of providing references to functions in dynamic link libraries.&nbsp;
When a dynamic link library is modified, typically the import library corresponding to the modified dynamic link library is
updated to reflect the changes.&nbsp; Hence, any directive file that specifies the import library in a &quot;LIBRARY&quot;
directive need not be modified.&nbsp; However, if you are using &quot;IMPORT&quot; directives, you may have to modify the
&quot;IMPORT&quot; directives to reflect the changes in the dynamic link library.
<BR><BR>Let us create an import library for our sample dynamic link library we created in the previous section.&nbsp; We do
this by issuing the following command.
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; C:\&gt;wlib dllsamp +dllsamp.dll</TT>
<BR><BR>A standard library called<TT> dllsamp.lib</TT> will be created.
<BR><BR>Suppose the following sample program, contained in the file<TT> dlltest.for,</TT> calls the functions from our sample
dynamic link library.
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; * DLLTEST.FOR</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call dll_entry_1()</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call dll_entry_2()</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; end</TT>
<BR><BR>We can compile and link our sample application by issuing the following command.
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; C:\&gt;wfl386 -l=nt dlltest dllsamp.lib</TT>
<BR><BR>If we had created a linker directive file of &quot;IMPORT&quot; directives instead of an import library for the dynamic
link library, the linker directive file, say<TT> dllimps.lnk,</TT> would be as follows.
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; import DLL_ENTRY_1 dllsamp</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; import DLL_ENTRY_2 dllsamp</TT>
<BR><BR>To compile and link our sample application, we would issue the following command.
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; C:\&gt;wfl386 -l=nt dlltest -&quot;@dllimps&quot;</TT>
<H2 ID="NT__The_Dynamic_Link_Library_Data_Area"> NT:&nbsp; The Dynamic Link Library Data Area </H2>
<BR>The Open Watcom FORTRAN 77 32-bit run-time library does not support the general case operation of DLLs in an execution
environment where there is only one instance of the DATA segment (DGROUP) for that DLL.
<BR><BR>There are two cases that can lead to a DLL executing with only one instance of the DGROUP.
<OL>
<LI>DLLs linked for 32-bit OS/2 without the MANYAUTODATA option.
<LI>DLLs linked for the Win32 API and executing under Win32s.
</OL>
<BR>In these cases the run-time library startup code detects that there is only one instance of the DGROUP when a second process
attempts to attach to the DLL.&nbsp; At that point, it issues a diagnostic for the user and then notifies the operating system
that the second process cannot attach to the DLL.
<BR><BR>Developers who require DLLs to operate when there is only one instance of the DGROUP can suppress the function which
issues the diagnostic and notifies the operating system that the second process cannot attach to the DLL.
<BR><BR>Doing so requires good behaviour on the part of processes attaching to the DLL.&nbsp; This good behaviour consists
primarily of ensuring that the first process to attach to the DLL is also the last process to detach from the DLL thereby
ensuring that the DATA segment is not released back to the free memory pool.
<BR><BR>To suppress the function which issues the diagnostic and notifies the operating system that the second process cannot
attach to the DLL, the developer must provide a replacement entry point with the following prototype:
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; int __disallow_single_dgroup( int );</TT>
<BR><BR>This function should return zero to indicate that the detected single copy of the DATA segment is allowed.
<H2 ID="NT__Dynamic_Link_Library_InitializationDTermination"> NT:&nbsp; Dynamic Link Library Initialization/Termination </H2>
<BR>Each dynamic link library (DLL) has an initialization and termination routine associated with it.&nbsp; The initialization
routine can either be called the first time any process accesses the DLL (&quot;INITGLOBAL&quot; is specified at link time)
or each time a process accesses the DLL (&quot;INITINSTANCE&quot; is specified at link time).&nbsp; Similarly, the termination
routine can either be called when all processes have completed their access of the DLL (&quot;TERMGLOBAL&quot; is specified
at link time) or each time a process completes its access of the DLL (&quot;TERMINSTANCE&quot; is specified at link time).
<BR><BR>For a DLL that uses the FORTRAN 77 run-time libraries, initialization and termination of the FORTRAN 77 run-time environment
is performed automatically.&nbsp; It is also possible for a DLL to do its own special initialization and termination process.
<BR><BR>The FORTRAN 77 run-time environment provides a method for calling user-written DLL initialization and termination
code.&nbsp; The <TT> __fdll_initialize_</TT> routine is called for DLL process initialization.&nbsp; The <TT> __fthrd_initialize_</TT>
routine is called for DLL thread initialization.&nbsp; The <TT> __fthrd_terminate_</TT> routine is called for DLL thread termination.
&nbsp;The <TT> __fdll_terminate_</TT> routine is called for DLL process termination.&nbsp; Default stub versions of these
routines are included in the run-time library.&nbsp; If you wish to perform additional initialization/termination processing
that is specific to your dynamic link library, you may write your own versions of these routines.
<BR><BR>When a process first attaches to the DLL, the FORTRAN 77 run-time environment is initialized and then the routine<TT>
__fdll_initialize_</TT> is called.&nbsp; When a thread is started, the routine<TT> __fthrd_initialize_</TT> is called.&nbsp;
When a thread is terminated, the routine<TT> __fthrd_terminate_</TT> is called.&nbsp; When the main process relinquishes the
DLL, the routine<TT> __fdll_terminate_</TT> is called and then the FORTRAN 77 run-time environment is terminated,
<BR><BR>The initialization and termination routines return an integer.&nbsp; A value of 0 indicates failure; a value of 1
indicates success.&nbsp; The following example illustrates sample initialization/termination routines.
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; * DLLINIT.FOR</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; integer function __fdll_initialize_()</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; integer __fthrd_initialize_, __fthrd_terminate_</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; integer __fdll_terminate_, dll_entry</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; integer WORKING_SIZE</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; parameter ( WORKING_SIZE = 16*1024 )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; integer ierr, WorkingStorage</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; dimension WorkingStorage(:)</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; allocate( WorkingStorage(WORKING_SIZE), stat=ierr
)</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if( ierr .eq. 0 )then</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; __fdll_initialize_ = 1</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; __fdll_initialize_ = 0</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; endif</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; entry __fthrd_initialize_()</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; __fthrd_initialize_ = 1</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; entry __fthrd_terminate_()</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; __fthrd_terminate_ = 1</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; entry __fdll_terminate_()</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; * Note: no run-time calls allowed under OS/2 Warp</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; deallocate( WorkingStorage )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; __fdll_terminate_ = 1</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; entry dll_entry()</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ! use WorkingStorage</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; end</TT>
<BR><BR>In the above example, the process initialization routine allocates storage that the dynamic link library needs, the
routine<TT> dll_entry</TT> uses the storage, and the process termination routine frees the storage allocated in the initialization
routine.
<H1 ID="16Mbit_OSD2__Creating_16Mbit_OSD2_1_x_Applications"> 16-bit OS/2:&nbsp; Creating 16-bit OS/2 1.x Applications </H1>
<BR><BR>An OS/2 application can be one of the following; a fullscreen application, a PM-compatible application, or a Presentation
Manager application.&nbsp; A fullscreen application runs in its own screen group.&nbsp; A PM-compatible application will run
in an OS/2 fullscreen environment or in a window in the Presentation Manager screen group but does not take direct advantage
of menus, mouse or other features available in the Presentation Manager.&nbsp; A Presentation Manager application has full
access to the complete set of user-interface tools such as menus, icons, scroll bars, etc.
<BR><BR>This chapter deals with the creation of OS/2 fullscreen applications.&nbsp; For information on creating Presentation
Manager applications, refer to the section entitled <A HREF="#OSD2__Programming_for_OSD2_Presentation_Manager">OS/2:&nbsp; Programming for OS/2 Presentation Manager</A>.
<BR><BR>We will illustrate the steps to creating 16-bit OS/2 1.x applications by taking a small sample application and showing
you how to compile, link, run and debug it.
<H2 ID="16Mbit_OSD2__The_Sample_Application"> 16-bit OS/2:&nbsp; The Sample Application </H2>
<BR>To demonstrate the creation of 16-bit OS/2 1.x applications using command-line oriented tools, we introduce a simple sample
program.&nbsp; For our example, we are going to use the &quot;sieve&quot; program.
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; * This program computes the prime numbers between 1 and 10,000</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; * using the Sieve of Eratosthenes algorithm.</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; IMPLICIT NONE</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; INTEGER UPBOUND</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; PARAMETER (UPBOUND=10000)</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; INTEGER I, K, PRIMES</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; LOGICAL*1 NUMBERS(2:UPBOUND)</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CHARACTER*11 FORM</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; PARAMETER (FORM='(A,I5,A,I5)')</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DO I = 2, UPBOUND</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; NUMBERS(I) = .TRUE.</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ENDDO</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; PRIMES = 0</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DO I = 2, UPBOUND</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; IF( NUMBERS(I) )THEN</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; PRIMES
= PRIMES + 1</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DO K
= I + I, UPBOUND, I</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp; NUMBERS(K) = .FALSE.</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ENDDO</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ENDIF</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ENDDO</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; PRINT FORM, 'The Number of Primes between 1 and ', UPBOUND,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;' are: ', PRIMES</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; END</TT>
<BR><BR>The goal of this program is to count the prime numbers between 1 and 10,000.&nbsp; It uses the famous<B> Sieve of
Eratosthenes</B> algorithm to accomplish this task.&nbsp; We will take you through the steps necessary to produce this result.
<H2 ID="16Mbit_OSD2__Building_and_Running_the_Sample_OSD2_1_x_Application"> 16-bit OS/2:&nbsp; Building and Running the Sample OS/2 1.x Application </H2>
<BR>To compile and link our example program which is stored in the file<TT> sieve.for</TT>, enter the following command:
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; [C:\]wfl -l=os2 sieve.for</TT>
<BR><BR>The typical messages that appear on the screen are shown in the following illustration.
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; [C:\]wfl -l=os2&nbsp; sieve.for</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Open Watcom F77/16 Compile and Link Utility</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Copyright (c) 2002-2019 the Open Watcom Contributors. All Rights Reserved.</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Portions Copyright (c) 1990-2002 Sybase, Inc. All Rights Reserved.</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Source code is available under the Sybase Open Watcom Public License.</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; See http://www.openwatcom.org/ for details.</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; wfc sieve.for </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Open Watcom FORTRAN 77/16 Optimizing Compiler</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Copyright (c) 2002-2019 the Open Watcom Contributors. All Rights Reserved.</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Portions Copyright (c) 1984-2002 Sybase, Inc. All Rights Reserved.</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Source code is available under the Sybase Open Watcom Public License.</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; See http://www.openwatcom.org/ for details.</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; sieve.for: 21 statements, 311 bytes, 6 extensions, 0 warnings, 0 errors</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Open Watcom Linker</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Copyright (c) 2002-2019 the Open Watcom Contributors. All Rights Reserved.</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Portions Copyright (c) 1985-2002 Sybase, Inc. All Rights Reserved.</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Source code is available under the Sybase Open Watcom Public License.</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; See http://www.openwatcom.org/ for details.</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; loading object files</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; searching libraries</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; creating an OS/2 16-bit executable</TT>
<BR><BR>Provided that no errors were encountered during the compile or link phases, the &quot;sieve&quot; program may now
be run.
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; [C:\]sieve</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; The Number of Primes between 1 and 10000 are:&nbsp; 1229</TT>
<BR><BR>If you examine the current directory, you will find that two files have been created.&nbsp; These are<TT> sieve.obj</TT>
(the result of compiling<TT> sieve.for</TT>) and<TT> sieve.exe</TT> (the result of linking<TT> sieve.obj</TT> with the appropriate
Open Watcom FORTRAN 77 libraries).&nbsp; It is<TT> sieve.exe</TT> that is run by OS/2 when you enter the &quot;sieve&quot;
command.
<H2 ID="16Mbit_OSD2__Debugging_the_Sample_OSD2_1_x_Application"> 16-bit OS/2:&nbsp; Debugging the Sample OS/2 1.x Application </H2>
<BR>Let us assume that you wish to debug your application in order to locate an error in programming.&nbsp; In the previous
section, the &quot;sieve&quot; program was compiled with default compile and link options.&nbsp; When debugging an application,
it is useful to refer to the symbolic names of routines and variables.&nbsp; It is also convenient to debug at the source
line level rather than the machine language level.&nbsp; To do this, we must direct both the compiler and linker to include
additional debugging information in the object and executable files.&nbsp; Using the <TT> WFL</TT> command, this is fairly
straightforward.&nbsp; <TT> WFL</TT> recognizes the Open Watcom F77 compiler &quot;debug&quot; options and will create the
appropriate debug directives for the Open Watcom Linker.
<BR><BR>For example, to compile and link the &quot;sieve&quot; program with debugging information, the following command may
be issued.
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; [C:\]wfl -l=os2 -d2 sieve.for</TT>
<BR><BR>The typical messages that appear on the screen are shown in the following illustration.
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; [C:\]wfl -l=os2&nbsp; -d2 sieve.for</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Open Watcom F77/16 Compile and Link Utility</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Copyright (c) 2002-2019 the Open Watcom Contributors. All Rights Reserved.</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Portions Copyright (c) 1990-2002 Sybase, Inc. All Rights Reserved.</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Source code is available under the Sybase Open Watcom Public License.</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; See http://www.openwatcom.org/ for details.</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; wfc sieve.for&nbsp; -d2</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Open Watcom FORTRAN 77/16 Optimizing Compiler</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Copyright (c) 2002-2019 the Open Watcom Contributors. All Rights Reserved.</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Portions Copyright (c) 1984-2002 Sybase, Inc. All Rights Reserved.</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Source code is available under the Sybase Open Watcom Public License.</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; See http://www.openwatcom.org/ for details.</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; sieve.for: 21 statements, 392 bytes, 6 extensions, 0 warnings, 0 errors</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Open Watcom Linker</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Copyright (c) 2002-2019 the Open Watcom Contributors. All Rights Reserved.</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Portions Copyright (c) 1985-2002 Sybase, Inc. All Rights Reserved.</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Source code is available under the Sybase Open Watcom Public License.</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; See http://www.openwatcom.org/ for details.</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; loading object files</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; searching libraries</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; creating an OS/2 16-bit executable</TT>
<BR><BR>The &quot;d2&quot; option requests the maximum amount of debugging information that can be provided by the Open Watcom
F77 compiler.&nbsp; <TT> WFL</TT> will make sure that this debugging information is included in the executable file that is
produced by the linker.
<BR><BR>The &quot;bytes&quot; value is larger than in the previous example since selection of the &quot;d2&quot; option results
in fewer code optimizations by default.&nbsp; You can request more optimization by specifying the appropriate options.&nbsp;
However, you do so at the risk of making it more difficult for yourself to determine the relationship between the object code
and the original source language code.
<BR><BR>For OS/2, you should also include the<TT> BINP\DLL</TT> directory in the &quot;LIBPATH&quot; directive of the system
configuration file<TT> CONFIG.SYS.</TT>&nbsp; It contains the Open Watcom Debugger Dynamic Link Libraries (DLLs).
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; libpath=c:\watcom\binp\dll</TT>
<BR><BR>To request the Open Watcom Debugger to assist in debugging the application, the following command may be issued.
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; [C:\]wd sieve</TT>
<BR><BR>It would be too ambitious to describe the debugger in this introductory chapter so we refer you to the book entitled<B><I>
Open Watcom Debugger User's Guide.</I></B>
<H1 ID="32Mbit_OSD2__Creating_32Mbit_OSD2_Applications"> 32-bit OS/2:&nbsp; Creating 32-bit OS/2 Applications </H1>
<BR>An OS/2 application can be one of the following; a fullscreen application, a PM-compatible application, or a Presentation
Manager application.&nbsp; A fullscreen application runs in its own screen group.&nbsp; A PM-compatible application will run
in an OS/2 fullscreen environment or in a window in the Presentation Manager screen group but does not take direct advantage
of menus, mouse or other features available in the Presentation Manager.&nbsp; A Presentation Manager application has full
access to the complete set of user-interface tools such as menus, icons, scroll bars, etc.
<BR><BR>This chapter deals with the creation of OS/2 fullscreen applications.&nbsp; For information on creating Presentation
Manager applications, refer to the section entitled <A HREF="#OSD2__Programming_for_OSD2_Presentation_Manager">OS/2:&nbsp; Programming for OS/2 Presentation Manager</A>.
<BR><BR>We will illustrate the steps to creating 32-bit OS/2 applications by taking a small sample application and showing
you how to compile, link, run and debug it.
<H2 ID="32Mbit_OSD2__The_Sample_Application"> 32-bit OS/2:&nbsp; The Sample Application </H2>
<BR>To demonstrate the creation of 32-bit OS/2 applications using command-line oriented tools, we introduce a simple sample
program.&nbsp; For our example, we are going to use the &quot;sieve&quot; program.
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; * This program computes the prime numbers between 1 and 10,000</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; * using the Sieve of Eratosthenes algorithm.</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; IMPLICIT NONE</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; INTEGER UPBOUND</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; PARAMETER (UPBOUND=10000)</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; INTEGER I, K, PRIMES</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; LOGICAL*1 NUMBERS(2:UPBOUND)</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CHARACTER*11 FORM</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; PARAMETER (FORM='(A,I5,A,I5)')</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DO I = 2, UPBOUND</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; NUMBERS(I) = .TRUE.</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ENDDO</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; PRIMES = 0</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DO I = 2, UPBOUND</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; IF( NUMBERS(I) )THEN</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; PRIMES
= PRIMES + 1</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DO K
= I + I, UPBOUND, I</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp; NUMBERS(K) = .FALSE.</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ENDDO</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ENDIF</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ENDDO</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; PRINT FORM, 'The Number of Primes between 1 and ', UPBOUND,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;' are: ', PRIMES</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; END</TT>
<BR><BR>The goal of this program is to count the prime numbers between 1 and 10,000.&nbsp; It uses the famous<B> Sieve of
Eratosthenes</B> algorithm to accomplish this task.&nbsp; We will take you through the steps necessary to produce this result.
<H2 ID="32Mbit_OSD2__Building_and_Running_the_Sample_OSD2_Application"> 32-bit OS/2:&nbsp; Building and Running the Sample OS/2 Application </H2>
<BR>To compile and link our example program which is stored in the file<TT> sieve.for</TT>, enter the following command:
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; [C:\]wfl386 -l=os2v2 sieve.for</TT>
<BR><BR>The typical messages that appear on the screen are shown in the following illustration.
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; [C:\]wfl386 -l=os2v2 sieve.for</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Open Watcom F77/32 Compile and Link Utility</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Copyright (c) 2002-2019 the Open Watcom Contributors. All Rights Reserved.</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Portions Copyright (c) 1990-2002 Sybase, Inc. All Rights Reserved.</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Source code is available under the Sybase Open Watcom Public License.</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; See http://www.openwatcom.org/ for details.</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; wfc386 sieve.for </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Open Watcom FORTRAN 77/32 Optimizing Compiler</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Copyright (c) 2002-2019 the Open Watcom Contributors. All Rights Reserved.</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Portions Copyright (c) 1984-2002 Sybase, Inc. All Rights Reserved.</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Source code is available under the Sybase Open Watcom Public License.</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; See http://www.openwatcom.org/ for details.</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; sieve.for: 21 statements, 172 bytes, 6 extensions, 0 warnings, 0 errors</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Open Watcom Linker</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Copyright (c) 2002-2019 the Open Watcom Contributors. All Rights Reserved.</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Portions Copyright (c) 1985-2002 Sybase, Inc. All Rights Reserved.</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Source code is available under the Sybase Open Watcom Public License.</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; See http://www.openwatcom.org/ for details.</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; loading object files</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; searching libraries</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; creating an OS/2 32-bit executable</TT>
<BR><BR>Provided that no errors were encountered during the compile or link phases, the &quot;sieve&quot; program may now
be run.
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; [C:\]sieve</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; The Number of Primes between 1 and 10000 are:&nbsp; 1229</TT>
<BR><BR>If you examine the current directory, you will find that two files have been created.&nbsp; These are<TT> sieve.obj</TT>
(the result of compiling<TT> sieve.for</TT>) and<TT> sieve.exe</TT> (the result of linking<TT> sieve.obj</TT> with the appropriate
Open Watcom FORTRAN 77 libraries).&nbsp; It is<TT> sieve.exe</TT> that is run by OS/2 when you enter the &quot;sieve&quot;
command.
<H2 ID="32Mbit_OSD2__Debugging_the_Sample_OSD2_Application"> 32-bit OS/2:&nbsp; Debugging the Sample OS/2 Application </H2>
<BR>Let us assume that you wish to debug your application in order to locate an error in programming.&nbsp; In the previous
section, the &quot;sieve&quot; program was compiled with default compile and link options.&nbsp; When debugging an application,
it is useful to refer to the symbolic names of routines and variables.&nbsp; It is also convenient to debug at the source
line level rather than the machine language level.&nbsp; To do this, we must direct both the compiler and linker to include
additional debugging information in the object and executable files.&nbsp; Using the <TT> WFL386</TT> command, this is fairly
straightforward.&nbsp; <TT> WFL386</TT> recognizes the Open Watcom F77 compiler &quot;debug&quot; options and will create
the appropriate debug directives for the Open Watcom Linker.
<BR><BR>For example, to compile and link the &quot;sieve&quot; program with debugging information, the following command may
be issued.
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; [C:\]wfl386 -l=os2v2 -d2 sieve.for</TT>
<BR><BR>The typical messages that appear on the screen are shown in the following illustration.
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; [C:\]wfl386 -l=os2v2 -d2 sieve.for</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Open Watcom F77/32 Compile and Link Utility</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Copyright (c) 2002-2019 the Open Watcom Contributors. All Rights Reserved.</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Portions Copyright (c) 1990-2002 Sybase, Inc. All Rights Reserved.</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Source code is available under the Sybase Open Watcom Public License.</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; See http://www.openwatcom.org/ for details.</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; wfc386 sieve.for&nbsp; -d2</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Open Watcom FORTRAN 77/32 Optimizing Compiler</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Copyright (c) 2002-2019 the Open Watcom Contributors. All Rights Reserved.</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Portions Copyright (c) 1984-2002 Sybase, Inc. All Rights Reserved.</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Source code is available under the Sybase Open Watcom Public License.</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; See http://www.openwatcom.org/ for details.</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; sieve.for: 21 statements, 237 bytes, 6 extensions, 0 warnings, 0 errors</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Open Watcom Linker</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Copyright (c) 2002-2019 the Open Watcom Contributors. All Rights Reserved.</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Portions Copyright (c) 1985-2002 Sybase, Inc. All Rights Reserved.</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Source code is available under the Sybase Open Watcom Public License.</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; See http://www.openwatcom.org/ for details.</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; loading object files</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; searching libraries</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; creating an OS/2 32-bit executable</TT>
<BR><BR>The &quot;d2&quot; option requests the maximum amount of debugging information that can be provided by the Open Watcom
F77 compiler.&nbsp; <TT> WFL386</TT> will make sure that this debugging information is included in the executable file that
is produced by the linker.
<BR><BR>The &quot;bytes&quot; value is larger than in the previous example since selection of the &quot;d2&quot; option results
in fewer code optimizations by default.&nbsp; You can request more optimization by specifying the appropriate options.&nbsp;
However, you do so at the risk of making it more difficult for yourself to determine the relationship between the object code
and the original source language code.
<BR><BR>To request the Open Watcom Debugger to assist in debugging the application, the following command may be issued.
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; [C:\]wd sieve</TT>
<BR><BR>It would be too ambitious to describe the debugger in this introductory chapter so we refer you to the book entitled<B><I>
Open Watcom Debugger User's Guide.</I></B>
<H1 ID="OSD2__OSD2_2_x_MultiMthreaded_Applications"> OS/2:&nbsp; OS/2 2.x Multi-threaded Applications </H1>
<BR>This chapter describes how to create multi-threaded applications.&nbsp; A multi-threaded application is one whose tasks
are divided among several threads of execution.&nbsp; A process is an executing application and the resources it uses.&nbsp;
A thread is the smallest unit of execution within a process.&nbsp; Each thread has its own stack and a set of machine registers
and shares all resources with its parent process.&nbsp; The path of execution of one thread does not affect that of another;
each thread is an independent entity.
<BR><BR>Typically, an application has a single thread of execution.&nbsp; In this type of application, all tasks, once initiated,
are completed before the next task begins.&nbsp; In contrast, tasks in a multi-threaded application can be performed concurrently
since more than one thread is executing at once.&nbsp; For example, each thread may be designed to perform a separate task.
<H2 ID="OSD2__Programming_Considerations"> OS/2:&nbsp; Programming Considerations </H2>
<BR>Since a multi-threaded application consists of many threads of execution, there are a number of issues that you must consider.
<BR><BR>Since threads share the resources of its parent, it may be necessary to serialize access to these resources.&nbsp;
For example, if your application contains more than one thread of execution and each thread uses the <TT> PRINT</TT> statement
to display output to the console, it would be necessary for the I/O support routines to allow only one thread to use the <TT>
PRINT</TT> facility at any time.&nbsp; That is, once a thread issues a <TT> PRINT</TT> request, the I/O support routines should
ensure that no other thread displays information until all information for the initial thread has been displayed.
<H2 ID="OSD2__Creating_Threads"> OS/2:&nbsp; Creating Threads </H2>
<BR>Each application initially contains a single thread.&nbsp; The run-time libraries contain two functions that create and
terminate threads of execution.&nbsp; The function<TT> beginthread</TT> creates a thread of execution and the function<TT>
endthread</TT> ends a thread of execution.&nbsp; The function<TT> threadid</TT> can be used to determine the current thread
identifier.
<HR>
<BR><B><I>&nbsp; WARNING!</I></B>&nbsp; If any thread uses an I/O statement or calls an intrinsic function, you must use the<TT>
beginthread</TT> function to create the thread.&nbsp; Do not use the<TT> DosCreateThread</TT> API function.
<HR>
<H3 ID="OSD2__Creating_a_New_Thread"> OS/2:&nbsp; Creating a New Thread </H3>
<BR>The<TT> beginthread</TT> function creates a new thread.&nbsp; It is defined as follows.
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; integer function beginthread( start_address,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; stack_size )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; integer stack_size</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; end</TT>
<DL>
<DT>where
<DD><B>description</B>
<DT>start_address
<DD>is the address of the subroutine that will be called when the newly created thread is executed.&nbsp; When the thread returns
from that subroutine, the thread will be terminated.&nbsp; Note that a call to the<TT> endthread</TT> subroutine will also
terminate the thread.
<DT>stack_size
<DD>specifies the size of the stack to be allocated by the operating system for the new thread.&nbsp; The stack size should be
a multiple of 4K.
</DL>
<BR>If a new thread is successfully created, the thread identifier of the new thread is returned.&nbsp; Otherwise, a value
of -1 is returned.
<BR><BR>The include file<TT> thread.fi</TT> contains the definition of the<TT> beginthread</TT> function.
<H3 ID="OSD2__Terminating_the_Current_Thread"> OS/2:&nbsp; Terminating the Current Thread </H3>
<BR>The<TT> endthread</TT> subroutine terminates the current thread.&nbsp; It is defined as follows.
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; subroutine endthread()</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; end</TT>
<BR><BR>The include file<TT> thread.fi</TT> contains the definition of the<TT> endthread</TT> function.
<H3 ID="OSD2__Getting_the_Current_Thread_Identifier"> OS/2:&nbsp; Getting the Current Thread Identifier </H3>
<BR>The<TT> threadid</TT> function can be used to determine the current thread identifier.&nbsp; It is defined as follows.
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; integer function threadid()</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; end</TT>
<BR><BR>The include file<TT> thread.fi</TT> contains the definition of the<TT> threadid</TT> function.
<H2 ID="OSD2__A_MultiMthreaded_Example"> OS/2:&nbsp; A Multi-threaded Example </H2>
<BR>Let us create a simple multi-threaded application.&nbsp; The source code for this example can be found in<TT> \watcom\samples\fortran\os2.</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; * MTHREAD.FOR</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; *$pragma aux DosSleep parm( value ) [] caller</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; integer NumThreads</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; logical HoldThreads</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; common NumThreads, HoldThreads</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; integer STACK_SIZE</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; parameter (STACK_SIZE=32768)</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; integer NUM_THREADS</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; parameter (NUM_THREADS=5)</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; integer i, threadid, beginthread</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; external a_thread</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; print '(''main thread id = '', i4)', threadid()</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; NumThreads = 0</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; HoldThreads = .true.</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ! main thread counts as 1</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; do i = 2, NUM_THREADS</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if( beginthread( a_thread, STACK_SIZE
) .eq. -1 )then</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; print
'(''creation of thread'', i4, ''failed'')', i</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; NumThreads
= NumThreads + 1</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; end if</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; end do</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; HoldThreads = .false.</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; while( NumThreads .ne. 0 )do</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call DosSleep( 1 )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; end while</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; end</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; subroutine a_thread()</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; integer NumThreads</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; logical HoldThreads</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; common NumThreads, HoldThreads</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; integer threadid</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; while( HoldThreads )do</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call DosSleep( 1 )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; end while</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call DosEnterCritSec()</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; print '(''Hi from thread '', i4)', threadid()</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; NumThreads = NumThreads - 1</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call DosExitCritSec()</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call endthread()</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; end</TT>
<BR><BR><B>Note:</B>
<OL>
<LI>In the subroutine<TT> a_thread, DosEnterCritSec</TT> and<TT> DosExitCritSec</TT> are called when we modify the variable<TT>
NumThreads.</TT>&nbsp; This ensures that the action of extracting the value of<TT> NumThreads</TT> from memory, incrementing
the value, and storing the new result into memory, occurs without interruption.&nbsp; If these functions were not called,
it would be possible for two threads to extract the value of<TT> NumThreads</TT> from memory before an update occurred.
</OL>
<BR>Let us assume that the file<TT> mthread.for</TT> contains the above example.&nbsp; Before compiling the file, make sure
that the<B> WATCOM</B> environment variable is set to the directory in which you installed Open Watcom FORTRAN 77.&nbsp; Also,
the<B> FINCLUDE</B> environment variable must contain the<TT> \watcom\src\fortran\os2</TT> directory where &quot;\WATCOM&quot;
is the name of the directory in which you installed Open Watcom FORTRAN 77.
<BR><BR>We can now compile and link the application by issuing the following command.
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; [C:\]wfl386 -bm -l=os2v2 mthread</TT>
<BR><BR>The &quot;bm&quot; option must be specified since we are creating a multi-threaded application.&nbsp; If your multi-threaded
application contains more than one module, each module must be compiled using the &quot;bm&quot; switch.
<BR><BR>The &quot;l&quot; option specifies the target system for which the application is to be linked.&nbsp; The system name<TT>
os2v2</TT> is defined in the file<TT> wlsystem.lnk</TT> which is located in the &quot;BINW&quot; subdirectory of the directory
in which you installed Open Watcom FORTRAN 77.
<BR><BR>The multi-threaded application is now ready to be run.
<H2 ID="OSD2__Thread_Limits"> OS/2:&nbsp; Thread Limits </H2>
<BR>There is a limit to the number of threads an application can create under 16-bit OS/2.&nbsp; The default limit is 32.
&nbsp;This limit can be adjusted by defining the integer function<TT> __getmaxthreads</TT> which returns the new thread limit.
<BR><BR>Under 32-bit OS/2, there is no limit to the number of threads an application can create.&nbsp; However, due to the
way in which multiple threads are supported in the Open Watcom libraries, there is a small performance penalty once the number
of threads exceeds the default limit of 32 (this number includes the initial thread).&nbsp; If you are creating more than
32 threads and wish to avoid this performance penalty, you can redefine the threshold value of 32.&nbsp; You can statically
initialize the global variable<TT> __MaxThreads.</TT>
<BR><BR>This limit can be adjusted by defining the integer function<TT> __getmaxthreads</TT> which returns the new thread
limit.&nbsp; By defining<TT> __getmaxthreads</TT> as follows, the new threshold value will be set to 48.
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; integer function __getmaxthreads()</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; __getmaxthreads = 48</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; end</TT>
<BR><BR>This version of<TT> __getmaxthreads</TT> will replace the default function that is included in the run-time library.
&nbsp;The default function simply returns the current value of the internal variable<TT> __MaxThreads.</TT>&nbsp; Your version
of this function will return a new value for this variable.&nbsp; Internally, the run-time system executes code similar to
the following:
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; __MaxThreads = __getmaxthreads()</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .</TT>
<BR><BR>Thus, the default<TT> __getmaxthreads</TT> function does not alter the value of<TT> __MaxThreads</TT> but your version
will.
<H1 ID="OSD2__OSD2_2_x_Dynamic_Link_Libraries"> OS/2:&nbsp; OS/2 2.x Dynamic Link Libraries </H1>
<BR>A dynamic link library, like a standard library, is a library of functions.&nbsp; When an application uses functions from
a standard library, the library functions referenced by the application become part of the executable module.&nbsp; This form
of linking is called static linking.&nbsp; When an application uses functions from a dynamic link library, the library functions
referenced by the application are not included in the executable module.&nbsp; Instead, the executable module contains references
to these functions which are resolved when the application is loaded.&nbsp; This form of linking is called dynamic linking.
<BR><BR>Let us consider some of the advantages of using dynamic link libraries over standard libraries.
<OL>
<LI>Functions in dynamic link libraries are not linked into your program.&nbsp; Only references to the functions in dynamic
link libraries are placed in the program module.&nbsp; These references are called import definitions.&nbsp; As a result,
the linking time is reduced and disk space is saved.&nbsp; If many applications reference the same dynamic link library, the
saving in disk space can be significant.
<LI>Since program modules only reference dynamic link libraries and do not contain the actual executable code, a dynamic link
library can be updated without re-linking your application.&nbsp; When your application is executed, it will use the updated
version of the dynamic link library.
<LI>Dynamic link libraries also allow sharing of code and data between the applications that use them.&nbsp; If many applications
that use the same dynamic link library are executing concurrently, the sharing of code and data segments improves memory utilization.
</OL>
<H2 ID="OSD2__Creating_Dynamic_Link_Libraries"> OS/2:&nbsp; Creating Dynamic Link Libraries </H2>
<BR>Once you have developed the source for a library of functions, a number of steps are required to create a dynamic link
library containing those functions.
<BR><BR>First, you must compile your source using the &quot;bd&quot; compiler option.&nbsp; This option tells the compiler
that the module you are compiling is part of a dynamic link library.&nbsp; Once you have successfully compiled your source,
you must create a linker directive file that describes the attributes of your dynamic link library.&nbsp; The following lists
the most common linker directives required to create a dynamic link library.
<OL>
<LI>The &quot;SYSTEM&quot; directive is used to specify that a dynamic link library is to be created.
<LI>The &quot;EXPORT&quot; directive is used to to specify which functions in the dynamic link library are to be exported.
<LI>The &quot;OPTION&quot; directive is used to specify attributes such as the name of the dynamic link library and how to
allocate the automatic data segment when the dynamic link library is referenced.
<LI>The &quot;SEGMENT&quot; directive is used to specify attributes of segments.&nbsp; For example, a segment may be read-only
or read-write.
</OL>
<BR>Once the dynamic link library is created, you must allow access to the dynamic link library to client applications that
wish to use it.&nbsp; This can be done by creating an import library for the dynamic link library or creating a linker directive
file that contains &quot;IMPORT&quot; directives for each of the entry points in the dynamic link library.
<H2 ID="OSD2__Creating_a_Sample_Dynamic_Link_Library"> OS/2:&nbsp; Creating a Sample Dynamic Link Library </H2>
<BR>Let us now create a dynamic link library using the following example.&nbsp; The source code for this example can be found
in<TT> \watcom\samples\fortran\os2\dll.</TT>&nbsp; Unlike applications developed in the C or C++ language, the FORTRAN 77
developer must not provide a <TT> LibMain</TT> entry point.&nbsp; This entry point is already defined in the Open Watcom FORTRAN
77 run-time libraries.&nbsp; The run-time system's <TT> LibMain</TT> provides for the proper initialization of the FORTRAN
77 run-time system and includes hooks to call developer-written process attach/detach and thread attach/detach routines.&nbsp;
These routines are optional but we show skeleton versions in the following example so that you can develop your own if required.
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; * DLLSAMP.FOR</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; integer function __fdll_initialize_()</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; *&nbsp;&nbsp;&nbsp;&nbsp; Called from LibMain during &quot;DLL PROCESS ATTACH&quot;</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; *&nbsp;&nbsp;&nbsp;&nbsp; do process initialization</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; print *, 'Hi from process attach'</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; *&nbsp;&nbsp;&nbsp;&nbsp; returning 0 indicates failure</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; __fdll_initialize_ = 1</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; end</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; integer function __fdll_terminate_()</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; *&nbsp;&nbsp;&nbsp;&nbsp; Called from LibMain during &quot;DLL PROCESS DETACH&quot;</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; *&nbsp;&nbsp;&nbsp;&nbsp; do process cleanup</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; print *, 'Hi from process detach'</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; *&nbsp;&nbsp;&nbsp;&nbsp; returning 0 indicates failure</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; __fdll_terminate_ = 1</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; end</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; subroutine dll_entry_1()</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; print *, 'Hi from dll entry #1'</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; end</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; subroutine dll_entry_2()</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; print *, 'Hi from dll entry #2'</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; end</TT>
<BR><BR>Assume the above example is contained in the file<TT> dllsamp.for.</TT>&nbsp; We can compile the file using the following
command.&nbsp; Note that we must specify the &quot;bd&quot; compiler option.
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; [C:\]wfc386 -bd dllsamp</TT>
<BR><BR>Before we can link our example, we must create a linker directive file that describes the attributes and entry points
of our dynamic link library.&nbsp; The following is a linker directive file, called<TT> dllsamp.lnk,</TT> that can be used
to create the dynamic link library.
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; system os2v2 dll initinstance terminstance</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; option manyautodata</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; export DLL_ENTRY_1</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; export DLL_ENTRY_2</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; file dllsamp</TT>
<BR><BR><B>Notes:</B>
<OL>
<LI>The &quot;SYSTEM&quot; directive specifies that we are creating a 32-bit OS/2 dynamic link library.
<LI>The &quot;MANYAUTODATA&quot; option specifies that the automatic data segment is allocated for every instance of the dynamic
link library.&nbsp; This option must be specified only for a dynamic link library that uses the Open Watcom FORTRAN 77 run-time
libraries.&nbsp; If the Open Watcom FORTRAN 77 run-time libraries are not used, this option is not required.&nbsp; Our example
does use the Open Watcom FORTRAN 77 run-time libraries so we must specify the &quot;MANYAUTODATA&quot; option.
<BR><BR>As was just mentioned, when a dynamic link library uses the Open Watcom FORTRAN 77 run-time libraries, an automatic
data segment is created each time a process accesses the dynamic link library.&nbsp; For this reason, initialization code
must be executed when a process accesses the dynamic link library for the first time.&nbsp; To achieve this, &quot;INITINSTANCE&quot;
must be specified in the &quot;SYSTEM&quot; directive.&nbsp; Similarly, &quot;TERMINSTANCE&quot; must be specified so that
the termination code is executed when a process has completed its access to the dynamic link library.&nbsp; If the Open Watcom
FORTRAN 77 run-time libraries are not used, these options are not required.
<LI>The &quot;EXPORT&quot; directive specifies the entry points into the dynamic link library.&nbsp; Note that in Open Watcom
FORTRAN 77, names of all symbols are uppercased.&nbsp; Regardless of the case used in source files, linker directives must
use uppercased symbol names.&nbsp; The linker is case sensitive by default, although the &quot;OP NOCASEEXACT&quot; directive
may be used to override this.
</OL>
<BR>We can now create our dynamic link library by issuing the following command.
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; [C:\]wlink @dllsamp</TT>
<BR><BR>A file called<TT> dllsamp.dll</TT> will be created.
<H2 ID="OSD2__Using_Dynamic_Link_Libraries"> OS/2:&nbsp; Using Dynamic Link Libraries </H2>
<BR>Once we have created a dynamic link library, we must allow other applications to access the functions available in the
dynamic link library.&nbsp; There are two ways to achieve this.
<BR><BR>The first method is to create a linker directive file which contains an &quot;IMPORT&quot; directive for all entry
points in the dynamic link library.&nbsp; The &quot;IMPORT&quot; directive provides the name of the entry point and the name
of the dynamic link library.&nbsp; When creating an application that references a function in the dynamic link library, this
linker directive file would be included as part of the linking process that created the application.
<BR><BR>The second method is to use import libraries.&nbsp; An import library is a standard library that is created from a
dynamic link library by using the Open Watcom Library Manager.&nbsp; It contains object modules that describe the entry points
in a dynamic link library.&nbsp; The resulting import library can then be specified in a &quot;LIBRARY&quot; directive in
the same way one would specify a standard library.
<BR><BR>Using an import library is the preferred method of providing references to functions in dynamic link libraries.&nbsp;
When a dynamic link library is modified, typically the import library corresponding to the modified dynamic link library is
updated to reflect the changes.&nbsp; Hence, any directive file that specifies the import library in a &quot;LIBRARY&quot;
directive need not be modified.&nbsp; However, if you are using &quot;IMPORT&quot; directives, you may have to modify the
&quot;IMPORT&quot; directives to reflect the changes in the dynamic link library.
<BR><BR>Let us create an import library for our sample dynamic link library we created in the previous section.&nbsp; We do
this by issuing the following command.
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; [C:\]wlib dllsamp +dllsamp.dll</TT>
<BR><BR>A standard library called<TT> dllsamp.lib</TT> will be created.
<BR><BR>Suppose the following sample program, contained in the file<TT> dlltest.for,</TT> calls the functions from our sample
dynamic link library.
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; * DLLTEST.FOR</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call dll_entry_1()</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call dll_entry_2()</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; end</TT>
<BR><BR>We can compile and link our sample application by issuing the following command.
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; [C:\]wfl386 -l=os2v2 dlltest dllsamp.lib</TT>
<BR><BR>If we had created a linker directive file of &quot;IMPORT&quot; directives instead of an import library for the dynamic
link library, the linker directive file, say<TT> dllimps.lnk,</TT> would be as follows.
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; import DLL_ENTRY_1 dllsamp</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; import DLL_ENTRY_2 dllsamp</TT>
<BR><BR>To compile and link our sample application, we would issue the following command.
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; [C:\]wfl386 -l=os2v2 dlltest -&quot;@dllimps&quot;</TT>
<H2 ID="OSD2__The_Dynamic_Link_Library_Data_Area"> OS/2:&nbsp; The Dynamic Link Library Data Area </H2>
<BR>The Open Watcom FORTRAN 77 32-bit run-time library does not support the general case operation of DLLs in an execution
environment where there is only one instance of the DATA segment (DGROUP) for that DLL.
<BR><BR>There are two cases that can lead to a DLL executing with only one instance of the DGROUP.
<OL>
<LI>DLLs linked for 32-bit OS/2 without the MANYAUTODATA option.
<LI>DLLs linked for the Win32 API and executing under Win32s.
</OL>
<BR>In these cases the run-time library startup code detects that there is only one instance of the DGROUP when a second process
attempts to attach to the DLL.&nbsp; At that point, it issues a diagnostic for the user and then notifies the operating system
that the second process cannot attach to the DLL.
<BR><BR>Developers who require DLLs to operate when there is only one instance of the DGROUP can suppress the function which
issues the diagnostic and notifies the operating system that the second process cannot attach to the DLL.
<BR><BR>Doing so requires good behaviour on the part of processes attaching to the DLL.&nbsp; This good behaviour consists
primarily of ensuring that the first process to attach to the DLL is also the last process to detach from the DLL thereby
ensuring that the DATA segment is not released back to the free memory pool.
<BR><BR>To suppress the function which issues the diagnostic and notifies the operating system that the second process cannot
attach to the DLL, the developer must provide a replacement entry point with the following prototype:
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; int __disallow_single_dgroup( int );</TT>
<BR><BR>This function should return zero to indicate that the detected single copy of the DATA segment is allowed.
<H2 ID="OSD2__Dynamic_Link_Library_InitializationDTermination"> OS/2:&nbsp; Dynamic Link Library Initialization/Termination </H2>
<BR>Each dynamic link library (DLL) has an initialization and termination routine associated with it.&nbsp; The initialization
routine can either be called the first time any process accesses the DLL (&quot;INITGLOBAL&quot; is specified at link time)
or each time a process accesses the DLL (&quot;INITINSTANCE&quot; is specified at link time).&nbsp; Similarly, the termination
routine can either be called when all processes have completed their access of the DLL (&quot;TERMGLOBAL&quot; is specified
at link time) or each time a process completes its access of the DLL (&quot;TERMINSTANCE&quot; is specified at link time).
<BR><BR>For a DLL that uses the FORTRAN 77 run-time libraries, initialization and termination of the FORTRAN 77 run-time environment
is performed automatically.&nbsp; It is also possible for a DLL to do its own special initialization and termination process.
<BR><BR>The FORTRAN 77 run-time environment provides a method for calling user-written DLL initialization and termination
code.&nbsp; The <TT> __fdll_initialize_</TT> routine is called for DLL process initialization.&nbsp; The <TT> __fdll_terminate_</TT>
routine is called for DLL process termination.&nbsp; Default stub versions of these routines are included in the run-time
library.&nbsp; If you wish to perform additional initialization/termination processing that is specific to your dynamic link
library, you may write your own versions of these routines.
<BR><BR>Once the FORTRAN 77 run-time environment is initialized, the routine<TT> __fdll_initialize_</TT> is called.&nbsp;
After the FORTRAN 77 run-time environment is terminated, the routine<TT> __fdll_terminate_</TT> is called.&nbsp; This last
point is important since it means that you cannot do any run-time calls in the termination routine.
<BR><BR>The initialization and termination routines return an integer.&nbsp; A value of 0 indicates failure; a value of 1
indicates success.&nbsp; The following example illustrates sample initialization/termination routines.
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; * DLLINIT.FOR</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; integer function __fdll_initialize_()</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; integer __fdll_terminate_, dll_entry</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; integer WORKING_SIZE</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; parameter ( WORKING_SIZE = 16*1024 )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; integer ierr, WorkingStorage</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; dimension WorkingStorage(:)</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; allocate( WorkingStorage(WORKING_SIZE), stat=ierr
)</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if( ierr .eq. 0 )then</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; __fdll_initialize_ = 1</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; __fdll_initialize_ = 0</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; endif</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; entry __fdll_terminate_()</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; * Note: no run-time calls allowed under OS/2 Warp</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; deallocate( WorkingStorage )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; __fdll_terminate_ = 1</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; entry dll_entry()</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ! use WorkingStorage</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; end</TT>
<BR><BR>In the above example, the process initialization routine allocates storage that the dynamic link library needs, the
routine<TT> dll_entry</TT> uses the storage, and the process termination routine frees the storage allocated in the initialization
routine.
<H1 ID="OSD2__Programming_for_OSD2_Presentation_Manager"> OS/2:&nbsp; Programming for OS/2 Presentation Manager </H1>
<BR>Basically, there are two classes of FORTRAN 77 applications that can run in a windowed environment.
<BR><BR>The first are those FORTRAN 77 applications that do not use any of the Presentation Manager API functions; they are
strictly FORTRAN 77 applications that do not rely on the features of a particular operating system.
<BR><BR>The second class of FORTRAN 77 applications are those that actually call Presentation Manager API functions directly.
&nbsp;These are applications that have been tailored for the Presentation Manager operating environment.
<BR><BR>It is assumed that the reader is familiar with the concepts of Presentation Manager programming.
<H2 ID="OSD2__Porting_Existing_FORTRAN_77_Applications"> OS/2:&nbsp; Porting Existing FORTRAN 77 Applications </H2>
<BR>Suppose you have a set of FORTRAN 77 applications that previously ran under DOS and you now wish to run them under OS/2.
&nbsp;To achieve this, simply recompile your application and link with the appropriate libraries.&nbsp; Depending on the method
with which you linked your application, it can run in an OS/2 fullscreen environment, a PM-compatible window, or as a Presentation
Manager application.&nbsp; An OS/2 fullscreen application runs in its own screen group.&nbsp; A PM-compatible application
will run in an OS/2 fullscreen environment or in a window in the Presentation Manager screen group but does not take direct
advantage of menus, mouse or other features available in the Presentation Manager.&nbsp; A Presentation Manager application
has full access to the complete set of user-interface tools such as menus, icons, scroll bars, etc.&nbsp; However, porting
a console oriented application to Presentation Manager often requires significant effort and a substantial redesign of the
application.
<H3 ID="OSD2__An_Example"> OS/2:&nbsp; An Example </H3>
<BR>Very little effort is required to port an existing FORTRAN 77 application to OS/2.&nbsp; Let us try to run the following
sample program (contained in the file<TT> hello.for</TT>).
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; print *, 'Hello world!'</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; end</TT>
<BR><BR>First we must compile the file<TT> hello.for</TT> by issuing the following command.
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; [C:\]wfc386 hello</TT>
<BR><BR>Once we have successfully compiled the file, we can link it by issuing the following command.
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; [C:\]wlink sys os2v2 file hello</TT>
<BR><BR>It is also possible to compile and link in one step, by issuing the following command.
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; [C:\]wfl386 -l=os2v2 hello</TT>
<BR><BR>This will create a PM-compatible application.&nbsp; If you wish to create a fullscreen application, link with the
following command.
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; [C:\]wlink sys os2v2 fullscreen file hello</TT>
<H2 ID="OSD2__Calling_Presentation_Manager_API_Functions"> OS/2:&nbsp; Calling Presentation Manager API Functions </H2>
<BR>It is also possible for a FORTRAN 77 application to create its own windowing environment.&nbsp; This is achieved by calling
PM API functions directly from your FORTRAN 77 program.&nbsp; The techniques for developing these applications can be found
in the<B><I> OS/2 Technical Library.</I></B>
<BR><BR>A number of FORTRAN 77 include files (files with extension<TT> .fi</TT> or<TT> .fap</TT>) are provided which define
Presentation Manager data structures and constants.&nbsp; They are located in the<TT> \watcom\src\fortran\os2</TT> directory.
&nbsp;These include files are equivalent to the C header files that are available with the IBM OS/2 Developer's Toolkit.
<BR><BR>A sample FORTRAN 77 Presentation Manager application is also located in the<TT> \watcom\samples\fortran\os2</TT> directory.
&nbsp;It is contained in the files<TT> fshapes.for</TT> and<TT> fshapes.fi.</TT>&nbsp; The file<TT> fshapes.for</TT> contains
the following.
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; c$define INCL_WINFRAMEMGR</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; c$define INCL_WINMESSAGEMGR</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; c$define INCL_WINWINDOWMGR</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; c$define INCL_WINTIMER</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; c$define INCL_GPIPRIMITIVES</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; c$include os2.fap</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; program fshapes</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; integer&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp; style</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; record /QMSG/&nbsp;&nbsp; qmsg</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; character*7&nbsp;&nbsp;&nbsp;&nbsp; watcom</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; parameter&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
(watcom='WATCOM'c)</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; include 'fshapes.fi'</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; AnchorBlock = WinInitialize( 0 )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if( AnchorBlock .eq. 0 ) stop</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; hMessageQueue = WinCreateMsgQueue( AnchorBlock,
0 )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if( hMessageQueue .eq. 0 ) stop</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if( WinRegisterClass( AnchorBlock, watcom,
MainDriver,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; +&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CS_SIZEREDRAW, 0 ) .eq. 0 ) stop</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; style = FCF_TITLEBAR .or. FCF_SYSMENU .or.
FCF_SIZEBORDER .or.</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; +&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; FCF_MINMAX
.or. FCF_SHELLPOSITION .or. FCF_TASKLIST</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; FrameHandle = WinCreateStdWindow( HWND_DESKTOP,
WS_VISIBLE,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; +&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp; style, watcom,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; +&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp; char(0), 0, NULL,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; +&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp; 0, WinHandle )</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if( FrameHandle .eq. 0 ) stop</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; while( WinGetMsg( AnchorBlock, qmsg,
NULL, 0, 0 ) ) do</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call WinDispatchMsg(
AnchorBlock, qmsg )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; end while</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call WinDestroyWindow( FrameHandle )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call WinDestroyMsgQueue( hMessageQueue )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call WinTerminate( AnchorBlock )</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; end</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; function MainDriver( hwnd, msg, mp1,
mp2 )</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; integer hwnd</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; integer msg</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; integer mp1</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; integer mp2</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; include 'fshapes.fi'</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; integer&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp; ps</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; record /RECTL/&nbsp; rcl</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; select case ( msg )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; case ( WM_CREATE )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; WinHandle = hwnd</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call WinStartTimer(
AnchorBlock, WinHandle, 1, 150 )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; case ( WM_TIMER )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call DrawEllipse()</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; MainDriver = 0</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; case ( WM_SIZE )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; SizeX = SHORT1FROMMP(
mp2 )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; SizeY = SHORT2FROMMP(
mp2 )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; MainDriver = 0</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; case ( WM_PAINT )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ps = WinBeginPaint(
WinHandle, NULL, NULL_POINTER )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call WinQueryWindowRect(
WinHandle, rcl )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call WinFillRect(
ps, rcl, CLR_WHITE )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call WinEndPaint(
ps )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; MainDriver = 0</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; end select</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; MainDriver = WinDefWindowProc( WinHandle,
msg, mp1, mp2 )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; end</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; subroutine DrawEllipse</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; record /POINTL/&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; ptl</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; integer&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ps</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; integer&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Odd /0/</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; integer&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; parm1</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; integer&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; parm2</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; include 'fshapes.fi'</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ps = WinGetPS( WinHandle )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ptl.x = Random( SizeX )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ptl.y = Random( SizeY )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call GpiMove( ps, ptl )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ptl.x = Random( SizeX )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ptl.y = Random( SizeY )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; parm1 = Random( 32767 )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; parm2 = Random( 32767 )</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if( Random( 10 ) .ge. 5 ) then</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; execute NewColor</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call GpiBox( ps,
DRO_FILL, ptl, 0, 0 )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; execute NewColor</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call GpiBox( ps,
DRO_OUTLINE, ptl, 0, 0 )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; execute NewColor</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call GpiBox( ps,
DRO_FILL, ptl, parm1, parm2 )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; execute NewColor</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call GpiBox( ps,
DRO_OUTLINE, ptl, parm1, parm2 )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; end if</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Odd = Odd + 1</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Odd = Odd .and. 1</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call WinReleasePS( ps )</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; remote block NewColor</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call GpiSetColor( ps, Random( 15 ) + 1 )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; end block</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; end</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; integer function Random( high )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; integer&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp; high</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; external&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp; urand</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; real&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp; urand</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; integer&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp; seed /75347/</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Random = urand( seed ) * high</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; end</TT>
<BR><BR>The include file<TT> fshapes.fi</TT> contains the following.
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; include 'os2.fi'</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; integer&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp; SizeX</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; integer&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp; SizeY</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; integer&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp; FrameHandle</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; integer&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp; WinHandle</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; integer&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp; hMessageQueue</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; integer&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp; AnchorBlock</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; common /globals/</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; +&nbsp; SizeX,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; +&nbsp; SizeY,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; +&nbsp; FrameHandle,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; +&nbsp; WinHandle,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; +&nbsp; hMessageQueue,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; +&nbsp; AnchorBlock</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; external&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Random</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; integer&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Random</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; external&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; MainDriver</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; integer&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; MainDriver</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; c$pragma aux (FNWP)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
MainDriver</TT>
<BR><BR><B>Notes:</B>
<OL>
<LI>Include files with extension<TT> .fap</TT> define the calling conventions for each of the OS/2 API functions.&nbsp; These
files must be included at the top of each FORTRAN 77 source module.
<LI>Include files with extension<TT> .fi</TT> define the data structures and constants used by the OS/2 API functions.&nbsp;
These files must be included in each subprogram that requires them.
<LI>Each call-back function (i.e.&nbsp; window procedure) must be defined using the following pragma.
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; c$pragma aux (FNWP) WindowProc</TT>
<LI>The include file<TT> os2.fap</TT> is included at the beginning of the source file and<TT> os2.fi</TT> is included in each
subprogram.&nbsp; Also note that a number of macros were defined at the top of the file.&nbsp; By defining these macros, only
those components of the OS/2 API required by the module will be compiled.
</OL>
<BR>You can compile, link and run this demonstration by issuing the following commands.
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; [C:\]set finclude=\watcom\src\fortran\os2</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; [C:\]wfl386 -l=os2v2_pm fshapes</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; [C:\]fshapes</TT>
<H1 ID="Creating_NetWare_386_NLM_Applications"> Creating NetWare 386 NLM Applications </H1>
<BR>Open Watcom FORTRAN 77 supports version 4.0 of the Netware 386 API.&nbsp; We include the following components:
<DL>
<DT>header files
<DD>Header files for the Netware 4.0 API are located in the<TT> \WATCOM\NOVH</TT> directory.
<DT>import libraries
<DD>Import libraries for the Netware 4.0 API are located in the<TT> \WATCOM\NOVI</TT> directory.
<DT>libraries
<DD>The FORTRAN 77 libraries for Netware 4.0 is located in the<TT> \WATCOM\LIB386</TT> and<TT> \WATCOM\LIB386\NETWARE</TT> directories.
<DT>debug servers
<DD>Servers for remote debugging of Netware 4.0 NLMs are located in the<TT> \WATCOM\NLM</TT> directory.&nbsp; The same directory
also contains the Open Watcom Execution Sampler for NLMs.
</DL>
<BR>Applications built for version 4.0 will run on 4.1.&nbsp; We do not include support for any API specific to version 4.1.
&nbsp;Netware developers must use the support included with Open Watcom FORTRAN 77 version 10.0 or greater since the version
supplied by Novell only works with Open Watcom FORTRAN 77 version 9.5.&nbsp; Netware 4.1 support requires modification to
the header files supplied by Novell.&nbsp; Contact Novell for more information.
<BR><BR>The following special notes apply to developing applications for NetWare.
<OL>
<LI>You must compile your source files with the small memory model option (&quot;ms&quot;).
<LI>You must compile your source files with the stack-based calling convention option (&quot;sc&quot;).
<LI>You must specify
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; system NETWARE</TT>
<BR><BR>when linking an NLM.&nbsp; This is automatic if you are using WFL386 and the &quot;-l=NETWARE&quot; option.
</OL>
<H1 ID="InterMLanguage_calls__C_and_FORTRAN"> Inter-Language calls:&nbsp; C and FORTRAN </H1>
<BR>The purpose of this chapter is to anticipate common questions about mixed-language development using Open Watcom C/C++
and Open Watcom FORTRAN 77.
<BR><BR>The following topics are discussed in this chapter:
<UL>
<LI>Symbol Naming Convention
<LI>Argument Passing Convention
<LI>Memory Model Compatibility
<LI>Integer Type Compatibility
<LI>How do I pass integers from C to a FORTRAN function?
<LI>How do I pass integers from FORTRAN to a C function?
<LI>How do I pass a string from a C function to FORTRAN?
<LI>How do I pass a string from FORTRAN to a C function?
<LI>How do I access a FORTRAN common block from within C?
<LI>How do I call a C function that accepts a variable number of arguments?
</UL>
<H2 ID="Symbol_Naming_Convention"> Symbol Naming Convention </H2>
<BR>The symbol naming convention describes how a symbol in source form is mapped to its object form.&nbsp; Because of this
mapping, the name generated in the object file may differ from its original source form.
<BR><BR>Default symbol naming conventions vary between compilers.&nbsp; Open Watcom C/C++ prefixes an underscore character
to the beginning of variable names and appends an underscore to the end of function names during the compilation process.
&nbsp;Open Watcom FORTRAN 77 converts symbols to upper case.&nbsp; Auxiliary pragmas can be used to resolve this inconsistency.
<BR><BR>Pragmas are compiler directives which can provide several capabilities, one of which is to provide information used
for code generation.&nbsp; When calling a FORTRAN subprogram from C, we want to instruct the compiler NOT to append the underscore
at the end of the function name and to convert the name to upper case.&nbsp; This is achieved by using the following C auxiliary
pragma:
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; #pragma aux ftnname &quot;^&quot;;</TT>
<BR><BR>The &quot;^&quot; character tells the compiler to convert the symbol name &quot;ftnname&quot; to upper case; no underscore
character will be appended.&nbsp; This solves potential linker problems with &quot;ftnname&quot; since (by C convention) the
linker would attempt to resolve a reference to &quot;ftnname_&quot;.
<BR><BR>When calling C functions from FORTRAN, we need to instruct the compiler to add the underscore at the end of the function
name, and to convert the name to lower case.&nbsp; Since the FORTRAN compiler automatically converts identifiers to uppercase,
it is necessary to force the compiler to emit an equivalent lowercase name.&nbsp; Both of these things can be done with the
following FORTRAN auxiliary pragma:
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; *$pragma aux CNAME &quot;!_&quot;</TT>
<BR><BR>There is another less convenient way to do this as shown in the following:
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; *$pragma aux CNAME &quot;cname_&quot;</TT>
<BR><BR>In the latter example, the case of the name in quotation marks is preserved.
<BR><BR>Use of these pragmas resolves the naming differences, however, the issue of argument passing must still be resolved.
<H2 ID="Argument_Passing_Convention"> Argument Passing Convention </H2>
<BR>In general, C uses call-by-value (passes argument values) while FORTRAN uses call-by-reference (passes pointers to argument
values).&nbsp; This implies that to pass arguments to a FORTRAN subprogram we must pass the addresses of arguments rather
than their values.&nbsp; C uses the &quot;&amp;&quot; character to signify &quot;address of&quot;.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; result = ftnname( &amp;arg );</TT>
<BR><BR>When calling a C function from FORTRAN, the pragma used to correct the naming conventions must also instruct the compiler
that the C function is expecting values, not addresses.
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; *$pragma aux CNAME &quot;!_&quot; parm (value)</TT>
<BR><BR>The &quot;parm (value)&quot; addition instructs the FORTRAN compiler to pass values, instead of addresses.
<BR><BR>Character data (strings) are an exception to the general case when used as arguments.&nbsp; In C, strings are not
thought of as a whole entity, but rather as an &quot;array of characters&quot;.&nbsp; Since strings are not considered scalar
arguments, they are referenced differently in both C and FORTRAN.&nbsp; This is described in more detail in a following section.
<H2 ID="Memory_Model_Compatibility"> Memory Model Compatibility </H2>
<BR>While it is really not an issue with the 32-bit compilers (both use the default &quot;flat&quot; memory model), it is
important to know that the default memory model used in Open Watcom FORTRAN 77 applications is the &quot;large&quot; memory
model (&quot;ml&quot;) with &quot;medium&quot; and &quot;huge&quot; memory models as options.&nbsp; Since the 16-bit Open
Watcom C/C++ default is the &quot;small&quot; memory model, you must specify the correct memory model when compiling your
C/C++ code with the 16-bit C or C++ compiler.
<H2 ID="Linking_Considerations"> Linking Considerations </H2>
<BR>When both C/C++ and FORTRAN object files are combined into an executable program or dynamic link library, it is important
that you list a least one of the FORTRAN object files first in the Open Watcom Linker (WLINK) &quot;FILES&quot; directive
to guarantee the proper search order of the FORTRAN and C run-time libraries.&nbsp; If you place a C/C++ object file first,
you may inadvertently cause the wrong version of run-time initialization routines to be loaded by the linker.
<H2 ID="Integer_Type_Compatibility"> Integer Type Compatibility </H2>
<BR>In general, the number of bytes used to store an integer type is implementation dependent.&nbsp; In FORTRAN, the default
size of an integer type is always 4 bytes, while in C/C++, the size is architecture dependent.&nbsp; The size of an &quot;int&quot;
is 2 bytes for the 16-bit Open Watcom C/C++ compilers and 4 bytes for the 32-bit compilers while the size of a &quot;long&quot;
is 4 bytes regardless of architecture.&nbsp; It is safest to prototype the function in C, specifying exactly what size integers
are being used.&nbsp; The byte sizes are as follows:
<OL>
<LI>LONG - 4 bytes
<LI>SHORT - 2 bytes
</OL>
<BR>Since FORTRAN uses a default of 4 bytes, we should specify the &quot;long&quot; keyword in C for integer types.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; long int ftnname( long int *, long int *, long int * );</TT>
<BR><BR>In this case, &quot;ftnname&quot; takes three &quot;pointers to long ints&quot; as arguments, and returns a &quot;long
int&quot;.&nbsp; By specifying that the arguments are pointers, and not values, and by specifying &quot;long int&quot; for
the return type, this prototype has solved the problems of argument passing and integer type compatibility.
<H2 ID="How_do_I_pass_integers_from_C_to_a_FORTRAN_function_"> How do I pass integers from C to a FORTRAN function? </H2>
<BR>The following Open Watcom C/C++ routine passes three integers to a FORTRAN function that returns an integer value.
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; /* MIX1C.C - This C program calls a FORTRAN function to</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; *&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; compute the max of three
numbers.</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; *</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; * Compile/Link: wcl /ml mix1c mix1f.obj /fe=mix1</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; *&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
wcl386&nbsp; mix1c mix1f.obj /fe=mix1</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; */</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; #include &lt;stdio.h&gt;</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; #pragma aux tmax3 &quot;^&quot;;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; long int tmax3( long int *, long int *, long int * );</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; void main()</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; long int&nbsp; result;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; long int&nbsp; i, j, k;</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; i = -1;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; j = 12;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; k = 5;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; result = tmax3( &amp;i, &amp;j, &amp;k );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;Maximum is %ld\n&quot;, result );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; }</TT>
<BR><BR>The FORTRAN function:
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; * MIX1F.FOR - This FORTRAN function accepts three integer</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; *&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; arguments and returns
their maximum.</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; * Compile: wfc[386] mix1f.for</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; integer function tmax3( arga, argb, argc
)</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; integer arga, argb, argc</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tmax3 = arga</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if ( argb .gt. tmax3 ) tmax3 = argb</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if ( argc .gt. tmax3 ) tmax3 = argc</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; end</TT>
<H2 ID="How_do_I_pass_integers_from_FORTRAN_to_a_C_function_"> How do I pass integers from FORTRAN to a C function? </H2>
<BR>The following Open Watcom FORTRAN 77 routine passes three integers to a Open Watcom C/C++ function that returns an integer
value.
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; *&nbsp; MIX2F.FOR - This FORTRAN program calls a C function to</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; *&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; compute the
max of three numbers.</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; *</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; * Compile/Link: wfl[386] mix2f mix2c.obj /fe=mix2</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; *$pragma aux tmax3 &quot;!_&quot; parm (value)</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; program mix2f</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; integer*4&nbsp; tmax3</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; integer*4&nbsp; result</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; integer*4&nbsp; i, j, k</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; i = -1</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; j = 12</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; k = 5</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; result = tmax3( i, j, k )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; print *, 'Maximum is ', result</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; end</TT>
<BR><BR>The C function &quot;tmax3&quot; is shown below.
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; /* MIX2C.C - This C function accepts 3 integer arguments</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; *&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; and returns their maximum.</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; *</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; * Compile: wcc /ml mix2c</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; *&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; wcc386&nbsp; mix2c</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; */</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; long int tmax3( long int arga,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;long int argb,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;long int argc )</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; long int&nbsp;&nbsp; result;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; result = arga;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if( argb &gt; result ) result = argb;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if( argc &gt; result ) result = argc;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return( result );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; }</TT>
<H2 ID="How_do_I_pass_a_string_from_a_C_function_to_FORTRAN_"> How do I pass a string from a C function to FORTRAN? </H2>
<BR>Character strings are referenced differently in C and FORTRAN.&nbsp; The C language terminates its strings with a null
character as an End-Of-String (EOS) marker.&nbsp; In this case, C need not store the length of the string in memory.&nbsp;
FORTRAN, however, does not use any EOS marker; hence it must store each string's length in memory.
<BR><BR>The structure FORTRAN uses to keep track of character data is called a &quot;string descriptor&quot; which consists
of a pointer to the character data (2, 4, or 6 bytes, depending on the data model) followed by an unsigned integer length
(2 bytes or 4 bytes, depending on the data model).
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; system option&nbsp;&nbsp; size of pointer&nbsp;&nbsp;&nbsp;&nbsp;
size of length</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ------ ------&nbsp;&nbsp; ---------------&nbsp;&nbsp;&nbsp;&nbsp;
--------------</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 16-bit /MM&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 16 bits&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 16 bits</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 16-bit /ML&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 32 bits&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 16 bits</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 32-bit /MF&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 32 bits&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 32 bits</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 32-bit /ML&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 48 bits&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 32 bits</TT>
<BR><BR>In order to access character data, FORTRAN needs to have access to the data's string descriptor.&nbsp; Hence, FORTRAN
expects a pointer to a string descriptor to be passed as an argument for character data.
<BR><BR>Passing string arguments between C and FORTRAN is a simple task of describing a struct type in C containing the two
fields described above.&nbsp; The first field must contain the pointer to the character data, and the second field must contain
the length of the string being passed.&nbsp; A pointer to this structure can then be passed to FORTRAN.
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; * MIX3F.FOR - This FORTRAN program calls a function written</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; *&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; in C that passes
back a string.</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; *</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; * Compile/Link: wfl[386] mix3f mix3c.obj /fe=mix3</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; program mix3f</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; character*80 sendstr</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; character*80 cstring</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cstring = sendstr()</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; print *, cstring(1:lentrim(cstring))</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; end</TT>
<BR><BR>The C function &quot;sendstr&quot; is shown below.
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; /* MIX3C.C - This C function passes a string back to its</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; *&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; calling FORTRAN program.</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; *</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; * Compile: wcc /ml mix3c</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; *&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; wcc386&nbsp; mix3c</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; */</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; #include &lt;string.h&gt;</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; #pragma aux sendstr &quot;^&quot;;</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; typedef struct descriptor {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; char&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; *addr;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; unsigned&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; len;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; } descriptor;</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; void sendstr( descriptor *ftn_str_desc )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ftn_str_desc-&gt;addr = &quot;This is a C string&quot;;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ftn_str_desc-&gt;len&nbsp; = strlen( ftn_str_desc-&gt;addr );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; }</TT>
<H2 ID="How_do_I_pass_a_string_from_FORTRAN_to_a_C_function_"> How do I pass a string from FORTRAN to a C function? </H2>
<BR>By default, FORTRAN passes the address of the string descriptor when passing strings.&nbsp; If the C function knows it
is being passed a string descriptor address, then it is very similar to the above example.&nbsp; If the C function is expecting
normal C-type strings, then a FORTRAN pragma can be used to pass the string correctly.&nbsp; When the Open Watcom FORTRAN
77 compiler pragma to pass by value is used for strings, then just a pointer to the string is passed.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; *$pragma aux cname &quot;!_&quot; parm (value)</TT>
<BR><BR>The following example FORTRAN mainline defines a string, and passes it to a C function that prints it out.
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; * MIX4F.FOR - This FORTRAN program calls a function written</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; *&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; in C and passes
it a string.</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; *</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; * Compile/Link: wfl[386] mix4f mix4c.obj /fe=mix4</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; *$pragma aux cstr &quot;!_&quot; parm (value)</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; program mix4f</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; character*80 forstring</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; forstring = 'This is a FORTRAN string'//char(0)</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call cstr( forstring )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; end</TT>
<BR><BR>The C function:
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; /* MIX4C.C - This C function prints a string passed from</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; *&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; FORTRAN.</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; *</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; * Compile: wcc /ml mix4c</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; *&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; wcc386&nbsp; mix4c</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; */</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; #include &lt;stdio.h&gt;</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; void cstr( char *instring )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;%s\n&quot;, instring );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; }</TT>
<H2 ID="How_do_I_access_a_FORTRAN_common_block_from_within_C_"> How do I access a FORTRAN common block from within C? </H2>
<BR>The following code demonstrates a technique for accessing a FORTRAN common block in a C routine.&nbsp; The C routine defines
an extern struct to correspond to the FORTRAN common block.
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; * MIX5F.FOR - This program shows how a FORTRAN common</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; *&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; block can be accessed
from C.</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; *</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; * Compile/Link: wfl[386] mix5f mix5c.obj /fe=mix5</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; program mix5f</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; external put</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; common/cblk/i,j</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; i=12</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; j=10</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call put</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; print *, 'i = ', i</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; print *, 'j = ', j</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; end</TT>
<BR><BR>The C function:
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; /* MIX5C.C - This code shows how to access a FORTRAN</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; *&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; common block from C.</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; *</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; * Compile: wcc /ml mix5c</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; *&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; wcc386&nbsp; mix5c</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; #include &lt;stdio.h&gt;</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; #pragma aux put &quot;^&quot;;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; #pragma aux cblk &quot;^&quot;;</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; #ifdef __386__</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; #define FAR</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; #else</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; #define FAR far</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; #endif</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; extern struct cb {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; long int i,j;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; } FAR cblk;</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; void put( void )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;i = %ld\n&quot;, cblk.i );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;j = %ld\n&quot;, cblk.j );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cblk.i++;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cblk.j++;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; }</TT>
<BR><BR>For the 16-bit C compiler, the common block &quot;cblk&quot; is described as <TT> far</TT> to force a load of the
segment portion of the address.&nbsp; Otherwise, since the object is smaller than 32K (the default data threshold), it is
assumed to be located in the DGROUP group which is accessed through the SS segment register.
<H2 ID="How_do_I_call_a_C_function_that_accepts_a_variable_number_of_arguments_"> How do I call a C function that accepts a variable number of arguments? </H2>
<BR>One capability that C possesses is the ability to define functions that accept variable number of arguments.&nbsp; This
feature is not present, however, in the definition of the FORTRAN 77 language.&nbsp; As a result, a special pragma is required
to call these kinds of functions.
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; *$pragma aux printf &quot;!_&quot; parm (value) caller []</TT>
<BR><BR>The &quot;caller&quot; specifies that the caller will pop the arguments from the stack.&nbsp; The &quot;[]&quot; indicates
that there are no arguments passed in registers because the<TT> printf</TT> function takes a variable number of arguments
passed on the stack.&nbsp; The following example is a FORTRAN function that uses this pragma.&nbsp; It calls the<TT> printf</TT>
function to print the value 47 on the screen.
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; * MIX6.FOR - This FORTRAN program calls the C</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; *&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf function.</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; * Compile/Link: wfl[386] mix6</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; *$pragma aux printf &quot;!_&quot; parm (value) caller []</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; program mix6</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; character cr/z0d/, nullchar/z00/</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call printf( 'Value is %ld.'//cr//nullchar,
47 )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; end</TT>
<BR><BR>For more information on the pragmas that are used extensively during inter-language programming, please refer to the
chapter entitled &quot;Pragmas&quot; in both the<B> Open Watcom C/C++ User's Guide</B> and the<B> Open Watcom FORTRAN 77 User's
Guide.</B>
<H1 ID="Commonly_Asked_Questions_and_Answers"> Commonly Asked Questions and Answers </H1>
<BR>As with any sophisticated piece of software, there are topics that are not directly addressed by the descriptive portions
of the manuals.&nbsp; The purpose of this chapter is to anticipate common questions concerning Open Watcom F77.&nbsp; It is
difficult to predict what topics will prove to be useful but with that in mind, we hope that this chapter will help our customers
make full use of Open Watcom F77.
<BR><BR>A number of example programs are presented throughout.&nbsp; The source text for these files can be found in the<TT>
\WATCOM\SAMPLES\GOODIES</TT> directory.
<BR><BR>The purpose of this chapter is to present some of the more commonly asked questions from our users and the answers
to these questions.&nbsp; The following topics are discussed:
<UL>
<LI>How do I determine my current patch level?
<LI>How do I convert to Open Watcom F77?
<LI>What should I know about optimization?
<LI>How do I read a stream of binary data from a file?
<LI>How do I redefine math error handling with Open Watcom F77?
<LI>Why can't the compiler find my include files?
<LI>Why does the linker report a &quot;stack segment not found&quot; error?
<LI>How do I resolve an &quot;Undefined Reference&quot; linker error?
<LI>Why aren't local variable values maintained between subprogram calls?
<LI>What does &quot;Stack Overflow!&quot; mean?
<LI>What are the probable causes of a General Protection Fault in 32-bit applications?
<LI>Which floating-point compiler option should I use for my application?
<LI>How can I open more than 20 files at a time?
<LI>How can I see my source files in the debugger?
<LI>What is the difference between the &quot;d1&quot; and &quot;d2&quot; compiler options?
<LI>What is the difference between the &quot;debug&quot; and &quot;d2&quot; compiler options?
</UL>
<H2 ID="Determining_my_current_patch_level"> Determining my current patch level </H2>
<BR>In an effort to immediately correct any problems discovered in the originally shipped product, Open Watcom provides patches
as a continued service to its customers.&nbsp; To determine the current patch level of your Open Watcom software, a TECHINFO
utility program has been provided.&nbsp; This program will display your current environment variables, the patch level of
various Open Watcom software programs, and other pertinent information, such as your<TT> AUTOEXEC.BAT</TT> and<TT> CONFIG.SYS</TT>
files.&nbsp; This information proves to be very useful when reporting a problem to the Technical Support team.
<BR><BR>To run TECHINFO, you must ensure the Open Watcom environment variable has been set to the directory where your Open
Watcom software has been installed.&nbsp; TECHINFO will pause after each screenful of information.&nbsp; The output is also
placed in the file<TT> TECHINFO.OUT.</TT>
<BR><BR>Below is an example of some partial output produced by running the TECHINFO utility:
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; WATCOM's Techinfo Utility, Version 1.4</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Current Time: Thu Oct 27 15:58:34 1994</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; WATCOM&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Phone: (519) 884-0702</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; 415 Phillip St.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp; Fax: (519) 747-4971</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Waterloo, Ontario</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; CANADA&nbsp;&nbsp;&nbsp; N2L 3X2</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; -------------WATCOM C Environment Variables -------------</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; WATCOM=&lt;c:\watcom&gt;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; EDPATH=&lt;c:\watcom\eddat&gt;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; INCLUDE=&lt;c:\watcom\h;c:\watcom\h\os2&gt;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; FINCLUDE=&lt;c:\watcom\src\fortran;c:\watcom\src\fortran\win&gt;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; LIBOS2=&lt;c:\watcom\lib286\os2;c:\watcom\lib286&gt;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; PATH=&lt;c:\dos;c:\windows;c:\watcom\binw&gt;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; TMP=&lt;h:\temp&gt;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; File 'c:\watcom\binw\wcc386.exe' has been patched to level '.d'</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; ...etc...</TT>
<BR><BR>In this example, the software has been patched to level &quot;d&quot;.&nbsp; In most cases, all tools will share a
common patch level.&nbsp; However, there are instances where certain tools have been patched to one level while others are
patched to a different level.&nbsp; For example, the compiler may be patched to level &quot;d&quot; while the debugger is
only patched to level &quot;c&quot;.&nbsp; Basically, this means that there were no debugger changes in the D-level patches.
<BR><BR>If you run the TECHINFO utility, and determine that you are not at the current patch level, it is recommended that
you update your software.&nbsp; Patches are available on Open Watcom's bulletin board, Open Watcom's FTP site and CompuServe.
&nbsp;They are available 24 hours a day.&nbsp; Patches are also available on the current release CD-ROM.&nbsp; Each patch
will include a batch file that allows you to apply the patches to your existing software.&nbsp; Note that patches must be
applied in sequential order, as each patch depends on the previous one.
<H2 ID="Converting_to_Open_Watcom_F77"> Converting to Open Watcom F77 </H2>
<BR>Applications written in ANSI standard FORTRAN 77 code usually only need to be recompiled with the Open Watcom F77 compiler.
&nbsp;In addition to the ANSI standard, many compilers support specific extensions.&nbsp; If you are porting code from a UNIX
platform or other DOS compilers, check<B> Appendix A - Extensions to Standard FORTRAN 77</B> of the<B><I> Open Watcom FORTRAN
77 Language Reference,</I></B> to determine which FORTRAN 77 extensions are supported.
<BR><BR>By default, most FORTRAN 77 compilers preserve the values of local variables in a subprogram between calls.&nbsp;
With Open Watcom F77, local variables are kept on the stack and their values are popped from the stack when exiting a subprogram.
&nbsp;To preserve local variables, use the FORTRAN 77 SAVE statement for variables that you wish to preserve, or the &quot;save&quot;
compiler option to preserve all local variables.&nbsp; Note that the use of the &quot;save&quot; compiler option causes an
overall performance degradation.
<BR><BR>Open Watcom F77 uses register-based parameter passing as a default, however, the compiler is flexible enough to use
different calling conventions on a per function basis.&nbsp; Auxiliary pragmas can be used to specify the calling convention
that is to be used to interface with assembler code.&nbsp; This enables you to explicitly state how parameters are to be passed
to the assembler code.&nbsp; This topic is described in the &quot;Pragmas&quot; chapter of the<B><I> Open Watcom F77 User's
Guide</I></B> under &quot;Describing Argument Information&quot;.&nbsp; See also the chapter entitled <A HREF="#InterMLanguage_calls__C_and_FORTRAN">Inter-Language calls:&nbsp; C and FORTRAN</A>.
<H2 ID="What_you_should_know_about_optimization"> What you should know about optimization </H2>
<BR>The<B><I> Open Watcom F77 User's Guide</I></B> contains a detailed description for each of the optimization options supported
by the compiler.&nbsp; These options allow you to customize the type of code optimizations that are performed.&nbsp; For instance,
the &quot;OS&quot; option can be used to reduce the size of your code, but this may affect the execution speed.&nbsp; To ensure
that the speed of the code is optimized, possibly at the cost of code size, use the &quot;OT&quot; option.&nbsp; The &quot;OX&quot;
option, intended for the maximum number of optimizations, generates code that is a combination of &quot;OM&quot; (inline math
functions), &quot;OL&quot; (loop), &quot;OT&quot; (time) and the &quot;OR&quot; (instruction scheduling) optimization options.
&nbsp;Note that when you are using the &quot;OM&quot; option to generate inline math functions no argument validation will
be done for the intrinsic math functions such as &quot;sin&quot; or &quot;cos&quot;.&nbsp; Consider the needs of your application
and select the optimization options that best meet your requirements.&nbsp; 
<BR><BR><B><I>Hint:</I></B>&nbsp; The definitive reference on compiler design is the &quot;dragon&quot; book &quot;Compilers
- Principles, Techniques, and Tools&quot;, Alfred V.&nbsp; Aho, Ravi Sethi, and Jeffrey D.&nbsp; Ullman, published by Addison-Wesley,
Reading, Massachusetts, 1986.&nbsp; The authors of the &quot;dragon&quot; book advocate a conservative approach to code generation
where optimizations must preserve the semantics of the original program.&nbsp; The conservative approach is used throughout
the Open Watcom F77 compiler to ensure that programmers can use the compiler without worrying about the semantics of their
program being changed.
<BR><BR>There are certain pieces of information which the compiler cannot derive from the source code.&nbsp; The &quot;*$pragma&quot;
compiler directive is used to provide extra information to the compiler.&nbsp; It is necessary to have a complete understanding
of both FORTRAN 77 and the machine architecture (i.e., 80x86) before using the powerful pragma compiler directives.&nbsp;
See the &quot;Pragmas&quot; chapter in the<B><I> Open Watcom F77 User's Guide</I></B> for more details.
<BR><BR>Debugging optimized programs is difficult because variables can be assigned to different locations (i.e., memory or
registers) in different parts of the function.&nbsp; The &quot;d2&quot; compiler option will restrict the amount of optimization
so that variables occupy one location and can be easily displayed.&nbsp; It follows that the &quot;d2&quot; option is useful
for initial development but production programs should be compiled with only the &quot;d1&quot; option for the best code quality.
&nbsp;Before you distribute your application to others, you may wish to use the Open Watcom Strip Utility (WSTRIP) to remove
debugging information from the executable image on disk thereby reducing disk space requirements.&nbsp; 
<BR><BR><B><I>Hint:</I></B>&nbsp; The &quot;d2&quot; compiler option will generate symbolic information (for every local variable)
and line number information for the source file.&nbsp; The &quot;d1&quot; compiler option will only generate line number information
for the source file.&nbsp; The use of these options determines what kind of information will be available for the particular
module during the debugging session.
<H2 ID="Reading_a_stream_of_binary_data_from_a_file"> Reading a stream of binary data from a file </H2>
<BR>The Open Watcom F77 allows for three types of binary data file formats:
<UL>
<LI>Variable length, unformatted sequential access binary records,
<LI>Fixed length, unformatted direct access binary records, and
<LI>Unformatted, sequential, binary data with a fixed record type.
</UL>
<BR>Variable length binary records are preceded by a four byte descriptor that indicates the length of the record in bytes.
&nbsp;The end of the binary record is also marked by another descriptor tag specifying the length.&nbsp; Binary records that
are of a fixed length are kept in a direct access, unformatted file.&nbsp; Refer to the<B><I> Open Watcom F77 User's Guide</I></B>
section on File Handling for more information on file formats.
<BR><BR>Binary data files that have no structure or record length information may be read if you open the file as a sequential,
unformatted file with a fixed record type.&nbsp; This allows you to read files that contain a stream of binary data without
any inherent record format.&nbsp; If you know the type of data that is contained in the binary file, you may then read the
binary data directly into variables.&nbsp; The following program provides an example of reading binary stream data.
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; * BINDATA.FOR - This program demonstrates how to read a</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; * binary data file that does not have any defined records.</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; program bindata</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; integer BinArray(20)</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; integer i</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; open( unit=1, file='bindata.fil',</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; +&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; access='sequential',</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; +&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; form='unformatted',</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; +&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; recordtype='fixed' )</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; *&nbsp; Read 20 integers from the binary data file</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; do i = 1, 20</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; read( 1 ) BinArray( i )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; end do</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; *&nbsp; Write the extracted values to standard output</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; do i = 1, 20</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; write( *, * ) BinArray( i )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; end do</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; end</TT>
<H2 ID="Redefining_math_error_handling_with_Open_Watcom_F77"> Redefining math error handling with Open Watcom F77 </H2>
<BR>If you wish to customize math error handling for your application, you can create your own math error handling procedure.
&nbsp;The following illustrates the procedures for trapping errors by way of an example.&nbsp; See the<B><I> Open Watcom F77
User's Guide</I></B> for a description of the <TT> fsignal</TT> subroutine and math library error handling.
<BR><BR>The main program example &quot;MATHDEMO&quot; is a FORTRAN program that contains a floating-point divide by zero error,
a floating-point overflow error, a floating-point underflow error, and an invalid argument to a math library function.
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; program mathdemo</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; * MATHDEMO.FOR - This program forms part of a collection of FORTRAN</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; *&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
code that demonstrates how to take over control of</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; *&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
math error handling from the run-time system.</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; * Compile: wfl[386] mathdemo cw87 _matherr</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; * Notes:</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; * (1) We call &quot;cw87&quot; to enable underflow exceptions which are</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; *&nbsp;&nbsp;&nbsp;&nbsp; masked (ignored) by default.</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; * (2) The signal handler must be re-installed after each signal</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; *&nbsp;&nbsp;&nbsp;&nbsp; (it can also be re-installed even when there is no signal).</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; * (3) To prevent compile-time constant folding in expressions,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; *&nbsp;&nbsp;&nbsp;&nbsp; we add log(1.0) which is 0.&nbsp; We do this for the sake of</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; *&nbsp;&nbsp;&nbsp;&nbsp; demonstrating exception handling.</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; implicit none</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; double precision x, y, z</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call cw87&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;! init 80x87 control word</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call resetFPE&nbsp;&nbsp;&nbsp;&nbsp; ! install signal
handler</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; print *, ' '</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; print *, 'Divide by zero will be attempted'</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; x = 1.0d0 + DLOG( 1.0d0 )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; y = 0.0d0</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; z = x / y</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call chkFPE&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ! check
for exception</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; print *, z</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call resetFPE&nbsp;&nbsp;&nbsp;&nbsp; ! install signal
handler</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; print *, ' '</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; print *, 'Overflow will be attempted'</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; x = 1.2d300 + DLOG( 1.0d0 )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; y = 1.2d300</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; z = x * y</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call chkFPE&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ! check
for exception</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; print *, z</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call resetFPE&nbsp;&nbsp;&nbsp;&nbsp; ! install signal
handler</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; print *, ' '</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; print *, 'Underflow will be attempted'</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; x = 1.14d-300 + DLOG( 1.0d0 )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; y = 2.24d-308</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; z = x * y</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call chkFPE&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ! check
for exception</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; print *, z</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call resetFPE&nbsp;&nbsp;&nbsp;&nbsp; ! install signal
handler</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; print *, ' '</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; print *, 'Math error will be attempted'</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; x = -12.0</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ! an exception will not be generated since the intrinsic
function</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ! will validate the argument - if you compile with /om,
the &quot;fsqrt&quot;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ! 80x87 instruction will be generated in-line and an
exception</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ! will occur</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; y = SQRT( x )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call chkFPE&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ! check
for exception</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; print *, x, y</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; end</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; subroutine resetFPE</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; include 'fsignal.fi'</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; external fpe_handler</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; logical fpe_flag</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; integer fpe_sig, fpe_fpe</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; common fpe_flag, fpe_sig, fpe_fpe</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; fpe_flag = .false.</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call fsignal( SIGFPE, fpe_handler )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; end</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; *$pragma aux fpe_handler parm( value )</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; subroutine fpe_handler( sig, fpe )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; integer sig, fpe</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; logical fpe_flag</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; integer fpe_sig, fpe_fpe</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; common fpe_flag, fpe_sig, fpe_fpe</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; fpe_flag = .true.</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; fpe_sig = sig</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; fpe_fpe = fpe</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; end</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; *$pragma aux fwait = &quot;fwait&quot;</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; subroutine chkFPE</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; include 'fsignal.fi'</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; logical fpe_flag</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; integer fpe_sig, fpe_fpe</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; common fpe_flag, fpe_sig, fpe_fpe</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; * Notes:</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; * (1) An fwait is required to make sure that the last</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; *&nbsp;&nbsp;&nbsp;&nbsp; floating-point instruction has completed.</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; * (2) &quot;volatile&quot; is not needed here but would be</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; *&nbsp;&nbsp;&nbsp;&nbsp; needed in main program if it references &quot;fpe_flag&quot;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call fwait()</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if( volatile( fpe_flag ) ) then</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; print *, '*ERROR* exception occurred',</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &amp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;fpe_sig, fpe_fpe</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if( fpe_fpe .eq. FPE_INVALID )then</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; print *, 'Invalid'</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else if( fpe_fpe .eq. FPE_DENORMAL )then</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; print *, 'Denormalized operand
error'</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else if( fpe_fpe .eq. FPE_ZERODIVIDE )then</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; print *, 'Divide by zero error'</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else if( fpe_fpe .eq. FPE_OVERFLOW )then</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; print *, 'Overflow error'</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else if( fpe_fpe .eq. FPE_UNDERFLOW )then</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; print *, 'Underflow error'</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else if( fpe_fpe .eq. FPE_INEXACT )then</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; print *, 'Inexact result (precision)then
error'</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else if( fpe_fpe .eq. FPE_UNEMULATED )then</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; print *, 'Unemulated instruction
error'</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else if( fpe_fpe .eq. FPE_SQRTNEG )then</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; print *, 'Square root of a negative
number error'</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else if( fpe_fpe .eq. FPE_STACKOVERFLOW )then</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; print *, 'NDP stack overflow
error'</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else if( fpe_fpe .eq. FPE_STACKUNDERFLOW
)then</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; print *, 'NDP stack underflow
error'</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else if( fpe_fpe .eq. FPE_EXPLICITGEN )then</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; print *, 'SIGFPE signal raised
(software)'</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else if( fpe_fpe .eq. FPE_IOVERFLOW )then</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; print *, 'Integer overflow error'</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; endif</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; print *, '*OK* no exception occurred'</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; endif</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; end</TT>
<BR><BR>The following subroutine illustrates how to enable or disable particular types of floating-point exceptions.
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; subroutine cw87</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; * CW87.FOR</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; * This subroutine uses the C Library routine &quot;_control87&quot;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; * to modify the math coprocessor exception mask.</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; * Compile: wfc[386] cw87</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; include 'fsignal.fi'</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; character*9 status(0:1)/' disabled',' enabled'/</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; integer fp_cw, fp_mask, bits, i</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; * Enable floating-point underflow since default is disabled.</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; * The mask defines which bits we want to change (1 means change,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; * 0 means do not change).&nbsp; The corresponding bit in the control</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; * word (fp_cw) is set to 0 to enable the exception or 1 to disable</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; * the exception.&nbsp; In this example, we change only the underflow</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; * bit and leave the others unchanged.</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; fp_mask = EM_UNDERFLOW&nbsp;&nbsp;&nbsp; ! mask for
the bits to set/reset</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; fp_cw = '0000'x&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp; ! new bit settings (0=enable/1=disable)</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; fp_cw = _control87( fp_cw, fp_mask )</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; * Now get up-to-date setting</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; fp_cw = _control87( 0, 0 )</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; bits = IAND( fp_cw, MCW_EM )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; print '(a,1x,z4)', 'Interrupt Exception Mask', bits</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; i = 0</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if( IAND(fp_cw, EM_INVALID) .eq. 0 ) i = 1</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; print *, '&nbsp; Invalid Operation exception', status(i)</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; i = 0</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if( IAND(fp_cw, EM_DENORMAL) .eq. 0 ) i = 1</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; print *, '&nbsp; Denormalized exception', status(i)</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; i = 0</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if( IAND(fp_cw, EM_ZERODIVIDE) .eq. 0 ) i = 1</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; print *, '&nbsp; Divide-By-Zero exception', status(i)</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; i = 0</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if( IAND(fp_cw, EM_OVERFLOW) .eq. 0 ) i = 1</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; print *, '&nbsp; Overflow exception', status(i)</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; i = 0</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if( IAND(fp_cw, EM_UNDERFLOW) .eq. 0 ) i = 1</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; print *, '&nbsp; Underflow exception', status(i)</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; i = 0</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if( IAND(fp_cw, EM_PRECISION) .eq. 0 ) i = 1</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; print *, '&nbsp; Precision exception', status(i)</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; end</TT>
<BR><BR>The following subroutine illustrates how to replace the run-time system's math error handler.&nbsp; Source code similar
to this example is provided with the software (look for the file<TT> _matherr.for</TT>).
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; *</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; * _MATHERR.FOR&nbsp; : math error handler</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; *</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; * Compile: wfc[386] _matherr</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; *$pragma aux __imath2err &quot;*_&quot; parm( value, reference, reference )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; *$pragma aux __amath1err &quot;*_&quot; parm( value, reference )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; *$pragma aux __amath2err &quot;*_&quot; parm( value, reference, reference )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; *$pragma aux __math1err &quot;*_&quot; parm( value, reference )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; *$pragma aux __math2err &quot;*_&quot; parm( value, reference, reference )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; *$pragma aux __zmath2err &quot;*_&quot; parm( value, reference, reference )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; *$pragma aux __qmath2err &quot;*_&quot; parm( value, reference, reference )</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; integer function __imath2err( err_info, arg1, arg2
)</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; integer err_info</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; integer arg1, arg2</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; include 'mathcode.fi'</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; arg1 = arg1&nbsp;&nbsp;&nbsp;&nbsp; ! to avoid unreferenced
warning message</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; arg2 = arg2&nbsp;&nbsp;&nbsp;&nbsp; ! to avoid unreferenced
warning message</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if( ( err_info .and. M_DOMAIN ) .ne. 0 )then</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; select( err_info .and. FUNC_MASK
)</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; case( FUNC_POW )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; print
*, 'arg2 cannot be &lt;= 0'</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; case( FUNC_MOD )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; print
*, 'arg2 cannot be 0'</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; end select</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; end if</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; __imath2err = 0</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; end</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; real function __amath1err( err_info, arg1 )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; integer err_info</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; real arg1</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; include 'mathcode.fi'</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; arg1 = arg1&nbsp;&nbsp;&nbsp;&nbsp; ! to avoid unreferenced
warning message</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if( ( err_info .and. M_DOMAIN ) .ne. 0 )then</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; select( err_info .and. FUNC_MASK
)</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; case( FUNC_COTAN )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; print
*, 'overflow'</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; end select</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; end if</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; __amath1err = 0.0</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; end</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; real function __amath2err( err_info, arg1, arg2 )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; integer err_info</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; real arg1, arg2</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; include 'mathcode.fi'</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; arg1 = arg1&nbsp;&nbsp;&nbsp;&nbsp; ! to avoid unreferenced
warning message</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; arg2 = arg2&nbsp;&nbsp;&nbsp;&nbsp; ! to avoid unreferenced
warning message</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if( ( err_info .and. M_DOMAIN ) .ne. 0 )then</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; select( err_info .and. FUNC_MASK
)</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; case( FUNC_MOD )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; print
*, 'arg2 cannot be 0'</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; end select</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; end if</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; __amath2err = 0.0</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; end</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; double precision function __math1err( err_info, arg1
)</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; integer err_info</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; double precision arg1, __math2err</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; __math1err = __math2err( err_info, arg1, arg1 )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; end</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; double precision function __math2err( err_info, arg1,
arg2 )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; integer err_info</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; double precision arg1, arg2</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; include 'mathcode.fi'</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; arg1 = arg1&nbsp;&nbsp;&nbsp;&nbsp; ! to avoid unreferenced
warning message</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; arg2 = arg2&nbsp;&nbsp;&nbsp;&nbsp; ! to avoid unreferenced
warning message</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if( ( err_info .and. M_DOMAIN ) .ne. 0 )then</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; select( err_info .and. FUNC_MASK
)</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; case( FUNC_SQRT )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; print
*, 'argument cannot be negative'</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; case( FUNC_ASIN, FUNC_ACOS )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; print
*, 'argument must be less than or equal to one'</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; case( FUNC_ATAN2 )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; print
*, 'both arguments must not be zero'</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; case( FUNC_POW )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if( arg1
.eq. 0.0 )then</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp; print *, 'a zero base cannot be raised to a ',</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &amp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 'negative power'</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else
! base &lt; 0 and non-integer power</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp; print *, 'a negative base cannot be raised to a ',</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &amp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 'non-integral power'</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; endif</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; case( FUNC_LOG, FUNC_LOG10 )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; print
*, 'argument must not be negative'</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; end select</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else if( ( err_info .and. M_SING ) .ne. 0 )then</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if( ( ( err_info .and. FUNC_MASK
) .eq. FUNC_LOG ) .or.</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &amp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ( ( err_info
.and. FUNC_MASK ) .eq. FUNC_LOG10 ) )then</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; print
*, 'argument must not be zero'</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; endif</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else if( ( err_info .and. M_OVERFLOW ) .ne. 0 )then</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; print *, 'value of argument will
cause overflow condition'</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else if( ( err_info .and. M_UNDERFLOW ) .ne. 0 )then</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; print *, 'value of argument will
cause underflow ',</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &amp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; 'condition - return zero'</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; end if</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; __math2err = 0</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; end</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; complex function __zmath2err( err_info, arg1, arg2
)</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; integer err_info</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; complex arg1, arg2</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; include 'mathcode.fi'</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; arg1 = arg1&nbsp;&nbsp;&nbsp;&nbsp; ! to avoid unreferenced
warning message</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; arg2 = arg2&nbsp;&nbsp;&nbsp;&nbsp; ! to avoid unreferenced
warning message</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if( ( err_info .and. M_DOMAIN ) .ne. 0 )then</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; select( err_info .and. FUNC_MASK
)</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; case( FUNC_POW )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ! arg1
is (0,0)</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if( imag(
arg2 ) .ne. 0 )then</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp; print *, 'a zero base cannot be raised to a',</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &amp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp; ' complex power with non-zero imaginary part'</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp; print *, 'a zero base cannot be raised to a',</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &amp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp; ' complex power with non-positive real part'</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; endif</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; end select</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; end if</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; __zmath2err = (0,0)</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; end</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; double complex function __qmath2err( err_info, arg1,
arg2 )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; integer err_info</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; double complex arg1, arg2</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; include 'mathcode.fi'</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; arg1 = arg1&nbsp;&nbsp;&nbsp;&nbsp; ! to avoid unreferenced
warning message</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; arg2 = arg2&nbsp;&nbsp;&nbsp;&nbsp; ! to avoid unreferenced
warning message</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if( ( err_info .and. M_DOMAIN ) .ne. 0 )then</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; select( err_info .and. FUNC_MASK
)</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; case( FUNC_POW )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ! arg1
is (0,0)</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if( imag(
arg2 ) .ne. 0 )then</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp; print *, 'a zero base cannot be raised to a',</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &amp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp; ' complex power with non-zero imaginary part'</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp; print *, 'a zero base cannot be raised to a',</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &amp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; ' complex power with non-positive real part'</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; endif</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; end select</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; end if</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; __qmath2err = (0,0)</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; end</TT>
<H2 ID="The_compiler_cannot_find_my_include_files"> The compiler cannot find my include files </H2>
<BR>In order to locate your INCLUDE files, the compiler first searches your current directory, then each directory listed
in the<B> FINCLUDE</B> environment variable (in the order that they are specified).&nbsp; If the compiler reports that it
is unable to find one of your include files, change the<B> FINCLUDE</B> environment variable by adding the directory path
to your include files.&nbsp; For more information on setting the environment variable, refer to the &quot;Compiling an Application&quot;
chapter of the<B><I> Open Watcom F77 User's Guide.</I></B>
<H2 ID="The_linker_reports_a__stack_segment_not_found__error"> The linker reports a &quot;stack segment not found&quot; error </H2>
<BR>The linker usually reports the error &quot;1014:&nbsp; stack segment not found&quot; when it is unable to find the run-time
libraries required to link your application.&nbsp; To ensure you are linking with the correct run-time libraries, check to
see that your link command contains the correct &quot;SYSTEM&quot; directive.&nbsp; As well, the<B> WATCOM</B> environment
variable should be pointing to the directory containing the Open Watcom F77 software.&nbsp; For a Open Watcom F77 application,
if this error is followed by the error &quot;1023:&nbsp; no starting address found&quot;, it may indicate that you are attempting
to link code that does not have a main program procedure.&nbsp; Ensure that you include your main program object module with
your linker directives.
<BR><BR>With FORTRAN 77, &quot;STACK&quot; is a reserved word.&nbsp; If you use &quot;STACK&quot; as the name of a common
block, this may also result in the &quot;Stack Segment Not Found&quot; error.&nbsp; Check the names of your common blocks
and rename them if necessary.
<H2 ID="Resolving_an__Undefined_Reference__linker_error"> Resolving an &quot;Undefined Reference&quot; linker error </H2>
<BR>The Open Watcom Linker builds an executable file by a process of resolving references to functions or data items that
are declared in other source files.&nbsp; Certain conditions arise that cause the linker to generate an &quot;Undefined Reference&quot;
error message.&nbsp; An &quot;Undefined Reference&quot; error message will be displayed by the linker when it cannot find
a function or data item that was referenced in the program.&nbsp; Verify that you have included all the required object modules
in the linker command and that you are linking with the correct libraries.
<BR><BR>The &quot;SYSTEM&quot; linker directive should be used to indicate the target environment for the executable.&nbsp;
This directive specifies the format of the executable and the libraries for the target environment.&nbsp; Verify that the<B>
WATCOM</B> environment variable is set to the directory that Open Watcom F77 was installed in since it is used to complete
the library path in the &quot;SYSTEM&quot; directive.&nbsp; You may also explicitly include a library using the &quot;LIBRARY&quot;
linker directive.
<BR><BR>If the linker reports an unresolved reference for &quot;_cstart_&quot;, this indicates that the linker could not find
the FORTRAN 77 run-time libraries.&nbsp; In 16-bit applications, the FORTRAN 77 run-time libraries for the medium memory model
(/mm) and the floating-point calls floating-point model (/fpc) would be<TT> flibm.lib.</TT>&nbsp; In 32-bit applications,
the FORTRAN 77 run-time libraries for the flat memory model would be<TT> flib.lib.</TT>&nbsp; Verify that the &quot;LIB&quot;
environment variable has been set to point to the correct<B> WATCOM</B> library directories and that the library corresponds
to the memory and floating-point model that you selected.
<H2 ID="Why_local_variable_values_are_not_maintained_between_subprogram_calls"> Why local variable values are not maintained between subprogram calls </H2>
<BR>By default, the local variables for a subprogram are stored on the stack and are not initialized.&nbsp; When the subprogram
returns, the variables are popped off the stack and their values are lost.&nbsp; If you want to preserve the value of a local
variable, after the execution of a RETURN or END statement in a subprogram, the FORTRAN 77 SAVE statement or the &quot;save&quot;
compiler option can be used.
<BR><BR>Using the FORTRAN 77 SAVE statement in your program allows you to explicitly select which values you wish to preserve.
&nbsp;The SAVE statement ensures that space is allocated for a local variable from static memory and not the stack.&nbsp;
Include a SAVE statement in your FORTRAN 77 code for each local variable that you wish to preserve.
<BR><BR>To automatically preserve all local variables, you can use the &quot;save&quot; compiler option.&nbsp; This option
adds code to initialize and allocate space for each local variable in the program.&nbsp; This is equivalent to specifying
a SAVE statement.&nbsp; The &quot;save&quot; option makes it easier to ensure that all the variables are preserved during
program execution, but it increases the size of the code that is generated.&nbsp; You may wish to use this option during debugging
to help diagnose bugs caused by corrupted local values.&nbsp; Usually, it is more efficient to use SAVE statements rather
than the general &quot;save&quot; compiler option.&nbsp; You should selectively use the SAVE statement for each subprogram
variable that you want to preserve until the next call.&nbsp; This leads to smaller code than the &quot;save&quot; option
and avoids the overhead of allocating space and initializing values unnecessarily.
<H2 ID="What__Stack_Overflow___means"> What &quot;Stack Overflow!&quot; means </H2>
<BR>The memory used for local variables is allocated from the function call stack although the Open Watcom compilers will
often use registers for local variables.&nbsp; The size of the function call stack is limited at link-time and it is possible
to exceed the amount of stack space during execution.
<BR><BR>There are various ways of protecting against stack overflow errors.&nbsp; First, one should minimize the number of
recursive functions used in an application program.&nbsp; This can be done by recoding recursive functions to use loops.
<BR><BR>The user may also optionally force the compiler to use static storage for all local variables (Open Watcom F77 &quot;save&quot;
option).&nbsp; This would eliminate most stack problems for FORTRAN programs.&nbsp; These techniques will reduce the amount
of stack space required but there still may be times where the default amount of stack space is insufficient.&nbsp; The Open
Watcom Linker (WLINK) allows the user to set the amount of stack space at link-time through the directive &quot;OPTION STACK=size&quot;
where size may be specified in bytes with an optional &quot;k&quot; suffix for kilobytes (1024 bytes).
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; option stack=9k</TT>
<BR><BR>Note that with the Open Watcom F77 run-time system, the I/O routines require 4k of stack space.&nbsp; If your application
requires 5K of stack space, set aside 9K to allow for 4K of I/O stack space in addition to the stack space required by the
application.
<BR><BR>Debugging a program that reports a stack overflow error can be accomplished with the following sequence.
<OL>
<LI>Load your application into the debugger
<LI>Set a breakpoint at<TT> __STKOVERFLOW</TT>
<LI>Run the application until the breakpoint at<TT> __STKOVERFLOW</TT> is triggered
<LI>Issue the debugger &quot;show calls&quot; command.&nbsp; This will display a stack traceback giving you the path of calls
that led up to the stack overflow situation.
</OL>
<BR>The solution to the stack overflow problem at this point depends on the programmer.
<H2 ID="What_are_the_probable_causes_of_a_General_Protection_Fault_in_32Mbit_applications_"> What are the probable causes of a General Protection Fault in 32-bit applications? </H2>
<BR>If you are running a 32-bit application using DOS/4GW, a program crash may report an &quot;Unexpected Interrupt 0D&quot;
general protection fault error.&nbsp; The Phar Lap DOS extender would report an &quot;Abnormal Program Termination&quot; general
protection fault error.&nbsp; This often indicates that something in your program has tried to access an invalid memory location.
&nbsp;In a Open Watcom F77 application, the most likely causes of a general protection fault are:
<UL>
<LI>Attempting to access an array out of bounds.
<LI>Running out of stack space.
<LI>Passing incorrect parameter types to a function.
</UL>
<BR>To help locate the cause of the protection fault, compile your program with the &quot;debug&quot; and &quot;stack&quot;
options.&nbsp; With these options, code will be added to your application to help identify these problems and generate run-time
error messages when they are encountered.&nbsp; In addition, the &quot;stack&quot; option checks for stack overflow conditions
by including code at the beginning of each subprogram.
<BR><BR>If you still encounter general protection faults after compiling with &quot;debug&quot; and &quot;stack&quot;, then
debug the program using the debugger.&nbsp; This will help to identify the location of the crash and the state of your parameters
and variables at the time of the crash.
<H2 ID="Which_floatingMpoint_compiler_option_should_I_use_for_my_application_"> Which floating-point compiler option should I use for my application? </H2>
<BR>The answer to this question depends on the expected target machines for your application.&nbsp; If you know that a co-processor
will be available, use the &quot;fpi87&quot; compiler option to optimize the run-time performance of the application.
<BR><BR>When you are running a FORTRAN 77 application on a machine with or without a co-processor and you want to favour the
use of emulation libraries over code size, use the &quot;fpc&quot; option.&nbsp; The &quot;fpc&quot; option will also take
advantage of an 80x87 co-processor if it is available.&nbsp; If your application needs to be flexible enough to run either
with or without a co-processor, the &quot;fpc&quot; option is recommended.
<BR><BR>The &quot;fpi&quot; option is the default floating-point option and can be used with or without a co-processor.&nbsp;
On machines that do not have a co-processor, you may notice that programs compiled using &quot;fpc&quot; run faster than those
compiled with &quot;fpi&quot;.&nbsp; This occurs because the &quot;fpc&quot; option uses the floating-point libraries directly
whereas the &quot;fpi&quot; option interfaces with an emulator interrupt handler.&nbsp; Although the &quot;fpi&quot; option
is slower than &quot;fpc&quot; without a co-processor, the code that it generates is smaller.
<BR><BR>When you are running an application that has been compiled with &quot;fpi&quot;, the startup code checks to determine
whether a math co-processor is present.&nbsp; If it is not present, the emulator hook is installed at the INT 7h interrupt
to manage the co-processor requests and convert them to the emulation library calls.&nbsp; Each time a floating-point operation
is requested, the processor issues an INT 7h.
<BR><BR>For 16-bit applications, the interrupt handler overhead accounts for the performance discrepancy between the &quot;fpc&quot;
and &quot;fpi&quot; options.
<BR><BR>For 32-bit applications, the manner in which this interrupt is handled depends on the DOS extender.&nbsp; Depending
on the DOS extender, there are two methods of managing floating-point instructions through the interrupt handler.&nbsp; The
DOS extender will either pass the interrupt directly to the INT 7h handler or it will perform some intermediary steps.&nbsp;
Similarly, there is a delay after the interrupt as control is passed back through the DOS extender.&nbsp; Passing floating-point
handling from the DOS extender to the interrupt handler results in the performance degradation.&nbsp; This performance degradation
may vary across DOS extenders.&nbsp; It is the overhead of transferring the call through an interrupt that leads to the speed
difference between &quot;fpi&quot; and &quot;fpc&quot;.&nbsp; If you need to run an application on machines without math co-processors,
and you want to ensure that your performance is optimal, build your application using the &quot;fpc&quot; option rather than
&quot;fpi&quot;.
<BR><BR>In a Windows environment, both the &quot;fpi87&quot; and the &quot;fpi&quot; options will use floating-point emulation
if a co-processor is not available.&nbsp; Windows floating-point emulation is provided through Open Watcom's &quot;WEMU387.386&quot;.
&nbsp;&quot;WEMU387.386&quot; is royalty free and may be redistributed with your application.&nbsp; For machines that do not
have a math co-processor, install &quot;WEMU387.386&quot; as a device in the [386Enh] section of the Windows SYSTEM.INI file
to handle the floating-point operations.&nbsp; Note that the speed of code using &quot;WEMU387.386&quot; on machines without
a co-processor will be much slower than code compiled with the &quot;fpc&quot; option that always uses floating-point libraries.
<H2 ID="How_more_than_20_files_at_a_time_can_be_opened"> How more than 20 files at a time can be opened </H2>
<BR>The number of file handles allowed by Open Watcom F77 is initialized to 20 in<TT> stdio.h,</TT> but this can be changed
by the application developer.&nbsp; To change the number of file handles allowed with Open Watcom F77, follow the steps outlined
below.
<OL>
<LI>Let<TT> n</TT> represent the number of files the application developer wishes to have open.&nbsp; Ensure that the<B> stdin,
stdout, stderr, stdaux,</B> and<B> stdprn</B> files are included in the count.
<LI>Change the<TT> CONFIG.SYS</TT> file to include &quot;files=n&quot; where &quot;n&quot; is the number of file handles required
by the application plus an additional 5 handles for the standard files (this applies to DOS 5.0).&nbsp; The number &quot;n&quot;
may vary depending on your operating system and version.&nbsp; If you are running a network such as Novell's NetWare, this
will also affect the number of available file handles.&nbsp; In this case, you may have to increase the number specified in
the &quot;files=n&quot; statement.
<LI>Add a call to<TT> GROWHANDLES</TT> in your application.
</OL>
<BR>The following example illustrates the use of<TT> GROWHANDLES.</TT>
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; *&nbsp; FHANDLES.FOR</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; *</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; *&nbsp; This FORTRAN program grows the number of file handles so</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; *&nbsp; more than 16 files can be opened. This program</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; *&nbsp; illustrates the interaction between GROWHANDLES and</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; *&nbsp; the DOS 5.0 file system. If you are running a network</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; *&nbsp; such as Novell's NetWare, this will also affect the</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; *&nbsp; number of available file handles. In the actual trial,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; *&nbsp; FILES=40 was specified in CONFIG.SYS.</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; *&nbsp; Compile/Link: set finclude=\watcom\src\fortran</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; *&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
wfl[386] fhandles</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; *&nbsp;&nbsp;&nbsp;&nbsp; Get proper typing information from include file</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; include 'fsublib.fi'</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; integer i, j, maxh, maxo</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; integer tmpfile</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; integer units(7:57)</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; do i = 25, 40</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; *&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Count 5 for stdin, stdout, stderr, stdaux,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; *&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; and stdprn</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; print 100, 5 + i</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; maxh = growhandles( 5 + i )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; print *, 'Growhandles=',maxh</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; maxo = 0</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; do j = 7, 7 + maxh</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; print *, 'Attempting
file', j</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; units(j) = tmpfile(j)</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if( units(j) .eq.
0 )goto 10</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; maxo = maxo + 1</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; enddo</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; 10&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; print 101, maxo, maxh</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; do j = 7, 7 + maxo</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; close( units(j) )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; enddo</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; enddo</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; 100&nbsp;&nbsp; format('Trying for ',I2,' handles... ',$)</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; 101&nbsp;&nbsp; format(I2,'/',I2,' temp files opened')</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; end</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; integer function tmpfile( un )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; integer un, ios</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; open( unit=un, status='SCRATCH', iostat=ios )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if( ios .eq. 0 )then</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; write( unit=un, fmt='(I2)', err=20 ) un</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tmpfile = un</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; endif</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; 20&nbsp;&nbsp;&nbsp; tmpfile = 0</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; end</TT>
<H2 ID="How_source_files_can_be_seen_in_the_debugger"> How source files can be seen in the debugger </H2>
<BR>The selection and use of debugging information is important for getting the most out of the Open Watcom Debugger.&nbsp;
If you are not able to see your source code in the Open Watcom Debugger source window, there are three areas where things
may have gone wrong, namely:
<OL>
<LI>using the correct option for the Open Watcom F77.
<LI>using the correct directives for the Open Watcom Linker.
<LI>using the right commands in the Open Watcom Debugger.
</OL>
<BR>The Open Watcom F77 compiler takes FORTRAN 77 source and creates an object file containing the generated code.&nbsp; By
default, no debugging information is included in the object file.&nbsp; The compiler will output debugging information into
the object file if you specify a debugging option during the compile.&nbsp; There are two levels of debugging information
that the compiler can generate:&nbsp; 
<OL>
<LI>Line numbers and local variables (&quot;d2&quot; option)
<LI>Line numbers (&quot;d1&quot; option)
</OL>
<BR>The options are used to determine how much debugging information will be visible when you are debugging a particular module.
&nbsp;If you use the &quot;d2&quot; option, you will be able to see your source file and display your local variables.&nbsp;
The &quot;d1&quot; option will display the source but will not give you access to local variable information.
<BR><BR>The Open Watcom Linker (WLINK) is the tool that puts together a complete program and sets up the debugging information
for all the modules in the executable file.&nbsp; There is a linker directive that indicates to the linker when it should
include debugging information from the modules.&nbsp; There are five levels of debugging information that can be collected
during the link.&nbsp; These are:
<OL>
<LI>global names (DEBUG)
<LI>global names, line numbers (DEBUG LINE)
<LI>global names, types (DEBUG TYPES)
<LI>global names, local variables (DEBUG LOCALS)
<LI>all of the above (DEBUG ALL)
</OL>
<BR>Notice that global names will always be included in any request for debugging information.&nbsp; The debugging options
can be combined
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; DEBUG LINE, TYPES</TT>
<BR><BR>with the above directive resulting in full line number and typing information being available during debugging.&nbsp;
The directives are position dependent so you must precede any object files and libraries with the debugging directive.&nbsp;
For instance, if the file<TT> mylink.lnk</TT> contained:
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; #</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; # invoke with: wlink @mylink</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; #</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; file main</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; debug line</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; file input, output</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; debug all</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; file process</TT>
<BR><BR>then the modules<TT> input</TT> and<TT> output</TT> will have global names and source line information available during
debugging.&nbsp; All debugging information in the module<TT> process</TT> will be available during debugging.
<BR><BR><B><I>Hint:</I></B>&nbsp; A subtle point to debugging information is that all the modules will have global names available
if any debugging directive is used.&nbsp; In the above example, the module<TT> main</TT> will have global name information
even though it does not have a DEBUG directive preceding it.
<BR><BR>It is preferable to have one DEBUG directive before any FILE and LIBRARY directives.&nbsp; You might wonder if this
increases the size of the executable file so that it will occupy too much memory during debugging.&nbsp; The debugging information
is loaded &quot;on demand&quot; by the debugger during the debugging session.&nbsp; A small amount of memory (40k default,
selectable with the Open Watcom Debugger &quot;dynamic&quot; command line option) is used to hold the most recently used module
debugging information.&nbsp; In practice, this approach saves a lot of memory because most debugging information is never
used.&nbsp; The overhead of accessing the disk for debugging information is negligible compared to accessing the source file
information.&nbsp; In other words, you can have as much debugging information as you want included in the executable file
without sacrificing memory required by the program.&nbsp; See the section entitled &quot;The DEBUG Directive&quot; in the<B><I>
Open Watcom Linker User's Guide</I></B> for more details.
<BR><BR>If the previous steps have been followed, you should be well on your way to debugging your programs with source line
information.&nbsp; There are instances where the Open Watcom Debugger cannot find the appropriate source file even though
it knows all the line numbers.&nbsp; The problem that has surfaced involves how the source file is associated with the debugging
information of the module.&nbsp; The original location of the source file is included in the debugging information for a module.
&nbsp;The name that is included in the debugging information is the original name that was on the Open Watcom F77 command
line.&nbsp; If the original filename is no longer valid (i.e., you have moved the executable to another directory), the Open
Watcom Debugger must be told where to find the source files.&nbsp; The Open Watcom Debugger &quot;Source Path&quot; menu item
(under &quot;File&quot;) can be used to supply new directories to search for source files.&nbsp; If your source files are
located in two directories, the following paths can be added in the Open Watcom Debugger:
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; c:\program\fortran\*.for</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; c:\program\new\fortran\*.for</TT>
<BR><BR>The &quot;*&quot; character indicates where the module name will be inserted while the Open Watcom Debugger is searching
for the source file.&nbsp; See the description of the &quot;Source Path&quot; menu item in the<B><I> Open Watcom Debugger
User's Guide</I></B> for more details.
<H2 ID="The_difference_between_the__d1__and__d2__compiler_options"> The difference between the &quot;d1&quot; and &quot;d2&quot; compiler options </H2>
<BR>The reason that there are two levels of debugging information available is that the code optimizer can perform many more
optimizations and still maintain &quot;d1&quot; (line) information.&nbsp; The &quot;d2&quot; option forces the code optimizer
to ensure that any local variable can be displayed at any time in the function.
<BR><BR>The &quot;d2&quot; option will always generate code and debugging information so that you can print the value of any
variable during the execution of the function.&nbsp; In order to get the best code possible and still see your source file
while debugging, the &quot;d1&quot; option only generates line number information into the object file.&nbsp; With line number
information, much better code can be generated.&nbsp; The debugging of programs that have undergone extensive optimization
can be difficult, but with the source line information it is much easier.&nbsp; To summarize, use the &quot;d2&quot; compiler
option if you are developing a module and you would like to be able to display each local variable.&nbsp; The &quot;d1&quot;
compiler option will give you line number information and the best generated code possible.&nbsp; There is absolutely no reason
not to specify the &quot;d1&quot; option because the code quality will be identical to code generated without the &quot;d1&quot;
option.
<H2 ID="The_difference_between_the__debug__and__d2__compiler_options"> The difference between the &quot;debug&quot; and &quot;d2&quot; compiler options </H2>
<BR>The &quot;d2&quot; (and &quot;d1&quot;) compiler options are used to add debugging information to your executable.&nbsp;
The &quot;d2&quot; option makes line numbering, local symbol and typing information available to the debugger whereas &quot;d1&quot;
only provides line number debugging information to the debugger.&nbsp; This information is used during a debugging session
to examine the state of variables and to provide the source code display.
<BR><BR>The &quot;debug&quot; option provides run-time error messages that are independent of the Open Watcom Debugger.&nbsp;
The &quot;debug&quot; option causes the generation of run-time error checking code.&nbsp; This includes subscript and substring
bounds checking as well as code that allows a run-time traceback to be issued when an error occurs.&nbsp; During the execution
of the application, if an error occurs, the code added with the &quot;debug&quot; option will halt the program and provide
an informative error message.
</BODY>
