<head>
<title> Open Watcom 2.0 Debugger Developers Guide </title>
</head>
<body>
<h1 id="Index_of_Topics"> Index of Topics </h1>
<dl>
<dt>- A -
<dd><a href="#Address_information_class">Address information class</a>
<br><a href="#ARRAY_Lvalue_0x2_R">ARRAY (value 0x2?)</a>
<dt><br>- B -
<dd><a href="#Base_Types">Base Types</a>
<br><a href="#Byte_Order">Byte Order</a>
<dt><br>- C -
<dd><a href="#CHARACTER_BLOCK_Lvalue_0x8_R">CHARACTER_BLOCK (value 0x8?)</a>
<br><a href="#CODE_Lvalue_0x2_R">CODE (value 0x2?)</a>
<br><a href="#Core_Requests">Core Requests</a>
<dt><br>- D -
<dd><a href="#Debugging_Information_Format">Debugging Information Format</a>
<dt><br>- E -
<dd><a href="#ENUMERATED_Lvalue_0x5_R">ENUMERATED (value 0x5?)</a>
<br><a href="#Environment_requests">Environment requests</a>
<br><a href="#Executable_file_structures">Executable file structures</a>
<dt><br>- F -
<dd><a href="#File_IDO_requests">File I/O requests</a>
<dt><br>- G -
<dd><a href="#GET_MOVED_SECTION">GET_MOVED_SECTION</a>
<br><a href="#GET_OVERLAY_STATE">GET_OVERLAY_STATE</a>
<br><a href="#GET_OVL_TBL_ADDR">GET_OVL_TBL_ADDR</a>
<br><a href="#GET_SECTION_DATA">GET_SECTION_DATA</a>
<br><a href="#GET_STATE_SIZE">GET_STATE_SIZE</a>
<br><a href="#Global_symbols_class">Global symbols class</a>
<dt><br>- H -
<dd><a href="#The_Handler_Routine">The Handler Routine</a>
<br><a href="#The_Hook_Routine">The Hook Routine</a>
<dt><br>- I -
<dd><a href="#The_Interface_Routines">The Interface Routines</a>
<dt><br>- L -
<dd><a href="#Line_number_information">Line number information</a>
<br><a href="#Line_numbers_class">Line numbers class</a>
<br><a href="#Local_symbol_information">Local symbol information</a>
<br><a href="#Local_symbols_class">Local symbols class</a>
<br><a href="#Location_information">Location information</a>
<dt><br>- M -
<dd><a href="#Master_debug_header">Master debug header</a>
<br><a href="#Module_information_class">Module information class</a>
<dt><br>- N -
<dd><a href="#NEW_BASE_Lvalue_0x3_R">NEW_BASE (value 0x3?)</a>
<dt><br>- O -
<dd><a href="#Object_file_structures">Object file structures</a>
<br><a href="#Overlay_manager_interface">Overlay manager interface</a>
<br><a href="#Overlay_requests">Overlay requests</a>
<br><a href="#Overlay_Table_Structure">Overlay Table Structure</a>
<dt><br>- P -
<dd><a href="#POINTER_Lvalue_0x4_R">POINTER (value 0x4?)</a>
<br><a href="#Pointer_Sizes">Pointer Sizes</a>
<br><a href="#PROCEDURE_Lvalue_0x7_R">PROCEDURE (value 0x7?)</a>
<dt><br>- R -
<dd><a href="#REQ_ASYNC_ADD_BREAK">REQ_ASYNC_ADD_BREAK</a>
<br><a href="#REQ_ASYNC_GO">REQ_ASYNC_GO</a>
<br><a href="#REQ_ASYNC_POLL">REQ_ASYNC_POLL</a>
<br><a href="#REQ_ASYNC_REMOVE_BREAK">REQ_ASYNC_REMOVE_BREAK</a>
<br><a href="#REQ_ASYNC_STEP">REQ_ASYNC_STEP</a>
<br><a href="#REQ_ASYNC_STOP">REQ_ASYNC_STOP</a>
<br><a href="#REQ_CAPABILITIES_GET_8B_BP">REQ_CAPABILITIES_GET_8B_BP</a>
<br><a href="#REQ_CAPABILITIES_GET_EXACT_BP">REQ_CAPABILITIES_GET_EXACT_BP</a>
<br><a href="#REQ_CAPABILITIES_SET_8B_BP">REQ_CAPABILITIES_SET_8B_BP</a>
<br><a href="#REQ_CAPABILITIES_SET_EXACT_BP">REQ_CAPABILITIES_SET_EXACT_BP</a>
<br><a href="#REQ_CHECKSUM_MEM">REQ_CHECKSUM_MEM</a>
<br><a href="#REQ_CLEAR_BREAK">REQ_CLEAR_BREAK</a>
<br><a href="#REQ_CLEAR_WATCH">REQ_CLEAR_WATCH</a>
<br><a href="#REQ_CONNECT">REQ_CONNECT</a>
<br><a href="#REQ_DISCONNECT">REQ_DISCONNECT</a>
<br><a href="#REQ_ENV_GET_VAR">REQ_ENV_GET_VAR</a>
<br><a href="#REQ_ENV_SET_VAR">REQ_ENV_SET_VAR</a>
<br><a href="#REQ_FILE_CLOSE">REQ_FILE_CLOSE</a>
<br><a href="#REQ_FILE_ERASE">REQ_FILE_ERASE</a>
<br><a href="#REQ_FILE_GET_CONFIG">REQ_FILE_GET_CONFIG</a>
<br><a href="#REQ_FILE_INFO_GET_DATE">REQ_FILE_INFO_GET_DATE</a>
<br><a href="#REQ_FILE_INFO_SET_DATE">REQ_FILE_INFO_SET_DATE</a>
<br><a href="#REQ_FILE_OPEN">REQ_FILE_OPEN</a>
<br><a href="#REQ_FILE_READ">REQ_FILE_READ</a>
<br><a href="#REQ_FILE_RUN_CMD">REQ_FILE_RUN_CMD</a>
<br><a href="#REQ_FILE_SEEK">REQ_FILE_SEEK</a>
<br><a href="#REQ_FILE_STRING_TO_FULLPATH">REQ_FILE_STRING_TO_FULLPATH</a>
<br><a href="#REQ_FILE_WRITE">REQ_FILE_WRITE</a>
<br><a href="#REQ_FILE_WRITE_CONSOLE">REQ_FILE_WRITE_CONSOLE</a>
<br><a href="#REQ_GET_ERR_TEXT">REQ_GET_ERR_TEXT</a>
<br><a href="#REQ_GET_LIB_NAME">REQ_GET_LIB_NAME</a>
<br><a href="#REQ_GET_MESSAGE_TEXT">REQ_GET_MESSAGE_TEXT</a>
<br><a href="#REQ_GET_NEXT_ALIAS">REQ_GET_NEXT_ALIAS</a>
<br><a href="#REQ_GET_SUPPLEMENTARY_SERVICE">REQ_GET_SUPPLEMENTARY_SERVICE</a>
<br><a href="#REQ_GET_SYS_CONFIG">REQ_GET_SYS_CONFIG</a>
<br><a href="#REQ_MACHINE_DATA">REQ_MACHINE_DATA</a>
<br><a href="#REQ_MAP_ADDR">REQ_MAP_ADDR</a>
<br><a href="#REQ_OVL_GET_DATA">REQ_OVL_GET_DATA</a>
<br><a href="#REQ_OVL_GET_REMAP_ENTRY">REQ_OVL_GET_REMAP_ENTRY</a>
<br><a href="#REQ_OVL_READ_STATE">REQ_OVL_READ_STATE</a>
<br><a href="#REQ_OVL_STATE_SIZE">REQ_OVL_STATE_SIZE</a>
<br><a href="#REQ_OVL_TRANS_RET_ADDR">REQ_OVL_TRANS_RET_ADDR</a>
<br><a href="#REQ_OVL_TRANS_VECT_ADDR">REQ_OVL_TRANS_VECT_ADDR</a>
<br><a href="#REQ_OVL_WRITE_STATE">REQ_OVL_WRITE_STATE</a>
<br><a href="#REQ_PERFORM_SUPPLEMENTARY_SERVICE">REQ_PERFORM_SUPPLEMENTARY_SERVICE</a>
<br><a href="#REQ_PROG_GODREQ_PROG_STEP">REQ_PROG_GO/REQ_PROG_STEP</a>
<br><a href="#REQ_PROG_KILL">REQ_PROG_KILL</a>
<br><a href="#REQ_PROG_LOAD">REQ_PROG_LOAD</a>
<br><a href="#REQ_READ_IO">REQ_READ_IO</a>
<br><a href="#REQ_READ_MEM">REQ_READ_MEM</a>
<br><a href="#REQ_READ_REGS">REQ_READ_REGS</a>
<br><a href="#REQ_READ_USER_KEYBOARD">REQ_READ_USER_KEYBOARD</a>
<br><a href="#REQ_REDIRECT_STDINDREQ_REDIRECT_STDOUT">REQ_REDIRECT_STDIN/REQ_REDIRECT_STDOUT</a>
<br><a href="#REQ_RESUME">REQ_RESUME</a>
<br><a href="#REQ_RFX_FINDCLOSE">REQ_RFX_FINDCLOSE</a>
<br><a href="#REQ_RFX_FINDFIRST">REQ_RFX_FINDFIRST</a>
<br><a href="#REQ_RFX_FINDNEXT">REQ_RFX_FINDNEXT</a>
<br><a href="#REQ_RFX_GETCWD">REQ_RFX_GETCWD</a>
<br><a href="#REQ_RFX_GETDATETIME">REQ_RFX_GETDATETIME</a>
<br><a href="#REQ_RFX_GETDRIVE">REQ_RFX_GETDRIVE</a>
<br><a href="#REQ_RFX_GETFILEATTR">REQ_RFX_GETFILEATTR</a>
<br><a href="#REQ_RFX_GETFREESPACE">REQ_RFX_GETFREESPACE</a>
<br><a href="#REQ_RFX_MKDIR">REQ_RFX_MKDIR</a>
<br><a href="#REQ_RFX_NAMETOCANONICAL">REQ_RFX_NAMETOCANONICAL</a>
<br><a href="#REQ_RFX_RENAME">REQ_RFX_RENAME</a>
<br><a href="#REQ_RFX_RMDIR">REQ_RFX_RMDIR</a>
<br><a href="#REQ_RFX_SETCWD">REQ_RFX_SETCWD</a>
<br><a href="#REQ_RFX_SETDATETIME">REQ_RFX_SETDATETIME</a>
<br><a href="#REQ_RFX_SETDRIVE">REQ_RFX_SETDRIVE</a>
<br><a href="#REQ_RFX_SETFILEATTR">REQ_RFX_SETFILEATTR</a>
<br><a href="#REQ_RUN_THREAD_GET_NAME">REQ_RUN_THREAD_GET_NAME</a>
<br><a href="#REQ_RUN_THREAD_GET_NEXT">REQ_RUN_THREAD_GET_NEXT</a>
<br><a href="#REQ_RUN_THREAD_GET_RUNTIME">REQ_RUN_THREAD_GET_RUNTIME</a>
<br><a href="#REQ_RUN_THREAD_INFO">REQ_RUN_THREAD_INFO</a>
<br><a href="#REQ_RUN_THREAD_POLL">REQ_RUN_THREAD_POLL</a>
<br><a href="#REQ_RUN_THREAD_SET">REQ_RUN_THREAD_SET</a>
<br><a href="#REQ_RUN_THREAD_SIGNAL_STOP">REQ_RUN_THREAD_SIGNAL_STOP</a>
<br><a href="#REQ_RUN_THREAD_STOP">REQ_RUN_THREAD_STOP</a>
<br><a href="#REQ_SET_BREAK">REQ_SET_BREAK</a>
<br><a href="#REQ_SET_DEBUG_SCREEN">REQ_SET_DEBUG_SCREEN</a>
<br><a href="#REQ_SET_USER_SCREEN">REQ_SET_USER_SCREEN</a>
<br><a href="#REQ_SET_WATCH">REQ_SET_WATCH</a>
<br><a href="#REQ_SPLIT_CMD">REQ_SPLIT_CMD</a>
<br><a href="#REQ_SUSPEND">REQ_SUSPEND</a>
<br><a href="#REQ_THREAD_FREEZE">REQ_THREAD_FREEZE</a>
<br><a href="#REQ_THREAD_GET_EXTRA">REQ_THREAD_GET_EXTRA</a>
<br><a href="#REQ_THREAD_GET_NEXT">REQ_THREAD_GET_NEXT</a>
<br><a href="#REQ_THREAD_SET">REQ_THREAD_SET</a>
<br><a href="#REQ_THREAD_THAW">REQ_THREAD_THAW</a>
<br><a href="#REQ_WRITE_IO">REQ_WRITE_IO</a>
<br><a href="#REQ_WRITE_MEM">REQ_WRITE_MEM</a>
<br><a href="#REQ_WRITE_REGS">REQ_WRITE_REGS</a>
<br><a href="#Request_Example">Request Example</a>
<br><a href="#The_Request_Interface">The Request Interface</a>
<br><a href="#Request_Structure">Request Structure</a>
<br><a href="#The_Requests">The Requests</a>
<br><a href="#RFX_requests">RFX requests</a>
<dt><br>- S -
<dd><a href="#Section_debug_header">Section debug header</a>
<br><a href="#Section_debug_information">Section debug information</a>
<br><a href="#Segment_address_table">Segment address table</a>
<br><a href="#SET_OVERLAY_STATE">SET_OVERLAY_STATE</a>
<br><a href="#Some_Definitions">Some Definitions</a>
<br><a href="#Source_language_table">Source language table</a>
<br><a href="#Special_Line_Number_Table">Special Line Number Table</a>
<br><a href="#STRUCTURE_Lvalue_0x6_R">STRUCTURE (value 0x6?)</a>
<br><a href="#SUBRANGE_Lvalue_0x3_R">SUBRANGE (value 0x3?)</a>
<br><a href="#System_Dependent_Aspects">System Dependent Aspects</a>
<dt><br>- T -
<dd><a href="#Thread_requests">Thread requests</a>
<br><a href="#TRANSLATE_RETURN_ADDR">TRANSLATE_RETURN_ADDR</a>
<br><a href="#TRANSLATE_VECTOR_ADDR">TRANSLATE_VECTOR_ADDR</a>
<br><a href="#Trap_File_Interface">Trap File Interface</a>
<br><a href="#Trap_Files_Under_DOS">Trap Files Under DOS</a>
<br><a href="#Trap_Files_Under_Netware_386_or_PenPoint">Trap Files Under Netware 386 or PenPoint</a>
<br><a href="#Trap_Files_Under_OSD2">Trap Files Under OS/2</a>
<br><a href="#Trap_Files_Under_QNX">Trap Files Under QNX</a>
<br><a href="#Trap_Files_Under_Windows_NT_">Trap Files Under Windows NT.</a>
<br><a href="#Trap_Files_Under_Windows_">Trap Files Under Windows.</a>
<br><a href="#TrapFini">TrapFini</a>
<br><a href="#TrapInit">TrapInit</a>
<br><a href="#TrapRequest">TrapRequest</a>
<br><a href="#TYPE_NAME_Lvalue_0x1_R">TYPE_NAME (value 0x1?)</a>
<br><a href="#Types_class">Types class</a>
<br><a href="#Typing_information">Typing information</a>
<dt><br>- V -
<dd><a href="#VARIABLE_Lvalue_0x1_R">VARIABLE (value 0x1?)</a>
<br><a href="#Version_number_and_source_language_identification">Version number and source language identification</a>
</dl>
<h1 id="Debugging_Information_Format"> Debugging Information Format </h1>
<br>This document describes the object and executable file structures used by the Open Watcom Debugger to provide symbolic
 information about a program.&nbsp; This information is subject to change.
<br>Note that version 4.0 of the Open Watcom debugger supports the DWARF and CodeView symbolic debugging information formats
 in addition to the format described in this document.&nbsp; For the purposes of discussion, this format will be known as
 the &quot;WATCOM&quot; format.&nbsp; DWARF is now the primary format used by Open Watcom compilers.&nbsp; Support for generating
 the WATCOM format will probably remain but is only useful for debugging DOS overlays.
<br><br>Before reading this document you should understand the Intel 8086 Object Module Format (OMF).&nbsp; This format is
 described in the Intel document<b><i> 8086 Relocatable Object Module Formats</i></b> and also the October 1985 issue of<b><i>
 PC Tech Journal</i></b>.
<br><br>Responsibility for the Intel/Microsoft OMF specification has been taken over by the Tools Interface Standards (TIS)
 Committee.&nbsp; The TIS standards (including the OMF spec) may be obtained by phoning the Intel literature center at 1-800-548-4725
 and asking for order number 241597.
<br><br>This document is for the Open Watcom Debugger version 4.0 (or above.)
<h1 id="Object_file_structures"> Object file structures </h1>
<br>The compiler is responsible for placing extra information into the object file in order to provide symbolic information
 for the Open Watcom Debugger.&nbsp; There are three classes of information, each of which may be present or absent from the
 file individually.&nbsp; These classes are line number, type and local symbol information.
<br>For the Open Watcom C compiler, line number information is provided when the &quot;/d1&quot; switch is used and all three
 classes are provided when the &quot;/d2&quot; switch is used.
<h2 id="Version_number_and_source_language_identification"> Version number and source language identification </h2>
<br>Since there may be different versions of the type and local symbol information, and there may be multiple front-ends a
 special OMF COMENT record is placed in the object file.&nbsp; It has the following form:
<br><br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; comment_class = 0xfe</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; 'D'</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; major_version_number (char)</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; minor_version_number (char)</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; source_language (string)</tt>
<br><br>The<tt> comment_class</tt> of 0xfe indicates a linker directive comment.&nbsp; The character 'D' informs the linker
 that this record is providing debugging information.&nbsp; The<tt> major_version_number</tt> is changed whenever there is
 a modification made to the types or local symbol classes that is not upwardly compatible with previous versions.&nbsp; The<tt>
 minor_version_number</tt> increments by one whenever a change is made to those classes that is upwardly compatible with previous
 versions.&nbsp; The<tt> source_language</tt> field is a string which determines what language that the file was compiled
 from.
<br><br>If the debugging comment record is not present, the local and type segments (described later) are not in WATCOM format
 and should be omitted from the resulting executable file's debugging information.&nbsp; The current major version is one,
 and the current minor version is three.
<h2 id="Line_number_information"> Line number information </h2>
<br>Line number information is provided by standard Intel OMF LINNUM records.&nbsp; A kludge has been added that allows for
 line numbers to refer to more than one source file.&nbsp; See the section on the &quot;Special Line Number Table&quot; in
 the executable structures portion of the document for more details.
<h2 id="Location_information"> Location information </h2>
<br>A type or symbol definition may contain a location field.&nbsp; This field is of variable length and identifies the memory
 (or register) location of the symbol in question.&nbsp; A location field may consist of a single entry, or a list of entries.
&nbsp; Each entry describes an operation of a stack machine.&nbsp; The value of the location field is the top entry of the
 stack after all the operations have been performed.&nbsp; To tell whether a field is a single entry or a list, the first
 byte is examined.&nbsp; If the value of the byte is greater than 0x80, then the field consists of a list of entries, and
 the length in bytes of the list is the value of the first byte minus 0x80.&nbsp; If the first byte is less than 0x80, the
 byte is the first byte of a single entry field.&nbsp; The top nibble of the first byte in each entry is a general location
 class while the low nibble specifies the sub-class.
<br><br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; BP_OFFSET&nbsp;&nbsp; (value 0x1?)</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; BYTE&nbsp;&nbsp;&nbsp; (value 0x10) offset_byte</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; WORD&nbsp;&nbsp;&nbsp; (value 0x11) offset_word</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DWORD&nbsp;&nbsp; (value 0x12) offset_dword</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp;&nbsp; CONST&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (value 0x2?)</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ADDR286 (value 0x20) memory_location_32_pointer</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ADDR386 (value 0x21) memory_location_48_pointer</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; INT_1&nbsp;&nbsp; (value 0x22) const_byte</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; INT_2&nbsp;&nbsp; (value 0x23) const_word</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; INT_4&nbsp;&nbsp; (value 0x24) const_dword</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp;&nbsp; MULTI_REG&nbsp;&nbsp; (value 0x3?)</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Low nibble is number of register bytes that follow - 1.</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; The registers are specified low order register first.</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp;&nbsp; REG&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (value 0x4?)</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Low nibble is low nibble of the appropriate register value.</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; This may only be used for the first 16 registers.</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp;&nbsp; IND_REG&nbsp;&nbsp;&nbsp;&nbsp; (value 0x5?)</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CALLOC_NEAR (value 0x50) register_byte</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CALLOC_FAR&nbsp; (value 0x51) register_byte, register_byte</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; RALLOC_NEAR (value 0x52) register_byte</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; RALLOC_FAR&nbsp; (value 0x53) register_byte, register_byte</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp;&nbsp; OPERATOR&nbsp;&nbsp;&nbsp;&nbsp; (value 0x6?)</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; IND_2&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (value 0x60)</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; IND_4&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (value 0x61)</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; IND_ADDR286 (value 0x62)</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; IND_ADDR386 (value 0x63)</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ZEB&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (value 0x64)</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ZEW&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (value 0x65)</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; MK_FP&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (value 0x66)</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; POP&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (value 0x67)</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; XCHG&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (value 0x68) stack_byte</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ADD&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (value 0x69)</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DUP&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (value 0x6a)</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; NOP&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (value 0x6b)</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp;&nbsp; Here is the list of register numbers:</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0-AL,&nbsp; 1-AH,&nbsp;&nbsp; 2-BL,&nbsp;&nbsp; 3-BH,&nbsp;&nbsp; 4-CL,&nbsp;&nbsp;
 5-CH,&nbsp;&nbsp; 6-DL,&nbsp;&nbsp; 7-DH</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 8-AX,&nbsp; 9-BX,&nbsp;&nbsp; 10-CX,&nbsp; 11-DX,&nbsp; 12-SI,&nbsp; 13-DI,&nbsp; 14-BP,
&nbsp; 15-SP</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; 16-CS,&nbsp; 17-SS,&nbsp; 18-DS,&nbsp; 19-ES</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; 20-ST0, 21-ST1, 22-ST2, 23-ST3, 24-ST4, 25-ST5, 26-ST6, 27-ST7</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; 28-EAX, 29-EBX, 30-ECX, 31-EDX, 32-ESI, 33-EDI, 34-EBP, 35-ESP</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; 36-FS,&nbsp; 37-GS</tt>
<br><br>CONST pushes a single constant value onto the expression stack.&nbsp; INT_1 and INT_2 constant values are sign-extended
 to four bytes before being pushed.
<br><br>The OPERATOR class performs a variety of operations on the expression stack.
<dl>
<dt>IND_2
<dd>Pick up two bytes at the location specified by the top entry of the stack, sign-extend to four bytes and replace top of stack
 with the result.
<dt><br>IND_4
<dd>Replace the top of stack with the contents of the four bytes at the location specified by the top of stack.
<dt><br>IND_ADDR286
<dd>Replace the top of stack with the contents of the four bytes, treated as a far pointer, at the location specified by the top
 of stack.
<dt><br>IND_ADDR386
<dd>Replace the top of stack with the contents of the six bytes, treated as a far pointer, at the location specified by the top
 of stack.
<dt><br>ZEB
<dd>Zero extend the top of stack from a byte to a dword (clear the high three bytes).
<dt><br>ZEW
<dd>Zero extend the top of stack from a word to a dword.
<dt><br>MK_FP
<dd>Remove the top two entries from the stack, use the top of stack as an offset and the next element as a segment to form a far
 pointer and push that back onto the stack.
<dt><br>POP
<dd>Remove the top entry from the stack.
<dt><br>XCHG
<dd>Exchange the top of stack with the entry specified by<tt> stack_byte</tt>.&nbsp; &quot;XCHG 1&quot; would exchange the top
 of stack with the next highest entry.
<dt><br>ADD
<dd>Remove the top two entries from the stack, add them together and push the result.
<dt><br>DUP
<dd>Duplicate the value at the top of the stack.
<dt><br>NOP
<dd>Perform no operation.
</dl>
<br>REG and MULTI_REG push the 'lvalue' of the register.&nbsp; If they are the only entry then the symbol exists in the specified
 register.&nbsp; To access the value of the register, you must indirect it.
<br><br>BP_OFFSET locations are for variables on the stack.&nbsp; The values given are offsets from the BP register for 286
 programs and from the EBP register for 386 programs.&nbsp; A BP_OFFSET could also be expressed with the following series
 of operations:
<br><br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; MULTI_REG(1) SS</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; IND_2</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; MULTI_REG(1) EBP</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; IND_4</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; MK_FP</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; INT_1 offset_byte</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; ADD</tt>
<br><br>The IND_REG location type is used for structured return values.&nbsp; The register or register pair is used to point
 at the memory location where the structure is returned.&nbsp; CALLOC means that the calling procedure is responsible for
 allocating the return area and passing a pointer to it as a parameter in the specified registers.&nbsp; RALLOC means that
 the called routine allocated the area and returns a pointer to it in the given registers.
<h2 id="Typing_information"> Typing information </h2>
<br>The Open Watcom Debugger typing information is contained in a special segment in the object file.&nbsp; The segment name
 is &quot;$$TYPES&quot; and the segment class is &quot;DEBTYP&quot;.&nbsp; To allow greater flexibility in demand loading
 the typing information and also let it exceed 60K for a single module, each object file may have multiple $$TYPES segments.
&nbsp; Each segment is identified by an entry in the demand link table (described in the executable file structures section).
&nbsp; No individual segment may exceed 60K and no individual type record may be split across a segment boundry.&nbsp; Also,
 any type which is described by multiple records (structures, enums, procedures) may not be split across a segment boundry.
&nbsp; Since each segment is loaded as a whole by the debugger when demand loading, increasing the segment size requires larger
 amounts of contiguous memory be present in the system.&nbsp; Decreasing the size of the individual segments reduces memory
 requirements, but increases debugger lookup time since it has to traverse more internal structures.&nbsp; The current code
 generator starts a new type segment when the current one exceeds 16K.&nbsp; The segments are considered to be a stream of
 variable length definitions, with each definition being preceded by a length byte.&nbsp; A number of the definitions contain
 indices of some form.&nbsp; These indices are standard Intel format, with 0 meaning no index, 1 to 127 is represented in
 one byte, 128 to 32767 in high byte/low byte form with the top bit on in the high byte.&nbsp; Definitions are given index
 numbers by the order in which they appear in the module, with the first being index one.&nbsp; Character strings representing
 names are always placed at the end of a definition so that their length can be calculated by subtracting the name's start
 point from the length of the record.&nbsp; They are not preceded by a length byte or followed by a zero byte.
<br><br>The first byte identifies the kind of the type definition that follows.&nbsp; The top nibble of the byte is used to
 indicate the general class of the type definition (there are eight of these).&nbsp; The low order nibble is used to qualify
 the general type class and uniquely identify the definition type.
<h3 id="TYPE_NAME_Lvalue_0x1_R"> TYPE_NAME (value 0x1?) </h3>
<br>This definition is used to give names to types.&nbsp; There are three sub-classes.
<br><br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; SCALAR&nbsp;&nbsp;&nbsp; (value 0x10) scalar_type_byte, name</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; SCOPE&nbsp;&nbsp;&nbsp;&nbsp; (value 0x11) name</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; NAME&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (value 0x12) scope_index, type_index, name</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; CUE_TABLE (value 0x13) table_offset_dword</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; EOF&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (value 0x14)</tt>
<br><br>SCALAR is used to give a name to a basic scalar type.&nbsp; It can also be used to give a type index to a scalar type
 without a name by specifying the null name.&nbsp; The<tt> scalar_type_byte</tt> informs the Open Watcom Debugger what sort
 of scalar item is being given a name.&nbsp; It has the following form:
<br><br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; BIT: 7 6 5 4 3 2 1 0</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | |&nbsp;&nbsp; | |&nbsp;&nbsp;&nbsp;&nbsp; |</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | |&nbsp;&nbsp; | +-----+--- size in bytes - 1</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | +---+----------- class (000 - integer)</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (001 - unsigned)</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (010 - float)</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (011 - void (size=0))</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (100 - complex)</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; +----------------- unused</tt>
<br><br>To create an unnamed scalar type, for use in other definitions, just use a zero length name.
<br><br><b>NOTE:</b>&nbsp; BASIC would have been a better name for this, since complex is not a scalar type, but the name
 was chosen before complex support was added.
<br><br>SCOPE is used to restrict the scope of other type names.&nbsp; A restricted scope type name must be preceded by its
 appropriate scope name in order for the Open Watcom Debugger to recognize it as a type name.&nbsp; This is useful for declaring
 C structure, union, and enum tag names.&nbsp; You declare SCOPE names of &quot;struct&quot;, &quot;union&quot;, and &quot;enum&quot;
 and then place the appropriate value in the<tt> scope_index</tt> field of the NAME record when declaring the tag.
<br><br>NAME gives an arbitrary type a name.&nbsp; The field,<tt> scope_index</tt> , is either zero, which indicates an unrestricted
 type name, or is the type index of a SCOPE definition, which means that the type name must be preceded by the given scope
 name in order to be recognized.
<br><br>The next two records are kludges to allow OMF line numbers to refer to more than one source file.&nbsp; See the section
 of on the &quot;Special Line Number Table&quot; in the executable structure for more details.
<br><br>CUE_TABLE is followed by<tt> table_offset_dword</tt> which gives the offset in bytes from the begining of the typing
 information for a module to the special line number table.&nbsp; If this record is present, it must be in the first $$TYPES
 segment for the module and preferably as close to the begining of the segment as possible.
<br><br>EOF marks the end of the typing information for the module and the begining of the special line number table.
<h3 id="ARRAY_Lvalue_0x2_R"> ARRAY (value 0x2?) </h3>
<br>This definition is used to define an array type.&nbsp; There are 6 sub-classes.
<br><br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; BYTE_INDEX&nbsp;&nbsp;&nbsp;&nbsp; (value 0x20) high_bound_byte, base_type_index</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; WORD_INDEX&nbsp;&nbsp;&nbsp;&nbsp; (value 0x21) high_bound_word, base_type_index</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; LONG_INDEX&nbsp;&nbsp;&nbsp;&nbsp; (value 0x22) high_bound_dword, base_type_index</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; TYPE_INDEX&nbsp;&nbsp;&nbsp;&nbsp; (value 0x23) index_type_index, base_type_index</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; DESC_INDEX&nbsp;&nbsp;&nbsp;&nbsp; (value 0x24) scalar_type_byte, scalar_type_byte,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; bounds_32_pointer,
 base_type_index</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; DESC_INDEX_386 (value 0x25) scalar_type_byte, scalar_type_byte,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; bounds_48_pointer,
 base_type_index</tt>
<br><br>BYTE_INDEX, WORD_INDEX, LONG_INDEX are all used to describe a restricted form of array.&nbsp; If one of these forms
 is used then the index type is an integer with the low bound of the array being zero and the high bound being whatever is
 specified.
<br><br>The DESC_INDEX form is used when the array bounds are not known at compile time.&nbsp; The<tt> bounds_32_pointer</tt>
 is a far pointer to a structure in memory.&nbsp; The type and size of the first field is given by the first<tt> scalar_type_byte</tt>
 and indicates the lower bound for the index.&nbsp; The second field's type and size is given by the second<tt> scalar_type_byte</tt>.
&nbsp; This field gives the number of elements in the array.
<br><br>The DESC_INDEX_386 is the same as DESC_INDEX except that a 48-bit far pointer is used to locate the structure in memory.
<h3 id="SUBRANGE_Lvalue_0x3_R"> SUBRANGE (value 0x3?) </h3>
<br>This definition is used to define a subrange type.&nbsp; There are 3 sub-classes.
<br><br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; BYTE_RANGE (value 0x30) lo_bnd_byte, hi_bnd_byte, base_type_index</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; WORD_RANGE (value 0x31) lo_bnd_word, hi_bnd_word, base_type_index</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; LONG_RANGE (value 0x32) lo_bnd_dword, hi_bnd_dword, base_type_index</tt>
<br><br>If the base type is unsigned then the low and high bounds should be interpreted as containing unsigned quantities,
 otherwise they contain integers.&nbsp; However, the decision to use the byte, word, or long form of the definition is always
 made considering the high and low bounds as signed numbers.
<h3 id="POINTER_Lvalue_0x4_R"> POINTER (value 0x4?) </h3>
<br>This definition is used to define a pointer type.&nbsp; There are 10 sub-classes.
<br><br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; NEAR&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (value 0x40) base_type_index
 &#91;,base_locator&#93;</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; FAR&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (value 0x41)
 base_type_index</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; HUGE&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (value 0x42) base_type_index</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; NEAR_DEREF&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (value 0x43) base_type_index &#91;,base_locator&#93;</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; FAR_DEREF&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (value 0x44) base_type_index</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; HUGE_DEREF&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (value 0x45) base_type_index</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; NEAR386&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (value 0x46) base_type_index &#91;,base_locator&#93;</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; FAR386&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (value 0x47) base_type_index</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; NEAR386_DEFREF&nbsp; (value 0x48) base_type_index &#91;,base_locator&#93;</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; FAR386_DEREF&nbsp;&nbsp;&nbsp; (value 0x49) base_type_index</tt>
<br><br>When a symbol is one of the *_DEREF types, the Open Watcom Debugger will automatically dereference the pointer.&nbsp;
 This &quot;hidden&quot; indirection may be used to define reference parameter types, or other indirectly located symbols.
&nbsp; The *_DEREF types have now been superceeded by location expressions.&nbsp; They should no longer be generated.&nbsp;
 The NEAR* pointer types all have an optional<tt> base_locator</tt> field.&nbsp; The debugger can tell if this field is present
 by examining the length of the debug type entry at the begining of the record and seeing if there are additional bytes after
 the<tt> base_type_index</tt> field.&nbsp; If there are more bytes, the<tt> base_locator</tt> is a location expression whose
 result is an address, the value of which is the base selector and offset value when indirecting through the pointer (based
 pointers).&nbsp; The contents of the based pointer variable are added to result of the location expression to form the true
 resulting address after an indirection.&nbsp; The address of the pointer variable being indirected through is pushed on the
 stack before the location expression is evaluated (needed for self-based pointers).&nbsp; If the<tt> base_locator</tt> field
 is not present, the debugger will use the default near segment and a zero offset.
<h3 id="ENUMERATED_Lvalue_0x5_R"> ENUMERATED (value 0x5?) </h3>
<br>This definition is used to define an enumerated type.&nbsp; There are 4 sub-classes.
<br><br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; LIST&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (value 0x50) #consts_word, scalar_type_byte</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; CONST_BYTE (value 0x51) value_byte, name</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; CONST_WORD (value 0x52) value_word, name</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; CONST_LONG (value 0x53) value_dword, name</tt>
<br><br>LIST is used to inform the Open Watcom Debugger of the number of constants in the enumerated type and the scalar type
 used to store them in memory.&nbsp; It will be followed immediately by all the constant definitions for the enumerated type.
&nbsp; See TYPE_NAME for a description of the<tt> scalar_type_byte</tt>.
<br><br>CONST_BYTE, CONST_WORD, and CONST_LONG define the individual constant values for an enumerated type.&nbsp; The type
 of the constant is provided by the preceeding LIST definition.&nbsp; The decision to use the byte, word, or long form of
 the definition is made always by considering the value as a signed number.&nbsp; The CONST_* definition records are not counted
 when determining type index values.
<br><br>The LIST record and its associated CONST_* records must all be contained in the same $$TYPES segment.
<h3 id="STRUCTURE_Lvalue_0x6_R"> STRUCTURE (value 0x6?) </h3>
<br>This definition is used to define a structure type.&nbsp; There are 10 sub-classes.
<br><br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; LIST&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (value 0x60) #fields_word &#91;,size_dword&#93;</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; FIELD_BYTE (value 0x61) offset_byte, type_index, name</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; FIELD_WORD (value 0x62) offset_word, type_index, name</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; FIELD_LONG (value 0x63) offset_dword, type_index, name</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; BIT_BYTE&nbsp;&nbsp; (value 0x64) offset_byte, start_bit_byte, bit_size_byte,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; type_index, name</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; BIT_WORD&nbsp;&nbsp; (value 0x65) offset_word, start_bit_byte, bit_size_byte,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; type_index, name</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; BIT_LONG&nbsp;&nbsp; (value 0x66) offset_dword, start_bit_byte, bit_size_byte,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; type_index, name</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; FIELD_CLASS (v&nbsp;&nbsp;&nbsp; 0x67) attrib_byte, field_locator, type_index, name</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; BIT_CLASS&nbsp; (value 0x68) attrib_byte, field_locator, start_bit_byte,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; bit_size_byte, type_index, name</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; INHERIT_CLASS (v&nbsp; 0x69) adjust_locator, ancestor_type_index</tt>
<br><br>LIST is used to introduce a structure definition.&nbsp; It is followed immediately by all the field definitions that
 make up the structure.&nbsp; The optional<tt> size_dword</tt> gives the size of the structure in bytes.&nbsp; If it is not
 present, the debugger calculates the size of the structure based on field offsets and sizes.
<br><br>FIELD_BYTE, FIELD_WORD, FIELD_LONG, and FIELD_CLASS define a single field entry in a structure defintion.
<br><br>BIT_BYTE, BIT_WORD, BIT_LONG, and BIT_CLASS define a bit field in a structure.&nbsp; :The FIELD_CLASS and BIT_CLASS
 records are used for defining fields in a C++ class.&nbsp; The<tt> attrib_byte</tt> contain a set of bits describing attributes
 of the field:
<br><br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; BIT: 7 6 5 4 3 2 1 0</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp; | | | | |</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp; | | | | +--- internal</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp; | | | +----- public</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp; | | +------- protected</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp; | +--------- private</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; +-----+----------- unused</tt>
<br><br>An internal field is one that is generated for compiler support.&nbsp; It is not normally displayed to the user.&nbsp;
 The other bits have their usual C++ meanings.
<br><br>The<tt> field_locator</tt> is a location expression describing how to calculate the field address.&nbsp; Before begining
 to evaluate the expression, the debugger will implicitly push the base address of the class instance onto the stack.&nbsp;
 The following is an example of the location expression used to calculate an ordinary field at offset 10 from the start of
 the class:
<br><br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; INT_1&nbsp;&nbsp; 10</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; ADD</tt>
<br><br>The INHERIT_CLASS record indicates that a particular class should inherit all the fields specified by<tt> ancestor_type_index</tt>.
&nbsp; This field must point at either a STRUCTURE LIST record or a TYPE NAME that eventually resolves to a STRUCTURE LIST.
&nbsp; The<tt> adjust_locator</tt> is a location expression that tells the debugger how to adjust the field offset expressions
 in the inherited class to their proper values for a class of this instance.
<br><br>The FIELD_*, BIT_*, and INHERIT_CLASS records are not counted when determining type index values.
<br><br>A C union, or Pascal variant record is described by having a number of fields all beginning at the same offset.&nbsp;
 The Open Watcom Debugger will display the fields in the reverse order that the records define them.&nbsp; This means that
 ordinarily, the records should be sorted by descending offsets and bit positions.
<br><br>The LIST record and it's associated field descriptions must all be contained in the same $$TYPES segment.
<h3 id="PROCEDURE_Lvalue_0x7_R"> PROCEDURE (value 0x7?) </h3>
<br>This definition is used to define a procedure type.&nbsp; There are 4 sub-classes.
<br><br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; NEAR&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (value 0x70) ret_type_index, #parms_byte {,parm_type_index}</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; FAR&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (value 0x71) ret_type_index, #parms_byte {,parm_type_index}</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; NEAR386&nbsp;&nbsp; (value 0x72) ret_type_index, #parms_byte {,parm_type_index}</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; FAR386&nbsp;&nbsp;&nbsp; (value 0x73) ret_type_index, #parms_byte {,parm_type_index}</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; EXT_PARMS (value 0x74) {,parm_type_index}</tt>
<br><br>The EXT_PARMS sub-class is used when there are too many parameter types to fit into one PROCEDURE record.&nbsp; This
 condition can be recognized when the #parms_byte indicates there are more parameter types than fit into the record according
 to the length field at the beginning.&nbsp; In this case the remaining parameter types are continued in the record immediately
 following, which will always be of type EXT_PARMS.&nbsp; The EXT_PARMS record must be contained in the same $$TYPES segment
 as the preceeding procedure record.
<h3 id="CHARACTER_BLOCK_Lvalue_0x8_R"> CHARACTER_BLOCK (value 0x8?) </h3>
<br>Items of type CHARACTER_BLOCK are length delimited strings.&nbsp; There are 4 sub-classes.
<br><br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; CHAR_BYTE&nbsp;&nbsp;&nbsp; (value 0x80) length_byte</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; CHAR_WORD&nbsp;&nbsp;&nbsp; (value 0x81) length_word</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; CHAR_LONG&nbsp;&nbsp;&nbsp; (value 0x82) length_dword</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; CHAR_IND&nbsp;&nbsp;&nbsp;&nbsp; (value 0x83) scalar_type_byte, length_32_pointer</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; CHAR_IND_386 (value 0x84) scalar_type_byte, length_48_pointer</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; CHAR_IND_LOC (value 0x85) scalar_type_byte, address_locator</tt>
<br><br>The CHAR_BYTE, CHAR_WORD, and CHAR_LONG forms are used when the length of the character string is known at compile
 time.&nbsp; Even though the length given is an unsigned quantity, the decision on which form to use is made by considering
 the value to be signed.&nbsp; The CHAR_IND form is used when the length of the string is determined at run time.&nbsp; The<tt>
 length_32_pointer</tt> gives the far address of a location containing the length of the string.&nbsp; The size of this location
 is given by the<tt> scalar_type_byte</tt>.&nbsp; The CHAR_IND_386 form is the same as CHAR_IND except that the location of
 the length is given by a 48-bit far pointer.&nbsp; The CHAR_IND_LOC form is the same as CHAR_IND except that the address
 of the length is given by a location expression.
<h2 id="Local_symbol_information"> Local symbol information </h2>
<br>The Open Watcom Debugger local symbol information is contained in a special segment in the object file.&nbsp; The segment
 name is &quot;$$SYMBOLS&quot; and the segment class is &quot;DEBSYM&quot;.&nbsp; The segment is considered to be a stream
 of variable length definitions, with each definition being preceded by a length byte.&nbsp; A number of the definitions contain
 indices of some form.&nbsp; These indices are standard Intel format, with 0 meaning no index, 1 to 127 is represented in
 one byte, 128 to 32767 in high byte/low byte form with the top bit on in the high byte.&nbsp; Character strings representing
 names are always placed at the end of a definition so that their length can be calculated by subtracting the name's start
 point from the length of the record.&nbsp; They are not preceded by a length byte or followed by a zero byte.
<br><br>The first byte identifies the kind of the symbol definition that follows.&nbsp; The top nibble of the byte is used
 to indicate the general class of the symbol definition.&nbsp; The low order nibble is used to qualify the general definition
 class.
<br><br>Symbol definitions are used to provide the Open Watcom Debugger with the location and scoping of source language local
 symbols.&nbsp; There are two general classes of symbol definition, one for variables and one for code.
<h3 id="VARIABLE_Lvalue_0x1_R"> VARIABLE (value 0x1?) </h3>
<br>This definition is used to define the location of a data symbol.&nbsp; There are 4 sub-classes.
<br><br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; MODULE&nbsp;&nbsp;&nbsp;&nbsp; (value 0x10) memory_location_32_pointer, type_index, name</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; LOCAL&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (value 0x11) address_locator, type_index, name</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; MODULE386&nbsp; (value 0x12) memory_location_48_pointer, type_index, name</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; MODULE_LOC (value 0x13) address_locator, type_index, name</tt>
<br><br>MODULE defines either an exported, domestic, or imported variable in the module.&nbsp; It is not necessary to generate
 symbol information for an imported variable since the Open Watcom Debugger will look for local symbol information in the
 module which defines the variable if required.
<br><br>LOCAL defines a symbol that is local to a code block or procedure.&nbsp; The defining block is the first one previous
 to this definition.&nbsp; Local symbols only &quot;exist&quot; for the purpose of the Open Watcom Debugger lookups when the
 program is executing in a block which defines the symbol.
<h3 id="CODE_Lvalue_0x2_R"> CODE (value 0x2?) </h3>
<br>This definition is used to define an object in the code.&nbsp; There are 6 sub-classes.
<br><br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; BLOCK&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (value 0x20) start_offset_word, size_word,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; parent_block_offset</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; NEAR_RTN&nbsp;&nbsp;&nbsp;&nbsp; (value 0x21) &lt;BLOCK&gt;, pro_size_byte, epi_size_byte,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ret_addr_offset_word, type_index,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return_val_loc, #parms_byte</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {,parm_location}, name</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; FAR_RTN&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (value 0x22) &lt;BLOCK&gt;, pro_size_byte, epi_size_byte,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ret_addr_offset_word, type_index,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return_val_loc, #parms_byte</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {,parm_location}, name</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; BLOCK_386&nbsp;&nbsp;&nbsp; (value 0x23) start_offset_dword, size_dword,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; parent_block_offset</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; NEAR_RTN_386 (value 0x24) &lt;BLOCK_386&gt;, pro_size_byte, epi_size_byte,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ret_addr_offset_dword, type_index,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return_val_loc, #parms_byte</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {,parm_location}, name</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; FAR_RTN_386&nbsp; (value 0x25) &lt;BLOCK_386&gt;, pro_size_byte, epi_size_byte,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ret_addr_offset_dword, type_index,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return_val_loc, #parms_byte</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {,parm_location}, name</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; MEMBER_SCOPE (value 0x26) parent_block_offset, class_type_index</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &#91;obj_ptr_type_byte, object_loc&#93;</tt>
<br><br>BLOCK is used to indicate a block of code that contains local symbol definitions.&nbsp; The field<tt> parent_block_offset</tt>
 is used to tell the Open Watcom Debugger the next block to search for a symbol definition if it is not found in this block.
&nbsp; The field is set to zero if there is no parent block.
<br><br>NEAR_RTN and FAR_RTN are used to specify a routine definition.&nbsp; Notice that the first part is identical to a
 code block definition.&nbsp; The<tt> ret_addr_offset_word</tt> is the offset from BP (or EBP) that the return address is
 located on the stack.&nbsp; The<tt> #parms_byte</tt> and<tt> parm_location</tt> following are only for those parms which
 are passed in registers.&nbsp; The remainder of the parms are assumed to be passed on the stack.
<br><br>The MEMBER_SCOPE record is used for C++ member functions.&nbsp; It introduces a scope where the the debugger looks
 up the fields of the class identified by<tt> class_type_index</tt> as if they were normal symbols.&nbsp; If the<tt> obj_ptr_type_byte</tt>
 and<tt> object_loc</tt> location expression portions of the record are present, it indicates that the function has a C++
 &quot;this&quot; pointer, and all fields of the class structure are accessable.&nbsp; The location expression evaluates to
 the address of the object that the member function is manipulating.&nbsp; The<tt> obj_ptr_type_byte</tt> contains a value
 from the low order nibble of a POINTER type record.&nbsp; It indicates the type of `this' pointer the routine is expecting.
&nbsp; I.e.:
<dl>
<dt><b><i>Value</i></b>
<dd><b><i>Definition</i></b>
<dt><br>0
<dd>16-bit near pointer
<dt><br>1
<dd>16-bit far pointer
<dt><br>6
<dd>32-bit near pointer
<dt><br>7
<dd>32-bit far pointer
</dl>
<br>If the portions following the<tt> class_type_index</tt> are absent from the record, the routine is a static member function
 and only has access to static data members.
<br>To use this record, the member function's<tt> parent_block_offset</tt> is pointed at the MEMBER_SCOPE record, and the
 MEMBER_SCOPE's<tt> parent_block_offset</tt> field is pointed at what the member function would normally be pointing at.&nbsp;
 In effect, a new block scope has been introduced.
<br><br>The *_386 versions of the records are identical to their 286 counterparts excepts that the<tt> start_offset</tt> ,<tt>
 size</tt> , and<tt> ret_addr_offset</tt> fields have been widened to 32 bits.
<br><br><b>NOTE:</b>&nbsp; There should be a better mapping of parm number to parm location.&nbsp; There is no provision for
 Pascal calling conventions (reversed parm order) or other strangeness.
<br><br>The BLOCK definition contains a<tt> start_offset_word</tt> (or<tt> start_offset_dword</tt> in a BLOCK_386).&nbsp;
 This is the offset from a given memory location provided by NEW_BASE entries and indicates the address of the start of executable
 code for the block.
<br><br>All the code location definitions are assumed to be sorted in order of increasing end offsets (start offset + size).
&nbsp; This ensures that the first scope that the debugger encounters in a traversal of the symbolic information is the closest
 enclosing scope.
<h3 id="NEW_BASE_Lvalue_0x3_R"> NEW_BASE (value 0x3?) </h3>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; ADD_PREV_SEG (value 0x30) seg_increment_word</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; SET_BASE&nbsp;&nbsp;&nbsp;&nbsp; (value 0x31) memory_location_32_pointer</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; SET_BASE386&nbsp; (value 0x32) memory_location_48_pointer</tt>
<br><br>For ADD_PREV_SEG, the specified amount is added to the segment value of the code start address of the module.&nbsp;
 The code start offset is reset to zero.&nbsp; All BLOCK definitions occuring after this item are relative to the new value.
&nbsp; After a SET_BASE or SET_BASE386 all BLOCK definitions are relative to the memory location that is given by the record.
<br><br><b>NOTE:</b>&nbsp; Avoid the use of the ADD_PREV_SEG record.&nbsp; Its operation is only valid in real mode.&nbsp;
 It is included for backwards compatiblity only.
<h1 id="Executable_file_structures"> Executable file structures </h1>
<br>The linker is responsible for processing the debugging information contained in the object files and some of its internal
 structures and appending them to the executable file.
<br>After linking, the executable file looks like this:
<br><br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; +-----------------------+</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; EXE file&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
 |</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; +=======================+</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Overlays&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
 |</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; +=======================+</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp; Any Other Stuff&nbsp;&nbsp;&nbsp; |</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; +=======================+&lt;--- start of debugging information</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; | source language table |</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; +-----------------------+</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; | segment address table |</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; +-----------------------+</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&lt;-\</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp; section debug info&nbsp;&nbsp; |&nbsp;&nbsp; +-- repeated for each overlay &amp;
 root</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&lt;-/</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; +-----------------------+</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp; master debug header&nbsp; |</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; +=======================+&lt;--- end of file</tt>
<br><br>The section marked as &quot;EXE file&quot; is the normal executable file.&nbsp; All debugging information is appended
 to the end of the file, after any overlay sections or other information.&nbsp; The<tt> master debug header</tt> begins at
 a fixed offset from the end of the file, and provides the location of the remainder of the debug information.&nbsp; The<tt>
 source language table</tt> contains the source languages used by the program.&nbsp; The<tt> section debug info</tt> is repeated
 once for the root and each overlay section defined in the executable.&nbsp; It contains all the debugging information for
 all object modules defined in the root or a particular overlay section.&nbsp; The<tt> section debug info</tt> is further
 divided into a number of debugging information classes, these will be explained later.&nbsp; All offsets in the debugging
 information that refer to other information items are relative to the start of the information, the start of a section of
 information, or the start of a class of the information.&nbsp; In other words, the information is not sensitive to its location
 in the executable file.
<h2 id="Master_debug_header"> Master debug header </h2>
<br>The master debug header allows the Open Watcom Debugger to verify the fact that there is debugging information, to locate
 the other sections and to verify that it is capable of handling the version of debugging information.&nbsp; The master header
 structure is as follows:
<br><br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; struct master_dbg_header {</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; unsigned_16 signature;</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; unsigned_8&nbsp; exe_major_ver;</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; unsigned_8&nbsp; exe_minor_ver;</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; unsigned_8&nbsp; obj_major_ver;</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; unsigned_8&nbsp; obj_minor_ver;</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; unsigned_16 lang_size;</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; unsigned_16 segment_size;</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; unsigned_32 debug_size;</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; };</tt>
<br><br>The<tt> signature</tt> word contains the value 0x8386.&nbsp; This is the first indication to the Open Watcom Debugger
 that there is debugging information present.&nbsp; The<tt> exe_major_ver</tt> field contains the major version number of
 the executable file debugging information structures.&nbsp; The major version number will change whenever there is a modification
 to these structures that is not upwardly compatible with the previous version.&nbsp; The current major version number is
 three.&nbsp; The<tt> exe_minor_ver</tt> field contains the minor version number of the executable file debugging information
 structures.&nbsp; The minor version number increments by one whenever there is a change to the structures which is upwardly
 compatible with the previous version.&nbsp; The current minor version number is zero.&nbsp; This means that in order for
 the Open Watcom Debugger to process the debugging information the following must be true:
<ol>
<li>FILE exe debug info major version == debugger exe debug info major version
<li>FILE exe debug info minor version &lt;= debugger exe debug info minor version
</ol>
<br>The<tt> obj_major_ver</tt> field contains the major version number of the object file debugging information structures
 (internal format of the types and local symbol information).&nbsp; The major version number will change whenever there is
 a modification to these structures that is not upwardly compatible with the previous version.&nbsp; The current major version
 number is one.&nbsp; The<tt> obj_minor_ver</tt> field contains the minor version number of the object file debugging information
 structures.&nbsp; The minor version number increments by one whenever there is a change to the structures which is upwardly
 compatible compatible with the previous version.&nbsp; The current minor version number is three.&nbsp; This means that in
 order for the debugger to process the debugging information the following must be true:
<ol>
<li>FILE obj debug info major version == debugger obj debug info major version
<li>FILE obj debug info minor version &lt;= debugger obj debug info minor version
</ol>
<br>These two fields are filled in by the linker by extracting the version information from special debug comment record in
 the processed object files.&nbsp; If two object files in the link contain different major version numbers, the linker should
 report an error or warning and not process the type or local symbol information for the 'incorrect' file.&nbsp; The minor
 version number placed in the master header should be the maximum of all the minor version numbers extracted from the object
 files.
<br><br>The<tt> lang_size</tt> field contains the size of the source language table at the beginning of the debug information.
&nbsp; The<tt> segment_size</tt> field informs the debugger of the size, in bytes, of the segment address table.&nbsp; The
 field,<tt> debug_size</tt> , gives the total size of the debugging information, including the size of the master header itself.
&nbsp; This allows the debugger to calculate the start of the debugging information by subtracting the value of the<tt> debug_size</tt>
 field from the location of the end of file.&nbsp; This gives the start of the source language and segment address tables,
 whose sizes are known from the master header.&nbsp; Once the location of the first section of debugging information is determined,
 it can be processed.&nbsp; Within the section information is a indicator of its total size, which allows the debugger to
 find the start of the next section, and process that as well.&nbsp; This continues until all the debug sections have been
 processed.&nbsp; the debugger knows there are no more debug sections to process when the indicated start of a section is
 the same as the start of the master header.
<h2 id="Source_language_table"> Source language table </h2>
<br>The source language table is merely the collection of unique source languages used in the program.&nbsp; The strings are
 extracted from the special debug comment records in the object files and placed in this section one after another with zero
 bytes separating them.
<h2 id="Segment_address_table"> Segment address table </h2>
<br>The segment address table is an array of all the unique segment numbers used by the executable.&nbsp; Essentially, any
 segment value that would appear in the map file will be represented in the table.
<h2 id="Section_debug_information"> Section debug information </h2>
<br>Each<tt> section debug info</tt> contains the following:
<br><br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; +-----------------------+</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp; section header&nbsp;&nbsp;&nbsp;&nbsp; |</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; +-----------------------+</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp; local symbols&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; +-----------------------+</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; types&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp; |</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; +-----------------------+</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp; line numbers&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; +-----------------------+</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp; module info&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; +-----------------------+</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp; global symbols&nbsp;&nbsp;&nbsp;&nbsp; |</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; +-----------------------+</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp; address info&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; +-----------------------+</tt>
<br><br>The local symbols, types and line numbers classes are demand loaded by the debugger as it requires pieces of the classes
 for various modules.&nbsp; The module info, global symbols, and address info classes are permanently loaded by the debugger
 at the start of a debugging session.&nbsp; The global symbol, module, and address info classes have no size restriction,
 however there is a limit of 65536 modules per section and there are some restrictions on how the address info class may be
 laid out.&nbsp; These restrictions are described in the section explaining the address info class.
<h3 id="Section_debug_header"> Section debug header </h3>
<br>The section header class allows the debugger to determine the size of the section information and the location of the
 permanently loaded classes.&nbsp; The header structure is as follows:
<br><br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; struct section_dbg_header {</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; unsigned_32 mod_offset;</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; unsigned_32 gbl_offset;</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; unsigned_32 addr_offset;</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; unsigned_32 section_size;</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; unsigned_16 section_id;</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; };</tt>
<br><br>The<tt> mod_offset</tt> ,<tt> gbl_offset</tt> , and<tt> addr_offset</tt> fields are offsets, from the beginning of
 the section debug header to the module info, global symbol, and address info classes of debugging information.&nbsp; The<tt>
 section_size</tt> field is the size of the debugging information for the section, including the section header.&nbsp; The
 following conditions must hold true for the debugger to recognize the debugging information as valid:
<ol>
<li>mod_offset &lt; gbl_offset
<li>gbl_offset &lt; addr_offset
<li>addr_offset &lt; section_size
</ol>
<br>The<tt> section_id</tt> field contains the overlay number for this section.&nbsp; This is zero for the root.
<h3 id="Local_symbols_class"> Local symbols class </h3>
<br>The local symbols segments are processed normally by the linker, except that the data in the segments is placed in this
 section, no relocation entries are output for any fixups in the data and fields in the module structure are intialized to
 point to the beginning and size of each object file's contribution to the section.
<h3 id="Types_class"> Types class </h3>
<br>The type segments are processed normally by the linker, except that the data in the segments is placed in this section,
 no relocation entries are output for any fixups in the data and fields in the module structure are intialized to point to
 the beginning and size of each object file's contribution to the section.
<h3 id="Line_numbers_class"> Line numbers class </h3>
<br>The LINNUM records for each object file are collected and placed in this class using an array of arrays.&nbsp; The top
 level array is the following structure:
<br><br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; struct line_segment {</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; unsigned_32&nbsp;&nbsp;&nbsp;&nbsp; segment;</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; unsigned_16&nbsp;&nbsp;&nbsp;&nbsp; num;</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; line_info&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; line&#91;1&#93;;</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; }</tt>
<br><br>The<tt> segment</tt> field contains a offset, from the start of the address info class, to an addr_info structure
 (see the address info class description).&nbsp; This provides the segment value for the array of line_info's following.&nbsp;
 The next field,<tt> num</tt> , provides the number of line_info's in the array.&nbsp; The<tt> line</tt> is a variable size
 array containing the following structure:
<br><br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; struct line_info {</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; unsigned_16&nbsp; line_number;</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; unsigned_32&nbsp; code_offset;</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; };</tt>
<br><br>The<tt> line_number</tt> contains the source line number whose offset is being defined.&nbsp; If the top bit of the
 line number is on, this line number refers to an entry in the special line number table.&nbsp; See the &quot;Special Line
 Number Table&quot; section for more details.&nbsp; The<tt> code_offset</tt> field contains the offset from the begining of
 the module for the first instruction associated with the line number.&nbsp; To get the true code address for the instruction
 you must add<tt> code_offset</tt> to the address given by the<tt> segment</tt> field in the line_segment structure.&nbsp;
 All the instructions up to the next element's<tt> code_offset</tt> , or the end of the object file's code for that segment
 if there is no next<tt> code_offset</tt> are considered to be part of the<tt> line_number</tt> source line.&nbsp; Within
 each line_segment structure the line_info array is assumed to be sorted in order of ascending<tt> code_offset</tt>.&nbsp;
 The module structure for the object file contains fields which indicate the start and size of the line_segment array within
 the class.
<br><br>Each line_segment structure may not exceed 60K, however the total amount of line information for a module may exceed
 60K with multiple line_segment structures and multiple entries in the demand link table (described in the module information
 section).
<br><br>To obtain a line number from an address, the debugger performs the following steps
<ol>
<li>Given an address, the defining module is found from the address information class.&nbsp; This allows the debugger to find
 and load the line number information for that module, if it is not already loaded.
<li>Walk down the array of line_segment structures until one with the appropriate segment is found.
<li>Binary search the array of line_info's until the proper one is located.
</ol>
<h4 id="Special_Line_Number_Table"> Special Line Number Table </h4>
<br>The OMF line number record does not allow for more than one source file to be referenced in an object file.&nbsp; This
 kludge gets around the restriction.&nbsp; If the top bit is on in<tt> line_number</tt> than that field refers to an entry
 in the special line number table.&nbsp; The debugger then searches the typing information for the module for a<tt> CUE_TABLE</tt>
 record.&nbsp; If it finds one, it uses the offset given to find the begining of the table in the typing information.&nbsp;
 The table looks like this:
<br><br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; /* cue entry table */</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; unsigned_16 cue_count</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp;&nbsp; struct {</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; unsigned_16 cue;</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; unsigned_16 fno;</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; unsigned_16 line;</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; unsigned_16 column;</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; } cue_entry; /* repeated cue_count times, sorted by the 'cue' field */</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp;&nbsp; /* file name index table */</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; unsigned_16 file_count</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp;&nbsp; struct {</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; unsigned_16 index;</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; } file_name_index_entry; /* repeated file_count times */</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp;&nbsp; /* file name table */</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; A list of zero terminated source file names</tt>
<br><br>To find the correct cue entry given the value in a<tt> line_number</tt> , search the<tt> cue_entry</tt> table for
 the cue which satisfies the following:
<br><br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; cue_entry&#91;entry&#93;.cue &lt;= (line_number &amp; 0x7fff) &lt; cue_entry&#91;entry+1&#93;.cue</tt>
<br><br>Once you have the cue entry, you can extract the true line number by:
<br><br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; line = cue_entry&#91;entry&#93;.line + (line_number &amp; 0x7fff)</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
 - cue_entry&#91;entry&#93;.cue;</tt>
<br><br>The file name is found by:
<br><br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; fname_index = file_name_index_table&#91; cue_entry&#91;entry&#93;.fno &#93;</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; fname =&nbsp; file_name_table&#91; fname_index &#93;</tt>
<br><br>The code offset and segment are found in the<tt> line_info</tt> and<tt> line_segment</tt> structures as usual.
<h3 id="Module_information_class"> Module information class </h3>
<br>The module information class is built from the linker's list of object files that it processes to build the executable
 file, which are either specified on the linker command line or extracted from libraries.&nbsp; All the modules are implicitly
 given an index number by their order in the class.&nbsp; These index numbers start at zero and are used by other classes
 to identify individual modules.&nbsp; The module structure contains the following fields:
<br><br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; struct mod_info {</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; unsigned_16 language;</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; demand_info locals;</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; demand_info types;</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; demand_info lines;</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; unsigned_8&nbsp; name&#91;1&#93;;</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; };</tt>
<br><br>The<tt> language</tt> field contains an offset, from the start of the source language table to the string of the source
 language for this module.&nbsp; The<tt> name</tt> field is a variable length array of characters with the first element of
 the array being the length of the name.&nbsp; The remaining characters identify the source file the compiler used to generate
 the object file (e.g.&nbsp; &quot;C:\DEV\WV\C\DBGMAIN.C&quot;).&nbsp; The source file name is obtained from the THEADR record
 of the object file.&nbsp; the debugger uses the file name part of the file specification as its &quot;module name&quot;.
&nbsp; The remaining fields,<tt> locals</tt> ,<tt> types</tt> , and<tt> lines</tt> are a structure type which define the location
 and size of this module's demand loaded information from those classes.&nbsp; The structure contains these fields:
<br><br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; struct demand_info {</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; unsigned_32 offset;</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; unsigned_16 num_entries;</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; };</tt>
<br><br>The<tt> offset</tt> field contains the offset from the beginning of the debugging information section to first entry
 in the demand link table containing the information for that particular demand load class.&nbsp; The<tt> num_entries</tt>
 field gives the number of contiguous entries in the demand link table that are present for the module's demand load information
 of that particular class.
<br><br>The demand link table consists of an array of unsigned_32 offsets, which are relative from the debugging information
 section, to the individual demand info class data blocks.&nbsp; The array is in ascending order of offsets so that the debugger
 may calculate the size of a particular demand load data block by subtracting the offset of the next data block from the offset
 of the current data block.&nbsp; This implies that there is an extra entry at the end of the table whose offset points to
 the end of the final demand load data block so that the debugger always has a 'next' link entry to calculate size of a data
 block with.&nbsp; The size of each individual block may not exceed 60K.&nbsp; A picture may be useful here to show how all
 the pieces fit together:
<br><br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; module info</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; class</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; +--------+</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp; demand link</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ...&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp; table&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; demand info</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp; +--------+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; data block</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; +------+</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; +--------+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ...&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; +---&gt;|&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; | offset | ---+&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;
&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ...</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; +--------+&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp; +--------+&nbsp;&nbsp; |&nbsp;&nbsp;
&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; |#entries|&nbsp;&nbsp;&nbsp; +----&gt;| offset |---+&nbsp;&nbsp;&nbsp; +------+</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; +--------+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; +--------+</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ...&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp; ...</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; +--------+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; +--------+&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp; demand info</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | offset |---+&nbsp;&nbsp;&nbsp; data block</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; +--------+&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp; +------+</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp; +---&gt;|&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp; |</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ...&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp; ...</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp; |</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; +--------+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; +------+</tt>
<br><br>When the debugger wishes to look something up in a demand load class for a module.&nbsp; It uses the offset in the
 mod_info structure to locate the array entry in the demand link table which has the offset for the first info data block.
&nbsp; It then loads the first block and searches it for the information.&nbsp; If the information is not present in that
 block, it moves to the next entry in the demand link table and repeats the above process.&nbsp; This continues until all
 the entries for that particular class of the module (identified by the<tt> num_entries</tt> field in the mod_info structure)
 have been examined, or the information is located.
<h3 id="Global_symbols_class"> Global symbols class </h3>
<br>All PUBDEF records processed by the linker create entries in this class.&nbsp; The fields in the structure are:
<br><br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; struct gbl_info {</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; addr48_ptr&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; addr;</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; unsigned_16&nbsp;&nbsp;&nbsp;&nbsp; mod_index;</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; unsigned_8&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; kind;</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; unsigned_8&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; name&#91;1&#93;;</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; };</tt>
<br><br>The<tt> addr</tt> field contains the location in memory associated with this symbol.&nbsp; The value placed in this
 field is the same that the linker places in the map file (i.e.&nbsp; unrelocated, as if the executable loads at location
 0:0).&nbsp; The field contains a 48 bit value (32 bit offset followed by a 16 bit segment).&nbsp; The<tt> mod_index</tt>
 field is an index which identifies the module which defines the symbol (i.e.&nbsp; contained the &#91;L&#93;PUBDEF record).
&nbsp; The<tt> kind</tt> gives rudimentary typing information for the symbol.&nbsp; It consists of the following set of bits:
<br><br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; BIT: 7 6 5 4 3 2 1 0</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | | | |</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | | | +--- STATIC symbol</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | | +----- DATA symbol</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | +------- CODE symbol</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; +-------+--------- unused</tt>
<br><br>Bit zero is 1 if the global was defined by a LPUBDEF record and 0 if it was defined by a PUBDEF record.&nbsp; LPUBDEF
 symbols are generated by the code generator for static symbols, so this allows a debugger to see static symbols even when
 no compiler debug switches are being used.&nbsp; Bit one is 1 if the producer of the information is able to determine that
 the symbol is a data symbol.&nbsp; Bit two is one if the producer is able to determine that the symbol is a code symbol.
&nbsp; Both bits may be zero if the producer is unable to determine whether the symbol is a code or data item.&nbsp; The final
 field,<tt> name</tt> is a variable length array, with the first character indicating the length of the name, and the remaining
 characters being the actual name of the symbol.
<h3 id="Address_information_class"> Address information class </h3>
<br>The address information class allows the debugger, given a memory address, to determine the module which defines that
 memory address.&nbsp; The linker builds this class from the SEGDEF and GRPDEF records in the object files that it processes.
&nbsp; The class consists of an array of structures with the following fields:
<br><br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; struct seg_info {</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; addr48_ptr&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; addr;</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; unsigned_16&nbsp;&nbsp;&nbsp;&nbsp; num;</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; addr_info&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; sects&#91;1&#93;;</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; };</tt>
<br><br>The<tt> addr</tt> field identifies the start of a segment in memory.&nbsp; This field contains the unrelocated value
 of the segment starting address (i.e.&nbsp; as if the executable had been loaded at 0:0).&nbsp; The the low order 15 bits
 of the next field,<tt> num</tt> tells how many of the<tt> sects</tt> entries there are in the structure.&nbsp; The top bit
 of the field is a one when the segment belongs to &quot;NonSect&quot;.&nbsp; &quot;NonSect&quot; is the overlay section which
 holds all program data that is not in the root or an overlay section.&nbsp; Typically this consists of DGROUP and FAR_DATA
 segments.&nbsp; NonSect always is located at the highest address of all sections.&nbsp; It is preloaded by the overlay manager
 and is never moved.&nbsp; If the segment does not belong to NonSect, the top bit of the<tt> num</tt> field is zero.&nbsp;
 The<tt> sects</tt> field is a variable size array of structures.&nbsp; This addr_info structure contains the following fields:
<br><br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; struct addr_info {</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; unsigned_32&nbsp;&nbsp;&nbsp;&nbsp; size;</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; unsigned_16&nbsp;&nbsp;&nbsp;&nbsp; mod_index;</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; };</tt>
<br><br>The<tt> mod_index</tt> field indicates the module in the module information class which defines this piece of the
 segment.&nbsp; The<tt> size</tt> field identifies how large a piece of the segment specified by the seg_info structure belongs
 to the module.&nbsp; The starting address of the segment piece is given by adding all the previous size fields in the<tt>
 sects</tt> array to the original starting address in the seg_info structure.
<br><br>The size of a seg_info structure may not exceed 60K.&nbsp; If a single physical segment would have more<tt> sects</tt>
 than would fit into this restriction (<tt> num</tt> greater than 10238), it should be split into two separate seg_info structures.
<br><br>To identify the module that defines a location in memory, the debugger does the following:
<ol>
<li>Walk down the array of seg_info structures until one is found with the same segment address as the location that is being
 identified.&nbsp; If no such seg_info is found, or the starting offset of the segment is greater than the offset of the memory
 location, then there is no defining module.
<li>Walk down the array of addr_info's in the seg_info structure until an entry is found whose starting offset is less than
 or equal to the memory location offset and whose ending offset is greater than the memory location offset.&nbsp; If there
 is no such entry, there is no defining module.
<li>Otherwise, the<tt> mod_offset</tt> field of the addr_info entry is added to the beginning of the module information class,
 which gives a pointer to the module structure that defines the memory location.
</ol>
<h1 id="Trap_File_Interface"> Trap File Interface </h1>
<br>The Open Watcom debugger consists of a number of separate pieces of code.&nbsp; The main executable, WD.EXE (wd on UNIX
 systems), provides a debugging `engine' and user interface.&nbsp; When the engine wishes to perform an operation upon the
 program being debugged such as reading memory or setting a breakpoint, it creates a request structure and sends it to the
 `trap file' (so called because under DOS, it contains the first level trap handlers).&nbsp; The trap file examines the request
 structure, performs the indicated action and returns a result structure to the debugger.&nbsp; The debugger and trap files
 also use Machine Architecture Description (MAD) files which abstract the CPU architecture.&nbsp; This design has the following
 benefits:
<ol>
<li>OS debugging interfaces tend to be wildly varying in how they are accessed.&nbsp; By moving all the OS specific interface
 code into the trap file and having a defined interface to access it, porting the debugger becomes much easier.
<li>By abstracting the machine architecture specifics through MAD files, it becomes possible to use one debugger for several
 target CPU architectures (such as x86 and Alpha AXP).&nbsp; Unlike most other debuggers, the Open Watcom debugger is not
 tied to a single host/target combination and if appropriate trap and MAD files are available, the debugger running on any
 host can remotely debug any target.
<li>The trap file does not have to actually perform the operation.&nbsp; Instead it could send the request out to a remote
 server by a communication link such as a serial line or LAN.&nbsp; The remote server can retrieve the request, perform the
 operation on the remote machine and send the results back via the link.&nbsp; This enables the debugger to debug applications
 in cases where there are memory constraints or other considerations which prevent the debugger proper from running on the
 remote system (such as Novell Netware 386).
</ol>
<br>This document describes the interface initially used by version 4.0 of the WATCOM debugger (shipped with the 10.0 C/C++
 and FORTRAN releases).&nbsp; It has been revised to describe changes incorporated in Watcom 11.0 release, as well as subsequent
 Open Watcom releases.&nbsp; It is expected to be modified in future releases.&nbsp; Where possible, notification of expected
 changes are given in the document, but all aspects are subject to revision.
<h2 id="Some_Definitions"> Some Definitions </h2>
<br>Next follow some general trap definitions.
<h3 id="Byte_Order"> Byte Order </h3>
<br>The trap file interface is defined to use little endian byte order.&nbsp; That is, the least significant byte is stored
 at the lowest address.&nbsp; Little endian byte order was chosen for compatibility with existing trap files and tools.&nbsp;
 Fixed byte order also eases network communication between debuggers and trap files running on machines with different byte
 order.
<h3 id="Pointer_Sizes"> Pointer Sizes </h3>
<br>In a 16-bit hosted environment such as DOS, all pointers used by the trap file are &quot;far&quot; 16:16 pointers.&nbsp;
 In a 32-bit environment such as Windows NT the pointers are &quot;near&quot; 0:32 pointers.
<h3 id="Base_Types"> Base Types </h3>
<br>A number of basic types are used in the interface.&nbsp; They are defined as follows:
<dl>
<dt><b><i>Type</i></b>
<dd><b><i>Definition</i></b>
<dt><br>unsigned_8
<dd>1 byte unsigned quantity
<dt><br>unsigned_16
<dd>2 byte unsigned quantity
<dt><br>unsigned_32
<dd>4 byte unsigned quantity
<dt><br>access_req
<dd>The first field of every request is of this type.&nbsp; It is a 1 byte field which identifies the request to be performed.
<dt><br>addr48_ptr
<dd>This type encapsulates the concept of a 16:32 pointer.&nbsp; All addresses in the debuggee memory are described with these.
&nbsp; The debugger always acts as if the debuggee were in a 32-bit large model environment since the 32-bit flat model and
 all 16-bit memory models are subsets.&nbsp; The structure is defined as follows:
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; typedef struct {</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; unsigned_32&nbsp;&nbsp;&nbsp; offset;</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; unsigned_16&nbsp;&nbsp;&nbsp; segment;</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; } addr48_ptr;</tt>
<br><br>The<tt> segment</tt> field contains the segment of the address and the<tt> offset</tt> field stores the offset of
 the address.
<dt><br>bytes
<dd>The type bytes is an array of unsigned_8.&nbsp; The length is provided by other means.&nbsp; Typically a field of type bytes
 is the last one in a request and the length is calculated from the total length of the request.
<dt><br>string
<dd>The type string is actually an array of characters.&nbsp; The array is terminated by a null ('\0') character.&nbsp; The length
 is provided by other means.&nbsp; Typically a field of type string is the last one in a request and the length is calculated
 from the total length of the request.
<dt><br>trap_error
<dd>Some trap file requests return debuggee operating system error codes, notably the requests to perform file I/O on the remote
 system.&nbsp; These error codes are returned as an unsigned_32.&nbsp; The debugger considers the value zero to indicate no
 error.
<dt><br>trap_phandle
<dd>This is an unsigned_32 type which holds process (task) handle.&nbsp; A task handle is used to uniquely identify a debuggee
 process.
<dt><br>trap_mhandle
<dd>This is an unsigned_32 type which holds a module handle.&nbsp; Typically the main executable will be one module, and on systems
 which support DLLs or shared libraries, each library will be identified by a unique module handle.
</dl>
<h1 id="The_Request_Interface"> The Request Interface </h1>
<br>Next follow detailed description of interface elements.
<h2 id="Request_Structure"> Request Structure </h2>
<br>Each request is a composed of two sequences of bytes provided by the debugger called messages.&nbsp; The first set contains
 the actual request code and whatever parameters that are required by the request.&nbsp; The second sequence is where the
 result of the operation is to be stored by the trap file.
<br><br>The two sequences need not be contiguous.&nbsp; The sequences are described to the trap file through two arrays of
 message entry structures.&nbsp; This allows the debugger to avoid unnecessary packing and unpacking of messages, since<tt>
 mx_entry</tt> can be set to point directly at parameter/result buffers.
<br><br>Multiple requests are<b> not</b> allowed in a single message.&nbsp; The<tt> mx_entry</tt> is only used to provide
 scatter/gather capabilities for one request at a time.
<br><br>The message entry structure is as follows (defined in<tt> trptypes.h</tt> ):
<br><br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; typedef struct {</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; void&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp; *ptr;</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; unsigned&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; len;</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; } mx_entry;</tt>
<br><br>The<tt> ptr</tt> is pointing to a block of data for that message entry.&nbsp; The<tt> len</tt> field gives the length
 of that block.&nbsp; One array of<tt> mx_entry</tt> describes the request message.&nbsp; The second array describes the return
 message.
<br><br>It is not legal to split a message into arbitrary pieces with mx_entries.&nbsp; Each request documents where an<tt>
 mx_entry</tt> is allowed to start with a line of dashes.
<h2 id="The_Interface_Routines"> The Interface Routines </h2>
<br>The trap file interface must provide three routines:<tt>&nbsp; TrapInit</tt> ,<tt> TrapRequest</tt> , and<tt> TrapFini</tt>.
&nbsp; How the debugger determines the address of these routines after loading a trap file, as well as the calling convention
 used, is system dependent and described later.&nbsp; These functions are prototyped in<tt> trpimp.h</tt>.
<h3 id="TrapInit"> TrapInit </h3>
<br>This function initializes the environment for proper operation of<tt> TrapRequest</tt>.
<br><br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; trap_version TRAPENTRY TrapInit(</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; char&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; *parm,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; char&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; *error,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; unsigned_8 remote</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; );</tt>
<br><br>The<tt> parm</tt> is a string that the user passes to the trap file.&nbsp; Its interpretation is completely up to
 the trap file.&nbsp; In the case of the Open Watcom debugger, all the characters following the semicolon in the<tt> /TRAP</tt>
 option are passed as the<tt> parm</tt>.&nbsp; For example:
<br><br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; wd /trap=nov;testing program</tt>
<br><br>The<tt> parm</tt> would be &quot;testing&quot;.&nbsp; Any error message will be returned in<tt> error</tt>.&nbsp;
 The<tt> remote</tt> field is a zero if the Open Watcom debugger is loading the trap file and a one if a remote server is
 loading it.&nbsp; This function returns a structure<tt> trap_version</tt> of the following form (defined in<tt> trptypes.h</tt>
 ):
<br><br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; typedef struct {</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; unsigned_8&nbsp; major;</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; unsigned_8&nbsp; minor;</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; unsigned_8&nbsp; remote;</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; } trap_version;</tt>
<br><br>The<tt> major</tt> field contains the major version number of the trap file while the<tt> minor</tt> field tells the
 minor version number of the trap file.<tt>&nbsp; Major</tt> is changed whenever there is a modification made to the trap
 file that is not upwardly compatable with previous versions.<tt>&nbsp; Minor</tt> increments by one whenever a change is
 made to the trap file that is upwardly compatible with previous versions.&nbsp; The current major verion is 1, the current
 minor version is 3.&nbsp; The<tt> remote</tt> field informs the debugger whether the trap file communicates with a remote
 machine.
<br><br><tt>TrapInit</tt> must be called before using<tt> TrapRequest</tt> to send a request.&nbsp; Failure to do so may result
 in unpredictable operation of<tt> TrapRequest</tt>.
<h3 id="TrapRequest"> TrapRequest </h3>
<br>All requests between the server and the remote trap file are handled by TrapRequest.
<br><br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; unsigned TRAPENTRY TrapRequest(</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; unsigned num_in_mx,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mx_entry *mx_in,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; unsigned num_out_mx,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mx_entry *mx_out</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; );</tt>
<br><br>The<tt> mx_in</tt> points to an array of request mx_entry's.&nbsp; The<tt> num_in_mx</tt> field contains the number
 of elements of the array.&nbsp; Similarly, the<tt> mx_out</tt> will point to an array of return mx_entry's.&nbsp; The number
 of elements will be given by the<tt> num_out_mx</tt> field.&nbsp; The total number of bytes actually filled in to the return
 message by the trap file is returned by the function (this may be less than the total number of bytes described by the<tt>
 mx_out</tt> array).
<br><br>Since every request must start with an<tt> access_req</tt> field, the minimum size of a request message is one byte.
<br><br>Some requests do not require a return message.&nbsp; In this case, the program invoking TrapRequest<b> must</b> pass
 zero for<tt> num_out_mx</tt> and NULL for<tt> mx_out</tt>.
<h4 id="Request_Example"> Request Example </h4>
<br>The request REQ_READ_MEM needs the memory address and length of memory to read as input and will return the memory block
 in the output message.&nbsp; To read 30 bytes of memory from address 0x0010:0x8000 into a buffer, we can write:
<br><br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; mx_entry&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; in&#91;1&#93;;</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; mx_entry&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; out&#91;1&#93;;</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; unsigned char&nbsp;&nbsp; buffer&#91;30&#93;;</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; struct in_msg_def {</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; access_req&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
 req;</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; addr48_ptr&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
 addr;</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; unsigned_16&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; len;</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; } in_msg = { REQ_READ_MEM, { 0x8000, 0x0010 }, sizeof( buffer ) };</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp;&nbsp; unsigned_16 mem_blk_len;</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp;&nbsp; in&#91;0&#93;.ptr = &amp;in_msg;</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; in&#91;0&#93;.len = sizeof( in_msg );</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; out&#91;0&#93;.ptr = &amp;buffer;</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; out&#91;0&#93;.len = sizeof( buffer );</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp;&nbsp; mem_blk_len = TrapRequest( 1, in, 1, out );</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp;&nbsp; if( mem_blk_length != sizeof( buffer ) ) {</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;Error in reading memory\n&quot; );</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; } else {</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;OK\n&quot; );</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; }</tt>
<br><br>The program will print &quot;OK&quot; if it has transferred 30 bytes of data from the debuggee's address space to
 the<tt> buffer</tt> variable.&nbsp; If less than 30 bytes is transfered, an error message is printed out.
<h3 id="TrapFini"> TrapFini </h3>
<br>The function terminates the link between the debugger and the trap file.&nbsp; It should be called after finishing all
 access requests.
<br><br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; void TRAPENTRY TrapFini( void );</tt>
<br><br>After calling<tt> TrapFini</tt> , it is illegal to call<tt> TrapRequest</tt> without calling<tt> TrapInit</tt> again.
<h1 id="The_Requests"> The Requests </h1>
<br>This section descibes the individual requests, their parameters, and their return values.&nbsp; A line of dashes indicates
 where an<tt> mx_entry</tt> is allowed (but not required) to start.&nbsp; The debugger allows (via REQ_GET_SUPPLEMENTARY_SERVICE/REQ_PERFORM_SUPPLEMENTARY_SERVICE)
 optional components to be implemented only on specific systems.
<br>The numeric value of the request which is placed in the<tt> req</tt> field follows the symbolic name in parentheses.
<h2 id="Core_Requests"> Core Requests </h2>
<br>These requests need to be implemented in all versions of the trap file, although some of them may only be stub implementations
 in some environments.&nbsp; Note that structures suitable for individual requests are declared in<tt> trpcore.h</tt>.
<h3 id="REQ_CONNECT"> REQ_CONNECT </h3>
<br>Request to connect to the remote machine.&nbsp; This must be the first request made.
<br><br>Request message:
<br><br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; access_req&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; req</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; unsigned_8&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; major;&nbsp;&nbsp; &lt;-+- struct trap_version</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; unsigned_8&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; minor;&nbsp;&nbsp;&nbsp;&nbsp; |</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; unsigned_8&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; remote;&nbsp; &lt;-+</tt>
<br><br>The<tt> req</tt> field contains the request.&nbsp; The<tt> trap_version</tt> structure tells the version of the program
 making the request.&nbsp; The<tt> major</tt> field contains the major version number of the trap file while the<tt> minor</tt>
 field tells the minor version number of the trap file.&nbsp; The<tt> major</tt> is changed whenever there is a modification
 made to the trap file that is not upwardly compatable with previous versions.&nbsp; The<tt> minor</tt> increments by one
 whenever a change is made to the trap file that is upwardly compatable with previous versions.&nbsp; The current major version
 is 1, the current minor version is 3.&nbsp; The<tt> remote</tt> field informs the trap file whether a remote server is between
 the Open Watcom debugger and the trap file.
<br><br>Return message:
<br><br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; unsigned_16 max_msg_size</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; ----------------------------</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; err_msg</tt>
<br><br>If error has occurred, the<tt> err_msg</tt> field will returns the error message string.&nbsp; If there is no error,<tt>
 error_msg</tt> returns a null character and the field<tt> max_msg_size</tt> will contain the allowed maximum size of a message
 in bytes.&nbsp; Any message (typically reading/writing memory or files) which would require more than the maximum number
 of bytes to transmit or receive must be broken up into multiple requests.&nbsp; The minimum acceptable value for this field
 is 256.
<h3 id="REQ_DISCONNECT"> REQ_DISCONNECT </h3>
<br>Request to terminate the link between the local and remote machine.&nbsp; After this request, a REQ_CONNECT must be the
 next one made.
<br><br>Request message:
<br><br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; access_req&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; req</tt>
<br><br>The<tt> req</tt> field contains the request.
<br><br>Return message:
<br><br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; NONE</tt>
<h3 id="REQ_SUSPEND"> REQ_SUSPEND </h3>
<br>Request to suspend the link between the server and the remote trap file.&nbsp; The debugger issues this message just before
 it spawns a sub-shell (the &quot;system&quot; command).&nbsp; This allows a remote server to enter a state where it allows
 other trap files to connect to it (normally, once a remote server has connected to a trap file, the remote link will fail
 any other attempts to connect to it).&nbsp; This allows the user for instance to start up an RFX process and transfer any
 missing files to the remote machine before continuing the debugging process.
<br><br>Request message:
<br><br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; access_req&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; req</tt>
<br><br>The<tt> req</tt> field contains the request.
<br><br>Return message:
<br><br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; NONE</tt>
<h3 id="REQ_RESUME"> REQ_RESUME </h3>
<br>Request to resume the link between the server and the remote trap file.&nbsp; The debugger issues this request when the
 spawned sub-shell exits.
<br><br>Request message:
<br><br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; access_req&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; req</tt>
<br><br>The<tt> req</tt> field contains the request.
<br><br>Return message:
<br><br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; NONE</tt>
<h3 id="REQ_GET_SUPPLEMENTARY_SERVICE"> REQ_GET_SUPPLEMENTARY_SERVICE </h3>
<br>Request to obtain a supplementary service id.
<br><br>Request message:
<br><br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; access_req&nbsp; req</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; ------------------------</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; service_name</tt>
<br><br>The<tt> req</tt> field contains the request.&nbsp; The<tt> service_name</tt> field contains a string identifying the
 supplementary service.&nbsp; This string is case insensitive.
<br><br>Return message:
<br><br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; trap_error&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; err;</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; trap_shandle&nbsp;&nbsp;&nbsp; id;</tt>
<br><br>The err field is non-zero if something went wrong in obtaining or initializing the service.<tt>&nbsp; Id</tt> is the
 identifier for a particular supplementary service.&nbsp; It need not be the same from one invocation of the trap file to
 another.&nbsp; If both it and the<tt> err</tt> field are zero, it means that the service is not available from this trap
 file.
<br><br><b>NOTE:</b>&nbsp; integrated with the debugger.&nbsp; There would be two components, one to be added to the debugger
 and one to be added to the trap file.&nbsp; The two pieces could communicate with each other via the supplementary services
 mechanism.
<h3 id="REQ_PERFORM_SUPPLEMENTARY_SERVICE"> REQ_PERFORM_SUPPLEMENTARY_SERVICE </h3>
<br>Request to perform a supplementary service.
<br><br>Request message:
<br><br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; access_req&nbsp; req</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; unsigned_32 service_id</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; ------------------------</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; unspecified</tt>
<br><br>The<tt> req</tt> field contains the request.&nbsp; The<tt> service_id</tt> field indicates which service is being
 requested.&nbsp; The remainder of the request is specified by the individual supplementary service provider.
<br><br>Return message:
<br><br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; unspecified</tt>
<br><br>The return message is specified by the individual supplementary service provider.
<h3 id="REQ_GET_SYS_CONFIG"> REQ_GET_SYS_CONFIG </h3>
<br>Request to get system information from the remote machine.
<br><br>Request message:
<br><br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; access_req&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; req</tt>
<br><br>The<tt> req</tt> field contains the request.
<br><br>Return message:
<br><br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; unsigned_8&nbsp; cpu;</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; unsigned_8&nbsp; fpu;</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; unsigned_8&nbsp; osmajor;</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; unsigned_8&nbsp; osminor;</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; unsigned_8&nbsp; os;</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; unsigned_8&nbsp; huge_shift;</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; mad_handle&nbsp; mad;</tt>
<br><br>The<tt> mad</tt> field specifies the MAD (Machine Architecture Description) in use and determines how the other fields
 will be interpreted.&nbsp; Currently the following MADs are used:
<br><br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; MAD_X86&nbsp; - Intel Architecture IA-32 compatible</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; MAD_X64&nbsp; - Intel Architecture X64 compatible</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; MAD_AXP&nbsp; - Alpha Architecture</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; MAD_PPC&nbsp; - PowerPC Architecture</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; MAD_MIPS - MIPS Architecture</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; MAD_MSJ&nbsp; - Java Virtual Machine (Microsoft)</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; MAD_JVM&nbsp; - Java Virtual Machine (Sun)</tt>
<br><br>The<tt> cpu</tt> fields returns the type of the remote CPU.&nbsp; The size of that field is unsigned_8.&nbsp; Possible
 CPU types for MAD_X86 are:
<br><br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; bits 0-3</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; X86_86&nbsp; = 0&nbsp;&nbsp; - 8086</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; X86_186 = 1&nbsp;&nbsp; - 80186</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; X86_286 = 2&nbsp;&nbsp; - 80286</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; X86_386 = 3&nbsp;&nbsp; - 80386</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; X86_486 = 4&nbsp;&nbsp; - 80486</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; X86_586 = 5&nbsp;&nbsp; - Pentium</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; X86_686 = 6&nbsp;&nbsp; - Pentium Pro/II/III</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; X86_P4&nbsp; = 15&nbsp; - Pentium 4</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; bit&nbsp; 4&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; - MMX registers</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; bit&nbsp; 5&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; - XMM registers</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; bits 6&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; - unused</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; bits 7&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; - unused</tt>
<br><br>The<tt> fpu</tt> fields tells the type of FPU.&nbsp; The size of the field is unsigned_8.&nbsp; FPU types for MAD_X86
 include:
<br><br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; X86_EMU = -1&nbsp;&nbsp;&nbsp;&nbsp; - Software emulated FPU</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; X86_NO&nbsp; =&nbsp; 0&nbsp;&nbsp;&nbsp;&nbsp; - No FPU</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; X86_87&nbsp; =&nbsp; 1&nbsp;&nbsp;&nbsp;&nbsp; - 8087</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; X86_287 =&nbsp; 2&nbsp;&nbsp;&nbsp;&nbsp; - 80287</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; X86_387 =&nbsp; 3&nbsp;&nbsp;&nbsp;&nbsp; - 80387</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; X86_487 =&nbsp; 4&nbsp;&nbsp;&nbsp;&nbsp; - 486 integrated FPU</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; X86_587 =&nbsp; 5&nbsp;&nbsp;&nbsp;&nbsp; - Pentium integrated FPU</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; X86_587 =&nbsp; 6&nbsp;&nbsp;&nbsp;&nbsp; - Pentium Pro/II/III integrated FPU</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; X86_P47 =&nbsp; 15&nbsp;&nbsp;&nbsp; - Pentium 4 integrated FPU</tt>
<br><br>The<tt> osmajor</tt> and<tt> osminor</tt> contains the major and minor version number for the operating system of
 the remote machine.&nbsp; The type of operating system can be found in<tt> os</tt> field.&nbsp; The size of this field is
 unsigned_8.&nbsp; The OS can be:
<br><br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; OS_IDUNNO&nbsp;&nbsp;&nbsp; =&nbsp; 0&nbsp;&nbsp; - Unknown operating system</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; OS_DOS&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; =&nbsp; 1&nbsp;&nbsp; - DOS</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; OS_OS2&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; =&nbsp; 2&nbsp;&nbsp; - OS/2</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; OS_PHAR&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; =&nbsp; 3&nbsp;&nbsp; - Phar Lap 386 DOS Extender</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; OS_ECLIPSE&nbsp;&nbsp; =&nbsp; 4&nbsp;&nbsp; - Eclipse 386 DOS Extender (obsolete)</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; OS_NW386&nbsp;&nbsp;&nbsp;&nbsp; =&nbsp; 5&nbsp;&nbsp; - NetWare 386</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; OS_QNX&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; =&nbsp; 6&nbsp;&nbsp; - QNX 4.x</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; OS_RATIONAL&nbsp; =&nbsp; 7&nbsp;&nbsp; - DOS/4G or compatible</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; OS_WINDOWS&nbsp;&nbsp; =&nbsp; 8&nbsp;&nbsp; - Windows 3.x</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; OS_PENPOINT&nbsp; =&nbsp; 9&nbsp;&nbsp; - PenPoint (obsolete)</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; OS_NT&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; = 10&nbsp;&nbsp; - Win32</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; OS_AUTOCAD&nbsp;&nbsp; = 11&nbsp;&nbsp; - ADS/ADI development (obsolete)</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; OS_NEUTRINO&nbsp; = 12&nbsp;&nbsp; - QNX 6.x</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; OS_LINUX&nbsp;&nbsp;&nbsp;&nbsp; = 13&nbsp;&nbsp; - Linux</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; OS_FREEBSD&nbsp;&nbsp; = 14&nbsp;&nbsp; - FreeBSD</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; OS_WIN64&nbsp;&nbsp;&nbsp;&nbsp; = 15&nbsp;&nbsp; - Windows 64-bit</tt>
<br><br>The<tt> huge_shift</tt> field is used to determine the shift needed for huge arithmetic in that system.&nbsp; It stores
 the number of left shifts required in order to calculate the next segment correctly.&nbsp; It is 12 for real mode programs.
&nbsp; The value in a protect mode environment must be obtained from the OS of the debuggee machine.&nbsp; This field is only
 relevant for 16-bit segmented architectures.
<h3 id="REQ_MAP_ADDR"> REQ_MAP_ADDR </h3>
<br>Request to map the input address to the actual address of the remote machine.&nbsp; The addresses in the symbolic information
 provided by the linker do not reflect any relocation performed on the executable by the system loader.&nbsp; This request
 obtains that relocation information so that the debugger can update its addresses.
<br><br>Request message:
<br><br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; access_req&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; req;</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; addr48_ptr&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; in_addr;</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; trap_mhandle&nbsp;&nbsp;&nbsp; mod_handle;</tt>
<br><br>The<tt> req</tt> field contains the request.&nbsp; The<tt> in_addr</tt> tells the address to map.&nbsp; The<tt> mod_handle</tt>
 field identifies the module which the address is from.&nbsp; The value from this field is obtained by REQ_PROG_LOAD or REQ_GET_LIB_NAME.
&nbsp; There are two magical values for the<tt> in_addr.segment</tt> field.
<br><br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; MAP_FLAT_CODE_SELECTOR&nbsp; = -1</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; MAP_FLAT_DATA_SELECTOR&nbsp; = -2</tt>
<br><br>When the<tt> in_addr.segment</tt> equals one of these values, the debugger does not have a map segment value and is
 requesting that the trap file performs the mapping as if the given offset was in the flat address space.
<br><br>Return message:
<br><br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; addr48_ptr&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; out_addr</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; addr48_off&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; lo_bound;</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; addr48_off&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; hi_bound;</tt>
<br><br>The mapped address is returned in<tt> out_addr</tt>.&nbsp; Note that in addition to the segment portion being modified,
 the offset of the portion of the address may be adjusted as well if the loader performs offset relocations (like OS/2 2.x
 or Windows NT).&nbsp; The<tt> lo_bound</tt> and<tt> hi_bound</tt> fields identify the lowest and highest input offsets for
 which this mapping is valid.&nbsp; If the debugger needs to map another address whose input segment value is the same as
 a previous request, and the input offset falls within the valid range identified by the return of that previous request,
 it can perform the mapping itself and not bother sending the request to the trap file.
<h3 id="REQ_CHECKSUM_MEM"> REQ_CHECKSUM_MEM </h3>
<br>Request to calculate the checksum for a block of memory in the debuggee's address space.&nbsp; This is used by the debugger
 to determine if the contents of the memory block have changed since the last time it was read.&nbsp; Since only a four byte
 checksum has to be transmitted back, it is more efficient than actually reading the memory again.&nbsp; The debugger does
 not care how the checksum is calculated.
<br><br>Request message:
<br><br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; access_req&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; req;</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; addr48_ptr&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; in_addr;</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; unsigned_16&nbsp;&nbsp;&nbsp;&nbsp; len;</tt>
<br><br>The<tt> req</tt> field stores the request.&nbsp; The<tt> in_addr</tt> contains the starting address and the<tt> len</tt>
 field tells how large the block of memory is.
<br><br>Return message:
<br><br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; unsigned_32&nbsp;&nbsp;&nbsp;&nbsp; result</tt>
<br><br>The checksum will be returned in<tt> result</tt>.
<h3 id="REQ_READ_MEM"> REQ_READ_MEM </h3>
<br>Request to read a block of memory.
<br><br>Request message:
<br><br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; access_req&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; req;</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; addr48_ptr&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mem_addr;</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; unsigned_16&nbsp;&nbsp;&nbsp;&nbsp; len;</tt>
<br><br>The<tt> mem_addr</tt> contains the address of the memory block to read from the remote machine.&nbsp; The length of
 the block is determined by<tt> len</tt>.&nbsp; The memory data will be copied to output message.
<br><br>Return message:
<br><br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; bytes&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; data</tt>
<br><br>The<tt> data</tt> field stores the memory block read in.&nbsp; The length of this memory block is given by the return
 value from TrapRequest.&nbsp; If error has occurred in reading memory, the length of the data returns will not be equal to
 the number of bytes requested.
<h3 id="REQ_WRITE_MEM"> REQ_WRITE_MEM </h3>
<br>Request to write a block of memory.
<br><br>Request message:
<br><br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; access_req&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; req</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; addr48_ptr&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mem_addr</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; ------------------------</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; bytes&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; data</tt>
<br><br>The<tt> data</tt> field stores the memory data to be transferred.&nbsp; The data will be stored in the debuggee's
 address space starting at the address in the<tt> mem_addr</tt> field.
<br><br>Return message:
<br><br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; unsigned_16 len</tt>
<br><br>The<tt> len</tt> field tells the length of memory block actually written to the debuggee machine.&nbsp; If error has
 occurred in writing the memory, the length returned will not be equal to the number of bytes requested.
<h3 id="REQ_READ_IO"> REQ_READ_IO </h3>
<br>Request to read data from I/O address space of the debuggee.
<br><br>Request message:
<br><br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; access_req&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; req</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; unsigned_32&nbsp;&nbsp;&nbsp;&nbsp; IO_offset</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; unsigned_8&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; len</tt>
<br><br>The<tt> IO_offset</tt> contains the I/O address of the debuggee machine.&nbsp; The length of the block is determined
 by<tt> len</tt>.&nbsp; It must be 1, 2 or 4 bytes.&nbsp; The data will be copied from<tt> IO_offset</tt> to the return message.
<br><br>Return message:
<br><br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; bytes&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; data</tt>
<br><br>The<tt> data</tt> field stores the memory block read in.&nbsp; The length of this memory block is given by the return
 value from TrapRequest.&nbsp; If an error has occurred in reading, the length returned will not be equal to the number of
 bytes requested.
<h3 id="REQ_WRITE_IO"> REQ_WRITE_IO </h3>
<br>Request to write data to the I/O address space of the debuggee.
<br><br>Request message:
<br><br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; access_req&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; req</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; unsigned_32&nbsp;&nbsp;&nbsp;&nbsp; IO_offset</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; -------------------------</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; bytes&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; data</tt>
<br><br>The<tt> IO_offset</tt> contains the I/O address of the debuggee machine.&nbsp; The data stored in<tt> data</tt> field
 will be copied to<tt> IO_offset</tt> on the debuggee machine.
<br><br>Return message:
<br><br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; unsigned_8&nbsp; len</tt>
<br><br>The<tt> len</tt> field tells the number of bytes actually written out.&nbsp; If an error has occurred in writing,
 the length returned will not be equal to the number of bytes requested.
<h3 id="REQ_PROG_GODREQ_PROG_STEP"> REQ_PROG_GO/REQ_PROG_STEP </h3>
<br>Requests to execute the debuggee.&nbsp; REQ_PROG_GO causes the debuggee to resume execution, while REQ_PROG_STEP requests
 only a single machine instruction to be executed before returning.&nbsp; In either case, this request will return when a
 breakpoint, watchpoint, machine exception or other significant event has been encountered.&nbsp; While executing, a trap
 file is allowed to return spurious COND_WATCH indications.&nbsp; The debugger always checks its own watchpoint table for
 changes before reporting to the user.&nbsp; This means that a legal implementation of a trap file (but<b> very</b> inefficient)
 can just single step the program and return COND_WATCH for every instruction when there are active watchpoints present.
<br><br>Request message:
<br><br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; access_req&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; req</tt>
<br><br>The request is in<tt> req</tt> field.
<br><br>Return message:
<br><br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; addr48_ptr&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; stack_pointer</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; addr48_ptr&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; program_counter</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; unsigned_16&nbsp;&nbsp;&nbsp;&nbsp; conditions</tt>
<br><br>The<tt> stack_pointer</tt> and<tt> program_counter</tt> fields store the latest values of SS:ESP and CS:EIP (or their
 non-x86 equivalents) respectively.&nbsp; The<tt> conditions</tt> informs the debugger what conditions have changed since
 execution began.&nbsp; It contains the following flags:
<br><br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; Bit 0&nbsp;&nbsp; : COND_CONFIG&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
 - Configurations change</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; Bit 1&nbsp;&nbsp; : COND_SECTIONS&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; - Program
 overlays change</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; Bit 2&nbsp;&nbsp; : COND_LIBRARIES&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; - Libraries
 (DLL) change</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; Bit 3&nbsp;&nbsp; : COND_ALIASING&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; - Alias
 change</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; Bit 4&nbsp;&nbsp; : COND_THREAD&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
 - Thread change</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; Bit 5&nbsp;&nbsp; : COND_THREAD_EXTRA&nbsp;&nbsp;&nbsp;&nbsp; - Thread extra change</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; Bit 6&nbsp;&nbsp; : COND_TRACE&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp; - Trace point occurred</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; Bit 7&nbsp;&nbsp; : COND_BREAK&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp; - Break point occurred</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; Bit 8&nbsp;&nbsp; : COND_WATCH&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp; - Watch point occurred</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; Bit 9&nbsp;&nbsp; : COND_USER&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp; - User interrupt</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; Bit 10&nbsp; : COND_TERMINATE&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; - Program terminated</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; Bit 11&nbsp; : COND_EXCEPTION&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; - Machine exception</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; Bit 12&nbsp; : COND_MESSAGE&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; - Message
 to be displayed</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; Bit 13&nbsp; : COND_STOP&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp; - Debuggee wants to stop</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; Bit 14&nbsp; : COND_RUNNING&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; - Debuggee
 is running</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; Bit 15&nbsp; : not used</tt>
<br><br>When a bit is off, the debugger avoids having to make additional requests to determine the new state of the debuggee.
&nbsp; If the trap file is not sure that a particular item has changed, or if it is expensive to find out, it should just
 turn the bit on.
<h3 id="REQ_PROG_LOAD"> REQ_PROG_LOAD </h3>
<br>Request to load a program.
<br><br>Request message:
<br><br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; access_req&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; req</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; unsigned_8&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; true_argv</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; -------------------------</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; bytes&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; argv</tt>
<br><br>The<tt> true_argv</tt> field indicates whether the argument consists of a single string, or a true C-style argument
 vector.&nbsp; This field is set to be one for a true argument vector and zero otherwise.&nbsp; The<tt> argv</tt> is a set
 of zero-terminated strings, one following each other.&nbsp; The first string gives the name of the program to be loaded.
&nbsp; The remainder of the<tt> argv</tt> field contains the program's arguments.&nbsp; The arguments can be a single string
 or an array of strings.
<br><br>Return message:
<br><br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; trap_error&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; err</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; trap_phandle&nbsp;&nbsp;&nbsp; task_id</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; trap_mhandle&nbsp;&nbsp;&nbsp; mod_handle</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; unsigned_8&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; flags</tt>
<br><br>The<tt> err</tt> field returns the error code while loading the program.&nbsp; The<tt> task_id</tt> shows the task
 (process) ID for the program loaded.&nbsp; The<tt> mod_handle</tt> is the system module identification for the executable
 image.&nbsp; It is used as input to the REQ_MAP_ADDR request.&nbsp; The<tt> flags</tt> field contains the following information:
<br><br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; Bit 0&nbsp;&nbsp; : LD_FLAG_IS_BIG&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp; - 32-bit program (obsolete)</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; Bit 1&nbsp;&nbsp; : LD_FLAG_IS_PROT&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp; - Protected mode (obsolete)</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; Bit 2&nbsp;&nbsp; : LD_FLAG_IS_STARTED&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; - Program
 already started</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; Bit 3&nbsp;&nbsp; : LD_FLAG_IGNORE_SEGMENTS&nbsp;&nbsp; - Ignore segments (flat)</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; Bit 4&nbsp;&nbsp; : LD_FLAG_HAVE_RUNTIME_DLLS - DLL load breaks supported</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; Bit 5&nbsp;&nbsp; : LD_FLAG_DISPLAY_DAMAGED&nbsp;&nbsp; - Debugger must repaint screen</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; Bit 6&nbsp;&nbsp; : not used</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; Bit 7&nbsp;&nbsp; : not used</tt>
<h3 id="REQ_PROG_KILL"> REQ_PROG_KILL </h3>
<br>Request to kill the program.
<br><br>Request message:
<br><br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; access_req&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; req</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; trap_phandle&nbsp;&nbsp;&nbsp; task_id</tt>
<br><br>The<tt> req</tt> field contains the request.&nbsp; The<tt> task_id</tt> field (obtained from REQ_PROG_LOAD) identifies
 the program to be killed.
<br><br>Return message:
<br><br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; trap_error&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; err</tt>
<br><br>The<tt> err</tt> field returns the error code of the OS kill program operation.
<h3 id="REQ_SET_WATCH"> REQ_SET_WATCH </h3>
<br>Request to set a watchpoint at the address given.
<br><br>Request message:
<br><br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; access_req&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; req</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; addr48_ptr&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; watch_addr</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; unsigned_8&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; size</tt>
<br><br>The address of the watchpoint is given by the<tt> watch_addr</tt> field.&nbsp; The<tt> size</tt> field gives the number
 of bytes to be watched.
<br><br>Return message:
<br><br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; trap_error&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; err</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; unsigned_32&nbsp;&nbsp;&nbsp;&nbsp; multiplier</tt>
<br><br>The<tt> err</tt> field returns the error code if the setting failed.&nbsp; If the setting of the watchpoint worked,
 the 31 low order bits of<tt> multiplier</tt> indicate the expected slow down of the program when it's placed into execution.
&nbsp; The top bit of the field is set to one if a debug register is being used for the watchpoint, and zero if the watchpoint
 is being done by software.
<h3 id="REQ_CLEAR_WATCH"> REQ_CLEAR_WATCH </h3>
<br>Request to clear a watchpoint at the address given.&nbsp; The trap file may assume all watch points are cleared at once.
<br><br>Request message:
<br><br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; access_req&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; req</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; addr48_ptr&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; watch_addr</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; unsigned_8&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; size</tt>
<br><br>The address of the watch point is given by the<tt> watch_addr</tt> field.&nbsp; The<tt> size</tt> field gives the
 size of the watch point.
<br><br>Return message:
<br><br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; NONE</tt>
<h3 id="REQ_SET_BREAK"> REQ_SET_BREAK </h3>
<br>Request to set a breakpoint at the address given.
<br><br>Request message:
<br><br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; access_req&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; req</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; addr48_ptr&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break_addr</tt>
<br><br>The address of the break point is given by the<tt> break_addr</tt> field.
<br><br>Return message:
<br><br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; unsigned_32&nbsp;&nbsp;&nbsp;&nbsp; old</tt>
<br><br>The<tt> old</tt> field returns the original byte(s) at the address<tt> break_addr</tt>.
<h3 id="REQ_CLEAR_BREAK"> REQ_CLEAR_BREAK </h3>
<br>Request to clear a breakpoint at the address given.&nbsp; The trap file may assume all breakpoints are cleared at once.
<br><br>Request message:
<br><br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; access_req&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; req</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; addr48_ptr&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break_addr</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; unsigned_32&nbsp;&nbsp;&nbsp;&nbsp; old</tt>
<br><br>The address of the break point is given by the<tt> break_addr</tt> field.&nbsp; The<tt> old</tt> field holds the old
 instruction returned from the REQ_SET_BREAK request.
<br><br>Return message:
<br><br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; NONE</tt>
<h3 id="REQ_GET_NEXT_ALIAS"> REQ_GET_NEXT_ALIAS </h3>
<br>Request to get alias information for a segment.&nbsp; In some protect mode environments (typically 32-bit flat) two different
 selectors may refer to the same physical memory.&nbsp; Which selectors do this is important to the debugger in certain cases
 (so that symbolic information is properly displayed).
<br><br>Request message:
<br><br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; access_req&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; req</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; unsigned_16&nbsp;&nbsp;&nbsp;&nbsp; seg</tt>
<br><br>The<tt> seg</tt> field contains the segment.&nbsp; To get the first alias, put zero in this field.
<br><br>Return message:
<br><br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; unsigned_16&nbsp;&nbsp;&nbsp;&nbsp; seg</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; unsigned_16&nbsp;&nbsp;&nbsp;&nbsp; alias</tt>
<br><br>The<tt> seg</tt> field contains the next segment where an alias appears.&nbsp; If this field returns zero, it implies
 no more aliases can be found.&nbsp; The<tt> alias</tt> field returns the alias of the input segment.&nbsp; Zero indicates
 a previously set alias should be deleted.
<h3 id="REQ_SET_USER_SCREEN"> REQ_SET_USER_SCREEN </h3>
<br>Request to make the debuggee's screen visible.
<br><br>Request message:
<br><br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; access_req&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; req</tt>
<br><br>Return message:
<br><br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; NONE</tt>
<h3 id="REQ_SET_DEBUG_SCREEN"> REQ_SET_DEBUG_SCREEN </h3>
<br>Request to make the debugger's screen visible.
<br><br>Request message:
<br><br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; access_req&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; req</tt>
<br><br>Return message:
<br><br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; NONE</tt>
<h3 id="REQ_READ_USER_KEYBOARD"> REQ_READ_USER_KEYBOARD </h3>
<br>Request to read the remote keyboard input.
<br><br>Request message:
<br><br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; access_req&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; req</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; unsigned_16&nbsp;&nbsp;&nbsp;&nbsp; wait</tt>
<br><br>The request will be time out if it waits longer than the period specifies in the<tt> wait</tt> field.&nbsp; The waiting
 period is measured in seconds.&nbsp; A value of zero means to wait forever.
<br><br>Return message:
<br><br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; unsigned_8&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; key</tt>
<br><br>The<tt> key</tt> field returns the input character from remote machine.
<h3 id="REQ_GET_LIB_NAME"> REQ_GET_LIB_NAME </h3>
<br>Request to get the name of a newly loaded library (DLL).
<br><br>Request message:
<br><br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; access_req&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; req</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; trap_mhandle&nbsp;&nbsp;&nbsp; mod_handle</tt>
<br><br>The<tt> mod_handle</tt> field contains the library handle.&nbsp; It should be zero to get the name of the first DLL
 or the value from the<tt> mod_handle</tt> of a previous request.
<br><br>Return message:
<br><br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; trap_mhandle&nbsp;&nbsp;&nbsp; mod_handle</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; ---------------------------</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; name</tt>
<br><br>The<tt> mod_handle</tt> field contains the library handle.&nbsp; It contains zero if there are no more DLL names to
 be returned.&nbsp; The name of the library will be returned in<tt> name</tt> field.&nbsp; If the<tt> name</tt> field is an
 empty string (consists just of the '\0' character), then this is a indication that the DLL indicated by the given handle
 has been unloaded, and the debugger should remove any symbolic information for the image.&nbsp; It is an error to attempt
 to remove a handle that has not been loaded in a previous REQ_GET_LIB_NAME request.
<h3 id="REQ_GET_ERR_TEXT"> REQ_GET_ERR_TEXT </h3>
<br>Request to get the error message text for an error code.
<br><br>Request message:
<br><br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; access_req&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; req</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; trap_error&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; err</tt>
<br><br>The<tt> err</tt> field contains the error code number of the error text requested.
<br><br>Return message:
<br><br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; error_msg</tt>
<br><br>The error message text will be returned in<tt> error_msg</tt> field.
<h3 id="REQ_GET_MESSAGE_TEXT"> REQ_GET_MESSAGE_TEXT </h3>
<br>Request to retrieve generic message text.&nbsp; After a REQ_PROG_LOAD, REQ_PROG_GO or REQ_PROG_STEP has returned with
 COND_MESSAGE or COND_EXCEPTION, the debugger will make this request to obtain the message text.&nbsp; In the case of a COND_EXCEPTION
 return text describing the machine exception that caused the return to the debugger.&nbsp; Otherwise return whatever generic
 message text that the trap file wants to display to the user.
<br><br>Request message:
<br><br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; access_req&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; req</tt>
<br><br>Return message:
<br><br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; unsigned_8&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; flags</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; ---------------------</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; msg</tt>
<br><br>The message text will be returned in the<tt> msg</tt> field.&nbsp; The<tt> flags</tt> contains a number of bits which
 control the next action of the debugger.&nbsp; They are:
<br><br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; Bit 0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; : MSG_NEWLINE</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; Bit 1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; : MSG_MORE</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; Bit 2&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; : MSG_WARNING</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; Bit 3&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; : MSG_ERROR</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; Bit 4&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; : not used</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; Bit 5&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; : not used</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; Bit 6&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; : not used</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; Bit 7&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; : not used</tt>
<br><br>The MSG_NEWLINE bit indicates that the debugger should scroll its display to a new line after displaying the message.
&nbsp; The MSG_MORE bit indicates that there is another line of output to come and the debugger should make another REQ_GET_MESSAGE_TEXT.
&nbsp; MSG_WARNING indicates that the message is a warning level message while MSG_ERROR is an error level message.&nbsp;
 If neither of these bits are on, the message is merely informational.
<h3 id="REQ_REDIRECT_STDINDREQ_REDIRECT_STDOUT"> REQ_REDIRECT_STDIN/REQ_REDIRECT_STDOUT </h3>
<br>Request to redirect the standard input (REQ_REDIRECT_STDIN) or standard output (REQ_REDIRECT_STDOUT) of the debuggee.
<br><br>Request message:
<br><br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; access_req&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; req</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; ------------------------</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; name</tt>
<br><br>The file name to be redirected to/from is given by the<tt> name</tt> field.
<br><br>Return message:
<br><br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; trap_error&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; err</tt>
<br><br>When an error has occurred, the<tt> err</tt> field contains an error code indicating the type of error that has been
 detected.
<h3 id="REQ_SPLIT_CMD"> REQ_SPLIT_CMD </h3>
<br>Request to split the command line into the command name and parameters.
<br><br>Request message:
<br><br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; access_req&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; req</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; ------------------------</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cmd</tt>
<br><br>The<tt> cmd</tt> field contains the command.&nbsp; Command can be a single command line or an array of command strings.
<br><br>Return message:
<br><br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; unsigned_16&nbsp;&nbsp;&nbsp;&nbsp; cmd_end</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; unsigned_16&nbsp;&nbsp;&nbsp;&nbsp; parm_start</tt>
<br><br>The<tt> cmd_end</tt> field tells the position in command line where the command name ends.&nbsp; The<tt> parm_start</tt>
 field stores the position where the program arguments begin.
<h3 id="REQ_READ_REGS"> REQ_READ_REGS </h3>
<br>Request to read CPU register contents.&nbsp; The data returned depends on the target architecture and is defined by the
 MAD file.
<br><br>Request message:
<br><br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; access_req&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; req</tt>
<br><br>Return message:
<br><br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; unspecified</tt>
<br><br>The return message content is specific to the MAD in use and will contain a<tt> mad_registers</tt> union (defined
 in<tt> madtypes.h</tt> ).
<h3 id="REQ_WRITE_REGS"> REQ_WRITE_REGS </h3>
<br>Request to write CPU register contents.&nbsp; The data is target architecture specific.
<br><br>Request message:
<br><br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; access_req&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; req</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; -------------------</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; unspecified</tt>
<br><br>The message content is specific to the MAD in use and will contain a<tt> mad_registers</tt> union.
<br><br>Return message:
<br><br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; NONE</tt>
<h3 id="REQ_MACHINE_DATA"> REQ_MACHINE_DATA </h3>
<br>Request to retrieve machine specific data.
<br><br>Request message:
<br><br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; access_req&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; req;</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; unsigned_8&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; info_type;</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; addr48_ptr&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; addr;</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; -----------------------------</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; unspecified</tt>
<br><br>The<tt> info_type</tt> field specifies what kind of information should be returned and<tt> addr</tt> determines the
 address for which the information is requested.&nbsp; The remainder of the message is MAD specific.
<br><br>Return message:
<br><br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; addr48_off&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cache_start;</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; addr48_off&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cache_end;</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; -----------------------------</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; unspecified</tt>
<br><br>The return message content is specific to the MAD in use.
<h2 id="File_IDO_requests"> File I/O requests </h2>
<br>This section describes requests that deal with file input/output on the target (debuggee) machine.&nbsp; These requests
 are actually performed by the core request REQ_PERFORM_SUPPLEMENTARY_SERVICE and appropriate service ID.&nbsp; The following
 descriptions do not show that &quot;prefix&quot; to the request messages.
<br><br>The service name to be used in the REQ_GET_SUPPLEMENTARY_SERVICE is &quot;Files&quot;.
<br><br>The file requests use a new basic type in addition to the ones already described:
<dl>
<dt><b><i>Type</i></b>
<dd><b><i>Definition</i></b>
<dt><br>trap_fhandle
<dd>This is an<tt> unsigned_64</tt> which holds a debuggee file handle.
</dl>
<h3 id="REQ_FILE_GET_CONFIG"> REQ_FILE_GET_CONFIG </h3>
<br>Request to retreive characteristics of the remote file system.
<br><br>Request message:
<br><br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; access_req&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; req</tt>
<br><br>Return message:
<br><br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; char&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ext_separator;</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; char&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; path_separator&#91;3&#93;;</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; char&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; newline&#91;2&#93;;</tt>
<br><br>The<tt> ext_separator</tt> contains the separator for file name extensions.&nbsp; The possible path separators can
 be found in array<tt> path_separator</tt>.&nbsp; The first one is the &quot;preferred&quot; path separator for that operating
 system.&nbsp; This is the path separator that the debugger will use if it needs to construct a file name for the remote system.
&nbsp; The new line control characters are stored in array<tt> newline</tt>.&nbsp; If the operating system uses only a single
 character for newline, put a zero in the second element.
<h3 id="REQ_FILE_OPEN"> REQ_FILE_OPEN </h3>
<br>Request to create/open a file.
<br><br>Request message:
<br><br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; access_req&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; req</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; unsigned_8&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mode</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; ------------------------</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; name</tt>
<br><br>The name of the file to be opened is given by<tt> name</tt>.&nbsp; The<tt> mode</tt> field stores the access mode
 of the file.&nbsp; The following bits are defined:
<br><br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; Bit 0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; :&nbsp; TF_READ</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; Bit 1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; :&nbsp; TF_WRITE</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; Bit 2&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; :&nbsp; TF_CREATE</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; Bit 3&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; :&nbsp; TF_EXEC</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; Bit 4&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; :&nbsp; not used</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; Bit 5&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; :&nbsp; not used</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; Bit 6&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; :&nbsp; not used</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; Bit 7&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; :&nbsp; not used</tt>
<br><br>For read/write mode, turn both<tt> TF_READ</tt> and<tt> TF_WRITE</tt> bits on.&nbsp; The<tt> TF_EXEC</tt> bit should
 only be used together with<tt> TF_CREATE</tt> and indicates that the created file needs executable permission (if relevant
 on the target platform).
<br><br>Return message:
<br><br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; trap_error&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; err</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; trap_fhandle&nbsp;&nbsp;&nbsp; handle</tt>
<br><br>If successful, the<tt> handle</tt> returns a handle for the file.&nbsp; When an error has occurred, the<tt> err</tt>
 field contains a value indicating the type of error that has been detected.
<h3 id="REQ_FILE_SEEK"> REQ_FILE_SEEK </h3>
<br>Request to seek to a particular file position.
<br><br>Request message:
<br><br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; access_req&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; req</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; trap_fhandle&nbsp;&nbsp;&nbsp; handle</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; unsigned_8&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mode</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; unsigned_32&nbsp;&nbsp;&nbsp;&nbsp; pos</tt>
<br><br>The handle of the file is given by the<tt> handle</tt> field.&nbsp; The<tt> mode</tt> field stores the seek mode.
&nbsp; There are three seek modes:
<br><br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; TF_SEEK_ORG = 0&nbsp; - Relative to the start of file</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; TF_SEEK_CUR = 1&nbsp; - Relative to the current file position</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; TF_SEEK_END = 2&nbsp; - Rrelative to the end of file</tt>
<br><br>The position to seek to is in the<tt> pos</tt> field.
<br><br>Return message:
<br><br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; trap_error&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; err</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; unsigned_32&nbsp;&nbsp;&nbsp;&nbsp; pos</tt>
<br><br>If an error has occurred, the<tt> err</tt> field contains a value indicating the type of error that has been detected.
&nbsp; The<tt> pos</tt> field returns the current position of the file.
<h3 id="REQ_FILE_READ"> REQ_FILE_READ </h3>
<br>Request to read a block of data from a file.
<br><br>Request message:
<br><br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; access_req&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; req</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; trap_fhandle&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; handle</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; unsigned_16&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; len</tt>
<br><br>The handle of the file is given by the<tt> handle</tt> field.&nbsp; The<tt> len</tt> field stores the number of bytes
 to be transmitted.
<br><br>Return message:
<br><br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; trap_error&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; err</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; --------------------------</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; bytes&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
 data</tt>
<br><br>If successful, the<tt> data</tt> returns the block of data.&nbsp; The length of returned data is given by the return
 value of TrapRequest minus 4 (to account for the size of<tt> err</tt> ).&nbsp; The length will normally be equal to the<tt>
 len</tt> field.&nbsp; If the end of file is encountered before the read completes, the return value will be less than the
 number of bytes requested.&nbsp; When an error has occurred, the<tt> err</tt> field contains a value indicating the type
 of error that has been detected.
<h3 id="REQ_FILE_WRITE"> REQ_FILE_WRITE </h3>
<br>Request to write a block of data to a file.
<br><br>Request message:
<br><br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; access_req&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; req</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; trap_fhandle&nbsp;&nbsp;&nbsp; handle</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; ------------------------</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; bytes&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; data</tt>
<br><br>The handle of the file is given by the<tt> handle</tt> field.&nbsp; The data is given in<tt> data</tt> field.
<br><br>Return message:
<br><br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; trap_error&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; err</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; unsigned_16&nbsp;&nbsp;&nbsp;&nbsp; len</tt>
<br><br>If there is no error,<tt> len</tt> will equal to that in the<tt> data_len</tt> field.&nbsp; When an error has occurred,
 the<tt> err</tt> field contains a value indicating the type of error that has been detected.
<h3 id="REQ_FILE_WRITE_CONSOLE"> REQ_FILE_WRITE_CONSOLE </h3>
<br>Request to write a block of data to the debuggee's screen.
<br><br>Request message:
<br><br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; access_req&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; req</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; ------------------------</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; bytes&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; data</tt>
<br><br>The data is given in<tt> data</tt> field.
<br><br>Return message:
<br><br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; trap_error&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; err</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; unsigned_16&nbsp;&nbsp;&nbsp;&nbsp; len</tt>
<br><br>If there is no error,<tt> len</tt> will equal to the<tt> data_len</tt> field.&nbsp; When an error has occurred, the<tt>
 err</tt> field contains a value indicating the type of error that has been detected.
<h3 id="REQ_FILE_CLOSE"> REQ_FILE_CLOSE </h3>
<br>Request to close a file.
<br><br>Request message:
<br><br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; access_req&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; req</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; trap_fhandle&nbsp;&nbsp;&nbsp; handle</tt>
<br><br>The handle of the file is given by the<tt> handle</tt> field.
<br><br>Return message:
<br><br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; trap_error&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; err</tt>
<br><br>When an error has occurred, the<tt> err</tt> field contains a value indicating the type of error that has been detected.
<h3 id="REQ_FILE_ERASE"> REQ_FILE_ERASE </h3>
<br>Request to erase a file.
<br><br>Request message:
<br><br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; access_req&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; req</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; -------------------------</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; file_name</tt>
<br><br>The<tt> file_name</tt> field contains the file name to be deleted.
<br><br>Return message:
<br><br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; trap_error&nbsp; err</tt>
<br><br>If error has occurred when erasing the file, the<tt> err</tt> field will return the error code number.
<h3 id="REQ_FILE_STRING_TO_FULLPATH"> REQ_FILE_STRING_TO_FULLPATH </h3>
<br>Request to convert a file name to its full path name.
<br><br>Request message:
<br><br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; access_req&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; req</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; unsigned_8&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; file_type</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; -------------------------</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; file_name</tt>
<br><br>The<tt> file_type</tt> field indicates the type of the input file.&nbsp; File types can be:
<br><br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; TF_FILE_EXE&nbsp; =&nbsp; 0</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; TF_FILE_DBG&nbsp; =&nbsp; 1</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; TF_FILE_PRS&nbsp; =&nbsp; 2</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; TF_FILE_HLP&nbsp; =&nbsp; 3</tt>
<br><br>This is so the trap file can search different paths for the different types of files.&nbsp; For example, under QNX,
 the PATH environment variable is searched for the FILE_EXE type, and the WD_PATH environment variable is searched for the
 others.&nbsp; The<tt> file_name</tt> field contains the file name to be converted.
<br><br>Return message:
<br><br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; trap_error&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; err</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; --------------------------</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; path_name</tt>
<br><br>If no error occurs the<tt> err</tt> field returns a zero and the full path name will be stored in the<tt> path_name</tt>
 field.&nbsp; When an error has occurred, the<tt> err</tt> field contains an error code indicating the type of error that
 has been detected.
<h3 id="REQ_FILE_RUN_CMD"> REQ_FILE_RUN_CMD </h3>
<br>Request to run a command on the target (debuggee's) system.
<br><br>Request message:
<br><br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; access_req&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; req</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; unsigned_16&nbsp;&nbsp;&nbsp;&nbsp; chk_size</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; ------------------------</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cmd</tt>
<br><br>The<tt> chk_size</tt> field gives the check size in kilobytes.&nbsp; This field is only useful in the DOS implementation.
&nbsp; It contains the value of the /CHECKSIZE debugger command line option and represents the amount of memory the user wishes
 to have free for the spawned sub-shell.&nbsp; The<tt> cmd</tt> field stores the command to be executed.
<br><br>Return message:
<br><br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; trap_error&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; err</tt>
<br><br>If error has occurred when executing the command, the<tt> err</tt> field will return the error code number.
<h2 id="Overlay_requests"> Overlay requests </h2>
<br>This section describes requests that deal with overlays (supported only under 16-bit DOS).&nbsp; These requests are actually
 performed by the core request REQ_PERFORM_SUPPLEMENTARY_SERVICE and appropriate service ID.&nbsp; The following descriptions
 do not show that &quot;prefix&quot; to the request messages.
<br><br>The service name to be used in the REQ_GET_SUPPLEMENTARY_SERVICE is &quot;Overlays&quot;.
<br><br>The overlay requests use a new basic type in addition to the ones already described:
<dl>
<dt><b><i>Type</i></b>
<dd><b><i>Definition</i></b>
<dt><br>addr32_ptr
<dd>This type encapsulates the concept of a 16:16 pointer into the debuggee's address space.&nbsp; Since overlays are only useful
 for 16-bit environments, using the addr48_ptr type would be inefficient.&nbsp; The structure is defined as follows:
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; typedef struct {</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; unsigned_16&nbsp;&nbsp;&nbsp; offset;</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; unsigned_16&nbsp;&nbsp;&nbsp; segment;</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; } addr32_ptr;</tt>
<br><br>The<tt> segment</tt> field contains the segment of the address and the<tt> offset</tt> field stores the offset of
 the address.
<dt><br>ovl_address
<dd>This type contains the overlay address and the number of entries down in the overlay stack.&nbsp; The structure is defined
 as follows:
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; typedef struct {</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; addr32_ptr&nbsp; mach;</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; unsigned_16 sect_id;</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; } ovl_address;</tt>
<br><br>The<tt> mach</tt> field is the machine address.&nbsp; The<tt> sect_id</tt> field stores the address section number.
</dl>
<h3 id="REQ_OVL_STATE_SIZE"> REQ_OVL_STATE_SIZE </h3>
<br>Request to return the size of the overlay state information in bytes of the task program.&nbsp; This request maps onto
 the overlay manager's GET_STATE_SIZE request.&nbsp; See the Overlay Manager Interface document for more information on the
 contents of the return message.
<br><br>Request message:
<br><br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; access_req&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; req</tt>
<br><br>The<tt> req</tt> field contains the request.
<br><br>Return message:
<br><br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; unsigned_16&nbsp;&nbsp;&nbsp;&nbsp; size</tt>
<br><br>The<tt> size</tt> field returns the size in bytes.&nbsp; A value of zero indicates no overlays are present in the
 debuggee and none of the other requests dealing with overlays will ever be called.
<h3 id="REQ_OVL_GET_DATA"> REQ_OVL_GET_DATA </h3>
<br>Request to get the address and size of an overlay section.&nbsp; This request maps onto the overlay manager's GET_SECTION_DATA
 request.&nbsp; See the Overlay Manager Interface document for more information on the contents of the return message.
<br><br>Request message:
<br><br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; access_req&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; req</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; unsigned_16&nbsp;&nbsp;&nbsp;&nbsp; sect_id</tt>
<br><br>The<tt> sect_id</tt> field indicates the overlay section the information is being requested of.
<br><br>Return message:
<br><br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; unsigned_16&nbsp;&nbsp;&nbsp;&nbsp; segment</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; unsigned_32&nbsp;&nbsp;&nbsp;&nbsp; size</tt>
<br><br>The<tt> segment</tt> field contains the segment value where the overlay section is loaded (or would be loaded if it
 was brought into memory).&nbsp; The<tt> size</tt> field gives the size, in bytes, of the overlay section.&nbsp; If there
 is no section for the given id, the<tt> segment</tt> field will be zero.
<h3 id="REQ_OVL_READ_STATE"> REQ_OVL_READ_STATE </h3>
<br>Request to read the overlay table state.&nbsp; This request maps onto the overlay manager's GET_OVERLAY_STATE request.
&nbsp; See the Overlay Manager Interface document for more information on the contents of the return message.&nbsp; The size
 of the returned data is provided by the REQ_OVL_STATE_SIZE trap file request.
<br><br>Request message:
<br><br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; access_req&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; req</tt>
<br><br>Return message:
<br><br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; bytes&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; data</tt>
<br><br>The<tt> data</tt> field contains the overlay state information requested.
<h3 id="REQ_OVL_WRITE_STATE"> REQ_OVL_WRITE_STATE </h3>
<br>Request to write the overlay table state.&nbsp; This request maps onto the overlay manager's SET_OVERLAY_STATE request.
&nbsp; See the Overlay Manager Interface document for more information on the contents of the return message.
<br><br>Request message:
<br><br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; access_req&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; req</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; --------------------</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; bytes&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; data</tt>
<br><br>The<tt> data</tt> field contains the overlay state information to be restored.
<br><br>Return message:
<br><br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; NONE</tt>
<h3 id="REQ_OVL_TRANS_VECT_ADDR"> REQ_OVL_TRANS_VECT_ADDR </h3>
<br>Request to check if the input overlay address is actually an overlay vector.&nbsp; This request maps onto the overlay
 manager's TRANSLATE_VECTOR_ADDR request.&nbsp; See the Overlay Manager Interface document for more information on the contents
 of the messages.
<br><br>Request message:
<br><br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; access_req&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; req</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; ovl_address&nbsp;&nbsp;&nbsp;&nbsp; ovl_addr</tt>
<br><br>The<tt> mach</tt> field is the machine address.&nbsp; The<tt> sect_id</tt> field stores the number of entries down
 in the overlay stack.
<br><br>Return message:
<br><br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; ovl_address&nbsp;&nbsp;&nbsp;&nbsp; ovl_addr</tt>
<br><br>The translated address will be returned in the<tt> ovl_addr</tt> field.&nbsp; If the address is not an overlay vector,
 then the input address will be returned and the<tt> sect_id</tt> field will be zero.
<h3 id="REQ_OVL_TRANS_RET_ADDR"> REQ_OVL_TRANS_RET_ADDR </h3>
<br>Request to check if the address is the overlay manager parallel return code.&nbsp; This request maps onto the overlay
 manager's TRANSLATE_RETURN_ADDR request.&nbsp; See the Overlay Manager Interface document for more information on the contents
 of the messages.
<br><br>Request message:
<br><br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; access_req&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; req</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; ovl_address&nbsp;&nbsp;&nbsp;&nbsp; ovl_addr</tt>
<br><br>Return message:
<br><br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; ovl_address&nbsp;&nbsp;&nbsp;&nbsp; ovl_addr</tt>
<br><br>The translated address will be returned in the<tt> ovl_addr</tt> field.&nbsp; If the address is not an parallel return
 code, then the input address will be returned and the<tt> sect_id</tt> field in the structure<tt> ovl_addr</tt> will be zero.
<h3 id="REQ_OVL_GET_REMAP_ENTRY"> REQ_OVL_GET_REMAP_ENTRY </h3>
<br>Request to check if the overlay address needs to be remapped.&nbsp; This request maps onto the overlay manager's GET_MOVED_SECTION
 request.&nbsp; See the Overlay Manager Interface document for more information on the contents of the messages.
<br><br>Request message:
<br><br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; access_req&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; req</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; ovl_address&nbsp;&nbsp;&nbsp;&nbsp; ovl_addr</tt>
<br><br>The<tt> ovl_addr</tt> field contains the overlay address.
<br><br>Return message:
<br><br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; unsigned_8&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; remapped</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; ovl_address&nbsp;&nbsp;&nbsp;&nbsp; ovl_addr</tt>
<br><br>If the address gets remapped the<tt> remapped</tt> field will return one.&nbsp; The remapped address will be returned
 in the<tt> ovl_addr</tt> field.&nbsp; The input address will be unchanged if the address has not been remapped.
<h2 id="Thread_requests"> Thread requests </h2>
<br>This section descibes requests that deal with threads.&nbsp; These requests are actually performed by the core request
 REQ_PERFORM_SUPPLEMENTARY_SERVICE and appropriate service ID.&nbsp; The following descriptions do not show that &quot;prefix&quot;
 to the request messages.
<br><br>The service name to be used in the REQ_GET_SUPPLEMENTARY_SERVICE is &quot;Threads&quot;.
<br><br>The thread requests use a new basic type in addition to the ones already described:
<dl>
<dt><b><i>Type</i></b>
<dd><b><i>Definition</i></b>
<dt><br>trap_thandle
<dd>This is an unsigned_32 type which holds a thread handle.
</dl>
<h3 id="REQ_THREAD_GET_NEXT"> REQ_THREAD_GET_NEXT </h3>
<br>Request to get next thread.
<br><br>Request message:
<br><br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; access_req&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; req</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; trap_thandle&nbsp;&nbsp;&nbsp; thread</tt>
<br><br>The<tt> thread</tt> contains the either a zero to get information on the first thread, or the value of the<tt> thread</tt>
 field in the return message of a previous request.
<br><br>Return message:
<br><br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; trap_thandle&nbsp;&nbsp;&nbsp; thread</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; unsigned_8&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; state</tt>
<br><br>The<tt> thread</tt> field returns the thread ID.&nbsp; There are no more threads in the list, it will contain zero.
&nbsp; The<tt> state</tt> field can have two values:
<br><br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; THREAD_THAWED = 0</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; THREAD_FROZEN = 1</tt>
<h3 id="REQ_THREAD_SET"> REQ_THREAD_SET </h3>
<br>Request to set a given thread ID to be the current thread.
<br><br>Request message:
<br><br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; access_req&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; req</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; trap_thandle&nbsp;&nbsp;&nbsp; thread</tt>
<br><br>The<tt> thread</tt> contains the thread number to set.&nbsp; If it's zero, do not attempt to set the thread, just
 return the current thread ID.
<br><br>Return message:
<br><br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; trap_error&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; error</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; trap_thandle&nbsp;&nbsp;&nbsp; old_thread</tt>
<br><br>The<tt> old_thread</tt> field returns the previous thread ID.&nbsp; If the set fails, the<tt> err</tt> field will
 be non-zero.
<h3 id="REQ_THREAD_FREEZE"> REQ_THREAD_FREEZE </h3>
<br>Request to freeze a thread so that it will not be run next time when executing the task program.
<br><br>Request message:
<br><br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; access_req&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; req</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; trap_thandle&nbsp;&nbsp;&nbsp; thread</tt>
<br><br>The<tt> thread</tt> contains the thread number to freeze.
<br><br>Return message:
<br><br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; trap_error&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; err</tt>
<br><br>If the thread cannot be frozen, the<tt> err</tt> field returns non-zero value.
<h3 id="REQ_THREAD_THAW"> REQ_THREAD_THAW </h3>
<br>Request to allow a thread to run next time when executing the program.
<br><br>Request message:
<br><br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; access_req&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; req</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; trap_thandle&nbsp;&nbsp;&nbsp; thread</tt>
<br><br>The<tt> thread</tt> contains the thread number to thaw.
<br><br>Return message:
<br><br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; trap_error&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; err</tt>
<br><br>If the thread cannot be thawed, the<tt> err</tt> field returns non zero value.
<h3 id="REQ_THREAD_GET_EXTRA"> REQ_THREAD_GET_EXTRA </h3>
<br>Request to get extra information about a thread.&nbsp; This is arbitrary textual data which the debugger merely displays
 in its thread window.&nbsp; The trap file can place any information in the return message which it feels would be useful
 for the user to know.
<br><br>Request message:
<br><br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; access_req&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; req</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; unsigned_32&nbsp;&nbsp;&nbsp;&nbsp; thread</tt>
<br><br>The<tt> thread</tt> field contains the thread ID.&nbsp; A zero value means to get the title string for the thread
 extra information.&nbsp; This is displayed at the top of the thread window.
<br><br>Return message:
<br><br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; extra</tt>
<br><br>The extra information of the thread will be returned in<tt> extra</tt> field.
<h2 id="RFX_requests"> RFX requests </h2>
<br>This section deals with requests that are only used by the RFX (Remote File Xfer) program.&nbsp; These requests are actually
 performed by the core request REQ_PERFORM_SUPPLEMENTARY_SERVICE and appropriate service ID.&nbsp; The following descriptions
 do not show that &quot;prefix&quot; to the request messages.
<br><br>The service name to be used in the REQ_GET_SUPPLEMENTARY_SERVICE is &quot;Rfx&quot;.
<h3 id="REQ_RFX_RENAME"> REQ_RFX_RENAME </h3>
<br>Request to rename a file on the debuggee's system.
<br><br>Request message:
<br><br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; access_req&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; req</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; -------------------------</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; from_name</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; -------------------------</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; to_name</tt>
<br><br>The file whose name is indicated by the field<tt> from_name</tt> will be renamed to the name given by the field<tt>
 to_name</tt>.
<br><br>Return message:
<br><br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; trap_error&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; err</tt>
<br><br>If error has occurred, the<tt> err</tt> field will return the error code number.
<h3 id="REQ_RFX_MKDIR"> REQ_RFX_MKDIR </h3>
<br>Request to create a directory on the target (debuggee) system.
<br><br>Request message:
<br><br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; access_req&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; req</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; ------------------------</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; dir_name</tt>
<br><br>The<tt> dir_name</tt> field contains the name of the directory to be created.
<br><br>Return message:
<br><br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; trap_error&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; err</tt>
<br><br>If error has occurred when creating the directory, the<tt> err</tt> field will return the error code number.
<h3 id="REQ_RFX_RMDIR"> REQ_RFX_RMDIR </h3>
<br>Request to remove a directory on the target system.
<br><br>Request message:
<br><br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; access_req&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; req</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; ------------------------</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; dir_name</tt>
<br><br>The<tt> dir_name</tt> field contains the name of the directory to be removed.
<br><br>Return message:
<br><br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; trap_error&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; err</tt>
<br><br>If error has occurred, the<tt> err</tt> field will return the error code number.
<h3 id="REQ_RFX_SETDRIVE"> REQ_RFX_SETDRIVE </h3>
<br>Request to set the current drive on the target system.
<br><br>Request message:
<br><br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; access_req&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; req</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; unsigned_8&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; drive</tt>
<br><br>The<tt> drive</tt> field contains the drive number to be set on the target system (0=A,1=B,...).
<br><br>Return message:
<br><br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; trap_error&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; err</tt>
<br><br>If error has occurred, the<tt> err</tt> field will return the error code number.
<h3 id="REQ_RFX_GETDRIVE"> REQ_RFX_GETDRIVE </h3>
<br>Request to get the current drive on the target system.
<br><br>Request message:
<br><br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; access_req&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; req</tt>
<br><br>The<tt> req</tt> field contains the request.
<br><br>Return message:
<br><br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; unsigned_8&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; drive</tt>
<br><br>The<tt> drive</tt> field returns the current drive number on the target system (0=A,1=B,...).
<h3 id="REQ_RFX_SETCWD"> REQ_RFX_SETCWD </h3>
<br>Request to set a directory on the target system.
<br><br>Request message:
<br><br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; access_req&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; req</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; ------------------------</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; dir_name</tt>
<br><br>The<tt> dir_name</tt> field contains the name of the directory to be set.
<br><br>Return message:
<br><br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; trap_error&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; err</tt>
<br><br>If error has occurred, the<tt> err</tt> field will return the error code number.
<h3 id="REQ_RFX_GETCWD"> REQ_RFX_GETCWD </h3>
<br>Request to get the current directory name on the target system.
<br><br>Request message:
<br><br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; access_req&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; req</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; unsigned_8&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; drive</tt>
<br><br>The<tt> drive</tt> field contains the target drive number (0=current drive,1=A,2=B,...).
<br><br>Return message:
<br><br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; trap_error&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; err</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; --------------------------</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; dir_name</tt>
<br><br>The<tt> dir_name</tt> field contains the name of the directory to be set.&nbsp; If error has occurred, the<tt> err</tt>
 field will return the error code number.
<h3 id="REQ_RFX_SETDATETIME"> REQ_RFX_SETDATETIME </h3>
<br>Request to set a file's date and time information on the target system.
<br><br>Request message:
<br><br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; access_req&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; req</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; trap_fhandle&nbsp;&nbsp;&nbsp; handle</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; time_t&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; time</tt>
<br><br>The<tt> handle</tt> contains the file handle.&nbsp; The<tt> time</tt> field follows the UNIX time format.&nbsp; The<tt>
 time</tt> represents the time since January 1, 1970 (UTC).
<br><br>Return message:
<br><br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; NONE</tt>
<h3 id="REQ_RFX_GETDATETIME"> REQ_RFX_GETDATETIME </h3>
<br>Request to get the date and time information for a file on the target system.
<br><br>Request message:
<br><br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; access_req&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; req</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; trap_fhandle&nbsp;&nbsp;&nbsp; handle</tt>
<br><br>The<tt> handle</tt> contains the file handle.
<br><br>Return message:
<br><br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; time_t&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; time</tt>
<br><br>The<tt> time</tt> field follows the UNIX time format.&nbsp; The<tt> time</tt> represents the time since January 1,
 1970 (UTC).
<h3 id="REQ_RFX_GETFREESPACE"> REQ_RFX_GETFREESPACE </h3>
<br>Request to get the amount of free space left on the drive.
<br><br>Request message:
<br><br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; access_req&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; req</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; unsigned_8&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; drive</tt>
<br><br>The<tt> drive</tt> field contains the target drive number (0=current drive,1=A,2=B,...).
<br><br>Return message:
<br><br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; unsigned_32&nbsp;&nbsp;&nbsp;&nbsp; size</tt>
<br><br>The<tt> size</tt> field returns the number of bytes left on the drive.
<h3 id="REQ_RFX_SETFILEATTR"> REQ_RFX_SETFILEATTR </h3>
<br>Request to set the file attribute of a file.
<br><br>Request message:
<br><br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; access_req&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; req</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; unsigned_32&nbsp;&nbsp;&nbsp;&nbsp; attribute</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; -------------------------</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; name</tt>
<br><br>The<tt> name</tt> field contains the name whose attributes are to be set.&nbsp; The<tt> attribute</tt> field contains
 the new attributes of the file.
<br><br>Return message:
<br><br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; trap_error&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; err</tt>
<br><br>If error has occurred, the<tt> err</tt> field will return the error code number.
<h3 id="REQ_RFX_GETFILEATTR"> REQ_RFX_GETFILEATTR </h3>
<br>Request to get the file attribute of a file.
<br><br>Request message:
<br><br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; access_req&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; req</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; --------------------</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; name</tt>
<br><br>The<tt> name</tt> field contains the name to be checked.
<br><br>Return message:
<br><br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; unsigned_32&nbsp;&nbsp;&nbsp;&nbsp; attribute</tt>
<br><br>The<tt> attribute</tt> field returns the attribute of the file.
<h3 id="REQ_RFX_NAMETOCANONICAL"> REQ_RFX_NAMETOCANONICAL </h3>
<br>Request to convert a file name to its canonical form.
<br><br>Request message:
<br><br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; access_req&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; req</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; -------------------------</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; file_name</tt>
<br><br>The<tt> file_name</tt> field contains the file name to be converted.
<br><br>Return message:
<br><br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; trap_error&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; err</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; --------------------------</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; path_name</tt>
<br><br>If there is no error, the<tt> err</tt> field returns a zero and the full path name will be stored in the<tt> path_name</tt>
 field.&nbsp; When an error has occurred, the<tt> err</tt> field contains an error code indicating the type of error that
 has been detected.
<h3 id="REQ_RFX_FINDFIRST"> REQ_RFX_FINDFIRST </h3>
<br>Request to find the first file in a directory.
<br><br>Request message:
<br><br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; access_req&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; req</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; unsigned_8&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; attrib</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; ----------------------</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; name</tt>
<br><br>The<tt> name</tt> field contains the name of the directory and the<tt> attrib</tt> field contains the attribute of
 the files to list in the directory.
<br><br>Return message:
<br><br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; trap_error&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; err</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; -----------------------</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; rfx_find&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; info</tt>
<br><br>If found, the<tt> err</tt> field will be zero.&nbsp; The location and information of about the first file will be
 in the structure<tt> info</tt>.&nbsp; Definition of the structure<tt> rfx_find</tt> is as follows:
<br><br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; typedef struct rfx_find {</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; unsigned_8&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
 reserved&#91;21&#93;;</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; unsigned_8&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
 attr;</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; unsigned_16&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; time;</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; unsigned_16&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; date;</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; unsigned_32&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; size;</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; unsigned_8&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
 name&#91;260&#93;;</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; } rfx_find;</tt>
<h3 id="REQ_RFX_FINDNEXT"> REQ_RFX_FINDNEXT </h3>
<br>Request to find the next file in the directory.&nbsp; This request should be used only after REQ_RFX_FINDFIRST.
<br><br>Request message:
<br><br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; access_req&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; req</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; --------------------</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; rfx_find&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; info</tt>
<br><br>The<tt> req</tt> field contains the request.&nbsp; The<tt> info</tt> field contains the rfx_find structure returned
 from the previous REQ_FIND_NEXT or REQ_FIND_FIRST.
<br><br>Return message:
<br><br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; trap_error&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; err</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; -----------------------</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; rfx_find&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; info</tt>
<br><br>The<tt> info</tt> field is the same as in REQ_FIND_FIRST.
<h3 id="REQ_RFX_FINDCLOSE"> REQ_RFX_FINDCLOSE </h3>
<br>Request to end the directory search operation.
<br><br>Request message:
<br><br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; access_req&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; req</tt>
<br><br>The<tt> req</tt> field contains the request.
<br><br>Return message:
<br><br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; trap_error&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; err</tt>
<br><br>If successful, the<tt> err</tt> field will be zero, otherwise the system error code will be returned.
<h2 id="Environment_requests"> Environment requests </h2>
<br>This section describes requests that deal with Environment on the target (debuggee) machine.&nbsp; These requests are
 actually performed by the core request REQ_PERFORM_SUPPLEMENTARY_SERVICE and appropriate service ID.&nbsp; The following
 descriptions do not show that &quot;prefix&quot; to the request messages.
<br><br>The service name to be used in the REQ_GET_SUPPLEMENTARY_SERVICE is &quot;Environment&quot;.
<h3 id="REQ_ENV_GET_VAR"> REQ_ENV_GET_VAR </h3>
<br>Request to retreive Environment variable from the remote system.
<br><br>Request message:
<br><br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; access_req&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; req</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; ------------------------</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; name</tt>
<br><br>Return message:
<br><br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; trap_error&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; err</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; value;</tt>
<br><br>The<tt> value</tt> contains the value for<tt> name</tt> Environment variable from the remote system.
<h3 id="REQ_ENV_SET_VAR"> REQ_ENV_SET_VAR </h3>
<br>Request to set Environment variable on the remote system.
<br><br>Request message:
<br><br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; access_req&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; req</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; ------------------------</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; name</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; value;</tt>
<br><br>Return message:
<br><br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; trap_error&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; err</tt>
<br><br>The<tt> value</tt> contains the new value for Environment variable<tt> name</tt> on the remote system.
<h2 id="File_Info_requests"> File Info requests </h2>
<h3 id="REQ_FILE_INFO_GET_DATE"> REQ_FILE_INFO_GET_DATE </h3>
<br>Request message:
<br><br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; access_req&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; req</tt>
<br><br>Return message:
<br><br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; trap_error&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; err</tt>
<h3 id="REQ_FILE_INFO_SET_DATE"> REQ_FILE_INFO_SET_DATE </h3>
<br>Request message:
<br><br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; access_req&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; req</tt>
<br><br>Return message:
<br><br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; trap_error&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; err</tt>
<h2 id="Asynchronous_Debugging_requests"> Asynchronous Debugging requests </h2>
<h3 id="REQ_ASYNC_GO"> REQ_ASYNC_GO </h3>
<br>Request message:
<br><br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; access_req&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; req</tt>
<br><br>Return message:
<br><br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; trap_error&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; err</tt>
<h3 id="REQ_ASYNC_STEP"> REQ_ASYNC_STEP </h3>
<br>Request message:
<br><br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; access_req&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; req</tt>
<br><br>Return message:
<br><br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; trap_error&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; err</tt>
<h3 id="REQ_ASYNC_POLL"> REQ_ASYNC_POLL </h3>
<br>Request message:
<br><br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; access_req&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; req</tt>
<br><br>Return message:
<br><br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; trap_error&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; err</tt>
<h3 id="REQ_ASYNC_STOP"> REQ_ASYNC_STOP </h3>
<br>Request message:
<br><br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; access_req&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; req</tt>
<br><br>Return message:
<br><br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; trap_error&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; err</tt>
<h3 id="REQ_ASYNC_ADD_BREAK"> REQ_ASYNC_ADD_BREAK </h3>
<br>Request message:
<br><br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; access_req&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; req</tt>
<br><br>Return message:
<br><br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; trap_error&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; err</tt>
<h3 id="REQ_ASYNC_REMOVE_BREAK"> REQ_ASYNC_REMOVE_BREAK </h3>
<br>Request message:
<br><br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; access_req&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; req</tt>
<br><br>Return message:
<br><br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; trap_error&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; err</tt>
<h2 id="NonMblocking_Thread_requests"> Non-blocking Thread requests </h2>
<h3 id="REQ_RUN_THREAD_INFO"> REQ_RUN_THREAD_INFO </h3>
<br>Request message:
<br><br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; access_req&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; req</tt>
<br><br>Return message:
<br><br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; trap_error&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; err</tt>
<h3 id="REQ_RUN_THREAD_GET_NEXT"> REQ_RUN_THREAD_GET_NEXT </h3>
<br>Request message:
<br><br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; access_req&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; req</tt>
<br><br>Return message:
<br><br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; trap_error&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; err</tt>
<h3 id="REQ_RUN_THREAD_GET_RUNTIME"> REQ_RUN_THREAD_GET_RUNTIME </h3>
<br>Request message:
<br><br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; access_req&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; req</tt>
<br><br>Return message:
<br><br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; trap_error&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; err</tt>
<h3 id="REQ_RUN_THREAD_POLL"> REQ_RUN_THREAD_POLL </h3>
<br>Request message:
<br><br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; access_req&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; req</tt>
<br><br>Return message:
<br><br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; trap_error&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; err</tt>
<h3 id="REQ_RUN_THREAD_SET"> REQ_RUN_THREAD_SET </h3>
<br>Request message:
<br><br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; access_req&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; req</tt>
<br><br>Return message:
<br><br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; trap_error&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; err</tt>
<h3 id="REQ_RUN_THREAD_GET_NAME"> REQ_RUN_THREAD_GET_NAME </h3>
<br>Request message:
<br><br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; access_req&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; req</tt>
<br><br>Return message:
<br><br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; trap_error&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; err</tt>
<h3 id="REQ_RUN_THREAD_STOP"> REQ_RUN_THREAD_STOP </h3>
<br>Request message:
<br><br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; access_req&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; req</tt>
<br><br>Return message:
<br><br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; trap_error&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; err</tt>
<h3 id="REQ_RUN_THREAD_SIGNAL_STOP"> REQ_RUN_THREAD_SIGNAL_STOP </h3>
<br>Request message:
<br><br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; access_req&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; req</tt>
<br><br>Return message:
<br><br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; trap_error&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; err</tt>
<h2 id="Capabilities_requests"> Capabilities requests </h2>
<h3 id="REQ_CAPABILITIES_GET_8B_BP"> REQ_CAPABILITIES_GET_8B_BP </h3>
<br>Request message:
<br><br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; access_req&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; req</tt>
<br><br>Return message:
<br><br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; trap_error&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; err</tt>
<h3 id="REQ_CAPABILITIES_SET_8B_BP"> REQ_CAPABILITIES_SET_8B_BP </h3>
<br>Request message:
<br><br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; access_req&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; req</tt>
<br><br>Return message:
<br><br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; trap_error&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; err</tt>
<h3 id="REQ_CAPABILITIES_GET_EXACT_BP"> REQ_CAPABILITIES_GET_EXACT_BP </h3>
<br>Request message:
<br><br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; access_req&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; req</tt>
<br><br>Return message:
<br><br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; trap_error&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; err</tt>
<h3 id="REQ_CAPABILITIES_SET_EXACT_BP"> REQ_CAPABILITIES_SET_EXACT_BP </h3>
<br>Request message:
<br><br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; access_req&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; req</tt>
<br><br>Return message:
<br><br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; trap_error&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; err</tt>
<h1 id="System_Dependent_Aspects"> System Dependent Aspects </h1>
<br>Every environment has a different method of loading the code for the trap file and locating the TrapInit, TrapRequest,
 and TrapFini routines.&nbsp; This section descibes how the Open Watcom debugger performs these operations for the various
 systems.
<h2 id="Trap_Files_Under_DOS"> Trap Files Under DOS </h2>
<br>A trap file is an &quot;EXE&quot; format file with the extension &quot;.TRP&quot;.&nbsp; The debugger searches the directories
 specified by the PATH environment variable.&nbsp; Once found, it is loaded into memory and has the normal EXE style relocations
 applied to the image.&nbsp; Then the lowest address in the load image (NOTE:&nbsp; not the starting address from EXE header
 information) is examined for the following structure:
<br><br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; typedef struct {</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; unsigned_16&nbsp;&nbsp;&nbsp;&nbsp; signature; /* == 0xDEAF */</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; unsigned_16&nbsp;&nbsp;&nbsp;&nbsp; init_off;</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; unsigned_16&nbsp;&nbsp;&nbsp;&nbsp; acc_off;</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; unsigned_16&nbsp;&nbsp;&nbsp;&nbsp; fini_off;</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; } trap_header;</tt>
<br><br>If the first 2 bytes contain the value 0xDEAF, the file is considered to be a valid trap file and the<tt> init_off</tt>
 ,<tt> acc_off</tt> , and<tt> fini_off</tt> fields are used to obtain the offsets of the TrapInit, TrapRequest, and TrapFini
 routines repectively.
<br><br>The starting address field of the EXE header should be set to point at some code which prints out a message about
 not being able to be run from the command line and then terminates.
<h2 id="Trap_Files_Under_OSD2"> Trap Files Under OS/2 </h2>
<br>A trap file is a normal OS/2 DLL.&nbsp; The system automatically searches the directories specified by the LIBPATH command
 in the CONFIG.SYS file.&nbsp; Once loaded, the Open Watcom debugger uses export ordinal 1 from the DLL for TrapInit, export
 ordinal 2 for TrapFini and export ordinal 3 for TrapRequest.&nbsp; Some example code follows:
<br><br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; rc = DosLoadModule( NULL, 0, trap_file_name, &amp;dll_module );</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; if( rc != 0 ) {</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return( &quot;unable to load trap file&quot; );</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; }</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; if( DosGetProcAddr( dll_module, &quot;#1&quot;, &amp;TrapInit ) != 0</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; || DosGetProcAddr( dll_module, &quot;#2&quot;, &amp;TrapFini ) != 0</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; || DosGetProcAddr( dll_module, &quot;#3&quot;, &amp;TrapRequest ) != 0 ) {</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return( &quot;incorrect version of trap file&quot; );</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; }</tt>
<h2 id="Trap_Files_Under_Windows_"> Trap Files Under Windows. </h2>
<br>A trap file is a normal Windows DLL.&nbsp; The system automatically searches the directories specified by the PATH environment
 variable.&nbsp; Once loaded, the Open Watcom debugger uses export ordinal 2 from the DLL for TrapInit, export ordinal 3 for
 TrapFini and export ordinal 4 for TrapRequest.&nbsp; Some example code follows:
<br><br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; dll = LoadLibrary( trap_file_name );</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; if( dll &lt; 32 ) {</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return( &quot;unable to load trap file&quot; );</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; }</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; TrapInit&nbsp;&nbsp; = (LPVOID) GetProcAddress( dll, (LPSTR)2 );</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; TrapFini&nbsp;&nbsp; = (LPVOID) GetProcAddress( dll, (LPSTR)3 );</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; TrapRequest = (LPVOID) GetProcAddress( dll, (LPSTR)4 );</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; if( TrapInit == NULL || TrapFini == NULL || TrapRequest == NULL ) {</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return( &quot;incorrect version of trap file&quot; );</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; }</tt>
<h2 id="Trap_Files_Under_Windows_NT_"> Trap Files Under Windows NT. </h2>
<br>A trap file is a normal Windows NT DLL.&nbsp; The system automatically searches the directories specified by the PATH
 environment variable.&nbsp; Once loaded, the Open Watcom debugger uses export ordinal 1 from the DLL for TrapInit, export
 ordinal 2 for TrapFini and export ordinal 3 for TrapRequest.&nbsp; Some example code follows:
<br><br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; dll = LoadLibrary( trap_file_name );</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; if( dll &lt; 32 ) {</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return( &quot;unable to load trap file&quot; );</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; }</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; TrapInit&nbsp;&nbsp; = (LPVOID) GetProcAddress( dll, (LPSTR)1 );</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; TrapFini&nbsp;&nbsp; = (LPVOID) GetProcAddress( dll, (LPSTR)2 );</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; TrapRequest = (LPVOID) GetProcAddress( dll, (LPSTR)3 );</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; if( TrapInit == NULL || TrapFini == NULL || TrapRequest == NULL ) {</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return( &quot;incorrect version of trap file&quot; );</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; }</tt>
<h2 id="Trap_Files_Under_QNX"> Trap Files Under QNX </h2>
<br>A trap file is a QNX load module format file with the extension &quot;.trp&quot; and whose file permissions are not marked
 as executable.&nbsp; The debugger searches the directories specified by the WD_PATH environment variable and then the &quot;/usr/watcom/wd&quot;
 directory.&nbsp; Once found, it is loaded into memory and has the normal loader relocations applied to the image.&nbsp; Then
 the lowest address in the load image (NOTE:&nbsp; not the starting address from load module header information) is examined
 for the following structure:
<br><br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; typedef struct {</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; unsigned_16&nbsp;&nbsp;&nbsp;&nbsp; signature; /* == 0xDEAF */</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; unsigned_16&nbsp;&nbsp;&nbsp;&nbsp; init_off;</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; unsigned_16&nbsp;&nbsp;&nbsp;&nbsp; acc_off;</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; unsigned_16&nbsp;&nbsp;&nbsp;&nbsp; fini_off;</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; } trap_header;</tt>
<br><br>If the first 2 bytes contain the value 0xDEAF, the file is considered to be a valid trap file and the<tt> init_off</tt>
 ,<tt> acc_off</tt> , and<tt> fini_off</tt> fields are used to obtain the offsets of the TrapInit, TrapRequest, and TrapFini
 routines repectively.
<br><br>The starting address field of the load image header should be set to point at some code which prints out a message
 about not being able to be run from the command line and then terminates.
<h2 id="Trap_Files_Under_Netware_386_or_PenPoint"> Trap Files Under Netware 386 or PenPoint </h2>
<br>The trap file routines are linked directly into the remote server code and TrapInit, TrapRequest, TrapFini are directly
 called.
<h1 id="Overlay_manager_interface"> Overlay manager interface </h1>
<br>For Open Watcom Debugger to be able to debug overlays, it must be able to make requests of the overlay manager for certain
 operations.&nbsp; The overlay manager must also be able to inform Open Watcom Debugger when a new overlay section is loaded.
<br>When Open Watcom Debugger loads a DOS program, it looks at the initial CS:IP value for the following structure:
<br><br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; struct ovl_header {</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; unsigned_8&nbsp; short_jmp_opcode;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp; /* == 0xeb */</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; signed_8&nbsp;&nbsp;&nbsp; short_jmp_displacment;</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; unsigned_16 signature;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* == 0x2112 */</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; void&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (far *hook)();</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; unsigned_16 handler_offset;</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; };</tt>
<br><br>Open Watcom Debugger checks to make sure that the first instruction is a short jump (opcode 0xeb) and that the word
 following that instruction contains the value 0x2112.&nbsp; If this occurs, Open Watcom Debugger assumes that it is debugging
 an overlaid application.
<br><br>Open Watcom Debugger then fills in the<tt> hook</tt> field with the far address of a routine that is invoked with
 a far call whenever a change in the overlay state occurs.&nbsp; The initial CS value and the contents of the<tt> handler_offset</tt>
 field gives the far address of the overlay manager routine responsible for handling debugger requests.
<h2 id="The_Hook_Routine"> The Hook Routine </h2>
<br>After the routine addresses have been exchanged, Open Watcom Debugger starts the program executing, to allow the overlay
 manager to initialize.&nbsp; After the manager has finished its initialization, it performs a far call to the debugger hook
 routine, with the return address on the stack being the &quot;real&quot; starting address of the program being debugged.
&nbsp; All register contents (including flags) should be preserved by the hook routine.
<br><br>After initialization, the debugger hook routine is invoked with a far call every time a new overlay section is loaded
 into memory.&nbsp; In this case the AX register contains the section number that was just loaded.&nbsp; The DL register contains
 a zero or non-zero value if the overlay load was caused by a call or return, respectively.&nbsp; The CX:BX registers form
 a far pointer to the last byte of the call instruction that caused the overlay load, in the case of a overlay load being
 caused by a return instruction (DL is non-zero) the far pointer is to the last byte of the call instruction that the return
 is returning from.
<br><br><b>NOTE:</b>&nbsp; may be loaded by the overlay manager before the hook routine is called.&nbsp; The current overlay
 manager also loads all of the ancestors of a section (See the WLINK documentation in the Users' Guide for a description of
 what an ancestor is).&nbsp; To find out what sections are really in memory the debugger should invoke the handler routine
 with a GET_OVERLAY_STATE request.
<h2 id="The_Handler_Routine"> The Handler Routine </h2>
<br>The handler routine is responsible for processing requests from the debugger pertaining to overlays.&nbsp; It is invoked
 by the debugger by performing a far call with a request number in the AX register.&nbsp; The AX register is used to return
 the result or return status of the request.&nbsp; The CX and BX registers are used for some requests to pass a far pointer
 to memory.
<br><br>There are two structures that the handler routines deals with.&nbsp; The first is called an overlay state.&nbsp; An
 overlay state consists of a block of memory containing all the information necessary for the overlay manager to restore the
 overlays to their current condition at some later point in time.&nbsp; The first portion of this block is a bit vector, with
 each bit representing an overlay section.&nbsp; If the bit is a one, then the overlay section is currently in memory.&nbsp;
 If the bit is a zero then the overlay section is not in memory.&nbsp; To convert from a section number to a bit position
 use the following formulas:
<br><br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; byte_offset = (section_number - 1) / 8;</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; bit_number&nbsp; = (section_number - 1) % 8;</tt>
<br><br>Following the bit vector is information that the manager uses to restore the overlay stack.
<br><br>The second structure used is an overlay address.&nbsp; This consists of a far pointer followed by a 16-bit section
 number.
<br><br>The following requests are recognized by the debug handler routine.
<h3 id="GET_STATE_SIZE"> GET_STATE_SIZE </h3>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; Inputs:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Outputs:</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; AX = request number (0)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; AX = size of overlay
 state</tt>
<br><br>This request returns the number of bytes required for an overlay state.
<h3 id="GET_OVERLAY_STATE"> GET_OVERLAY_STATE </h3>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; Inputs:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Outputs:</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; AX = request number (1)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; AX = 1</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; CX:BX = far pointer to memory</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; to store overlay state</tt>
<br><br>This request copies the overlay state into the memory pointed at by the CX:BX registers.&nbsp; A one is always returned
 in AX.
<h3 id="SET_OVERLAY_STATE"> SET_OVERLAY_STATE </h3>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; Inputs:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Outputs:</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; AX = request number (2)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; AX = 1</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; CX:BX = far pointer to memory</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; to load overlay state</tt>
<br><br>This request takes a previously obtained overlay state and causes the overlay manager to return itself to that overlay
 configuration.&nbsp; A one is always returned in AX.&nbsp; The overlay manager will not explicitly unload a section that
 is not in memory according to the given overlay state, so a GET_OVERLAY_STATE request following a SET_OVERLAY_STATE may not
 return the same bit vector portion.&nbsp; This request may also be used by the debugger to explicitly load a section, so
 the assembly code may be examined, perhaps.&nbsp; To do this, zero out a block of memory the size of an overlay state, and
 then turn on the appropriate section number in the bit vector, then make a SET_OVERLAY_STATE request.&nbsp; Remember that
 not only that section will be loaded, but all of its ancestor sections as well.
<h3 id="TRANSLATE_VECTOR_ADDR"> TRANSLATE_VECTOR_ADDR </h3>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; Inputs:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Outputs:</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; AX = request number (3)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; AX = 1 if addr was
 translated,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; CX:BX = far pointer to&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; 0 otherwise</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; overlay address</tt>
<br><br>This request checks to see if the far pointer portion of the overlay address pointed at by CX:BX is actually an overlay
 vector.&nbsp; If the address is a vector then the vector address is replaced by the true address of the routine that the
 vector is for, and the section number portion is filled in with the section number the of routine.&nbsp; A one is returned
 in AX in this case.&nbsp; If the address is not an overlay vector, then the overlay address is untouched and an zero is returned
 in AX.
<h3 id="TRANSLATE_RETURN_ADDR"> TRANSLATE_RETURN_ADDR </h3>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; Inputs:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Outputs:</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; AX = request number (4)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; AX = 1 if addr was
 translated,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; CX:BX = far pointer to&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; 0 otherwise</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; overlay address</tt>
<br><br>In order to handle parallel overlay calls, the overlay manager replaces the true return address on the stack with
 that of some special code (the parallel return code).&nbsp; It then takes the original return address and section number
 an places them on the overlay stack.&nbsp; When a routine returns to the overlay manager, it pops the top entry of the overlay
 stack, makes sure that the original overlay section is loaded, and returns to the original return address.
<br><br>This function performs much the same function as TRANSLATE_VECTOR_ADDR, except that rather than checking for a vector
 address, it checks to see if the address is that of the overlay manager parallel return code.&nbsp; If it is then the section
 number in the overlay address is used as the number of entries down in the overlay stack that the real return address and
 section number is to be found (zero is the top entry of the overlay stack).&nbsp; The true return address and section number
 then replaces the contents of the overlay address and a one is returned in AX.&nbsp; If the address is not the parallel return
 code, then the overlay address is left untouched and a zero is returned in AX.
<h3 id="GET_OVL_TBL_ADDR"> GET_OVL_TBL_ADDR </h3>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; Inputs:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Outputs:</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; AX = request number (5)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; AX = 0</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; CX:BX = far pointer to variable</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; of type far pointer to</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; be filled in with</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; overlay table address</tt>
<br><br>This request fills in the far pointer pointed at by CX:BX with the address of the overlay table so that a profiler
 can find out where sections are located in the executable, or overlay files.&nbsp; The sampler program, when it detects that
 it is sampling a overlaid application, can perform this function and write the result into the sample file.&nbsp; Since the
 overlay table is always in the root, the profiler can then find the overlay table and from that, find the other sections.
&nbsp; It should be noted that the format of the overlay table may change, so this call should be avoided if at all possible.
<h3 id="GET_MOVED_SECTION"> GET_MOVED_SECTION </h3>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; Inputs:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Outputs:</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; AX = request number (6)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; AX = 1 if the section
 exists</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; CX:BX = far pointer to&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; 0 otherwise</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; overlay address</tt>
<br><br>With the dynamic overlay manager, sections may be loaded, or moved, to positions other than where the linker originally
 placed them.&nbsp; The debugger must be informed of the new positions so that it can update the locations of its symbolic
 information.&nbsp; The GET_MOVED_SECTION request is responsible for informing the debugger what sections have moved and their
 new locations.&nbsp; The debugger will call this request after the hook routine has been called, or the debugger has invoked
 the SET_OVERLAY_STATE request.&nbsp; The request returns the first section whose id larger than the section number that is
 in the overlay address being passed in.&nbsp; The overlay manager will fill in the overlay address with the section number
 that has moved and its new segment address.&nbsp; The offset portion of the overlay address is unused.&nbsp; The request
 will return a one in AX.&nbsp; If there are no sections numbers larger than the one being passed in that have moved, a zero
 is returned.
<br><br>Here is some example debugger code:
<br><br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; void CheckMovedSections()</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; {</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; overlay_address&nbsp;&nbsp;&nbsp;&nbsp; addr;</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; addr.sect_id = 0;</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; while( OvlHandler( GET_MOVED_SECTION, &amp;addr ) ) {</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; HandleMovedSection( addr.sect_id, addr.segment
 );</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; }</tt>
<h3 id="GET_SECTION_DATA"> GET_SECTION_DATA </h3>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; Inputs:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Outputs:</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; AX = request number (7)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; AX = 1 if the section
 exists</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; CX:BX = far pointer to&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; 0 otherwise</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; overlay address</tt>
<br><br>This request returns information on the current location of a section while it is in memory (or where it would be
 if it was loaded).&nbsp; The section number portion of the overlay address is filled in with the section id that information
 is being requested about before the request is made.&nbsp; The overlay manager returns zero in AX if the section does not
 exist.&nbsp; Otherwise it returns one and fills in the overlay address with the location that the section is in memory, or
 where it would currently go if it was loaded at that time.&nbsp; It also fills in the section number portion of the address
 with the size of the section in paragraphs.
<h2 id="Overlay_Table_Structure"> Overlay Table Structure </h2>
<br>The pointer returned by the GET_OVL_TBL_ADDR request has the following format:
<br><br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; typedef struct ovl_table {</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; unsigned_8&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; major;</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; unsigned_8&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; minor;</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; void&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp; far *start;</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; unsigned_16&nbsp;&nbsp;&nbsp;&nbsp; delta;</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; unsigned_16&nbsp;&nbsp;&nbsp;&nbsp; ovl_size;</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ovltab_entry&nbsp;&nbsp;&nbsp; entries&#91; 1 &#93;;</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; } ovl_table;</tt>
<br><br>The fields<tt> major</tt> and<tt> minor</tt> field contain version numbers for the overlay table structure.&nbsp;
 If an upwardly compatible change in the structures is made, the minor number will be incremented.&nbsp; If a non-upwardly
 compatible change to the structures is made, the major field will be incremented.&nbsp; The current major version is 3, the
 current minor version is 0.&nbsp; The<tt> start</tt> field contains a 32-bit far pointer to the &quot;actual&quot; starting
 address of the program.&nbsp; The overlay manager jumps to this address after it has finished initializing (If a debugger/sampler
 is present then the overlay manager calls into the hook routine with this address on the return stack).&nbsp; The<tt> delta</tt>
 field contains the value to be added to each of the segment relocations when a section is loaded into memory (it contains
 the segment value for the first segment in the program).&nbsp; The<tt> ovl_size</tt> field contains the size of the overlay
 area.&nbsp; This is only used in the dynamic overlay manager.&nbsp; The final field,<tt> entries</tt> , is a variable sized
 array containing one entry for each overlay section in the program (e.g.&nbsp; the tenth element in the array describes overlay
 section 10).&nbsp; Each entry has the following form:
<br><br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; typedef struct ovltab_entry {</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; unsigned_16&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; flags_anc;</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; unsigned_16&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; relocs;</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; unsigned_16&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; start_para;</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; unsigned_16&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; code_handle;</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; unsigned_16&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; num_paras;</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; unsigned_16&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; fname;</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; unsigned_32&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; disk_addr;</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; } ovltab_entry;</tt>
<br><br>The top bit of the<tt> flag_anc</tt> field contains an indicator, while the program is running, of whether the overlay
 section is in memory (value one) or must be loaded from disk (value zero).&nbsp; The next highest bit is filled in by the
 linker and informs the overlay manager that the section must be loaded during the overlay manager initialization.&nbsp; The
 remaining bits contain the overlay number for the ancestor of this section (zero if there is none).&nbsp; The<tt> relocs</tt>
 field say how many segment relocation items there are for this section, while the<tt> start_para</tt> field gives the location
 in memory (relative to the start of the program) that the section should be placed when loaded.&nbsp; The<tt> num_paras</tt>
 field contains the size of the section in paragraphs, and the<tt> code_handle</tt> field is used for various purposes inside
 the dynamic overlay loader.&nbsp; The<tt> fname</tt> field has the offset of the address of a zero terminated string for
 the name of the file containing the overlay section data and relocations (The segment value is the same as the overlay table).
&nbsp; If the top bit of the offset is on, then the file is the original EXE file rather than a separate overlay file, and
 the overlay manager should use the program file name obtained from DOS (if the version is 3.0.&nbsp; or greater).&nbsp; The<tt>
 disk_addr</tt> field gives the starting offset the overlay data in the overlay file.&nbsp; The segment relocation items immediately
 follow the data.
<br><br>The end of the<tt> entries</tt> array is indicated when an element's<tt> flags_anc</tt> field contains the value 0xffff.
&nbsp; The remaining fields in that element contain garbage values.
</body>
